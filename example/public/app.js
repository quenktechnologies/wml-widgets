(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("afpl/lib/util");
var app_1 = require("./wml/app");
var navigation_1 = require("./wml/navigation");
var panel_1 = require("./pages/panel");
var list_layout_1 = require("./pages/list-layout");
var table_1 = require("./pages/table");
var text_field_1 = require("./pages/text-field");
var date_1 = require("./pages/date");
var button_1 = require("./pages/button");
var toolbar_1 = require("./pages/toolbar");
var button_select_1 = require("./pages/button-select");
var checkbox_1 = require("./pages/checkbox");
var switch_1 = require("./pages/switch");
var tab_bar_1 = require("./pages/tab-bar");
var stack_1 = require("./pages/stack");
var multi_select_1 = require("./pages/multi-select");
var select_1 = require("./pages/select");
var breadcrumb_1 = require("./pages/breadcrumb");
var activity_indicator_1 = require("./pages/activity-indicator");
var menu_1 = require("./pages/menu");
var button_group_1 = require("./pages/button-group");
var drop_down_1 = require("./pages/drop-down");
var tab_layout_1 = require("./pages/tab-layout");
var horizontal_layout_1 = require("./pages/horizontal-layout");
var nav_1 = require("./pages/nav");
var displayName = function (s) {
    return [s[0].toUpperCase()]
        .concat(s
        .split(s[0])
        .slice(1)
        .join(s[0]))
        .join('')
        .replace(/(\-|_|\s)+(.)?/g, function (_, __, c) { return (c ? c.toUpperCase() : ''); });
};
var flatten = function (links) {
    return util_1.reduce(links, function (flatLinks, current) {
        return util_1.reduce(current, function (p, c, k) {
            return util_1.merge(p, (_a = {}, _a[k] = c, _a));
            var _a;
        }, flatLinks);
    }, {});
};
var App = /** @class */ (function () {
    function App() {
        var _this = this;
        /**
         * page currently displayed.
         */
        this.page = '';
        /**
         * links to the pages.
         */
        this.links = {
            layout: {
                panel: new panel_1.PanelPage(this),
                'list-layout': new list_layout_1.ListLayoutPage(this),
                'tab-layout': new tab_layout_1.TabLayoutPage(this),
                'horizontal-layout': new horizontal_layout_1.HorizontalLayoutPage(this)
            },
            data: {
                table: new table_1.TablePage(this)
            },
            control: {
                'text-field': new text_field_1.TextFieldPage(this),
                date: new date_1.DatePage(this),
                select: new select_1.SelectPage(this),
                'multi-select': new multi_select_1.MultiSelectPage(this),
                button: new button_1.ButtonPage(this),
                'button-group': new button_group_1.ButtonGroupPage(this),
                'toolbar': new toolbar_1.ToolbarPage(this),
                'button-select': new button_select_1.ButtonSelectPage(this),
                'tab-bar': new tab_bar_1.TabBarPage(this),
                menu: new menu_1.MenuPage(this),
                'drop-down': new drop_down_1.DropDownPage(this),
                stack: new stack_1.StackPage(this),
                checkbox: new checkbox_1.CheckboxPage(this),
                'switch': new switch_1.SwitchPage(this)
            },
            content: {
                nav: new nav_1.NavPage(this),
                breadcrumb: new breadcrumb_1.BreadcrumbPage(this),
            },
            app: {
                'activity-indicator': new activity_indicator_1.ActivityIndicatorPage(this)
            }
        };
        /**
         * navigation view
         */
        this.navigation = new navigation_1.Navigation(this);
        /**
         * values used within the template.
         */
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * view is the current application view.
         */
        this.view = new app_1.Main(this);
        /**
         * displayName provides the display name for a the links.
         */
        this.displayName = displayName;
        /**
         * sort an object.
         */
        this.sort = function (o) {
            return Object.keys(o).sort().reduce(function (p, k) { p[k] = o[k]; return p; }, {});
        };
        /**
         * toggleDrawer
         */
        this.toggleDrawer = function () {
            _this
                .view
                .findById(_this.values.id.layout)
                .map(function (d) { return d.toggle(); });
        };
        /**
         * navigate is called when the user clicks on a
         * navigation link.
         */
        this.navigate = function (_a) {
            var name = _a.name;
            return _this.route(name);
        };
    }
    Object.defineProperty(App.prototype, "pages", {
        /**
         * pages to show the user.
         */
        get: function () { return flatten(this.links); },
        enumerable: true,
        configurable: true
    });
    /**
     * route the main content based on the passed string.
     */
    App.prototype.route = function (name) {
        this.page = name;
        if (this.pages.hasOwnProperty(name)) {
            this.content = this.pages[name].view;
            this.view.invalidate();
            this.navigation.invalidate();
        }
    };
    /**
     * run the application.
     */
    App.prototype.run = function () {
        var root = document.getElementById('app');
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        this.layout = this.view.findById(this.values.id.layout);
        var path = window.location.hash.split('#')[1];
        path = path ? path.split('/').join('') : '';
        this.route(path);
    };
    App.main = function () {
        return new App();
    };
    return App;
}());
exports.App = App;
var w = window;
w.app = App.main();
w.app.run();

},{"./pages/activity-indicator":5,"./pages/breadcrumb":7,"./pages/button":13,"./pages/button-group":9,"./pages/button-select":11,"./pages/checkbox":15,"./pages/date":17,"./pages/drop-down":19,"./pages/horizontal-layout":21,"./pages/list-layout":23,"./pages/menu":25,"./pages/multi-select":27,"./pages/nav":29,"./pages/panel":31,"./pages/select":33,"./pages/stack":35,"./pages/switch":37,"./pages/tab-bar":39,"./pages/tab-layout":41,"./pages/table":44,"./pages/text-field":46,"./pages/toolbar":48,"./wml/app":50,"./wml/navigation":51,"afpl/lib/util":169}],2:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/page-example");
var PageExample = /** @class */ (function (_super) {
    __extends(PageExample, _super);
    function PageExample() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            size: _this.attrs.size,
            offset: _this.attrs.offset
        };
        return _this;
    }
    return PageExample;
}(wml.Component));
exports.PageExample = PageExample;

},{"./wml/page-example":3,"@quenk/wml":160}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../lib/layout/grid-layout");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': ___context.values.size
                        }
                    }, [___wml.domify(___context.children)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Page = /** @class */ (function () {
    function Page(app) {
        this.app = app;
    }
    Page.prototype.get = function (id, fn) {
        this
            .view
            .findById(id)
            .map(fn)
            .orJust(function () { return console.warn(id + ": is missing"); });
    };
    return Page;
}());
exports.Page = Page;

},{}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/activity-indicator");
var Page_1 = require("../Page");
var ActivityIndicatorPage = /** @class */ (function (_super) {
    __extends(ActivityIndicatorPage, _super);
    function ActivityIndicatorPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return ActivityIndicatorPage;
}(Page_1.Page));
exports.ActivityIndicatorPage = ActivityIndicatorPage;

},{"../Page":4,"./wml/activity-indicator":6}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var activity_1 = require("../../../../../lib/app/indicator/activity");
;
var page_example_1 = require("../../../page-example");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(activity_1.ActivityIndicator, {
                    html: {},
                    wml: {}
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/app/indicator/activity":56,"../../../page-example":2,"@quenk/wml":160}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var breadcrumb_1 = require("./wml/breadcrumb");
var BreadcrumbPage = /** @class */ (function (_super) {
    __extends(BreadcrumbPage, _super);
    function BreadcrumbPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new breadcrumb_1.Main(_this);
        return _this;
    }
    return BreadcrumbPage;
}(Page_1.Page));
exports.BreadcrumbPage = BreadcrumbPage;

},{"../Page":4,"./wml/breadcrumb":8}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var breadcrumb_1 = require("../../../../../lib/content/nav/breadcrumb");
;
var link_1 = require("../../../../../lib/content/nav/link");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(breadcrumb_1.Breadcrumb, {
                    html: {},
                    wml: {}
                }, [___wml.widget(breadcrumb_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "One"
                            }
                        }, [], ___view)], ___view), ___wml.widget(breadcrumb_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "Two"
                            }
                        }, [], ___view)], ___view), ___wml.widget(breadcrumb_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "Three"
                            }
                        }, [], ___view)], ___view), ___wml.widget(breadcrumb_1.Item, {
                        html: {},
                        wml: {},
                        ww: {
                            'active': true
                        }
                    }, [___wml.text("\n\n\tFour\n\n     ")], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/content/nav/breadcrumb":59,"../../../../../lib/content/nav/link":64,"../../../page-example":2,"@quenk/wml":160}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-group");
var Page_1 = require("../Page");
var ButtonGroupPage = /** @class */ (function (_super) {
    __extends(ButtonGroupPage, _super);
    function ButtonGroupPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return ButtonGroupPage;
}(Page_1.Page));
exports.ButtonGroupPage = ButtonGroupPage;

},{"../Page":4,"./wml/button-group":10}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var button_1 = require("../../../../../lib/control/button");
;
var button_group_1 = require("../../../../../lib/control/button-group");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(button_group_1.ButtonGroup, {
                    html: {},
                    wml: {}
                }, [___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'text': "one"
                        }
                    }, [], ___view), ___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'text': "three",
                            'active': true
                        }
                    }, [], ___view), ___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'text': "four"
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/button":81,"../../../../../lib/control/button-group":77,"../../../page-example":2,"@quenk/wml":160}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var Page_1 = require("../Page");
var ButtonSelectPage = /** @class */ (function (_super) {
    __extends(ButtonSelectPage, _super);
    function ButtonSelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            options: [
                { title: 'Asus', value: 'Asus' },
                { title: 'MSI', value: 'MSI' },
                { title: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        _this.onChange = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        _this.onChangeMulti = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        return _this;
    }
    return ButtonSelectPage;
}(Page_1.Page));
exports.ButtonSelectPage = ButtonSelectPage;

},{"../Page":4,"./wml/button-select":12}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var button_select_1 = require("../../../../../lib/control/button-select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "select-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.ButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "select"
                                },
                                ww: {
                                    'name': "select",
                                    'style': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You can also use MultiButtonSelect instead: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "multi-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.MultiButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "multi"
                                },
                                ww: {
                                    'name': "multi",
                                    'style': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChangeMulti
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/button-select":79,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button");
var style = require("../../../../lib/content/style");
var size = require("../../../../lib/content/size");
var Page_1 = require("../Page");
var ButtonPage = /** @class */ (function (_super) {
    __extends(ButtonPage, _super);
    function ButtonPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            capitalize: function (s) { return "" + s[0].toUpperCase() + s.slice(1); },
            styles: style,
            sizes: size
        };
        return _this;
    }
    return ButtonPage;
}(Page_1.Page));
exports.ButtonPage = ButtonPage;

},{"../../../../lib/content/size":70,"../../../../lib/content/style":73,"../Page":4,"./wml/button":14}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var button_1 = require("../../../../../lib/control/button");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('h1', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Buttons")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('h2', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Style")], ___view), ___wml.map(___context.values.styles, function _map(v, k) {
                                return ___wml.box(___wml.widget(button_1.Button, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'name': v,
                                        'style': v,
                                        'text': ___context.values.capitalize(k)
                                    }
                                }, [], ___view), ___wml.domify(" "));
                            }, function otherwise() {
                                return document.createDocumentFragment();
                            })], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('h2', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Outline")], ___view), ___wml.map(___context.values.styles, function _map(style, text) {
                            return ___wml.box(___wml.widget(button_1.Button, {
                                html: {},
                                wml: {},
                                ww: {
                                    'style': style,
                                    'outline': true,
                                    'text': ___context.values.capitalize(text)
                                }
                            }, [], ___view), ___wml.domify(" "));
                        }, function otherwise() {
                            return document.createDocumentFragment();
                        })], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('h2', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Active")], ___view), ___wml.map(___context.values.styles, function _map(v, k) {
                                return ___wml.box(___wml.widget(button_1.Button, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'name': v,
                                        'active': true,
                                        'style': v,
                                        'text': ___context.values.capitalize(k)
                                    }
                                }, [], ___view), ___wml.domify(" "));
                            }, function otherwise() {
                                return document.createDocumentFragment();
                            })], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('h2', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Disabled")], ___view), ___wml.map(___context.values.styles, function _map(v, k) {
                                return ___wml.box(___wml.widget(button_1.Button, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'name': v,
                                        'disabled': true,
                                        'style': v,
                                        'text': ___context.values.capitalize(k)
                                    }
                                }, [], ___view), ___wml.domify(" "));
                            }, function otherwise() {
                                return document.createDocumentFragment();
                            })], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('h2', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Size")], ___view), ___wml.map(___context.values.styles, function _map(style, _) {
                            return ___wml.node('p', {
                                html: {},
                                wml: {}
                            }, [___wml.map(___context.values.sizes, function _map(sizeValue, size) {
                                    return ___wml.box(___wml.widget(button_1.Button, {
                                        html: {},
                                        wml: {},
                                        ww: {
                                            'name': size,
                                            'style': style,
                                            'size': sizeValue,
                                            'text': ___context.values.capitalize(size)
                                        }
                                    }, [], ___view), ___wml.domify(" "));
                                }, function otherwise() {
                                    return document.createDocumentFragment();
                                })], ___view);
                        }, function otherwise() {
                            return document.createDocumentFragment();
                        })], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('h2', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Block")], ___view), ___wml.map(___context.values.styles, function _map(style, text) {
                            return ___wml.box(___wml.widget(button_1.Button, {
                                html: {},
                                wml: {},
                                ww: {
                                    'style': style,
                                    'block': true,
                                    'text': ___context.values.capitalize(text)
                                }
                            }, [], ___view), ___wml.domify(" "));
                        }, function otherwise() {
                            return document.createDocumentFragment();
                        })], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/button":81,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/checkbox");
var Page_1 = require("../Page");
var CheckboxPage = /** @class */ (function (_super) {
    __extends(CheckboxPage, _super);
    function CheckboxPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return CheckboxPage;
}(Page_1.Page));
exports.CheckboxPage = CheckboxPage;

},{"../Page":4,"./wml/checkbox":16}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var checkbox_1 = require("../../../../../lib/control/checkbox");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.text("The checkbox is "), ___wml.node('b', {
                        html: {},
                        wml: {
                            'id': "content"
                        }
                    }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.widget(checkbox_1.Checkbox, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': "checkbox",
                            'onChange': ___context.onChange
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/checkbox":83,"../../../page-example":2,"@quenk/wml":160}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var Page_1 = require("../Page");
var DatePage = /** @class */ (function (_super) {
    __extends(DatePage, _super);
    function DatePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value));
            });
        };
        return _this;
    }
    return DatePage;
}(Page_1.Page));
exports.DatePage = DatePage;

},{"../Page":4,"./wml/date":18}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var date_1 = require("../../../../../lib/control/date");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.text("The date is : "), ___wml.node('b', {
                        html: {},
                        wml: {
                            'id': "selected"
                        }
                    }, [___wml.text("(None selected)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.widget(date_1.Date, {
                        html: {},
                        wml: {
                            'id': "date"
                        },
                        ww: {
                            'name': "date",
                            'onChange': ___context.onChange
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/date":85,"../../../page-example":2,"@quenk/wml":160}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-down");
var Page_1 = require("../Page");
var DropDownPage = /** @class */ (function (_super) {
    __extends(DropDownPage, _super);
    function DropDownPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onClick = function (msg) { return function (e) {
            e.preventDefault();
            alert(msg);
        }; };
        return _this;
    }
    return DropDownPage;
}(Page_1.Page));
exports.DropDownPage = DropDownPage;

},{"../Page":4,"./wml/drop-down":20}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var drop_down_1 = require("../../../../../lib/control/drop-down");
;
var menu_1 = require("../../../../../lib/control/menu");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.widget(drop_down_1.DropDown, {
                        html: {},
                        wml: {},
                        ww: {
                            'buttonText': "Click Me"
                        }
                    }, [___wml.widget(menu_1.Menu, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(menu_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.node('a', {
                                    html: {
                                        'href': "#",
                                        'onclick': ___context.onClick("You clicked one")
                                    },
                                    wml: {}
                                }, [___wml.text("One")], ___view)], ___view), ___wml.widget(menu_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.node('a', {
                                    html: {
                                        'href': "#",
                                        'onclick': ___context.onClick("You clicked two")
                                    },
                                    wml: {}
                                }, [___wml.text("Two")], ___view)], ___view), ___wml.widget(menu_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.node('a', {
                                    html: {
                                        'href': "#",
                                        'onclick': ___context.onClick("You clicked three")
                                    },
                                    wml: {}
                                }, [___wml.text("Three")], ___view)], ___view)], ___view)], ___view), ___wml.widget(drop_down_1.DropDown, {
                        html: {},
                        wml: {},
                        ww: {
                            'buttonText': "Me Too",
                            'autoClose': false
                        }
                    }, [___wml.node('h1', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Any flow content can go here!")], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/drop-down":87,"../../../../../lib/control/menu":92,"../../../page-example":2,"@quenk/wml":160}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/horizontal-layout");
var Page_1 = require("../Page");
var HorizontalLayoutPage = /** @class */ (function (_super) {
    __extends(HorizontalLayoutPage, _super);
    function HorizontalLayoutPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return HorizontalLayoutPage;
}(Page_1.Page));
exports.HorizontalLayoutPage = HorizontalLayoutPage;

},{"../Page":4,"./wml/horizontal-layout":22}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var horizontal_layout_1 = require("../../../../../lib/layout/horizontal-layout");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(horizontal_layout_1.HorizontalLayout, {
                    html: {},
                    wml: {}
                }, [___wml.node('textarea', {
                        html: {},
                        wml: {}
                    }, [___wml.text("Area 1")], ___view), ___wml.node('textarea', {
                        html: {},
                        wml: {}
                    }, [___wml.text("Area 2")], ___view), ___wml.node('textarea', {
                        html: {},
                        wml: {}
                    }, [___wml.text("Area 3")], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/layout/horizontal-layout":136,"../../../page-example":2,"@quenk/wml":160}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var list_layout_1 = require("./wml/list-layout");
var ListLayoutPage = /** @class */ (function (_super) {
    __extends(ListLayoutPage, _super);
    function ListLayoutPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new list_layout_1.Main(_this);
        return _this;
    }
    return ListLayoutPage;
}(Page_1.Page));
exports.ListLayoutPage = ListLayoutPage;

},{"../Page":4,"./wml/list-layout":24}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var list_layout_1 = require("../../../../../lib/layout/list-layout");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(list_layout_1.ListLayout, {
                    html: {},
                    wml: {}
                }, [___wml.widget(list_layout_1.ListLayoutItem, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("This is the first item.")], ___view)], ___view), ___wml.widget(list_layout_1.ListLayoutItem, {
                        html: {},
                        wml: {}
                    }, [___wml.node('b', {
                            html: {},
                            wml: {}
                        }, [___wml.text("This is the second item.")], ___view)], ___view), ___wml.widget(list_layout_1.ListLayoutItem, {
                        html: {},
                        wml: {}
                    }, [___wml.node('h3', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Whoa!")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("This is a third item!")], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/layout/list-layout":139,"../../../page-example":2,"@quenk/wml":160}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var menu_1 = require("./wml/menu");
var MenuPage = /** @class */ (function (_super) {
    __extends(MenuPage, _super);
    function MenuPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        return _this;
    }
    return MenuPage;
}(Page_1.Page));
exports.MenuPage = MenuPage;

},{"../Page":4,"./wml/menu":26}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var menu_1 = require("../../../../../lib/control/menu");
;
var link_1 = require("../../../../../lib/content/nav/link");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(menu_1.Menu, {
                    html: {},
                    wml: {}
                }, [___wml.node('h6', {
                        html: {},
                        wml: {}
                    }, [___wml.text("Menu")], ___view), ___wml.widget(menu_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'disabled': true,
                                'text': "Back"
                            }
                        }, [], ___view)], ___view), ___wml.widget(menu_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'disabled': true,
                                'text': "Refresh"
                            }
                        }, [], ___view)], ___view), ___wml.widget(menu_1.Divider, {
                        html: {},
                        wml: {}
                    }, [], ___view), ___wml.widget(menu_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.node('a', {
                            html: {
                                'href': "#/menu"
                            },
                            wml: {}
                        }, [___wml.text("Quit")], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/content/nav/link":64,"../../../../../lib/control/menu":92,"../../../page-example":2,"@quenk/wml":160}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/multi-select");
var Page_1 = require("../Page");
var options = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Asunder', value: 'Asunder' }
];
var MultiSelectPage = /** @class */ (function (_super) {
    __extends(MultiSelectPage, _super);
    function MultiSelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: 'search',
            name: 'search',
            text: function () { return _this.values.selected.map(function (m) { return m.label; }).join(','); },
            selected: [],
            options: options
        };
        _this.onSearch = function (_a) {
            var value = _a.value;
            _this.view.findById(_this.values.id).map(function (s) {
                return s.update(options.filter(function (s) { return s.value.toLowerCase().startsWith(value.toLowerCase()); }));
            });
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.values.selected = value;
            _this.view.invalidate();
        };
        return _this;
    }
    return MultiSelectPage;
}(Page_1.Page));
exports.MultiSelectPage = MultiSelectPage;

},{"../Page":4,"./wml/multi-select":28}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var multi_select_1 = require("../../../../../lib/control/multi-select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "text"
                                }
                            }, [___wml.domify(___context.values.text())], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(multi_select_1.MultiSelect, {
                                html: {},
                                wml: {
                                    'id': ___context.values.id
                                },
                                ww: {
                                    'name': ___context.values.name,
                                    'value': ___context.values.selected,
                                    'decorator': function (r) { return r.label; },
                                    'onChange': ___context.onChange,
                                    'onSearch': ___context.onSearch
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/multi-select":96,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/nav");
var Page_1 = require("../Page");
var NavPage = /** @class */ (function (_super) {
    __extends(NavPage, _super);
    function NavPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.active = '';
        _this.links = {
            Home: {},
            Profile: {},
            Messages: {}
        };
        _this.navigate = function (e) {
            _this
                .view
                .findGroupByName('links')
                .map(function (ls) { return ls.map(function (l) { return l.deactivate(); }); })
                .chain(function () { return _this.view.findById(e.name); })
                .map(function (l) { return l.activate(); });
        };
        return _this;
    }
    return NavPage;
}(Page_1.Page));
exports.NavPage = NavPage;

},{"../Page":4,"./wml/nav":30}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var nav_1 = require("../../../../../lib/content/nav");
;
var item_1 = require("../../../../../lib/content/nav/item");
;
var link_1 = require("../../../../../lib/content/nav/link");
;
var page_example_1 = require("../../../page-example");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(nav_1.Nav, {
                    html: {},
                    wml: {}
                }, [___wml.map(___context.links, function _map(_, key) {
                        return ___wml.widget(item_1.Item, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(link_1.Link, {
                                html: {},
                                wml: {
                                    'id': key,
                                    'group': "links"
                                },
                                ww: {
                                    'name': key,
                                    'onClick': ___context.navigate,
                                    'text': key
                                }
                            }, [], ___view)], ___view);
                    }, function otherwise() {
                        return document.createDocumentFragment();
                    })], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/content/nav":61,"../../../../../lib/content/nav/item":62,"../../../../../lib/content/nav/link":64,"../../../page-example":2,"@quenk/wml":160}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var panel_1 = require("./wml/panel");
var PanelPage = /** @class */ (function (_super) {
    __extends(PanelPage, _super);
    function PanelPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_1.Main(_this);
        return _this;
    }
    return PanelPage;
}(Page_1.Page));
exports.PanelPage = PanelPage;

},{"../Page":4,"./wml/panel":32}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var panel_1 = require("../../../../../lib/layout/panel");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(panel_1.PanelBody, {
                                html: {},
                                wml: {}
                            }, [___wml.text("PanelBody only.")], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(panel_1.PanelHeader, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With PanelHeader")], ___view), ___wml.widget(panel_1.PanelBody, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(panel_1.PanelHeader, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With PanelFooter")], ___view), ___wml.widget(panel_1.PanelBody, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view), ___wml.widget(panel_1.PanelFooter, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Meh foot.")], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/layout/grid-layout":134,"../../../../../lib/layout/panel":148,"@quenk/wml":160}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var Page_1 = require("../Page");
var results = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Kirpalani\'s', value: 'Kirpalani\'s' },
    { label: 'Asunder', value: 'Asunder' }
];
var onSearch = function (page) { return function (id) { return function (_a) {
    var value = _a.value;
    return page
        .view
        .findById(id)
        .map(function (s) {
        var hit = results.filter(function (c) {
            return c.value.toLowerCase().startsWith(value) ? true : false;
        });
        s.update(hit);
    });
}; }; };
var onChange = function (page) { return function (_a) {
    var name = _a.name, value = _a.value;
    return page.view.findById(name)
        .map(function (e) {
        while (e.lastChild)
            e.removeChild(e.lastChild);
        e.appendChild(document.createTextNode(value.value));
    });
}; };
var SelectPage = /** @class */ (function (_super) {
    __extends(SelectPage, _super);
    function SelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            autocomplete: {
                id: 'autocomplete',
                name: 'autocompleteName',
                onSearch: onSearch(_this)('autocomplete'),
                onChange: onChange(_this)
            },
            native: {
                id: 'native',
                name: 'nativeName',
                options: results,
                onSearch: onSearch(_this)('native'),
                onChange: onChange(_this)
            }
        };
        return _this;
    }
    return SelectPage;
}(Page_1.Page));
exports.SelectPage = SelectPage;

},{"../Page":4,"./wml/select":34}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var select_1 = require("../../../../../lib/control/select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': ___context.values.autocomplete.name
                                }
                            }, [___wml.text("(nothing)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(select_1.Select, {
                                html: {},
                                wml: {
                                    'id': ___context.values.autocomplete.id
                                },
                                ww: {
                                    'name': ___context.values.autocomplete.name,
                                    'stringifier': function (r) { return r.value; },
                                    'onSearch': ___context.values.autocomplete.onSearch,
                                    'onChange': ___context.values.autocomplete.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': ___context.values.native.name
                                }
                            }, [___wml.text("(nothing)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(select_1.Select, {
                                html: {},
                                wml: {
                                    'id': ___context.values.native.id
                                },
                                ww: {
                                    'name': ___context.values.native.name,
                                    'readOnly': true,
                                    'stringifier': function (r) { return r.value; },
                                    'options': ___context.values.native.options,
                                    'onSearch': ___context.values.native.onSearch,
                                    'onChange': ___context.values.native.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/select":100,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var Page_1 = require("../Page");
var _getValues = function () { return [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' }
]; };
var _getText = function (m) { return m.map(function (_a) {
    var label = _a.label;
    return label;
}).join(','); };
var StackPage = /** @class */ (function (_super) {
    __extends(StackPage, _super);
    function StackPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            values: _getValues(),
            text: _getText(_getValues()),
            decorator: function (m) { return m.label; }
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            if (value.length === 0)
                _this.values.values = _getValues();
            _this.values.text = _getText(_this.values.values);
            _this.view.invalidate();
        };
        return _this;
    }
    return StackPage;
}(Page_1.Page));
exports.StackPage = StackPage;

},{"../Page":4,"./wml/stack":36}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var stack_1 = require("../../../../../lib/control/stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Members: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.domify(___context.values.text)], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(stack_1.Stack, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "stack",
                                    'value': ___context.values.values,
                                    'decorator': ___context.values.decorator,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/stack":102,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/switch");
var Page_1 = require("../Page");
var SwitchPage = /** @class */ (function (_super) {
    __extends(SwitchPage, _super);
    function SwitchPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return SwitchPage;
}(Page_1.Page));
exports.SwitchPage = SwitchPage;

},{"../Page":4,"./wml/switch":38}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var switch_1 = require("../../../../../lib/control/switch");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.text("The switch is "), ___wml.node('b', {
                        html: {},
                        wml: {
                            'id': "content"
                        }
                    }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                    html: {},
                    wml: {}
                }, [___wml.widget(switch_1.Switch, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': "switch",
                            'onChange': ___context.onChange
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/switch":104,"../../../page-example":2,"@quenk/wml":160}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab-bar");
var Page_1 = require("../Page");
var TabBarPage = /** @class */ (function (_super) {
    __extends(TabBarPage, _super);
    function TabBarPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.tab = 'First';
        _this.content = 'First Tab';
        _this.clicked = function (_a) {
            var name = _a.name;
            _this.tab = name;
            _this.content = name + " Tab";
            _this.view.invalidate();
        };
        return _this;
    }
    return TabBarPage;
}(Page_1.Page));
exports.TabBarPage = TabBarPage;

},{"../Page":4,"./wml/tab-bar":40}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var tab_bar_1 = require("../../../../../lib/control/tab-bar");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(tab_bar_1.TabBar, {
                    html: {},
                    wml: {}
                }, [___wml.widget(tab_bar_1.Tab, {
                        html: {},
                        wml: {},
                        ww: {
                            'active': (___context.tab === "First"),
                            'text': "First",
                            'name': "First",
                            'onClick': ___context.clicked
                        }
                    }, [], ___view), ___wml.widget(tab_bar_1.Tab, {
                        html: {},
                        wml: {},
                        ww: {
                            'active': (___context.tab === "Second"),
                            'text': "Second",
                            'name': "Second",
                            'onClick': ___context.clicked
                        }
                    }, [], ___view), ___wml.widget(tab_bar_1.Tab, {
                        html: {},
                        wml: {},
                        ww: {
                            'active': (___context.tab === "Third"),
                            'text': "Third",
                            'name': "Third",
                            'onClick': ___context.clicked
                        }
                    }, [], ___view)], ___view), ___wml.node('p', {
                    html: {},
                    wml: {
                        'id': "content"
                    }
                }, [___wml.domify(___context.content)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/tab-bar":109,"../../../page-example":2,"@quenk/wml":160}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab-layout");
var Page_1 = require("../Page");
var TabLayoutPage = /** @class */ (function (_super) {
    __extends(TabLayoutPage, _super);
    function TabLayoutPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.tabs = {
            first: {
                contentTemplate: views.firstTab
            },
            second: {
                contentTemplate: views.secondTab
            },
            third: {
                contentTemplate: views.thirdTab
            }
        };
        return _this;
    }
    return TabLayoutPage;
}(Page_1.Page));
exports.TabLayoutPage = TabLayoutPage;

},{"../Page":4,"./wml/tab-layout":42}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var tab_layout_1 = require("../../../../../lib/layout/tab-layout");
;
exports.firstTab = function (_) { return function (___view) { return ___wml.node('p', {
    html: {},
    wml: {}
}, [___wml.text("Click a tab to change content.")], ___view); }; };
;
exports.secondTab = function (_) { return function (___view) { return ___wml.node('p', {
    html: {},
    wml: {}
}, [___wml.text("Second tab.")], ___view); }; };
;
exports.thirdTab = function (_) { return function (___view) { return ___wml.node('p', {
    html: {},
    wml: {}
}, [___wml.text("Third tab.")], ___view); }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(tab_layout_1.TabLayout, {
                    html: {},
                    wml: {},
                    ww: {
                        'tabs': ___context.tabs
                    }
                }, [___wml.node('p', {
                        html: {},
                        wml: {}
                    }, [___wml.text("Click a tab to change content.")], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/layout/tab-layout":153,"../../../page-example":2,"@quenk/wml":160}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.users = [
    {
        "_id": "59f1334ccc21ff728cf7f3ce",
        "index": 0,
        "guid": "fd94cd52-e7f1-44ab-a74f-05604eee46dd",
        "isActive": false,
        "balance": "$2,849.93",
        "picture": "http://placehold.it/32x32",
        "age": 34,
        "eyeColor": "green",
        "name": "Johns Lewis",
        "gender": "male",
        "company": "PROFLEX",
        "email": "johnslewis@proflex.com",
        "phone": "+1 (925) 409-3400",
        "address": "874 Grove Street, Edgewater, Georgia, 8112",
        "about": "Ex esse dolore et sint sint proident nostrud ut officia. Do nulla mollit dolore ut aute excepteur deserunt laboris ut proident. Ullamco est deserunt ex commodo veniam duis elit excepteur velit ullamco deserunt culpa do est.\r\n",
        "registered": "2015-02-22T10:25:32 +04:00",
        "latitude": 56.278862,
        "longitude": -79.459101,
        "tags": [
            "labore",
            "proident",
            "aliqua",
            "amet",
            "amet",
            "officia",
            "enim"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Mason Noble"
            },
            {
                "id": 1,
                "name": "Coffey Mendez"
            },
            {
                "id": 2,
                "name": "Dionne Cole"
            }
        ],
        "greeting": "Hello, Johns Lewis! You have 5 unread messages.",
        "favoriteFruit": "banana"
    },
    {
        "_id": "59f1334c09dc1bcdc5732491",
        "index": 1,
        "guid": "33255995-0431-4271-9876-37eabc117a7b",
        "isActive": false,
        "balance": "$2,167.40",
        "picture": "http://placehold.it/32x32",
        "age": 23,
        "eyeColor": "blue",
        "name": "Williamson Gregory",
        "gender": "male",
        "company": "NETAGY",
        "email": "williamsongregory@netagy.com",
        "phone": "+1 (910) 462-3918",
        "address": "158 Sedgwick Street, Glasgow, Utah, 5498",
        "about": "Excepteur sit nisi et velit. Laboris minim id duis ad qui cupidatat. Est Lorem quis duis Lorem laboris velit laboris non excepteur et velit voluptate qui. Dolore qui anim exercitation veniam incididunt laboris labore. Id minim labore amet sunt excepteur tempor proident.\r\n",
        "registered": "2016-04-25T04:25:24 +04:00",
        "latitude": 54.457833,
        "longitude": 122.803765,
        "tags": [
            "tempor",
            "exercitation",
            "et",
            "elit",
            "ex",
            "cillum",
            "laboris"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Navarro Reeves"
            },
            {
                "id": 1,
                "name": "Stanton Vincent"
            },
            {
                "id": 2,
                "name": "Alexis Guzman"
            }
        ],
        "greeting": "Hello, Williamson Gregory! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334c9d799789bc494a3c",
        "index": 2,
        "guid": "158ffa5d-15da-4a9f-a1da-0a48b76b8226",
        "isActive": false,
        "balance": "$1,289.35",
        "picture": "http://placehold.it/32x32",
        "age": 33,
        "eyeColor": "green",
        "name": "Dalton House",
        "gender": "male",
        "company": "EYEWAX",
        "email": "daltonhouse@eyewax.com",
        "phone": "+1 (959) 550-2263",
        "address": "116 Howard Avenue, Rossmore, New York, 6302",
        "about": "Elit eu ipsum pariatur duis mollit ex quis. Amet nulla exercitation laboris minim fugiat tempor in aliqua nisi nostrud aute. Duis minim esse irure irure fugiat sit nulla et tempor nisi cillum proident id adipisicing. Eu elit magna Lorem irure labore. Aliquip id sint veniam adipisicing. Amet eiusmod mollit reprehenderit reprehenderit dolore.\r\n",
        "registered": "2017-02-28T08:53:00 +04:00",
        "latitude": -25.679774,
        "longitude": 29.374781,
        "tags": [
            "qui",
            "cillum",
            "anim",
            "irure",
            "non",
            "commodo",
            "deserunt"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Carmela Wilcox"
            },
            {
                "id": 1,
                "name": "Elba Garza"
            },
            {
                "id": 2,
                "name": "Garrison Church"
            }
        ],
        "greeting": "Hello, Dalton House! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334cd1518c3a44d69fff",
        "index": 3,
        "guid": "5109bc50-9a8e-4184-aba0-6740dc00b606",
        "isActive": true,
        "balance": "$3,891.83",
        "picture": "http://placehold.it/32x32",
        "age": 22,
        "eyeColor": "blue",
        "name": "Ray Wilkins",
        "gender": "male",
        "company": "EXPOSA",
        "email": "raywilkins@exposa.com",
        "phone": "+1 (812) 414-3258",
        "address": "837 Bedford Avenue, Harleigh, South Carolina, 2323",
        "about": "Est amet quis eu proident ipsum veniam sit. Irure labore ad consectetur ullamco sit ipsum proident. Ad pariatur irure nisi irure commodo aliquip nisi eu anim irure dolor dolor veniam quis.\r\n",
        "registered": "2015-09-17T04:52:42 +04:00",
        "latitude": 34.354801,
        "longitude": -168.303952,
        "tags": [
            "nisi",
            "laboris",
            "incididunt",
            "amet",
            "aute",
            "quis",
            "mollit"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Olivia Russo"
            },
            {
                "id": 1,
                "name": "Rita Tyler"
            },
            {
                "id": 2,
                "name": "Lorie Walker"
            }
        ],
        "greeting": "Hello, Ray Wilkins! You have 1 unread messages.",
        "favoriteFruit": "strawberry"
    },
    {
        "_id": "59f1334c6901bda003e52fa6",
        "index": 4,
        "guid": "0ab33477-b152-4b12-af35-f5b9254d5c2a",
        "isActive": true,
        "balance": "$3,730.71",
        "picture": "http://placehold.it/32x32",
        "age": 27,
        "eyeColor": "brown",
        "name": "Madden Hatfield",
        "gender": "male",
        "company": "ZOGAK",
        "email": "maddenhatfield@zogak.com",
        "phone": "+1 (832) 552-2294",
        "address": "530 Clermont Avenue, Bethpage, Virgin Islands, 5607",
        "about": "Commodo tempor anim tempor deserunt laboris qui eu reprehenderit consequat. Non laborum ullamco qui proident. Est cupidatat do dolor excepteur est nostrud laborum. Eu excepteur ex commodo aliquip adipisicing excepteur. Et reprehenderit laboris reprehenderit aute ut excepteur deserunt nostrud velit. Ullamco est sit fugiat irure aliqua aliquip proident. Voluptate ad culpa dolor id enim tempor laborum.\r\n",
        "registered": "2016-04-10T03:37:17 +04:00",
        "latitude": 80.888876,
        "longitude": 117.84337,
        "tags": [
            "occaecat",
            "nisi",
            "est",
            "ad",
            "nostrud",
            "eu",
            "dolore"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Vincent Gay"
            },
            {
                "id": 1,
                "name": "Rosario Forbes"
            },
            {
                "id": 2,
                "name": "Baxter Green"
            }
        ],
        "greeting": "Hello, Madden Hatfield! You have 4 unread messages.",
        "favoriteFruit": "banana"
    }
];

},{}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var table_1 = require("./wml/table");
var data_1 = require("./data");
var columns = [
    { name: 'index', heading: '#' },
    { name: 'name', heading: 'Name' },
    { name: 'balance', heading: 'Balance' }
];
var TablePage = /** @class */ (function (_super) {
    __extends(TablePage, _super);
    function TablePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new table_1.Main(_this);
        _this.values = {
            users: data_1.users,
            columns: columns,
            onCellClicked: function (e) {
                var span = document.createElement('span');
                span.appendChild(document.createTextNode("You clicked " + e.column + e.rowNumber + "!"));
                e.cell.setContent({ render: function () { return span; } });
            }
        };
        return _this;
    }
    return TablePage;
}(Page_1.Page));
exports.TablePage = TablePage;

},{"../Page":4,"./data":43,"./wml/table":45}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var Table_1 = require("../../../../../lib/data/table/Table");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(Table_1.Table, {
                    html: {},
                    wml: {},
                    ww: {
                        'selectable': true,
                        'data': ___context.values.users,
                        'columns': ___context.values.columns,
                        'onCellClicked': ___context.values.onCellClicked
                    }
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/data/table/Table":125,"../../../page-example":2,"@quenk/wml":160}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var Page_1 = require("../Page");
var TextFieldPage = /** @class */ (function (_super) {
    __extends(TextFieldPage, _super);
    function TextFieldPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.id = 'text';
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            (value === 'error') ?
                _this.get(_this.id, function (c) {
                    return c.error('This control is now in the error state!');
                }) :
                (value === 'success') ?
                    _this.get(_this.id, function (c) {
                        return c.success('This control is now in the success state!');
                    }) :
                    (value === 'warning') ?
                        _this.get(_this.id, function (c) {
                            return c.warning('This control now in the warning state!');
                        }) :
                        (value === 'neutral') ?
                            _this.get(_this.id, function (c) {
                                return c.neutral();
                            }) :
                            _this
                                .view
                                .findById('content')
                                .map(function (e) {
                                while (e.lastChild)
                                    e.removeChild(e.lastChild);
                                e.appendChild(document.createTextNode(value));
                            });
        };
        return _this;
    }
    return TextFieldPage;
}(Page_1.Page));
exports.TextFieldPage = TextFieldPage;

},{"../Page":4,"./wml/text-field":47}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var grid_layout_1 = require("../../../../../lib/layout/grid-layout");
;
var text_field_1 = require("../../../../../lib/control/text-field");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(grid_layout_1.GridLayout, {
                html: {},
                wml: {}
            }, [___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The value of the input is:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {
                                'id': "content"
                            }
                        }, [___wml.domify("(Nothing)")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(text_field_1.TextField, {
                                html: {},
                                wml: {
                                    'id': "text"
                                },
                                ww: {
                                    'name': "text",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Success")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(text_field_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'success': "This textfield has a success",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Warning")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(text_field_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'warning': "This textfield has a warning.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Error")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(text_field_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'error': "This textfield has an error.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(grid_layout_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(grid_layout_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The one uses rows to render a text area:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(text_field_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'rows': 3,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/text-field":112,"../../../../../lib/layout/grid-layout":134,"@quenk/wml":160}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/toolbar");
var Page_1 = require("../Page");
var ToolbarPage = /** @class */ (function (_super) {
    __extends(ToolbarPage, _super);
    function ToolbarPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return ToolbarPage;
}(Page_1.Page));
exports.ToolbarPage = ToolbarPage;

},{"../Page":4,"./wml/toolbar":49}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var page_example_1 = require("../../../page-example");
;
var toolbar_1 = require("../../../../../lib/control/toolbar");
;
var button_1 = require("../../../../../lib/control/button");
;
var button_group_1 = require("../../../../../lib/control/button-group");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(page_example_1.PageExample, {
                html: {},
                wml: {}
            }, [___wml.widget(toolbar_1.Toolbar, {
                    html: {},
                    wml: {}
                }, [___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'text': "Start"
                        }
                    }, [], ___view), ___wml.widget(button_group_1.ButtonGroup, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(button_1.Button, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "Up"
                            }
                        }, [], ___view), ___wml.widget(button_1.Button, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "Down"
                            }
                        }, [], ___view), ___wml.widget(button_1.Button, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': "Reset"
                            }
                        }, [], ___view)], ___view), ___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'text': "Stop"
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../../../lib/control/button":81,"../../../../../lib/control/button-group":77,"../../../../../lib/control/toolbar":114,"../../../page-example":2,"@quenk/wml":160}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var drawer_layout_1 = require("../../../lib/layout/drawer-layout");
;
var action_bar_1 = require("../../../lib/app/action-bar");
;
;
var button_1 = require("../../../lib/control/button");
;
var dash_1 = require("../../../lib/app/dash");
;
var main_layout_1 = require("../../../lib/layout/main-layout");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(drawer_layout_1.DrawerLayout, {
                html: {},
                wml: {
                    'id': ___context.values.id.layout
                },
                ww: {
                    'drawer': ___context.navigation
                }
            }, [___wml.widget(action_bar_1.ActionBar, {
                    html: {},
                    wml: {}
                }, [___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': "toggle",
                            'onClick': ___context.toggleDrawer
                        }
                    }, [___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view), ___wml.widget(main_layout_1.MainLayout, {
                    html: {},
                    wml: {}
                }, [(___context.content) ? ___wml.domify(___context.content.render()) : ___wml.domify("")], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../lib/app/action-bar":52,"../../../lib/app/dash":54,"../../../lib/control/button":81,"../../../lib/layout/drawer-layout":128,"../../../lib/layout/main-layout":142,"@quenk/wml":160}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var nav_1 = require("../../../lib/content/nav");
;
var item_1 = require("../../../lib/content/nav/item");
;
var nav_header_1 = require("../../../lib/content/nav/nav-header");
;
var link_1 = require("../../../lib/content/nav/link");
var Navigation = /** @class */ (function (_super) {
    __extends(Navigation, _super);
    function Navigation(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(nav_1.Nav, {
                html: {},
                wml: {},
                ww: {
                    'vertical': true
                }
            }, [___wml.widget(item_1.Item, {
                    html: {},
                    wml: {}
                }, [___wml.widget(link_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'active': (___context.page === "home"),
                            'name': "home",
                            'href': "#",
                            'onClick': ___context.navigate,
                            'text': "Home"
                        }
                    }, [], ___view)], ___view), ___wml.map(___context.links, function _map(items, section) {
                    return ___wml.widget(item_1.Item, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(nav_header_1.NavHeader, {
                            html: {},
                            wml: {},
                            ww: {
                                'text': ___context.displayName(section)
                            }
                        }, [], ___view), ___wml.widget(nav_1.Nav, {
                            html: {},
                            wml: {},
                            ww: {
                                'vertical': true
                            }
                        }, [___wml.map(___context.sort(items), function _map(_, name) {
                                return ___wml.widget(item_1.Item, {
                                    html: {},
                                    wml: {}
                                }, [___wml.widget(link_1.Link, {
                                        html: {},
                                        wml: {
                                            'group': "links"
                                        },
                                        ww: {
                                            'name': name,
                                            'href': "#/" + name,
                                            'onClick': ___context.navigate,
                                            'active': (___context.page === "" + name),
                                            'text': ___context.displayName(name)
                                        }
                                    }, [], ___view)], ___view);
                            }, function otherwise() {
                                return document.createDocumentFragment();
                            })], ___view)], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Navigation;
}(___wml.AppView));
exports.Navigation = Navigation;

},{"../../../lib/content/nav":61,"../../../lib/content/nav/item":62,"../../../lib/content/nav/link":64,"../../../lib/content/nav/nav-header":66,"@quenk/wml":160}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var orientation = require("../../content/orientation");
var Group_1 = require("../../content/Group");
var action_bar_1 = require("./wml/action-bar");
///classNames:begin
/**
 * ACTION_BAR class name. for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT class name.
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
var ActionBar = /** @class */ (function (_super) {
    __extends(ActionBar, _super);
    function ActionBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new action_bar_1.Main(_this);
        _this.values = {
            id: {
                content: 'content'
            },
            class: {
                root: util.combine([
                    exports.ACTION_BAR,
                    orientation.RIGHT_PUSHABLE,
                    orientation.POSITIONED
                ]),
                content: exports.ACTION_BAR_CONTENT
            }
        };
        return _this;
    }
    return ActionBar;
}(Group_1.Group));
exports.ActionBar = ActionBar;

},{"../../content/Group":58,"../../content/orientation":69,"../../util":155,"./wml/action-bar":53}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.class.content
                    },
                    wml: {
                        'id': ___context.values.id.content
                    }
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var dash_1 = require("./wml/dash");
///classNames:begin
/**
 * DASH
 */
exports.DASH = 'ww-dash';
///classNames:end
/**
 * Dash are literal horizontal dashes.
 *
 * These can be used with app/menu/Button to create 'hamburger' menus.
 */
var Dash = /** @class */ (function (_super) {
    __extends(Dash, _super);
    function Dash() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new dash_1.Main(_this);
        _this.values = {
            class: {
                root: exports.DASH
            }
        };
        return _this;
    }
    return Dash;
}(wml_1.Component));
exports.Dash = Dash;

},{"./wml/dash":55,"@quenk/wml":160}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('span', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var activity_indicator_1 = require("./wml/activity-indicator");
var util_1 = require("../../../util");
///classNames:begin
exports.ACTIVITY_INDICATOR = 'ww-activity-indicator';
/**
 * Busy provides a css driven animation that indicates
 * some action or activity is being carried out.
 */
var ActivityIndicator = /** @class */ (function (_super) {
    __extends(ActivityIndicator, _super);
    function ActivityIndicator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new activity_indicator_1.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.ACTIVITY_INDICATOR, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return ActivityIndicator;
}(wml.Component));
exports.ActivityIndicator = ActivityIndicator;

},{"../../../util":155,"./wml/activity-indicator":57,"@quenk/wml":160}],57:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Group is an abstract class providing an api for
 * widgets whose primary purpose is displaying content.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * setContent changes the content value.
     */
    Group.prototype.setContent = function (content) {
        this.content = content;
        this.view.invalidate();
        return this;
    };
    /**
     * removeContent removes existing content.
     */
    Group.prototype.removeContent = function () {
        this.content = null;
        return this;
    };
    return Group;
}(wml_1.Component));
exports.Group = Group;

},{"@quenk/wml":160}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/breadcrumb");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../../util");
///classNames:begin
exports.BREADCRUMB = 'ww-breadcrumb'; //@todo un-bootstrap
///classNames:end
var item_1 = require("../item");
exports.Item = item_1.Item;
/**
 * Breadcrumb
 */
var Breadcrumb = /** @class */ (function (_super) {
    __extends(Breadcrumb, _super);
    function Breadcrumb() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.BREADCRUMB, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Breadcrumb;
}(wml_1.Component));
exports.Breadcrumb = Breadcrumb;

},{"../../../util":155,"../item":62,"./wml/breadcrumb":60,"@quenk/wml":160}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('ol', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var util = require("../../util");
var views = require("./wml/nav");
var orientation_1 = require("../orientation");
var item_1 = require("./item");
exports.Item = item_1.Item;
var link_1 = require("./link");
exports.Link = link_1.Link;
///classNames:begin
/**
 * NAV
 */
exports.NAV = 'ww-nav';
/**
 * Nav provides styling for displaying a list of anchor links.
 */
var Nav = /** @class */ (function (_super) {
    __extends(Nav, _super);
    function Nav() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: util.concat(exports.NAV, _this.attrs.ww && _this.attrs.ww.class, _this.attrs.ww && _this.attrs.ww.vertical && orientation_1.VERTICAL)
            }
        };
        return _this;
    }
    return Nav;
}(wml.Component));
exports.Nav = Nav;

},{"../../util":155,"../orientation":69,"./item":62,"./link":64,"./wml/nav":68,"@quenk/wml":160}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/item");
var active_1 = require("../../state/active");
var active_2 = require("../../state/active");
var util_1 = require("../../../util");
var get = function (i) {
    return function () { return i.view.findById(i.values.root.id).map(function (e) { return e; }); };
};
///classNames:begin
/**
 * ITEM
 */
exports.ITEM = 'ww-item';
/**
 * ItemClickedEvent is fired when the user clicks on an item in
 * a nav list.
 */
var ItemClickedEvent = /** @class */ (function () {
    function ItemClickedEvent(name) {
        this.name = name;
    }
    return ItemClickedEvent;
}());
exports.ItemClickedEvent = ItemClickedEvent;
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.activate = active_1.activate(_this)(get(_this));
        _this.deactivate = active_1.deactivate(_this)(get(_this));
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(exports.ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? active_2.ACTIVE : null)
            },
            content: {
                render: function () { return (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : _this.children; }
            }
        };
        return _this;
    }
    return Item;
}(wml.Component));
exports.Item = Item;

},{"../../../util":155,"../../state/active":71,"./wml/item":63,"@quenk/wml":160}],63:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.values.content.render())], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/link");
var util_1 = require("../../../util");
var active_1 = require("../../state/active");
///classNames:begin
/**
 * LINK
 */
exports.LINK = 'ww-link';
/**
 * LinkClickedEvent indicates an Link has been clicked.
 */
var LinkClickedEvent = /** @class */ (function () {
    function LinkClickedEvent(name, href) {
        this.name = name;
        this.href = href;
    }
    return LinkClickedEvent;
}());
exports.LinkClickedEvent = LinkClickedEvent;
/**
 * Link generates an <a> element.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * name assigned to this Link.
         */
        _this.name = (_this.attrs.ww && _this.attrs.ww.name) ?
            _this.attrs.ww.name : '';
        /**
         * title assigned to this Link.
         */
        _this.title = (_this.attrs.ww && _this.attrs.ww.title) ?
            _this.attrs.ww.title : '';
        /**
         * href assigned to this Link
         */
        _this.href = (_this.attrs.ww && _this.attrs.ww.href) ?
            _this.attrs.ww.href : '';
        _this.values = {
            a: {
                id: 'root',
                disabled: _this.attrs.ww.disabled || null,
                class: util_1.concat(exports.LINK, _this.attrs.ww ? _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    active_1.ACTIVE : ''),
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : null,
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : null,
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                content: function () { return (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : _this.children; },
                clicked: function (e) {
                    if (_this.attrs.ww) {
                        var _a = _this.attrs.ww, name_1 = _a.name, href = _a.href, onClick = _a.onClick;
                        if (!href)
                            e.preventDefault();
                        if (onClick)
                            onClick(new LinkClickedEvent(name_1, href));
                    }
                }
            }
        };
        return _this;
    }
    /**
      * activate this nav list Item.
      */
    Link.prototype.activate = function () {
        this.view.findById(this.values.a.id)
            .map(function (w) {
            w.classList.remove(active_1.ACTIVE);
            w.classList.add(active_1.ACTIVE);
        });
        return this;
    };
    /**
     * deactivate this nav list item.
     */
    Link.prototype.deactivate = function () {
        this.view.findById(this.values.a.id)
            .map(function (w) { return w.classList.remove(active_1.ACTIVE); });
        return this;
    };
    return Link;
}(wml.Component));
exports.Link = Link;

},{"../../../util":155,"../../state/active":71,"./wml/link":65,"@quenk/wml":160}],65:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('a', {
                html: {
                    'class': ___context.values.a.class,
                    'href': ___context.values.a.href,
                    'title': ___context.values.a.title,
                    'disabled': ___context.values.a.disabled,
                    'onclick': ___context.values.a.clicked
                },
                wml: {}
            }, [___wml.domify(___context.values.a.content())], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/nav-header");
var util_1 = require("../../../util");
///classNames:begin
/**
 * NAV_HEADER
 */
exports.NAV_HEADER = 'ww-nav-header';
/**
 * NavHeader can be used to display non-clickable heading text in a nav list.
 */
var NavHeader = /** @class */ (function (_super) {
    __extends(NavHeader, _super);
    function NavHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            item: {
                class: ''
            },
            span: {
                class: util_1.concat(exports.NAV_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return NavHeader;
}(wml.Component));
exports.NavHeader = NavHeader;

},{"../../../util":155,"./wml/nav-header":67,"@quenk/wml":160}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('span', {
                html: {
                    'class': ___context.values.span.class
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
/**
 * VERTICAL indicates an element is vertical rendererd.
 */
exports.VERTICAL = '-vertical';
/**
 * RIGHT_PUSHABLE indicates an element can supports being pushed right
 * by specifying styles around this class.
 */
exports.RIGHT_PUSHABLE = '-right-pushable';
/**
 * POSITIONED indicates an element is positioned and responds
 * to the left ,right modifiers etc.
 */
exports.POSITIONED = '-positioned';
/**
 * BLOCK indicates an element should be block displayed.
 */
exports.BLOCK = '-block';
/**
 * CLEARFIX hack.
 */
exports.CLEARFIX = '-clearfix';
///classNames:end

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
exports.EXTRA_SMALL = '-xs-small';
exports.SMALL = '-small';
exports.MEDIUM = '-medium';
exports.LARGE = '-large';
exports.EXTRA_LARGE = '-xs-large';
///classNames:end

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
/**
 * ACTIVE
 */
exports.ACTIVE = '-active';
/**
 * deactivate this nav list item.
 */
exports.deactivate = function (a) { return function (fn) { return function () {
    return fn()
        .map(function (e) { return e.classList.remove(exports.ACTIVE); })
        .map(function () { return a; })
        .orJust(function () { return a; })
        .get();
}; }; };
/**
 * activate this nav list Item.
 */
exports.activate = function (a) { return function (fn) { return function () {
    return fn()
        .map(function (e) {
        e.classList.remove(exports.ACTIVE);
        e.classList.add(exports.ACTIVE);
    })
        .map(function () { return a; })
        .orJust(function () { return a; })
        .get();
}; }; };

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Maybe_1 = require("afpl/lib/monad/Maybe");
///classNames:begin
/**
 * HIDDEN means an element should not be visible but not removed
 * from the DOM.
 */
exports.HIDDEN = '-hidden';
/**
  * visible queries whether the Hidable is visible or not.
  *
  * It retrieves an HTMLElement by id and checks whether
  * it does not have a hidden class.
  */
exports.isHidden = function (fn) { return function () {
    return fn()
        .map(function (e) { return e.classList.contains(exports.HIDDEN); })
        .orJust(function () { return false; })
        .get();
}; };
/**
 * hide the Hidable.
 *
 * This is acheived by adding a 'hidden' class name
 * to an HTMLElement retrieved by id.
 */
exports.hide = function (h) { return function (fn) { return function () {
    return fn()
        .map(function (e) { e.classList.remove(exports.HIDDEN); e.classList.add(exports.HIDDEN); })
        .map(function () { return h; })
        .orJust(function () { return h; })
        .get();
}; }; };
/**
 * show the Hidable
 *
 * This is acheived by removing a 'hidden' class name
 * to an HTMLElement retrieved by id.
 */
exports.show = function (h) { return function (fn) { return function () {
    return Maybe_1.Maybe
        .fromBoolean(h.isHidden())
        .map(function () { return fn().map(function (e) { return e.classList.remove(exports.HIDDEN); }); })
        .map(function () { return h; })
        .orJust(function () { return h; })
        .get();
}; }; };
/**
 * toggle the visibility of the Hidable.
 */
exports.toggle = function (h) { return function (fn) { return function () {
    return fn()
        .map(function (e) { return e.classList.toggle(exports.HIDDEN); })
        .map(function () { return h; })
        .orJust(function () { return h; })
        .get();
}; }; };

},{"afpl/lib/monad/Maybe":167}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
///classNames:begin
/**
 * DEFAULT style.
 */
exports.DEFAULT = '-default';
/**
 * PRIMARY style.
 */
exports.PRIMARY = '-primary';
/**
 * SUCCESS style.
 */
exports.SUCCESS = '-success';
/**
 * INFO style.
 */
exports.INFO = '-info';
/**
 * WARNING style.
 */
exports.WARNING = '-warning';
/**
 * ERROR style.
 */
exports.ERROR = '-error';
/**
 * OUTLINE style.
 */
exports.OUTLINE = '-outline';
///classNames:end

},{}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/caret");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../../util");
///classNames:begin
exports.CARET = 'ww-caret';
var Caret = /** @class */ (function (_super) {
    __extends(Caret, _super);
    function Caret() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.CARET, _this.attrs.ww && _this.attrs.ww.class)
            }
        };
        return _this;
    }
    return Caret;
}(wml_1.Component));
exports.Caret = Caret;

},{"../../../util":155,"./wml/caret":75,"@quenk/wml":160}],75:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('span', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/button-group");
var util_1 = require("../../util");
var toolbar_1 = require("../toolbar");
///classNames:begin
exports.BUTTON_GROUP = 'ww-button-group';
///classNames:end
/**
 * ButtonGroup groups multiple buttons into one element.
 */
var ButtonGroup = /** @class */ (function (_super) {
    __extends(ButtonGroup, _super);
    function ButtonGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.BUTTON_GROUP, toolbar_1.TOOLBAR_COMPAT, (_this.attrs.ww) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return ButtonGroup;
}(wml.Component));
exports.ButtonGroup = ButtonGroup;

},{"../../util":155,"../toolbar":114,"./wml/button-group":78,"@quenk/wml":160}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonGroup_1 = require("./ButtonGroup");
exports.ButtonGroup = ButtonGroup_1.ButtonGroup;

},{"./ButtonGroup":76}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var style = require("../../content/style");
var active = require("../../content/state/active");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var util_1 = require("../../util");
var _1 = require("../");
///className:begin
exports.BUTTON_SELECT = 'ww-button-select';
exports.BUTTON_SELECT_OPTION = 'ww-button-select__option';
/**
 * ButtonChangedEvent
 */
var ButtonChangedEvent = /** @class */ (function (_super) {
    __extends(ButtonChangedEvent, _super);
    function ButtonChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonChangedEvent;
}(_1.Event));
exports.ButtonChangedEvent = ButtonChangedEvent;
/**
 * ButtonSelect
 */
var ButtonSelect = /** @class */ (function (_super) {
    __extends(ButtonSelect, _super);
    function ButtonSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: exports.BUTTON_SELECT
            },
            buttons: {
                value: _this.attrs.ww.value,
                options: _this.attrs.ww.options,
                isActive: function (v) { return _this.values.buttons.value === v; },
                click: function (value) {
                    _this.values.buttons.value = value;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new ButtonChangedEvent(_this.attrs.ww.name, value));
                    _this.view.invalidate();
                },
                getClass: function (o) {
                    return util_1.concat(exports.BUTTON_SELECT_OPTION, o.class, (_this.attrs.ww.style) ?
                        _this.attrs.ww.style :
                        style.DEFAULT, _this.values.buttons.isActive(o.value) ? active.ACTIVE : '');
                }
            }
        };
        return _this;
    }
    return ButtonSelect;
}(_1.GenericControl));
exports.ButtonSelect = ButtonSelect;
/**
 * MultiButtonSelect
 */
var MultiButtonSelect = /** @class */ (function (_super) {
    __extends(MultiButtonSelect, _super);
    function MultiButtonSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: exports.BUTTON_SELECT
            },
            buttons: {
                value: _this.attrs.ww.value || [],
                options: _this.attrs.ww.options,
                isActive: function (v) { return _this.values.buttons.value.indexOf(v) > -1; },
                click: function (v) {
                    _this.values.buttons.value =
                        Maybe_1.Maybe
                            .fromArray(_this.values.buttons.value)
                            .map(function (value) {
                            var pos = value.indexOf(v);
                            if (pos > -1)
                                value.splice(pos, 1);
                            else
                                value.push(v);
                            if (_this.attrs.ww.onChange)
                                _this.attrs.ww.onChange(new ButtonChangedEvent(_this.attrs.ww.name, value.slice()));
                            _this.view.invalidate();
                            return value;
                        })
                            .orJust(function () { return [v]; })
                            .get();
                },
                getClass: function (o) {
                    return util_1.concat(exports.BUTTON_SELECT_OPTION, o.class, (_this.attrs.ww.style) ?
                        _this.attrs.ww.style :
                        style.DEFAULT, _this.values.buttons.isActive(o.value) ? active.ACTIVE : '');
                }
            }
        };
        return _this;
    }
    return MultiButtonSelect;
}(_1.GenericControl));
exports.MultiButtonSelect = MultiButtonSelect;

},{"../":91,"../../content/state/active":71,"../../content/style":73,"../../util":155,"./wml/button-select":80,"afpl/lib/monad/Maybe":167}],80:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var button_group_1 = require("../../button-group");
;
var button_1 = require("../../button");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(button_group_1.ButtonGroup, {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.map(___context.values.buttons.options, function _map(opt) {
                    return ___wml.widget(button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'class': ___context.values.buttons.getClass(opt),
                            'active': ___context.values.buttons.isActive(opt.value),
                            'onClick': function () { return ___context.values.buttons.click(opt.value); },
                            'text': opt.title
                        }
                    }, [], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../button":81,"../../button-group":77,"@quenk/wml":160}],81:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button");
var style = require("../../content/style");
var active = require("../../content/state/active");
var orientation = require("../../content/orientation");
var util_1 = require("../../util");
var toolbar_1 = require("../toolbar");
var _1 = require("../");
///classNames:begin
exports.BUTTON = 'ww-button';
;
/**
 * ButtonClickedEvent
 */
var ButtonClickedEvent = /** @class */ (function (_super) {
    __extends(ButtonClickedEvent, _super);
    function ButtonClickedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonClickedEvent;
}(_1.Event));
exports.ButtonClickedEvent = ButtonClickedEvent;
/**
 * Button is an improvement over HTMLButtionElement
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            button: {
                id: 'button',
                class: _this.attrs.ww ?
                    util_1.concat(exports.BUTTON, toolbar_1.TOOLBAR_COMPAT, _this.attrs.ww.class, _this.attrs.ww.style || style.DEFAULT, _this.attrs.ww.size && _this.attrs.ww.size, _this.attrs.ww.outline && style.OUTLINE, _this.attrs.ww.block && orientation.BLOCK, _this.attrs.ww.active && active.ACTIVE) : exports.BUTTON,
                type: (_this.attrs.ww && _this.attrs.ww.type) ? _this.attrs.ww.type : 'button',
                name: (_this.attrs.ww && _this.attrs.ww.name) ? _this.attrs.ww.name : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ? true : null,
                onclick: function () { return _this.attrs.ww &&
                    _this.attrs.ww.onClick &&
                    _this.attrs.ww.onClick(new ButtonClickedEvent(_this.attrs.ww.name || '', _this.attrs.ww.value)); },
                text: (_this.attrs.ww && _this.attrs.ww.text) ? _this.attrs.ww.text : ''
            }
        };
        return _this;
    }
    /**
     * disable this button.
     */
    Button.prototype.disable = function () {
        this
            .view
            .findById(this.values.button.id)
            .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    /**
     * enable this button.
     */
    Button.prototype.enable = function () {
        this
            .view
            .findById(this.values.button.id)
            .map(function (b) { return b.removeAttribute('disabled'); });
    };
    /**
     * toggle the disabled state of this button.
     */
    Button.prototype.toggle = function () {
        var _this = this;
        this
            .view
            .findById(this.values.button.id)
            .map(function (b) { return b.hasAttribute('disabled') ?
            _this.enable() :
            _this.disable(); });
    };
    return Button;
}(_1.GenericControl));
exports.Button = Button;

},{"../":91,"../../content/orientation":69,"../../content/state/active":71,"../../content/style":73,"../../util":155,"../toolbar":114,"./wml/button":82}],82:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('button', {
                html: {
                    'id': ___context.values.button.id,
                    'type': ___context.values.button.type,
                    'name': ___context.values.button.name,
                    'disabled': ___context.values.button.disabled,
                    'class': ___context.values.button.class,
                    'onclick': ___context.values.button.onclick
                },
                wml: {
                    'id': ___context.values.button.id
                }
            }, [___wml.domify(___context.values.button.text), ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],83:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var checkbox_1 = require("./wml/checkbox");
var _1 = require("../");
///classNames:begin
exports.CHECKBOX = 'ww-checkbox';
/**
 * CheckChangedEvent signals the user has changed the checkbox state.
 */
var CheckChangedEvent = /** @class */ (function (_super) {
    __extends(CheckChangedEvent, _super);
    function CheckChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CheckChangedEvent;
}(_1.Event));
exports.CheckChangedEvent = CheckChangedEvent;
/**
 * Checkbox control.
 *
 * This is an alternative to the native checkbox that can be styled.
 */
var Checkbox = /** @class */ (function (_super) {
    __extends(Checkbox, _super);
    function Checkbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new checkbox_1.Main(_this);
        _this.values = {
            root: {
                class: exports.CHECKBOX,
            },
            input: {
                name: _this.attrs.ww.name,
                value: _this.attrs.ww.value || null,
                onChange: function () {
                    _this.values.input.value = (!_this.values.input.value) || null;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new CheckChangedEvent(_this.values.input.name, _this.values.input.value || false));
                }
            }
        };
        return _this;
    }
    return Checkbox;
}(_1.GenericControl));
exports.Checkbox = Checkbox;

},{"../":91,"./wml/checkbox":84}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.node('label', {
                    html: {},
                    wml: {}
                }, [___wml.node('input', {
                        html: {
                            'type': "checkbox",
                            'name': ___context.values.input.name,
                            'checked': ___context.values.input.value,
                            'onchange': ___context.values.input.onChange
                        },
                        wml: {}
                    }, [], ___view), ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],85:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var moment = require("moment");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var _1 = require("../");
var _prefix = function (s, inc) {
    if (inc === void 0) { inc = false; }
    var n = Number(s);
    if (inc)
        n = n + 1;
    if (isNaN(n))
        return '';
    return (n < 10) ? "0" + n : "" + n;
};
var _months = function () {
    return exports.MONTHS.map(function (label, value) { return ({ label: label, value: _prefix(value + 1) }); });
};
///classNames:begin
/**
 * DATE class name.
 */
exports.DATE = 'ww-date';
/**
 * DATE_DAY class name.
 */
exports.DATE_DAY = exports.DATE + "__day";
/**
 * DATE_MONTH class name.
 */
exports.DATE_MONTH = exports.DATE + "__month";
/**
 * DATE_YEAR class name.
 */
exports.DATE_YEAR = exports.DATE + "__year form-control";
/**
 * DateChangedEvent is generated when the date has
 * been changed to a valid date.
 */
var DateChangedEvent = /** @class */ (function (_super) {
    __extends(DateChangedEvent, _super);
    function DateChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DateChangedEvent;
}(_1.Event));
exports.DateChangedEvent = DateChangedEvent;
exports.format = {
    YYYYDDMM: 'YYYY-MM-DD',
    DD: 'DD',
    MM: 'MM',
    YYYY: 'YYYY'
};
exports.MONTHS = [
    'Jan', 'Feb', 'Mar',
    'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'
];
/**
 * Date input.
 */
var Date = /** @class */ (function (_super) {
    __extends(Date, _super);
    function Date() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.get = function () { return _this.calculate().format(_this.values.date.format); };
        _this.set = function (_) { return _this; };
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(exports.DATE, 'form-group', _this.attrs.ww && _this.attrs.ww.class, feedback_1.selectState(_this.attrs.ww)),
            },
            inline: {
                class: 'form-inline'
            },
            date: {
                months: _months(),
                value: (_this.attrs.ww && _this.attrs.ww.value) ?
                    moment(_this.attrs.ww.value, exports.format.YYYYDDMM) : null,
                sep: '-',
                format: exports.format.YYYYDDMM,
                fire: function () {
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        if (_this.values.date.value && _this.values.date.value.isValid())
                            _this.attrs.ww.onChange(new DateChangedEvent(_this.values.name, _this.values.date.value.format(_this.values.date.format)));
                }
            },
            month: {
                id: 'month',
                class: util_1.concat(exports.DATE_MONTH, 'form-control'),
                value: function () { return (_this.values.date.value && _this.values.date.value.isValid()) ?
                    _this.values.date.value.format(exports.format.MM) : ''; },
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled === true) ?
                    true : null,
                onchange: function (e) {
                    _this
                        .view
                        .findById(_this.values.day.id)
                        .map(function (e) { e.focus(); })
                        .map(function () {
                        _this.values.month.value =
                            function () { return e.target.value; };
                        _this.values.date.value = _this.calculate();
                        _this.values.date.fire();
                    });
                }
            },
            day: {
                id: 'day',
                class: util_1.concat(exports.DATE_DAY, 'form-control'),
                value: function () { return (_this.values.date.value && _this.values.date.value.isValid()) ?
                    _this.values.date.value.format(exports.format.DD) : ''; },
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled === true) ? true : null,
                oninput: function (e) {
                    e.target.oninput = null;
                    _this.values.day.onkeyup(e);
                },
                onkeyup: function (e) {
                    var value = e.target.value;
                    _this.values.day.value =
                        function () { return _prefix(value); };
                    _this.values.date.value = _this.calculate();
                    _this.values.date.fire();
                    console.error(value, value.length);
                    if (value.length === 2)
                        _this
                            .view
                            .findById(_this.values.year.id)
                            .map(function (e) { return e.focus(); });
                }
            },
            year: {
                id: 'year',
                class: exports.DATE_YEAR,
                value: function () { return (_this.values.date.value && _this.values.date.value.isValid()) ?
                    _this.values.date.value.format(exports.format.YYYY) : ''; },
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled === true) ? true : null,
                oninput: function (e) {
                    e.target.oninput = null;
                    _this.values.year.onkeyup(e);
                },
                onkeyup: function (e) {
                    _this.values.year.value = function () { return e.target.value; };
                    _this.values.date.value = _this.calculate();
                    _this.values.date.fire();
                }
            },
            name: (_this.attrs.ww && _this.attrs.ww.name) || '<name>',
            messages: {
                id: 'messages',
                success: (_this.attrs.ww && _this.attrs.ww.success) || undefined,
                error: (_this.attrs.ww && _this.attrs.ww.error) || undefined,
                warning: (_this.attrs.ww && _this.attrs.ww.warning) || undefined
            },
            label: {
                id: (_this.attrs.ww && _this.attrs.ww.name) || '<name>',
                text: (_this.attrs.ww && _this.attrs.ww.label) || '<label>'
            }
        };
        return _this;
    }
    /**
     * calculate the date based on the current value of the inputs.
     */
    Date.prototype.calculate = function () {
        var date = [
            this.values.year.value(),
            this.values.month.value(),
            this.values.day.value()
        ].filter(function (d) { return d; });
        return (date.length != 3) ?
            null :
            moment(date.join(this.values.date.sep), moment.ISO_8601);
    };
    ;
    return Date;
}(feedback_1.GenericFeedbackControl));
exports.Date = Date;

},{"../":91,"../../util":155,"../feedback":89,"./wml/date":86,"moment":174}],86:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var wml_1 = require("../../wml");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id)(___context.values.label.text)(___view)), ___wml.node('div', {
                    html: {
                        'class': ___context.values.inline.class
                    },
                    wml: {}
                }, [___wml.node('select', {
                        html: {
                            'name': ___context.values.month.id,
                            'onchange': ___context.values.month.onchange,
                            'disabled': ___context.values.month.disabled,
                            'class': ___context.values.month.class
                        },
                        wml: {
                            'id': ___context.values.month.id
                        }
                    }, [___wml.node('option', {
                            html: {
                                'selected': true,
                                'value': "",
                                'disabled': true
                            },
                            wml: {}
                        }, [___wml.text("Month")], ___view), ___wml.map(___context.values.date.months, function _map(opt) {
                            return ___wml.node('option', {
                                html: {
                                    'value': opt.value
                                },
                                wml: {}
                            }, [___wml.domify(opt.label)], ___view);
                        }, function otherwise() {
                            return document.createDocumentFragment();
                        })], ___view), ___wml.node('input', {
                        html: {
                            'name': ___context.values.day.id,
                            'oninput': ___context.values.day.oninput,
                            'onkeyup': ___context.values.day.onkeyup,
                            'value': ___context.values.day.value(),
                            'disabled': ___context.values.day.disabled,
                            'class': ___context.values.day.class,
                            'size': "2",
                            'placeholder': "DD"
                        },
                        wml: {
                            'id': ___context.values.day.id
                        }
                    }, [], ___view), ___wml.node('input', {
                        html: {
                            'name': ___context.values.year.id,
                            'oninput': ___context.values.year.oninput,
                            'onkeyup': ___context.values.year.onkeyup,
                            'value': ___context.values.year.value(),
                            'disabled': ___context.values.year.disabled,
                            'class': ___context.values.year.class,
                            'placeholder': "YYYY",
                            'size': "4"
                        },
                        wml: {
                            'id': ___context.values.year.id
                        }
                    }, [], ___view), ___wml.domify(wml_1.message(___context.values.messages.id)(___context.values.messages)(___view))], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../wml":116,"@quenk/wml":160}],87:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/drop-down");
var hidden = require("../../content/state/hidden");
var style = require("../../content/style");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var content = function (dm) { return function () {
    return dm.view.findById(dm.values.content.id);
}; };
///classNames:begin
exports.DROP_DOWN = 'ww-drop-down-menu';
exports.DROP_DOWN_TOGGLE = 'ww-drop-down-menu__toggle';
exports.DROP_DOWN_CONTENT = 'ww-drop-down__content';
/**
 * DropDown provides a component for displaying a pop up menu.
 *
 *
 *    +--------+
 *    |  Menu  |
 *    +--------+
 *    +-------------------------+
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    | ----------------------- |
 *    |                         |
 *    +-------------------------+
 */
var DropDown = /** @class */ (function (_super) {
    __extends(DropDown, _super);
    function DropDown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.isHidden = hidden.isHidden(content(_this));
        _this.hide = hidden.hide(_this)(content(_this));
        _this.show = hidden.show(_this)(content(_this));
        _this.toggle = hidden.toggle(_this)(content(_this));
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(exports.DROP_DOWN, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            },
            button: {
                text: _this.attrs.ww.buttonText ? _this.attrs.ww.buttonText : '',
                class: style.DEFAULT,
                template: function () { return _this.attrs.ww.buttonTemplate ?
                    _this.attrs.ww.buttonTemplate : views.button; },
            },
            toggle: {
                class: util_1.concat(exports.DROP_DOWN_TOGGLE, style.PRIMARY),
                onClick: function () {
                    _this
                        .view
                        .findById(_this.values.root.id)
                        .map(function (e) {
                        if (_this.values.content.autoClose) {
                            for (var i = 0; i < e.children.length; i++) {
                                e.children[i].removeEventListener('click', _this.hide);
                                e.children[i].addEventListener('click', _this.hide);
                            }
                        }
                    })
                        .map(_this.toggle)
                        .map(function () { return window.addEventListener('click', _this); });
                }
            },
            content: {
                id: 'content',
                class: util_1.concat(exports.DROP_DOWN_CONTENT, hidden.HIDDEN),
                autoClose: (_this.attrs.ww.autoClose === false) ? false : true,
                render: function () { return _this.children; }
            }
        };
        return _this;
    }
    DropDown.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.root.id)
            .map(function (root) {
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
            if ((!root.contains(e.target)))
                _this.hide();
        });
    };
    return DropDown;
}(wml_1.Component));
exports.DropDown = DropDown;

},{"../../content/state/hidden":72,"../../content/style":73,"../../util":155,"./wml/drop-down":88,"@quenk/wml":160}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var button_1 = require("../../button");
;
var caret_1 = require("../../../content/x/caret");
;
exports.button = function (___context) { return function (___view) { return ___wml.box(___wml.widget(button_1.Button, {
    html: {},
    wml: {},
    ww: {
        'class': ___context.values.button.class,
        'onClick': ___context.values.toggle.onClick,
        'text': ___context.values.button.text
    }
}, [], ___view), ___wml.widget(button_1.Button, {
    html: {},
    wml: {},
    ww: {
        'class': ___context.values.toggle.class,
        'onClick': ___context.values.toggle.onClick
    }
}, [___wml.widget(caret_1.Caret, {
        html: {},
        wml: {}
    }, [], ___view)], ___view)); }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [___wml.domify(___context.values.button.template()(___context)(___view)), ___wml.node('div', {
                    html: {
                        'class': ___context.values.content.class
                    },
                    wml: {
                        'id': ___context.values.content.id
                    }
                }, [___wml.domify(___context.values.content.render())], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../content/x/caret":74,"../../button":81,"@quenk/wml":160}],89:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var style = require("../content/style");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var control_1 = require("../control");
exports.NEUTRAL = 0x0;
exports.ERROR = 0x1;
exports.SUCCESS = 0x2;
exports.WARNING = 0x3;
/**
 * ValidationState
 */
var ValidationState;
(function (ValidationState) {
    ValidationState[ValidationState["NEUTRAL"] = 0] = "NEUTRAL";
    ValidationState[ValidationState["ERROR"] = 1] = "ERROR";
    ValidationState[ValidationState["SUCCESS"] = 2] = "SUCCESS";
    ValidationState[ValidationState["WARNING"] = 3] = "WARNING";
})(ValidationState = exports.ValidationState || (exports.ValidationState = {}));
/**
 * GenericFeedbackControl provides a base implementation of a FeedbackControl.
 */
var GenericFeedbackControl = /** @class */ (function (_super) {
    __extends(GenericFeedbackControl, _super);
    function GenericFeedbackControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.setMessage = exports.setMessage(_this)(_root(_this));
        _this.success = exports.success(_this)(_root(_this));
        _this.warning = exports.warning(_this)(_root(_this));
        _this.error = exports.error(_this)(_root(_this));
        _this.neutral = exports.neutral(_this)(_root(_this));
        _this.getValidationState = exports.getValidationState(_root(_this));
        return _this;
    }
    return GenericFeedbackControl;
}(control_1.GenericControl));
exports.GenericFeedbackControl = GenericFeedbackControl;
var _root = function (c) { return function () { return c.view.findById(c.values.root.id); }; };
/**
 * setState helper.
 */
exports.setState = function (c) { return function (fn) { return function (state) { return function (m) {
    if (m === void 0) { m = ''; }
    return Maybe_1.Maybe
        .fromAny(c.neutral())
        .map(function (c) { return c.setMessage(m); })
        .chain(function () { return fn(); })
        .map(function (e) { return e.classList.add(state); })
        .map(function () { return c; })
        .get();
}; }; }; };
/**
 * success helper.
 */
exports.success = function (c) { return function (fn) { return exports.setState(c)(fn)(style.SUCCESS); }; };
/**
 * warning helper.
 */
exports.warning = function (c) { return function (fn) { return exports.setState(c)(fn)(style.WARNING); }; };
/**
 * error helper.
 */
exports.error = function (c) { return function (fn) { return exports.setState(c)(fn)(style.ERROR); }; };
/**
 * setMessage helper.
 */
exports.setMessage = function (c) { return function (fn) { return function (msg) {
    return fn()
        .map(function (message) {
        var node = document.createTextNode(msg);
        if (message.firstChild) {
            message.replaceChild(node, message.firstChild);
        }
        else {
            message.appendChild(node);
        }
    })
        .map(function () { return c; })
        .orJust(function () { return c; })
        .get();
}; }; };
/**
 * neutral clears validation states from a control.
 */
exports.neutral = function (c) { return function (fn) { return function () {
    return fn()
        .map(function (h) {
        h.classList.remove(style.SUCCESS);
        h.classList.remove(style.ERROR);
        h.classList.remove(style.WARNING);
    })
        .map(function () { return c.setMessage(''); })
        .orJust(function () { return c; })
        .get();
}; }; };
/**
 * getValidationState default.
 */
exports.getValidationState = function (fn) { return function () {
    return fn()
        .map(function (h) { return h.classList.contains(style.SUCCESS) ?
        exports.SUCCESS :
        h.classList.contains(style.WARNING) ?
            exports.WARNING :
            h.classList.contains(style.ERROR) ?
                exports.ERROR : exports.NEUTRAL; })
        .get();
}; };
/**
 * selectState from an attribute list.
 */
exports.selectState = function (attrs) {
    return attrs.success ? style.SUCCESS :
        attrs.error ? style.ERROR :
            attrs.warning ? style.WARNING : '';
};

},{"../content/style":73,"../control":91,"afpl/lib/monad/Maybe":167}],90:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var feedback_1 = require("./feedback");
/**
 * GenericFormControl provides a base implementation of a
 * FormControl.
 */
var GenericFormControl = /** @class */ (function (_super) {
    __extends(GenericFormControl, _super);
    function GenericFormControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GenericFormControl;
}(feedback_1.GenericFeedbackControl));
exports.GenericFormControl = GenericFormControl;

},{"./feedback":89}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Event is the parent class of all events generated by controls.
 */
var Event = /** @class */ (function () {
    function Event(name, value) {
        this.name = name;
        this.value = value;
    }
    return Event;
}());
exports.Event = Event;
/**
 * GenericControl implements the methods of the Control interface.
 */
var GenericControl = /** @class */ (function (_super) {
    __extends(GenericControl, _super);
    function GenericControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GenericControl;
}(wml_1.Component));
exports.GenericControl = GenericControl;

},{"@quenk/wml":160}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hidden = require("../../content/state/hidden");
var dividerViews = require("./wml/divider");
var headerViews = require("./wml/header");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
var menu_1 = require("./wml/menu");
var item_1 = require("../../content/nav/item");
exports.Item = item_1.Item;
///classNames:begin
exports.MENU = 'ww-menu';
exports.MENU_DIVIDER = 'ww-menu__divider';
exports.MENU_HEADER = 'ww-menu__header';
///classNames:end
exports.NAV_MODE = 'nav';
exports.CONTENT_MODE = 'content';
var get = function (m) { return function () { return m.view.findById(m.values.root.id); }; };
/**
 * Header
 */
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new headerViews.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.MENU_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Header;
}(wml_1.Component));
exports.Header = Header;
/**
 * Divider
 */
var Divider = /** @class */ (function (_super) {
    __extends(Divider, _super);
    function Divider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new dividerViews.Main(_this);
        _this.values = {
            root: {
                class: exports.MENU_DIVIDER
            }
        };
        return _this;
    }
    return Divider;
}(wml_1.Component));
exports.Divider = Divider;
/**
 * Menu provides a DOM container for rendering
 * a dropdown style menu.
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        _this.isHidden = hidden.isHidden(get(_this));
        _this.hide = hidden.hide(_this)(get(_this));
        _this.show = hidden.show(_this)(get(_this));
        _this.toggle = hidden.toggle(_this)(get(_this));
        _this.values = {
            /**
             * root level values.
             */
            root: {
                id: 'root',
                class: util_1.concat(exports.MENU, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.hidden) ?
                    hidden.HIDDEN : '')
            },
            menu: {
                id: 'menu'
            },
            content: function () { return _this.children; }
        };
        return _this;
    }
    /**
     * setContent of this Menu.
     */
    Menu.prototype.setContent = function (view) {
        this.values.content = function () { return [view.render()]; };
        this.view.invalidate();
        this.show();
        return this;
    };
    return Menu;
}(wml_1.Component));
exports.Menu = Menu;

},{"../../content/nav/item":62,"../../content/state/hidden":72,"../../util":155,"./wml/divider":93,"./wml/header":94,"./wml/menu":95,"@quenk/wml":160}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],95:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [___wml.domify(___context.values.content())], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/multi-select");
var util_1 = require("../../util");
var _1 = require("../");
var select_1 = require("../select");
exports.TermChangedEvent = select_1.TermChangedEvent;
///classNames:begin
exports.MULTI_SELECT = 'ww-multi-select';
/**
 * ItemsChangedEvent
 */
var ItemsChangedEvent = /** @class */ (function (_super) {
    __extends(ItemsChangedEvent, _super);
    function ItemsChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemsChangedEvent;
}(_1.Event));
exports.ItemsChangedEvent = ItemsChangedEvent;
/**
 * MultiSelect provides a control for allowing a user to select
 * multiple items from a list.
 *
 * It use a stack to display the selected items.
 *
 *     +=========================+
 *     |  <select>               |
 *     +=========================+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 *     +-------------------------+
 *     |   <item>              x |
 *     +-------------------------+
 */
var MultiSelect = /** @class */ (function (_super) {
    __extends(MultiSelect, _super);
    function MultiSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                input: 'button',
                search: 'search',
                message: 'message'
            },
            root: {
                id: 'root',
                class: util_1.concat(exports.MULTI_SELECT, _this.attrs.ww && _this.attrs.ww.class)
            },
            help: {
                id: 'help'
            },
            search: {
                id: 'search',
                name: (_this.attrs.ww && _this.attrs.ww.name) || '',
                value: '',
                onSearch: function (evt) {
                    if (_this.attrs.ww && _this.attrs.ww.onSearch)
                        _this.attrs.ww.onSearch(evt);
                },
                onChange: function (_a) {
                    var value = _a.value;
                    return _this.push(value);
                }
            },
            stack: {
                id: 'stack',
                name: _this.attrs.ww.name,
                value: (_this.attrs.ww && _this.attrs.ww.value) ? _this.attrs.ww.value : [],
                decorator: _this.attrs.ww.decorator ?
                    _this.attrs.ww.decorator :
                    function (v) { return String(v); },
                onChange: function (e) {
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(e);
                }
            }
        };
        return _this;
    }
    /**
     * update the list of available options displayed to the user.
     */
    MultiSelect.prototype.update = function (list) {
        this
            .view
            .findById(this.values.search.id)
            .map(function (s) { return s.update(list); });
        return this;
    };
    /**
     * push a value onto the stack.
     */
    MultiSelect.prototype.push = function (v) {
        this
            .view
            .findById(this.values.stack.id)
            .map(function (s) { return s.push(v); });
        return this;
    };
    return MultiSelect;
}(_1.GenericControl));
exports.MultiSelect = MultiSelect;

},{"../":91,"../../util":155,"../select":100,"./wml/multi-select":97}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var select_1 = require("../../select");
;
var stack_1 = require("../../stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(select_1.Select, {
                    html: {},
                    wml: {
                        'id': ___context.values.search.id
                    },
                    ww: {
                        'name': ___context.values.search.name,
                        'value': ___context.values.search.value,
                        'stringifier': ___context.values.stack.decorator,
                        'onSearch': ___context.values.search.onSearch,
                        'onChange': ___context.values.search.onChange
                    }
                }, [], ___view), ___wml.widget(stack_1.Stack, {
                    html: {},
                    wml: {
                        'id': ___context.values.stack.id
                    },
                    ww: {
                        'name': ___context.values.stack.name,
                        'value': ___context.values.stack.value,
                        'decorator': ___context.values.stack.decorator,
                        'onChange': ___context.values.stack.onChange
                    }
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../select":100,"../../stack":102,"@quenk/wml":160}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/search");
var util_1 = require("../../util");
var _1 = require("../");
/**
 * ESCAPE key code.
 */
exports.ESCAPE = 27;
///className:begin
exports.SEARCH = 'ww-search form-control';
/**
 * TermChangedEvent signals the search term has changed.
 */
var TermChangedEvent = /** @class */ (function (_super) {
    __extends(TermChangedEvent, _super);
    function TermChangedEvent(name, value) {
        return _super.call(this, name, value) || this;
    }
    return TermChangedEvent;
}(_1.Event));
exports.TermChangedEvent = TermChangedEvent;
/**
 * Search provides an input that can be used in the ui for a search engine.
 */
var Search = /** @class */ (function (_super) {
    __extends(Search, _super);
    function Search() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'input',
                class: util_1.concat(exports.SEARCH, _this.attrs.ww && _this.attrs.ww.class),
                placeholder: (_this.attrs.ww && _this.attrs.ww.placeholder) || '',
                readOnly: (_this.attrs.ww && _this.attrs.ww.readOnly) || null,
                value: (_this.attrs.ww && _this.attrs.ww.value) || '',
                onfocus: function (e) {
                    _this.attrs.ww && _this.attrs.ww.onFocus();
                    e.target.value = e.target.value;
                },
                onkeydown: function (e) {
                    (e.keyCode === exports.ESCAPE) ?
                        _this.attrs.ww &&
                            _this.attrs.ww.onEscape &&
                            _this.attrs.ww.onEscape() :
                        _this.attrs.ww &&
                            _this.attrs.ww.onSearch &&
                            _this.attrs.ww.onSearch(new TermChangedEvent(_this.attrs.ww.name, e.target.value));
                },
                onkeyup: function (e) {
                    if (e.keyCode === exports.ESCAPE)
                        e.target.blur();
                },
                oninput: function (e) {
                    //For compatability reasons
                    e.target.oninput = null;
                    _this.values.root.onkeydown(e);
                }
            }
        };
        return _this;
    }
    Search.prototype.set = function (value) {
        this
            .view
            .findById(this.values.root.id)
            .map(function (e) { e.value = value; });
        return this;
    };
    Search.prototype.get = function () {
        return this
            .view
            .findById(this.values.root.id)
            .map(function (e) { return e.value; })
            .get();
    };
    return Search;
}(_1.GenericControl));
exports.Search = Search;

},{"../":91,"../../util":155,"./wml/search":99}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('input', {
                html: {
                    'class': ___context.values.root.class,
                    'onkeydown': ___context.values.root.onkeydown,
                    'onkeyup': ___context.values.root.onkeyup,
                    'oninput': ___context.values.root.oninput,
                    'onfocus': ___context.values.root.onfocus,
                    'placeholder': ___context.values.root.placeholder,
                    'readOnly': ___context.values.root.readOnly,
                    'value': ___context.values.root.value
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var util_1 = require("../../util");
var feedback_1 = require("../feedback");
var search_1 = require("../search");
exports.TermChangedEvent = search_1.TermChangedEvent;
var _1 = require("../");
exports.ESCAPE = 27;
exports.INPUT_ID = 'input';
///classNames:begin
exports.SELECT = 'ww-select';
/**
 * ItemChangedEvent
 */
var ItemChangedEvent = /** @class */ (function (_super) {
    __extends(ItemChangedEvent, _super);
    function ItemChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemChangedEvent;
}(_1.Event));
exports.ItemChangedEvent = ItemChangedEvent;
/* *
 * Autocomplate provides an input with a dropdown menu that allows
 * the user to search and select form a list of options.
 */
var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                input: 'input',
                menu: 'menu',
                message: 'mesage',
            },
            class: {
                root: '',
                input: ''
            },
            root: {
                id: 'root',
                class: util_1.concat(exports.SELECT, _this.attrs.ww.class)
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            menu: {
                id: 'menu',
                hide: true,
                options: (_this.attrs.ww && _this.attrs.ww.options) || []
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            search: {
                id: 'search',
                class: _this.attrs.ww.inputClass,
                placeholder: _this.attrs.ww.placeholder ?
                    _this.attrs.ww.placeholder : null,
                readOnly: _this.attrs.ww && _this.attrs.ww.readOnly,
                onFocus: function () {
                    if (_this.values.menu.options.length > 0)
                        _this.update(_this.values.menu.options);
                },
                onSearch: (_this.attrs.ww && _this.attrs.ww.onSearch) ?
                    _this.attrs.ww.onSearch : function () { },
                onEscape: function () { return _this.close(); },
            },
            item: {
                itemContentTemplate: function () {
                    return (_this.attrs.ww && _this.attrs.ww.itemContentTemplate) ?
                        _this.attrs.ww.itemContentTemplate : views.itemContentTemplate;
                },
                noItemsTemplate: function () {
                    return (_this.attrs.ww && _this.attrs.ww.noItemsTemplate) ?
                        _this.attrs.ww.noItemsTemplate : views.noItemsTemplate;
                },
                stringify: (_this.attrs.ww && _this.attrs.ww.stringifier) ?
                    _this.attrs.ww.stringifier : function (v) { return String(v); },
                click: function (index) {
                    var selected = _this.values.menu.options[Number(index)];
                    _this.close();
                    if (_this.attrs.ww && _this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new ItemChangedEvent(_this.attrs.ww.name, selected));
                    _this
                        .view
                        .findById(_this.values.search.id)
                        .map(function (s) { return s.set(_this.values.item.stringify(selected)); });
                }
            }
        };
        return _this;
    }
    Select.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.root.id)
            .map(function (root) {
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
            if ((!root.contains(e.target)))
                _this.close();
        });
    };
    Select.prototype.open = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.show(); });
        return this;
    };
    Select.prototype.close = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.hide(); });
        return this;
    };
    /**
     * update the Select with new item options to
     * present to the user.
     */
    Select.prototype.update = function (results) {
        var _this = this;
        this.values.menu.options = results;
        window.removeEventListener('click', this);
        window.addEventListener('click', this);
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.setContent(new views.Results(_this)); });
        return this;
    };
    return Select;
}(feedback_1.GenericFeedbackControl));
exports.Select = Select;

},{"../":91,"../../util":155,"../feedback":89,"../search":98,"./wml/select":101}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var search_1 = require("../../search");
;
var menu_1 = require("../../menu");
;
var link_1 = require("../../../content/nav/link");
;
var fragment_1 = require("../../../layout/fragment");
;
var wml_1 = require("../../wml");
;
exports.itemContentTemplate = function (___context) { return function (option) { return function (_index) { return function (___view) { return ___wml.domify(___context.values.item.stringify(option)); }; }; }; };
;
exports.noItemsTemplate = function (___context) { return function (___view) { return ___wml.domify("No results to display."); }; };
;
var Results = /** @class */ (function (_super) {
    __extends(Results, _super);
    function Results(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [___wml.map(___context.values.menu.options, function _map(option, index) {
                    return ___wml.widget(menu_1.Item, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': ("" + index)
                        }
                    }, [___wml.widget(link_1.Link, {
                            html: {},
                            wml: {},
                            ww: {
                                'onClick': function () { return ___context.values.item.click(index); }
                            }
                        }, [___wml.domify(___context.values.item.itemContentTemplate()(___context)(option)(index)(___view))], ___view)], ___view);
                }, function otherwise() {
                    return ___wml.domify(___context.values.item.noItemsTemplate()(___context)(___view));
                })], ___view);
        };
        return _this;
    }
    return Results;
}(___wml.AppView));
exports.Results = Results;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id)(___context.values.label.text)(___view)), ___wml.widget(search_1.Search, {
                    html: {},
                    wml: {
                        'id': ___context.values.search.id
                    },
                    ww: {
                        'class': ___context.values.search.class,
                        'placeholder': ___context.values.search.placeholder,
                        'readOnly': ___context.values.search.readOnly,
                        'onEscape': ___context.values.search.onEscape,
                        'onFocus': ___context.values.search.onFocus,
                        'onSearch': ___context.values.search.onSearch
                    }
                }, [], ___view), ___wml.widget(menu_1.Menu, {
                    html: {},
                    wml: {
                        'id': ___context.values.menu.id
                    },
                    ww: {
                        'hidden': true
                    }
                }, [], ___view), ___wml.domify(wml_1.message(___context.values.help.id)(___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../content/nav/link":64,"../../../layout/fragment":132,"../../menu":92,"../../search":98,"../../wml":116,"@quenk/wml":160}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var util_1 = require("../../util");
var _1 = require("../");
///classNames:begin
exports.STACK = 'ww-stack';
exports.STACK_ELEMENT = 'ww-stack__element';
exports.STACK_ELEMENT_CONTENT = 'ww-stack__element__content';
exports.STACK_CLOSE_BUTTON = 'ww-stack__button';
/**
 * StackChangedEvent is generated when the user removes an item from the stack.
 */
var StackChangedEvent = /** @class */ (function (_super) {
    __extends(StackChangedEvent, _super);
    function StackChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StackChangedEvent;
}(_1.Event));
exports.StackChangedEvent = StackChangedEvent;
/**
 * Stack displays a list of items that can be modified
 * by releasing one or more at a time.
 */
var Stack = /** @class */ (function (_super) {
    __extends(Stack, _super);
    function Stack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'stack',
                class: util_1.concat(exports.STACK, _this.attrs.ww.class),
                value: _this.attrs.ww.value ? _this.attrs.ww.value : [],
                fire: function () {
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new StackChangedEvent(_this.attrs.ww.name, _this.values.root.value.slice()));
                    _this.view.invalidate();
                }
            },
            element: {
                class: exports.STACK_ELEMENT,
                template: function () { return _this.attrs.ww.elementTemplate ?
                    _this.attrs.ww.elementTemplate(_this) : views.content(_this); },
                content: {
                    class: exports.STACK_ELEMENT_CONTENT
                },
                close: function (index) { return function () {
                    _this.values.root.value.splice(Number(index), 1);
                    _this.values.root.fire();
                }; },
                decorator: _this.attrs.ww.decorator ? _this.attrs.ww.decorator : function (v) { return String(v); }
            },
            close: {
                class: exports.STACK_CLOSE_BUTTON
            }
        };
        return _this;
    }
    /**
     * push a new member onto the stack.
     */
    Stack.prototype.push = function (value) {
        this.values.root.value.push(value);
        this.values.root.fire();
        return this;
    };
    return Stack;
}(_1.GenericControl));
exports.Stack = Stack;

},{"../":91,"../../util":155,"./wml/stack":103}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
exports.content = function (___context) { return function (v) { return function (_) { return function (___view) { return ___wml.node('div', {
    html: {
        'class': ___context.values.element.content.class
    },
    wml: {}
}, [___wml.domify(___context.values.element.decorator(v))], ___view); }; }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.map(___context.values.root.value, function _map(v, index) {
                    return ___wml.node('li', {
                        html: {
                            'class': ___context.values.element.class
                        },
                        wml: {}
                    }, [___wml.domify(___context.values.element.template()(v)(index)(___view)), ___wml.node('button', {
                            html: {
                                'class': ___context.values.close.class,
                                'onclick': ___context.values.element.close(index)
                            },
                            wml: {}
                        }, [___wml.text("\u00D7")], ___view)], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("../../control");
var switch_1 = require("./wml/switch");
///classNames:begin
exports.SWITCH = 'ww-switch';
exports.SWITCH_SLIDER = 'ww-switch__slider';
/**
 * SwitchChangedEvent signals the user has changed the switch.
 */
var SwitchChangedEvent = /** @class */ (function (_super) {
    __extends(SwitchChangedEvent, _super);
    function SwitchChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SwitchChangedEvent;
}(control_1.Event));
exports.SwitchChangedEvent = SwitchChangedEvent;
/**
 * Switch allows the user to select between one or two values.
 */
var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new switch_1.Main(_this);
        _this.values = {
            root: {
                class: exports.SWITCH
            },
            slider: {
                class: exports.SWITCH_SLIDER
            },
            input: {
                name: _this.attrs.ww.name,
                value: _this.attrs.ww.value || null,
                disabled: _this.attrs.ww.disabled ? true : null,
                onChange: function () {
                    _this.values.input.value = (!_this.values.input.value) || null;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new SwitchChangedEvent(_this.values.input.name, _this.values.input.value || false));
                }
            }
        };
        return _this;
    }
    return Switch;
}(control_1.GenericControl));
exports.Switch = Switch;

},{"../../control":91,"./wml/switch":105}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('label', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.node('input', {
                    html: {
                        'type': "checkbox",
                        'name': ___context.values.input.name,
                        'checked': ___context.values.input.value,
                        'disabled': ___context.values.input.disabled,
                        'onchange': ___context.values.input.onChange
                    },
                    wml: {}
                }, [], ___view), ___wml.node('div', {
                    html: {
                        'class': ___context.values.slider.class
                    },
                    wml: {}
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var afpl = require("afpl");
var view = require("./wml/tab");
var active = require("../../content/state/active");
var util_1 = require("../../util");
var TabClickedEvent_1 = require("./TabClickedEvent");
var __1 = require("..");
var _1 = require(".");
/**
 * Tab provides a single tab item.
 *
 * When a tab is clicked, it attempts to remove the active class from
 * it's siblings and apply it to itself. Therefore the sibling of a
 * tab should always be a Tab.
 */
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(_1.TAB, _this.attrs.ww.active ? active.ACTIVE : ''),
            },
            a: {
                id: 'link',
                text: _this.attrs.ww.text,
                clicked: function (e) {
                    e.preventDefault();
                    _this
                        .view
                        .findById(_this.values.root.id)
                        .chain(function (root) {
                        var parent = root.parentNode;
                        var us = parent.children;
                        for (var i = 0; i < us.length; i++)
                            us[i].classList.remove(active.ACTIVE);
                        return _this
                            .view
                            .findById(_this.values.root.id)
                            .map(function (el) { return el.classList.add(active.ACTIVE); })
                            .chain(function () { return afpl.Maybe.fromAny(_this.attrs.ww.onClick); })
                            .map(function (f) {
                            return f(new TabClickedEvent_1.TabClickedEvent(_this.attrs.ww.name));
                        });
                    });
                }
            }
        };
        return _this;
    }
    /**
     * click this Tab
     */
    Tab.prototype.click = function () {
        var _this = this;
        return this
            .view
            .findById(this.values.a.id)
            .map(function (e) { return e.click(); })
            .map(function () { return _this; })
            .get();
    };
    return Tab;
}(__1.GenericControl));
exports.Tab = Tab;

},{".":109,"..":91,"../../content/state/active":71,"../../util":155,"./TabClickedEvent":108,"./wml/tab":111,"afpl":162}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var view = require("./wml/tab-bar");
var util_1 = require("../../util");
var wml_1 = require("@quenk/wml");
var _1 = require(".");
/**
 * TabBar acts as a parent container for a group of Tab.
 *
 * Use it to create a tabbed navigation or view for main layout,
 * sub views or forms etc.
 */
var TabBar = /** @class */ (function (_super) {
    __extends(TabBar, _super);
    function TabBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(_1.TAB_BAR, 'nav nav-tabs', _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return TabBar;
}(wml_1.Component));
exports.TabBar = TabBar;

},{".":109,"../../util":155,"./wml/tab-bar":110,"@quenk/wml":160}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("../../control");
/**
 * TabClickedEvent is fired when a user clicks on a tab.
 *
 * It contains information about the tab that was clicked.
 */
var TabClickedEvent = /** @class */ (function (_super) {
    __extends(TabClickedEvent, _super);
    function TabClickedEvent(name) {
        var _this = _super.call(this, name, name) || this;
        _this.name = name;
        return _this;
    }
    return TabClickedEvent;
}(control_1.Event));
exports.TabClickedEvent = TabClickedEvent;

},{"../../control":91}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TabClickedEvent_1 = require("./TabClickedEvent");
exports.TabClickedEvent = TabClickedEvent_1.TabClickedEvent;
var TabBar_1 = require("./TabBar");
exports.TabBar = TabBar_1.TabBar;
var Tab_1 = require("./Tab");
exports.Tab = Tab_1.Tab;
///classNames:begin
/**
 * TAB_BAR
 */
exports.TAB_BAR = 'ww-tab-bar';
/**
 * TAB
 */
exports.TAB = 'ww-tab';
///classNames:end

},{"./Tab":106,"./TabBar":107,"./TabClickedEvent":108}],110:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],111:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [___wml.node('a', {
                    html: {
                        'href': "#",
                        'onclick': ___context.values.a.clicked
                    },
                    wml: {
                        'id': ___context.values.a.id
                    }
                }, [(___context.values.a.text) ? ___wml.domify(___context.values.a.text) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var util_1 = require("../../util");
var form_1 = require("../form");
var feedback_1 = require("../feedback");
var _1 = require("../");
var oninput = function (f) { return function (e) {
    return f.attrs.ww.onChange(new TextChangedEvent(f.attrs.ww.name, e.target.value));
}; };
var input = function (f) {
    return f.view.findById(f.values.control.id);
};
///classNames:begin
exports.TEXT_FIELD = 'form-control';
/**
 * TextChangedEvent
 */
var TextChangedEvent = /** @class */ (function (_super) {
    __extends(TextChangedEvent, _super);
    function TextChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextChangedEvent;
}(_1.Event));
exports.TextChangedEvent = TextChangedEvent;
/**
 * TextField provides a wrapped native text input control.
 */
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.get = function () { return input(_this).map(function (e) { return e.value; }).get(); };
        _this.set = function (v) { return input(_this).map(function (e) { e.value = v; return _this; }).get(); };
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat('form-group', _this.attrs.ww.class, feedback_1.selectState(_this.attrs.ww))
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            control: {
                id: 'control',
                template: function () { return _this.attrs.ww.controlTemplate || views.group; },
                class: util_1.concat(exports.TEXT_FIELD, _this.attrs.ww.class),
                name: _this.attrs.ww.name,
                type: _this.attrs.ww.type || 'text',
                focus: _this.attrs.ww.focus,
                placeholder: _this.attrs.ww.placeholder || '',
                value: _this.attrs.ww.value || '',
                disabled: (_this.attrs.ww.disabled === true) ? true : null,
                readOnly: (_this.attrs.ww.readOnly === true) ? true : null,
                rows: _this.attrs.ww.rows || 1,
                oninput: _this.attrs.ww.onChange ? oninput(_this) : function () { }
            }
        };
        return _this;
    }
    return TextField;
}(form_1.GenericFormControl));
exports.TextField = TextField;

},{"../":91,"../../util":155,"../feedback":89,"../form":90,"./wml/text-field":113}],113:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var wml_1 = require("../../wml");
;
var wml_2 = require("../../wml");
exports.label = wml_2.label;
exports.message = wml_2.message;
;
exports.input = function (___context) { return function (___view) { return ___wml.node('input', {
    html: {
        'name': ___context.values.control.name,
        'type': ___context.values.control.type,
        'focus': ___context.values.control.focus,
        'placeholder': ___context.values.control.placeholder,
        'oninput': ___context.values.control.oninput,
        'value': ___context.values.control.value,
        'disabled': ___context.values.control.disabled,
        'readonly': ___context.values.control.readOnly,
        'class': ___context.values.control.class
    },
    wml: {
        'id': "control"
    }
}, [], ___view); }; };
;
exports.textarea = function (___context) { return function (___view) { return ___wml.node('textarea', {
    html: {
        'name': ___context.values.control.name,
        'placeholder': ___context.values.control.placeholder,
        'oninput': ___context.values.control.oninput,
        'disabled': ___context.values.control.disabled,
        'readonly': ___context.values.control.readOnly,
        'rows': ___context.values.control.rows,
        'class': ___context.values.control.class
    },
    wml: {
        'id': "control"
    }
}, [___wml.domify(___context.values.control.value)], ___view); }; };
;
exports.control = function (___context) { return function (___view) { return ((___context.values.control.rows === 1)) ? ___wml.domify(exports.input(___context)(___view)) : ___wml.domify(exports.textarea(___context)(___view)); }; };
;
exports.group = function (___context) { return function (___view) { return ___wml.box(___wml.domify(wml_1.label(___context.values.label.id)(___context.values.label.text)(___view)), ___wml.domify(exports.control(___context)(___view)), ___wml.domify(wml_1.message(___context.values.help.id)(___context.values.help)(___view))); }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [___wml.domify(___context.values.control.template()(___context)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../wml":116,"@quenk/wml":160}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/toolbar");
var wml_1 = require("@quenk/wml");
var util_1 = require("../../util");
///classNames:begin
exports.TOOLBAR = 'ww-toolbar';
exports.TOOLBAR_COMPAT = '-toolbar-compat';
/**
 * Toolbar provides a widget for grouping related controls into a
 * single row.
 */
var Toolbar = /** @class */ (function (_super) {
    __extends(Toolbar, _super);
    function Toolbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: util_1.concat(exports.TOOLBAR, _this.attrs.ww && _this.attrs.ww.class)
            }
        };
        return _this;
    }
    return Toolbar;
}(wml_1.Component));
exports.Toolbar = Toolbar;

},{"../../util":155,"./wml/toolbar":115,"@quenk/wml":160}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
exports.label = function (id) { return function (text) { return function (___view) { return ___wml.node('label', {
    html: {
        'for': id,
        'class': "control-label"
    },
    wml: {}
}, [___wml.domify(text)], ___view); }; }; };
;
exports.message = function (id) { return function (m) { return function (___view) { return (m.success) ? ___wml.node('span', {
    html: {
        'class': "help-block"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.success)], ___view) : (m.error) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.error)], ___view) : (m.warning) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.warning)], ___view) : ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [], ___view); }; }; };

},{"@quenk/wml":160}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * AllSelectedEvent is triggered when the user selects all the fields on the table.
 */
var AllSelectedEvent = /** @class */ (function () {
    function AllSelectedEvent(value) {
        this.value = value;
    }
    return AllSelectedEvent;
}());
exports.AllSelectedEvent = AllSelectedEvent;

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Cell wraps around a <td> to provide an easier to use api.
 */
var Cell = /** @class */ (function () {
    function Cell(element) {
        this.element = element;
    }
    /**
     * setContent chanages the content of the Cell's <td> element.
     */
    Cell.prototype.setContent = function (r) {
        while (this.element.lastChild)
            this.element.removeChild(this.element.lastChild);
        this.element.appendChild(r.render());
        return this;
    };
    return Cell;
}());
exports.Cell = Cell;

},{}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * CellClickedEvent is triggered when the whitespace of a cell is clicked.
 */
var CellClickedEvent = /** @class */ (function () {
    function CellClickedEvent(value, column, rowData, rowNumber, cell) {
        this.value = value;
        this.column = column;
        this.rowData = rowData;
        this.rowNumber = rowNumber;
        this.cell = cell;
    }
    return CellClickedEvent;
}());
exports.CellClickedEvent = CellClickedEvent;

},{}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * DefaultDelegate will handle table events if no Delegate is
 * specified.
 *
 * It passes it's events onto registered callbacks.
 */
var DefaultDelegate = /** @class */ (function () {
    function DefaultDelegate(table) {
        this.table = table;
    }
    DefaultDelegate.prototype.onAllSelected = function (e) {
        if (this.table.attrs.ww.onAllSelected)
            this.table.attrs.ww.onAllSelected(e);
    };
    DefaultDelegate.prototype.onCellClicked = function (e) {
        if (this.table.attrs.ww.onCellClicked)
            this.table.attrs.ww.onCellClicked(e);
    };
    DefaultDelegate.prototype.onHeadingClicked = function (e) {
        if (this.table.attrs.ww.onHeadingClicked)
            this.table.attrs.ww.onHeadingClicked(e);
    };
    DefaultDelegate.prototype.onRowClicked = function (e) {
        if (this.table.attrs.ww.onRowClicked)
            this.table.attrs.ww.onRowClicked(e);
    };
    DefaultDelegate.prototype.onRowSelected = function (e) {
        if (this.table.attrs.ww.onRowSelected)
            this.table.attrs.ww.onRowSelected(e);
    };
    return DefaultDelegate;
}());
exports.DefaultDelegate = DefaultDelegate;

},{}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HeadingClicked is triggered when the user clicks on
 * one of the column headings.
 */
var HeadingClickedEvent = /** @class */ (function () {
    function HeadingClickedEvent(field) {
        this.field = field;
    }
    return HeadingClickedEvent;
}());
exports.HeadingClickedEvent = HeadingClickedEvent;

},{}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RowClickedEvent is triggered when the user clicks on whitespace in
 * the row of a table.
 */
var RowClickedEvent = /** @class */ (function () {
    function RowClickedEvent(value, row, data) {
        this.value = value;
        this.row = row;
        this.data = data;
    }
    return RowClickedEvent;
}());
exports.RowClickedEvent = RowClickedEvent;

},{}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var RowClickedEvent_1 = require("./RowClickedEvent");
/**
 * RowSelectedEvent is triggered when the checkbox (if displayed) is clicked
 * on for a row.
 */
var RowSelectedEvent = /** @class */ (function (_super) {
    __extends(RowSelectedEvent, _super);
    function RowSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RowSelectedEvent;
}(RowClickedEvent_1.RowClickedEvent));
exports.RowSelectedEvent = RowSelectedEvent;

},{"./RowClickedEvent":122}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DefaultDelegate_1 = require("./DefaultDelegate");
var SortDelegate = /** @class */ (function (_super) {
    __extends(SortDelegate, _super);
    function SortDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SortDelegate.prototype.onHeadingClicked = function (e) {
        this.table.sort(e.field);
        _super.prototype.onHeadingClicked.call(this, e);
    };
    return SortDelegate;
}(DefaultDelegate_1.DefaultDelegate));
exports.SortDelegate = SortDelegate;

},{"./DefaultDelegate":120}],125:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var view = require("./wml/table");
var util_1 = require("../../util");
var wml_1 = require("@quenk/wml");
var property_seek_1 = require("property-seek");
var CellClickedEvent_1 = require("./CellClickedEvent");
var RowClickedEvent_1 = require("./RowClickedEvent");
var RowSelectedEvent_1 = require("./RowSelectedEvent");
var HeadingClickedEvent_1 = require("./HeadingClickedEvent");
var AllSelectedEvent_1 = require("./AllSelectedEvent");
var SortDelegate_1 = require("./SortDelegate");
var Cell_1 = require("./Cell");
var _1 = require(".");
/**
 * Table provides a smarter html table.
 *
 * @todo split sort and select api into own table widgets.
 */
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.originalData = _this.attrs.ww.data;
        _this.view = new view.Main(_this);
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new SortDelegate_1.SortDelegate(_this);
        _this.values = {
            empty: _this.attrs.ww.empty,
            options: {
                selectable: _this.attrs.ww.selectable
            },
            table: {
                id: _1.TABLE,
                class: util_1.concat(_1.TABLE, _this.attrs.ww.class),
                thead: {
                    id: _1.THEAD,
                    class: _this.attrs.ww.theadClass,
                    template: (_this.attrs.ww.thead || view.thead),
                    onCheck: function () {
                        return _this.delegate.onAllSelected(new AllSelectedEvent_1.AllSelectedEvent(_this.originalData));
                    },
                    th: {
                        class: _this.attrs.ww.thClass,
                        onclick: function (field) { return function () {
                            return _this.delegate.onHeadingClicked(new HeadingClickedEvent_1.HeadingClickedEvent(field));
                        }; },
                    }
                },
                tbody: {
                    id: _1.TBODY,
                    template: (_this.attrs.ww.tbody || view.tbody),
                    tr: {
                        class: _this.attrs.ww.trClass,
                        onclick: function (row, index, data) { return function () {
                            return _this.delegate.onRowClicked(new RowClickedEvent_1.RowClickedEvent(row, index, data));
                        }; },
                        onCheck: function (row, index, data) { return function () {
                            return _this.delegate.onRowSelected(new RowSelectedEvent_1.RowSelectedEvent(row, index, data));
                        }; }
                    },
                    td: {
                        id: function (column, colNumber, rowNumber) { return "" + column + colNumber + "," + rowNumber; },
                        class: _this.attrs.ww.tdClass,
                        onclick: function (value, column, rowData, rowNumber) {
                            return function (e) {
                                return _this
                                    .delegate
                                    .onCellClicked(new CellClickedEvent_1.CellClickedEvent(value, column, rowData, rowNumber, new Cell_1.Cell(e.target)));
                            };
                        }
                    }
                }
            },
            sortedOn: '',
            data: _this.originalData.slice(),
            columns: _this.attrs.ww.columns,
            arrow: ''
        };
        return _this;
    }
    /**
     * modifyBody allows a function to modify the contents
     * of the <tbody>
     */
    Table.prototype.modifyBody = function (f) {
        this.view.findById(_1.TBODY).map(f);
        return this;
    };
    Table.prototype.sort = function (name) {
        var columns = this.attrs.ww ? this.attrs.ww.columns ? this.attrs.ww.columns : [] : [];
        var field = columns.reduce(function (p, c) { return p ? p : (c.name === name ? c : null); });
        var sortOn;
        var strategy;
        if (!field)
            throw new Error("Table#sort: unknown field '" + name + "'");
        sortOn = field.sortAs || name;
        strategy = field.strategy || _1.stringSort;
        if (this.values.sortedOn === name) {
            this.values.data = this.values.data.reverse();
            this.values.arrow = (this.values.arrow === _1.ASC_ARROW) ? _1.DESC_ARROW : _1.ASC_ARROW;
        }
        else {
            this.values.arrow = _1.DESC_ARROW;
            this.values.data = this
                .originalData
                .slice()
                .sort(function (a, b) { return strategy(property_seek_1.get(sortOn, a), property_seek_1.get(sortOn, b)); });
        }
        this.values.sortedOn = name;
        this.view.invalidate();
        return this;
    };
    /**
     * update the data the table displays
     */
    Table.prototype.update = function (data) {
        this.originalData = data.slice();
        this.values.data = data.slice();
        (this.values.sortedOn === '') ? this.view.invalidate() : this.sort(this.values.sortedOn);
        return this;
    };
    /**
     * cellAt produces a Cell instance for the coordinates passed (if found).
     */
    Table.prototype.cellAt = function (column, row) {
        return this
            .view
            .findById("" + column + row)
            .map(function (e) { return new Cell_1.Cell(e); });
    };
    /**
     * prepend adds one or more new data rows to the begining of the table.
     */
    Table.prototype.prepend = function (data) {
        var _this = this;
        var d = Array.isArray(data) ? data : [data];
        this.modifyBody(function (e) {
            var dom = view.rows(_this)(d)(_this.values.columns)(_this.view);
            if (e.children.length === 0)
                e.appendChild(dom);
            else
                e.replaceChild(dom, e.firstChild);
        });
        return this;
    };
    /**
     * append adds one or more new data rows to the end of the table.
     */
    Table.prototype.append = function (data) {
        var _this = this;
        var d = Array.isArray(data) ? data : [data];
        this.modifyBody(function (e) {
            return e.appendChild(view.rows(_this)(d)(_this.values.columns)(_this.view));
        });
        return this;
    };
    /**
     * prependRow prepends customisable DOM content to the
     * begining of the table body.
     *
     * NOTE: This DOM content of must be between <tr> elements.
     */
    Table.prototype.prependRow = function (renderer) {
        this.modifyBody(function (e) {
            if (e.firstChild == null)
                e.appendChild(renderer.render());
            else
                e.replaceChild(renderer.render(), e.firstChild);
        });
        return this;
    };
    /**
     * appendRow appends customisable DOM content to the
     * begining of the table body.
     *
     * NOTE: This DOM content of must be between <tr> elements.
     */
    Table.prototype.appendRow = function (renderer) {
        this.modifyBody(function (e) {
            e.appendChild(renderer.render());
        });
        return this;
    };
    /**
     * removeRow will remove an entire row from the table given its index.
     */
    Table.prototype.removeRow = function (index) {
        this.modifyBody(function (e) {
            for (var i = 0; i <= e.rows.length; i++)
                if (i === index)
                    e.rows[i].parentNode.removeChild(e.rows[i]);
        });
        return this;
    };
    return Table;
}(wml_1.Component));
exports.Table = Table;

},{".":126,"../../util":155,"./AllSelectedEvent":117,"./Cell":118,"./CellClickedEvent":119,"./HeadingClickedEvent":121,"./RowClickedEvent":122,"./RowSelectedEvent":123,"./SortDelegate":124,"./wml/table":127,"@quenk/wml":160,"property-seek":175}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AllSelectedEvent_1 = require("./AllSelectedEvent");
exports.AllSelectedEvent = AllSelectedEvent_1.AllSelectedEvent;
var CellClickedEvent_1 = require("./CellClickedEvent");
exports.CellClickedEvent = CellClickedEvent_1.CellClickedEvent;
var RowClickedEvent_1 = require("./RowClickedEvent");
exports.RowClickedEvent = RowClickedEvent_1.RowClickedEvent;
var HeadingClickedEvent_1 = require("./HeadingClickedEvent");
exports.HeadingClickedEvent = HeadingClickedEvent_1.HeadingClickedEvent;
var Table_1 = require("./Table");
exports.Table = Table_1.Table;
///classNames:begin
exports.TABLE = 'table'; //@todo un-bootstrap
var Cell_1 = require("./Cell");
exports.Cell = Cell_1.Cell;
exports.ASC_ARROW = '\u21e7';
exports.DESC_ARROW = '\u21e9';
exports.THEAD = 'thead';
exports.TBODY = 'tbody';
exports.dateSort = function (a, b) {
    var na = new Date(a).getTime();
    var nb = new Date(b).getTime();
    return na > nb ? -1 : na < nb ? 1 : 0;
};
exports.stringSort = function (a, b) {
    var la = String(a).replace(/\s+/, '').toLowerCase();
    var lb = String(b).replace(/\s+/, '').toLowerCase();
    return (la > lb) ? -1 : (la < lb) ? 1 : 0;
};
exports.naturalSort = function (a, b) {
    if (a === void 0) { a = ''; }
    if (b === void 0) { b = ''; }
    //Source: http://stackoverflow.com/questions/4340227/sort-mixed-alpha-numeric-array
    var reA = /[^a-zA-Z]/g;
    var reN = /[^0-9]/g;
    var AInt = parseInt(a, 10);
    var BInt = parseInt(b, 10);
    if (isNaN(AInt) && isNaN(BInt)) {
        var aA = a.replace(reA, '');
        var bA = b.replace(reA, '');
        if (aA === bA) {
            var aN = parseInt(a.replace(reN, ''), 10);
            var bN = parseInt(b.replace(reN, ''), 10);
            return aN === bN ? 0 : aN > bN ? -1 : 1;
        }
        else {
            return aA > bA ? -1 : 1;
        }
    }
    else if (isNaN(AInt)) { //A is not an Int
        return -1; //to make alphanumeric sort first return -1 here
    }
    else if (isNaN(BInt)) { //B is not an Int
        return 1; //to make alphanumeric sort first return 1 here
    }
    else {
        return AInt > BInt ? -1 : 1;
    }
};
exports.numberSort = function (a, b) {
    var na = parseFloat(a);
    var nb = parseFloat(b);
    na = (isNaN(a)) ? -Infinity : a;
    nb = (isNaN(b)) ? -Infinity : b;
    return (na > nb) ? -1 : (na < nb) ? 1 : 0;
};

},{"./AllSelectedEvent":117,"./Cell":118,"./CellClickedEvent":119,"./HeadingClickedEvent":121,"./RowClickedEvent":122,"./Table":125}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var util_1 = require("../../../util");
;
var property_seek_1 = require("property-seek");
;
var fragment_1 = require("../../../layout/fragment");
;
var active_1 = require("../../../content/state/active");
;
exports.thead = function (___context) { return function (columns) { return function (___view) { return ___wml.node('thead', {
    html: {},
    wml: {
        'id': ___context.values.table.thead.id
    }
}, [___wml.domify(exports.heads(___context)(columns)(___view))], ___view); }; }; };
;
exports.heads = function (___context) { return function (columns) { return function (___view) { return ___wml.node('tr', {
    html: {},
    wml: {}
}, [(___context.values.options.selectable) ? ___wml.box(___wml.domify(exports.allSelectedCheckbox(___context)(___view)), ___wml.domify(exports.headings(___context)(columns)(___view))) : ___wml.domify(exports.headings(___context)(columns)(___view))], ___view); }; }; };
;
exports.allSelectedCheckbox = function (___context) { return function (___view) { return ___wml.node('th', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': ___context.values.table.thead.onCheck
        },
        wml: {}
    }, [], ___view)], ___view); }; };
;
exports.headings = function (___context) { return function (columns) { return function (___view) { return ___wml.map(columns, function _map(field) {
    return (field.sortAs) ? ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.table.thead.th.class, ((___context.values.sortedOn === field.name)) ? active_1.ACTIVE : ""),
            'onclick': ___context.values.table.thead.th.onclick(field.name)
        },
        wml: {}
    }, [___wml.domify(field.heading), ((___context.values.sortedOn === field.name)) ? ___wml.domify(___context.values.arrow) : ___wml.domify("")], ___view) : ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.table.thead.th.class, ((___context.values.sortedOn === field.name)) ? active_1.ACTIVE : ""),
            'onclick': ___context.values.table.thead.th.onclick(field.name)
        },
        wml: {}
    }, [___wml.domify(field.heading), ___wml.domify(((___context.values.sortedOn === field.name)) ? ___context.values.arrow : "")], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.tbody = function (___context) { return function (data) { return function (columns) { return function (___view) { return ___wml.node('tbody', {
    html: {},
    wml: {
        'id': ___context.values.table.tbody.id
    }
}, [___wml.domify(exports.rows(___context)(data)(columns)(___view))], ___view); }; }; }; };
;
exports.rows = function (___context) { return function (data) { return function (columns) { return function (___view) { return ___wml.map(data, function _map(rowData, index) {
    return ___wml.node('tr', {
        html: {
            'class': ___context.values.table.tbody.tr.class,
            'onclick': ___context.values.table.tbody.tr.onclick(rowData, index, data)
        },
        wml: {}
    }, [___wml.domify(exports.cells(___context)(rowData)(index)(columns)(___view))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; }; };
;
exports.cells = function (___context) { return function (rowData) { return function (rowNumber) { return function (columns) { return function (___view) { return ___wml.box((___context.values.options.selectable) ? ___wml.domify(exports.rowSelectCheckbox(___context)(rowData)(rowNumber)(___view)) : ___wml.domify(""), ___wml.map(columns, function _map(field, index) {
    return ___wml.node('td', {
        html: {
            'class': ___context.values.table.tbody.td.class,
            'onclick': ___context.values.table.tbody.td.onclick(property_seek_1.get(field.name, rowData), field.name, rowData, rowNumber)
        },
        wml: {
            'id': ___context.values.table.tbody.td.id(field.name, index, rowNumber)
        }
    }, [(field.fragment) ? ___wml.domify(field.fragment(property_seek_1.get(field.name, rowData))(field.name)(rowData)(___view)) : ___wml.domify(property_seek_1.get(field.name, rowData))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
})); }; }; }; }; };
;
exports.rowSelectCheckbox = function (___context) { return function (row) { return function (index) { return function (___view) { return (___context.values.options.selectable) ? ___wml.node('td', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': ___context.values.table.tbody.tr.onCheck(row, index, ___context.values.data)
        },
        wml: {}
    }, [], ___view)], ___view) : ___wml.domify(""); }; }; }; };
;
exports.table = function (___context) { return function (___view) { return ___wml.node('table', {
    html: {
        'class': ___context.values.table.class
    },
    wml: {
        'id': ___context.values.table.id
    }
}, [___wml.domify(___context.values.table.thead.template(___context)(___context.values.columns)(___view)), ___wml.domify(___context.values.table.tbody.template(___context)(___context.values.data)(___context.values.columns)(___view))], ___view); }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.widget(fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [((___context.values.data.length === 0)) ? (___context.values.empty) ? ___wml.domify(___context.values.empty(___view)) : ___wml.domify(exports.table(___context)(___view)) : ___wml.domify(exports.table(___context)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../content/state/active":71,"../../../layout/fragment":132,"../../../util":155,"@quenk/wml":160,"property-seek":175}],128:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var drawer_layout_1 = require("./wml/drawer-layout");
///classNames:begin
/**
 * DRAWER_LAYOUT
 */
exports.DRAWER_LAYOUT = 'ww-drawer-layout';
///classNames:end
var drawer = function (l) { return function (f) {
    return l
        .view
        .findById(l.values.drawer.id)
        .map(function (e) { return e; })
        .map(f)
        .map(function () { return l; })
        .orJust(function () { return l; })
        .get();
}; };
;
/**
 * DrawerLayout provides a 1 column application layout with a drawer that can
 * be shown or hidden upon requests.
 *
 * The drawer takes up most of the screen on mobile and about roughly 1/6 - 1/8 on
 * a desktop (not fact checked yet).
 *
 *  Mobile:
 *  +------------------------------------------------------------------------------+
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |   <drawer>                                 |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  |                                            |                                 |
 *  +------------------------------------------------------------------------------+
 *
 *  Desktop:
 *  +------------------------------------------------------------------------------+
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |   <drawer>  |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  |             |                                                                |
 *  +------------------------------------------------------------------------------+
 *
 */
var DrawerLayout = /** @class */ (function (_super) {
    __extends(DrawerLayout, _super);
    function DrawerLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_layout_1.Main(_this);
        _this.isHidden = function () {
            return _this
                .view
                .findById(_this.values.drawer.id)
                .map(function (d) { return d.isHidden(); })
                .orJust(function () { return false; })
                .get();
        };
        _this.hide = function () { return drawer(_this)(function (d) { return d.hide(); }); };
        _this.show = function () { return drawer(_this)(function (d) { return d.show(); }); };
        _this.toggle = function () { return drawer(_this)(function (d) { return d.toggle(); }); };
        _this.setContent = function (c) {
            _this.values.content.render = function () { return [c]; };
            return _this;
        };
        _this.removeContent = function () {
            _this.values.content.render = function () { return []; };
            return _this;
        };
        /**
         * values is a hash of values used in the template.
         */
        _this.values = {
            root: {
                class: exports.DRAWER_LAYOUT,
            },
            drawer: {
                id: 'drawer',
                content: (_this.attrs.ww && _this.attrs.ww.drawer) ? _this.attrs.ww.drawer : null
            },
            content: {
                id: 'content',
                render: function () { return _this.children; }
            }
        };
        return _this;
    }
    return DrawerLayout;
}(wml_1.Component));
exports.DrawerLayout = DrawerLayout;

},{"./wml/drawer-layout":129,"@quenk/wml":160}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var drawer_1 = require("../../drawer");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(drawer_1.Drawer, {
                    html: {},
                    wml: {
                        'id': ___context.values.drawer.id
                    },
                    ww: {
                        'content': ___context.values.drawer.content
                    }
                }, [], ___view), ___wml.domify(___context.values.content.render())], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../drawer":130,"@quenk/wml":160}],130:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hidden_1 = require("../../content/state/hidden");
var Group_1 = require("../../content/Group");
var drawer_1 = require("./wml/drawer");
var getDom = function (d) { return function () {
    return d
        .view
        .findById(d.values.root.id)
        .map(function (e) { return e; });
}; };
///classNames:begin
exports.DRAWER = 'ww-drawer';
exports.DRAWER_CONTENT = 'ww-drawer__content';
/**
 * Drawer provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as querying the
 * current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears in-front
 * of other content. Adjust the respective style variables to change.
 */
var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_1.Main(_this);
        _this.isHidden = hidden_1.isHidden(getDom(_this));
        _this.hide = hidden_1.hide(_this)(getDom(_this));
        _this.show = hidden_1.show(_this)(getDom(_this));
        _this.toggle = hidden_1.toggle(_this)(getDom(_this));
        /**
         * values is a hash of values used in the template
         */
        _this.values = {
            root: {
                id: 'drawer',
                class: exports.DRAWER,
            },
            content: {
                class: exports.DRAWER_CONTENT,
                render: function () { return (_this.attrs.ww && _this.attrs.ww.content) ?
                    _this.attrs.ww.content.render() :
                    _this.children; }
            }
        };
        return _this;
    }
    return Drawer;
}(Group_1.Group));
exports.Drawer = Drawer;

},{"../../content/Group":58,"../../content/state/hidden":72,"./wml/drawer":131}],131:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {
                    'id': ___context.values.root.id
                }
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.content.class
                    },
                    wml: {}
                }, [___wml.domify(___context.values.content.render())], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],132:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/fragment");
var wml_1 = require("@quenk/wml");
/**
 * Fragment allows for the grouping of widgets in a DocumentFragment.
 *
 * This is intended to facilitate view templates that do not have a single
 * root but instead generated multiple sibling content.
 */
var Fragment = /** @class */ (function (_super) {
    __extends(Fragment, _super);
    function Fragment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(undefined);
        return _this;
    }
    Fragment.prototype.render = function () {
        var frag = document.createDocumentFragment();
        this.children.forEach(function (c) { return frag.appendChild(c); });
        return frag;
    };
    return Fragment;
}(wml_1.Component));
exports.Fragment = Fragment;

},{"./wml/fragment":133,"@quenk/wml":160}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('fragment', {
                html: {},
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/grid-layout");
var util_1 = require("../../util");
var _1 = require("../");
///classNames:begin
//@todo: refactor this to be inline with other class names
exports.GRID_LAYOUT = 'container-fluid';
exports.COLUMN = 'ww-column';
exports.ROW = 'row';
;
/**
 * GridLayout
 */
var GridLayout = /** @class */ (function (_super) {
    __extends(GridLayout, _super);
    function GridLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Grid(_this);
        _this.values = {
            content: {
                id: 'root',
                class: util_1.concat(exports.GRID_LAYOUT, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return GridLayout;
}(_1.GenericLayout));
exports.GridLayout = GridLayout;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Row(_this);
        _this.values = {
            content: {
                id: 'row',
                class: util_1.concat(exports.ROW, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Row;
}(_1.GenericLayout));
exports.Row = Row;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Column(_this);
        _this.values = {
            content: {
                id: 'column',
                class: _this.attrs.ww ? util_1.concat(_this.attrs.ww.size ?
                    "col-md-" + _this.attrs.ww.size : 'col-md-12', _this.attrs.ww.class) : 'col-md-12'
            }
        };
        return _this;
    }
    return Column;
}(_1.GenericLayout));
exports.Column = Column;

},{"../":138,"../../util":155,"./wml/grid-layout":135}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('section', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Grid;
}(___wml.AppView));
exports.Grid = Grid;
;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Row;
}(___wml.AppView));
exports.Row = Row;
;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Column;
}(___wml.AppView));
exports.Column = Column;

},{"@quenk/wml":160}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/horizontal-layout");
var util_1 = require("../../util");
///classNames:begin
exports.HORIZONTAL_LAYOUT = 'ww-horizontal-layout';
/**
 * HorizontalLayout uses the css flexbox to provide a container
 * where all items are laid out in a single row.
 */
var HorizontalLayout = /** @class */ (function (_super) {
    __extends(HorizontalLayout, _super);
    function HorizontalLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * values
         */
        _this.values = {
            /**
             * root element values.
             */
            root: {
                /**
                 * class names of the root element.
                 */
                class: util_1.concat(exports.HORIZONTAL_LAYOUT)
            }
        };
        return _this;
    }
    return HorizontalLayout;
}(wml.Component));
exports.HorizontalLayout = HorizontalLayout;

},{"../../util":155,"./wml/horizontal-layout":137,"@quenk/wml":160}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
var _get = function (gen) { return function () {
    return gen
        .view
        .findById(gen.values.content.id);
}; };
/**
 * GenericLayout provides an implementation of Layout.
 */
var GenericLayout = /** @class */ (function (_super) {
    __extends(GenericLayout, _super);
    function GenericLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.setContent = exports.setContent(_this)(_get(_this));
        _this.removeContent = exports.removeContent(_this)(_get(_this));
        return _this;
    }
    return GenericLayout;
}(wml_1.Component));
exports.GenericLayout = GenericLayout;
/**
 * setContent helper.
 */
exports.setContent = function (l) { return function (fn) { return function (content) {
    return fn()
        .map(function (e) {
        while (e.firstChild)
            e.removeChild(e.firstChild);
        e.appendChild(content);
    })
        .map(function () { return l; })
        .orJust(function () { return l; })
        .get();
}; }; };
/**
 * removeContent helper.
 */
exports.removeContent = function (l) { return function (fn) { return function () {
    return fn()
        .map(function (e) { while (e.firstChild)
        e.removeChild(e.firstChild); })
        .map(function () { return l; })
        .orJust(function () { return l; })
        .get();
}; }; };

},{"@quenk/wml":160}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var item = require("./wml/list-layout-item");
var layout = require("./wml/list-layout");
var util_1 = require("../../util");
var _1 = require("../");
///classNames:begin
exports.LIST_LAYOUT = 'ww-list-layout';
exports.LIST_LAYOUT_ITEM = 'ww-list-layout__item';
/**
 * ListLayoutItem
 */
var ListLayoutItem = /** @class */ (function (_super) {
    __extends(ListLayoutItem, _super);
    function ListLayoutItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new item.Main(_this);
        _this.values = {
            content: {
                id: 'item',
                class: exports.LIST_LAYOUT_ITEM
            }
        };
        return _this;
    }
    return ListLayoutItem;
}(_1.GenericLayout));
exports.ListLayoutItem = ListLayoutItem;
/**
 * ListLayout is used to create a vertical list of content.
 *
 * Children must be ListGroupItems.
 */
var ListLayout = /** @class */ (function (_super) {
    __extends(ListLayout, _super);
    function ListLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new layout.Main(_this);
        _this.values = {
            content: {
                id: 'list',
                class: util_1.concat(exports.LIST_LAYOUT, _this.attrs.ww && _this.attrs.ww.class)
            }
        };
        return _this;
    }
    return ListLayout;
}(_1.GenericLayout));
exports.ListLayout = ListLayout;

},{"../":138,"../../util":155,"./wml/list-layout":141,"./wml/list-layout-item":140}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],142:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/main-layout");
var orientation = require("../../../lib/content/orientation");
var util_1 = require("../../util");
var _1 = require("../");
///classNames:begin
exports.MAIN_LAYOUT = 'ww-main-layout';
/**
 * MainLayout provides a container for the main content of an application.
 */
var MainLayout = /** @class */ (function (_super) {
    __extends(MainLayout, _super);
    function MainLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            content: {
                id: 'main',
                class: util_1.concat(exports.MAIN_LAYOUT, orientation.RIGHT_PUSHABLE, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return MainLayout;
}(_1.GenericLayout));
exports.MainLayout = MainLayout;

},{"../":138,"../../../lib/content/orientation":69,"../../util":155,"./wml/main-layout":143}],143:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var style = require("../../content/style");
var util_1 = require("../../util");
var panel_1 = require("./wml/panel");
var __1 = require("..");
var _1 = require(".");
/**
 * Panel provides a rectangular container for visually seperating
 * content by context.
 *
 * This class provides the containing, part that can be further
 * subdivided into a header, body and/or footer section.
 */
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_1.Main(_this);
        /**
         * values
         */
        _this.values = {
            /**
             * root values.
             */
            content: {
                id: 'panel',
                /**
                 * class name for the root element.
                 */
                class: util_1.concat(_1.PANEL, _this.attrs.ww ?
                    _this.attrs.ww.style : style.DEFAULT, _this.attrs.ww ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Panel;
}(__1.GenericLayout));
exports.Panel = Panel;

},{".":148,"..":138,"../../content/style":73,"../../util":155,"./wml/panel":152}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var panel_body_1 = require("./wml/panel-body");
var _1 = require("../");
var _2 = require(".");
/**
 * PanelBody part of a Panel for containing the main content.
 */
var PanelBody = /** @class */ (function (_super) {
    __extends(PanelBody, _super);
    function PanelBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_body_1.Main(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                id: 'body',
                /**
                 * class for the root element.
                 */
                class: util_1.concat(_2.PANEL_BODY, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return PanelBody;
}(_1.GenericLayout));
exports.PanelBody = PanelBody;

},{".":148,"../":138,"../../util":155,"./wml/panel-body":149}],146:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var panel_footer_1 = require("./wml/panel-footer");
var _1 = require("../");
var _2 = require(".");
/**
 * PanelFooter part of the panel for summary content etc.
 */
var PanelFooter = /** @class */ (function (_super) {
    __extends(PanelFooter, _super);
    function PanelFooter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_footer_1.Main(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                id: 'footer',
                /**
                 * class name for the root element.
                 */
                class: util_1.concat(_2.PANEL_FOOTER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return PanelFooter;
}(_1.GenericLayout));
exports.PanelFooter = PanelFooter;

},{".":148,"../":138,"../../util":155,"./wml/panel-footer":150}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var panel_header_1 = require("./wml/panel-header");
var _1 = require("../");
var _2 = require(".");
var PanelHeader = /** @class */ (function (_super) {
    __extends(PanelHeader, _super);
    function PanelHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_header_1.Main(_this);
        /**
         * values
         */
        _this.values = {
            content: {
                id: 'header',
                /**
                 * class name for the root element.
                 */
                class: util_1.concat(_2.PANEL_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return PanelHeader;
}(_1.GenericLayout));
exports.PanelHeader = PanelHeader;

},{".":148,"../":138,"../../util":155,"./wml/panel-header":151}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Panel_1 = require("./Panel");
exports.Panel = Panel_1.Panel;
var PanelHeader_1 = require("./PanelHeader");
exports.PanelHeader = PanelHeader_1.PanelHeader;
var PanelBody_1 = require("./PanelBody");
exports.PanelBody = PanelBody_1.PanelBody;
var PanelFooter_1 = require("./PanelFooter");
exports.PanelFooter = PanelFooter_1.PanelFooter;
///classNames:begin
/**
 * PANEL wrapper class.
 */
exports.PANEL = 'ww-panel';
/**
 * PANEL_HEADER class name.
 */
exports.PANEL_HEADER = 'ww-panel__header';
/**
 * PANEL_BODY class name.
 */
exports.PANEL_BODY = 'ww-panel__body';
/**
 * PANEL_FOOTER class name.
 */
exports.PANEL_FOOTER = 'ww-panel__footer';

},{"./Panel":144,"./PanelBody":145,"./PanelFooter":146,"./PanelHeader":147}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],150:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],151:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],152:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.content.class
                },
                wml: {
                    'id': ___context.values.content.id
                }
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":160}],153:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tab-layout");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var wml_1 = require("@quenk/wml");
///classNames:begin
exports.TAB_LAYOUT = 'ww-tab-layout';
/**
 * TabLayout provides a layout whose displayed content can be changed via tabs.
 *
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * | Tab1  |  Tab2  | Tab2                                                    |
 * |                                                                          |
 * ----------------------------------------------------------------------------
 * |                                                                          |
 * |                                                                          |
 * |                             <Content>                                    |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |                                                                          |
 * |__________________________________________________________________________|
 */
var TabLayout = /** @class */ (function (_super) {
    __extends(TabLayout, _super);
    function TabLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.setContent = function (c) {
            _this.values.content = views.content(c);
            _this.view.invalidate();
            return _this;
        };
        _this.removeContent = function () {
            _this.values.content = views.empty;
            _this.view.invalidate();
            return _this;
        };
        _this.values = {
            root: {
                class: exports.TAB_LAYOUT
            },
            tab: _this.attrs.ww.active || Object.keys(_this.attrs.ww.tabs)[0],
            tabs: _this.attrs.ww.tabs,
            content: Maybe_1.Maybe
                .fromAny(_this.attrs.ww.tabs[_this.attrs.ww.active])
                .orElse(function () { return Maybe_1.Maybe.fromAny(_this.attrs.ww.tabs[Object.keys(_this.attrs.ww.tabs)[0]]); })
                .map(function (ts) { return ts.contentTemplate; })
                .get(),
            onClick: function (e) {
                Maybe_1.Maybe
                    .fromBoolean(_this.values.tab !== e.name)
                    .map(function () { _this.values.tab = e.name; })
                    .chain(function () {
                    return Maybe_1.Maybe
                        .fromAny(_this.attrs.ww.tabs[e.name])
                        .map(function (ts) {
                        _this.values.content = ts.contentTemplate;
                    })
                        .map(function () { _this.view.invalidate(); })
                        .orJust(function () { console.error("TabLayout: unknown tab '" + e.name + "'!"); });
                });
            }
        };
        return _this;
    }
    return TabLayout;
}(wml_1.Component));
exports.TabLayout = TabLayout;

},{"./wml/tab-layout":154,"@quenk/wml":160,"afpl/lib/monad/Maybe":167}],154:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var fragment_1 = require("../../fragment");
;
var tab_bar_1 = require("../../../control/tab-bar");
;
exports.empty = function (___context) { return function (___view) { return ___wml.widget(fragment_1.Fragment, {
    html: {},
    wml: {}
}, [], ___view); }; };
;
exports.content = function (c) { return function (_) { return function (___view) { return ___wml.domify(c); }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(___context) {
        var _this = _super.call(this, ___context) || this;
        _this.template = function (___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(tab_bar_1.TabBar, {
                    html: {},
                    wml: {}
                }, [___wml.map(___context.values.tabs, function _map(tab, name) {
                        return ___wml.widget(tab_bar_1.Tab, {
                            html: {},
                            wml: {},
                            ww: {
                                'name': name,
                                'active': (___context.values.tab === name),
                                'onClick': ___context.values.onClick
                            }
                        }, [(tab.tabTemplate) ? ___wml.domify(tab.tabTemplate(___context)(___view)) : (tab.text) ? ___wml.domify(tab.text) : ___wml.domify(name)], ___view);
                    }, function otherwise() {
                        return document.createDocumentFragment();
                    })], ___view), (___context.values.content) ? ___wml.domify(___context.values.content(___context)(___view)) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../../../control/tab-bar":109,"../../fragment":132,"@quenk/wml":160}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This module provides utility functions and constants used
 * through out the wml-widgets module.
 */
/**
 * combine the members of an array into one string.
 */
exports.combine = function (str, joiner) {
    if (joiner === void 0) { joiner = ' '; }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(joiner);
};
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
exports.concat = function () {
    var str = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        str[_i] = arguments[_i];
    }
    return str.filter(function (s) { return ((s == null) || (s == '')) ? false : true; }).map(function (s) { return s.trim(); }).join(' ');
};
/**
 * noop
 */
exports.noop = function () { };
/**
 * replaceContent
 */
exports.replaceContent = function (r, node) {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};
/**
 * debounce a function so that it is only called once after
 * a period of time.
 */
exports.debounce = function (f, delay) {
    var timer = null;
    return delay === 0 ? f : function (a) {
        if (!timer) {
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
        else {
            clearTimeout(timer);
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
    };
};

},{}],156:[function(require,module,exports){
"use strict";
/**
 * Types corresponding to the WML AST.
 */
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * Module is what a wml file compiles to.
 *
 * A module contains a list of imports and exported symbols.
 * All declarations in wml are exported. There is no such thing
 * as private here.
 */
var Module = /** @class */ (function () {
    function Module(imports, exports, main, location) {
        this.imports = imports;
        this.exports = exports;
        this.main = main;
        this.location = location;
        this.type = 'module';
    }
    return Module;
}());
exports.Module = Module;
/**
 * ImportStatement
 */
var ImportStatement = /** @class */ (function () {
    function ImportStatement(member, module, location) {
        this.member = member;
        this.module = module;
        this.location = location;
        this.type = 'import-statement';
    }
    return ImportStatement;
}());
exports.ImportStatement = ImportStatement;
/**
 * AliasedMember
 * @property {Identifier} alias - The identifier introduced to scope.
 * @property {Identifier} member - The identifier that is aliased.
 */
var AliasedMember = /** @class */ (function () {
    function AliasedMember(member, alias, location) {
        this.member = member;
        this.alias = alias;
        this.location = location;
        this.type = 'aliased-member';
    }
    return AliasedMember;
}());
exports.AliasedMember = AliasedMember;
/**
 * AggregateMember
 */
var AggregateMember = /** @class */ (function () {
    function AggregateMember(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'qualified-member';
    }
    return AggregateMember;
}());
exports.AggregateMember = AggregateMember;
/**
 * CompositeMember
 * @property {...Identifier|Aliased_Member} members
 */
var CompositeMember = /** @class */ (function () {
    function CompositeMember(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'composite-member';
    }
    return CompositeMember;
}());
exports.CompositeMember = CompositeMember;
var TypedMain = /** @class */ (function () {
    function TypedMain(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'typed-main';
    }
    return TypedMain;
}());
exports.TypedMain = TypedMain;
var UntypedMain = /** @class */ (function () {
    function UntypedMain(tag, location) {
        this.tag = tag;
        this.location = location;
        this.type = 'untyped-main';
    }
    return UntypedMain;
}());
exports.UntypedMain = UntypedMain;
var ExportStatement = /** @class */ (function () {
    function ExportStatement(members, module, location) {
        this.members = members;
        this.module = module;
        this.location = location;
        this.type = 'export-statement';
    }
    return ExportStatement;
}());
exports.ExportStatement = ExportStatement;
/**
 * ViewStatement
 */
var ViewStatement = /** @class */ (function () {
    function ViewStatement(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'view-statement';
    }
    return ViewStatement;
}());
exports.ViewStatement = ViewStatement;
var FunStatement = /** @class */ (function () {
    function FunStatement(id, typeClasses, context, parameters, body, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'fun-statement';
    }
    return FunStatement;
}());
exports.FunStatement = FunStatement;
/**
 * TypeClass
 */
var TypeClass = /** @class */ (function () {
    function TypeClass(id, constraint, location) {
        this.id = id;
        this.constraint = constraint;
        this.location = location;
        this.type = 'type-class';
    }
    return TypeClass;
}());
exports.TypeClass = TypeClass;
var Type = /** @class */ (function () {
    function Type(id, typeClasses, list, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.list = list;
        this.location = location;
        this.type = 'type';
    }
    return Type;
}());
exports.Type = Type;
var TypedParameter = /** @class */ (function () {
    function TypedParameter(id, hint, location) {
        this.id = id;
        this.hint = hint;
        this.location = location;
        this.type = 'typed-parameter';
    }
    return TypedParameter;
}());
exports.TypedParameter = TypedParameter;
var UntypedParameter = /** @class */ (function () {
    function UntypedParameter(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'untyped-parameter';
    }
    return UntypedParameter;
}());
exports.UntypedParameter = UntypedParameter;
var Node = /** @class */ (function () {
    function Node(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'node';
    }
    return Node;
}());
exports.Node = Node;
var Widget = /** @class */ (function () {
    function Widget(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'widget';
    }
    return Widget;
}());
exports.Widget = Widget;
var Attribute = /** @class */ (function () {
    function Attribute(namespace, name, value, location) {
        this.namespace = namespace;
        this.name = name;
        this.value = value;
        this.location = location;
        this.type = 'attribute';
    }
    return Attribute;
}());
exports.Attribute = Attribute;
var Interpolation = /** @class */ (function () {
    function Interpolation(expression, filters, location) {
        this.expression = expression;
        this.filters = filters;
        this.location = location;
        this.type = 'interpolation';
    }
    return Interpolation;
}());
exports.Interpolation = Interpolation;
var ForStatement = /** @class */ (function () {
    function ForStatement(variable, index, all, list, body, otherwise, location) {
        this.variable = variable;
        this.index = index;
        this.all = all;
        this.list = list;
        this.body = body;
        this.otherwise = otherwise;
        this.location = location;
        this.type = 'for-statement';
    }
    return ForStatement;
}());
exports.ForStatement = ForStatement;
var IfStatement = /** @class */ (function () {
    function IfStatement(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'if-statement';
    }
    return IfStatement;
}());
exports.IfStatement = IfStatement;
var ElseClause = /** @class */ (function () {
    function ElseClause(children, location) {
        this.children = children;
        this.location = location;
        this.type = 'else-clause';
    }
    return ElseClause;
}());
exports.ElseClause = ElseClause;
var ElseIfClause = /** @class */ (function () {
    function ElseIfClause(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'else-if-clause';
    }
    return ElseIfClause;
}());
exports.ElseIfClause = ElseIfClause;
var Characters = /** @class */ (function () {
    function Characters(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'characters';
    }
    return Characters;
}());
exports.Characters = Characters;
var IfThenExpression = /** @class */ (function () {
    function IfThenExpression(condition, iftrue, iffalse, location) {
        this.condition = condition;
        this.iftrue = iftrue;
        this.iffalse = iffalse;
        this.location = location;
        this.type = 'if-then-expression';
    }
    return IfThenExpression;
}());
exports.IfThenExpression = IfThenExpression;
var BinaryExpression = /** @class */ (function () {
    function BinaryExpression(left, operator, right, location) {
        this.left = left;
        this.operator = operator;
        this.right = right;
        this.location = location;
        this.type = 'binary-expression';
    }
    return BinaryExpression;
}());
exports.BinaryExpression = BinaryExpression;
var UnaryExpression = /** @class */ (function () {
    function UnaryExpression(operator, expression) {
        this.operator = operator;
        this.expression = expression;
        this.type = 'unary-expression';
    }
    return UnaryExpression;
}());
exports.UnaryExpression = UnaryExpression;
var ViewConstruction = /** @class */ (function () {
    function ViewConstruction(cons, context, location) {
        this.cons = cons;
        this.context = context;
        this.location = location;
        this.type = 'view-construction';
    }
    return ViewConstruction;
}());
exports.ViewConstruction = ViewConstruction;
var FunApplication = /** @class */ (function () {
    function FunApplication(target, typeArgs, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.args = args;
        this.location = location;
        this.type = 'fun-application';
    }
    return FunApplication;
}());
exports.FunApplication = FunApplication;
var ConstructExpression = /** @class */ (function () {
    function ConstructExpression(cons, args, location) {
        this.cons = cons;
        this.args = args;
        this.location = location;
        this.type = 'construct-expression';
    }
    return ConstructExpression;
}());
exports.ConstructExpression = ConstructExpression;
var CallExpression = /** @class */ (function () {
    function CallExpression(target, typeArgs, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.args = args;
        this.location = location;
        this.type = 'call-expression';
    }
    return CallExpression;
}());
exports.CallExpression = CallExpression;
/**
 * MemberExpression
 */
var MemberExpression = /** @class */ (function () {
    function MemberExpression(target, member, location) {
        this.target = target;
        this.member = member;
        this.location = location;
    }
    return MemberExpression;
}());
exports.MemberExpression = MemberExpression;
var ReadExpression = /** @class */ (function () {
    function ReadExpression(target, path, hint, defaults, location) {
        this.target = target;
        this.path = path;
        this.hint = hint;
        this.defaults = defaults;
        this.location = location;
        this.type = 'read-expression';
    }
    return ReadExpression;
}());
exports.ReadExpression = ReadExpression;
var FunctionExpression = /** @class */ (function () {
    function FunctionExpression(parameters, body, location) {
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'function-expression';
    }
    return FunctionExpression;
}());
exports.FunctionExpression = FunctionExpression;
var List = /** @class */ (function () {
    function List(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'list';
    }
    return List;
}());
exports.List = List;
var Record = /** @class */ (function () {
    function Record(properties, location) {
        this.properties = properties;
        this.location = location;
        this.type = 'record';
    }
    return Record;
}());
exports.Record = Record;
var Property = /** @class */ (function () {
    function Property(key, value, location) {
        this.key = key;
        this.value = value;
        this.location = location;
        this.type = 'property';
    }
    return Property;
}());
exports.Property = Property;
var StringLiteral = /** @class */ (function () {
    function StringLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'string';
    }
    return StringLiteral;
}());
exports.StringLiteral = StringLiteral;
var NumberLiteral = /** @class */ (function () {
    function NumberLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'number-literal';
    }
    return NumberLiteral;
}());
exports.NumberLiteral = NumberLiteral;
var BooleanLiteral = /** @class */ (function () {
    function BooleanLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'boolean-literal';
    }
    return BooleanLiteral;
}());
exports.BooleanLiteral = BooleanLiteral;
var ContextProperty = /** @class */ (function () {
    function ContextProperty(member, location) {
        this.member = member;
        this.location = location;
        this.type = 'context-property';
    }
    return ContextProperty;
}());
exports.ContextProperty = ContextProperty;
var ContextVariable = /** @class */ (function () {
    function ContextVariable(location) {
        this.location = location;
        this.type = 'context-variable';
    }
    return ContextVariable;
}());
exports.ContextVariable = ContextVariable;
var UnqualifiedConstructor = /** @class */ (function () {
    function UnqualifiedConstructor(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-constructor';
    }
    return UnqualifiedConstructor;
}());
exports.UnqualifiedConstructor = UnqualifiedConstructor;
var QualifiedConstructor = /** @class */ (function () {
    function QualifiedConstructor(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-constructor';
    }
    return QualifiedConstructor;
}());
exports.QualifiedConstructor = QualifiedConstructor;
var UnqualifiedIdentifier = /** @class */ (function () {
    function UnqualifiedIdentifier(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-identifier';
    }
    return UnqualifiedIdentifier;
}());
exports.UnqualifiedIdentifier = UnqualifiedIdentifier;
/**
 * QualifiedIdentifier
 */
var QualifiedIdentifier = /** @class */ (function () {
    function QualifiedIdentifier(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-identifier';
    }
    return QualifiedIdentifier;
}());
exports.QualifiedIdentifier = QualifiedIdentifier;

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path='Parser.d.ts' />
var Parser = require("./Parser");
var nodes = require("./AST");
var afpl = require("afpl");
var jsfmt = require("js-beautify");
var TypeScript = require("./TypeScript");
var afpl_1 = require("afpl");
var defaultOptions = {
    debug: false,
    main: 'Main',
    module: '@quenk/wml',
};
/**
 * parse a string as WML returning either an error or an AST.
 */
exports.parse = function (str, ast) {
    if (ast === void 0) { ast = nodes; }
    Parser.parser.yy = { ast: ast };
    try {
        return afpl_1.Either.right(Parser.parser.parse(str));
    }
    catch (e) {
        return afpl_1.Either.left(e);
    }
};
/**
 * pretty up the output.
 */
exports.pretty = function (doit) { return function (s) {
    return doit ? jsfmt(s, {}) : s;
}; };
/**
 * compile a string of WML turning it into typescript code.
 */
exports.compile = function (src, options) {
    if (options === void 0) { options = {}; }
    var opts = afpl.util.merge(defaultOptions, options);
    return exports.parse(src)
        .map(function (m) { return TypeScript.code(m, opts); })
        .map(exports.pretty(options.pretty));
};

},{"./AST":156,"./Parser":158,"./TypeScript":159,"afpl":162,"js-beautify":170}],158:[function(require,module,exports){

/* parser generated by jison 0.6.1-203 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var Parser = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   no try..catch: ................... false
    //   no default resolve on conflict:    false
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main(): 
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3,
  ebnf: true
},
symbols_: {
  "!": 16,
  "!=": 61,
  "$accept": 0,
  "$end": 1,
  "%}": 30,
  "&&": 62,
  "(": 7,
  ")": 8,
  "*": 3,
  "+": 21,
  ",": 6,
  "-": 23,
  "->": 57,
  ".": 17,
  "/": 22,
  "/>": 38,
  ":": 12,
  ";": 20,
  "<": 13,
  "</": 37,
  "<=": 59,
  "=": 9,
  "==": 60,
  "=>": 50,
  ">": 14,
  ">=": 58,
  "?": 18,
  "@": 19,
  "AS": 27,
  "CHARACTERS": 47,
  "CONSTRUCTOR": 56,
  "ELSE": 44,
  "ENDFOR": 43,
  "ENDFUN": 36,
  "ENDIF": 46,
  "ENDMAIN": 31,
  "ENDVIEW": 34,
  "EOF": 1,
  "EXPORT": 32,
  "FALSE": 54,
  "FOR": 41,
  "FROM": 26,
  "FUN": 35,
  "IDENTIFIER": 55,
  "IF": 45,
  "IMPORT": 25,
  "IN": 42,
  "INSTANCEOF": 64,
  "MAIN": 29,
  "NUMBER_LITERAL": 52,
  "STRING_LITERAL": 51,
  "THEN": 48,
  "TRUE": 53,
  "VIEW": 33,
  "[": 10,
  "\\\\": 49,
  "]": 11,
  "^": 24,
  "aggregate_member": 70,
  "aliased_member": 69,
  "argument_list": 107,
  "arguments": 106,
  "attribute": 96,
  "attribute_value": 97,
  "attribute_value_group": 159,
  "attributes": 95,
  "binary_expression": 110,
  "binary_operator": 141,
  "binary_operator_group": 165,
  "boolean_literal": 132,
  "call_expression": 120,
  "characters": 105,
  "child": 91,
  "child_group": 154,
  "children": 90,
  "composite_member": 71,
  "cons": 135,
  "construct_expression": 119,
  "context_property": 133,
  "context_type": 81,
  "context_variable": 134,
  "control": 101,
  "control_group": 160,
  "curried_parameters": 86,
  "curried_parameters_group": 153,
  "else_clause": 104,
  "end_main": 75,
  "error": 2,
  "export": 77,
  "export_statement": 78,
  "exports": 76,
  "expression": 108,
  "filter": 100,
  "filters": 99,
  "for_statement": 102,
  "fun_application": 114,
  "fun_statement": 80,
  "fun_target": 115,
  "function_expression": 124,
  "identifier": 138,
  "if_expression": 109,
  "if_statement": 103,
  "import_member": 68,
  "import_statement": 67,
  "import_statement_option": 142,
  "imports": 66,
  "interpolation": 98,
  "list": 129,
  "literal": 125,
  "literal_group": 163,
  "main": 74,
  "main_option": 146,
  "main_option2": 147,
  "main_option3": 148,
  "main_option4": 149,
  "member": 73,
  "member_expression": 121,
  "member_group": 145,
  "member_list": 72,
  "member_list_group": 143,
  "member_list_group2": 144,
  "module": 65,
  "node": 93,
  "node_option": 155,
  "node_option2": 156,
  "number_literal": 131,
  "parameter": 89,
  "parameter_list": 88,
  "parameters": 87,
  "partial_application": 118,
  "properties": 127,
  "property": 128,
  "property_group": 164,
  "qualified_constructor": 136,
  "qualified_identifier": 139,
  "read_expression": 122,
  "readable_expression": 123,
  "readable_expression_group": 162,
  "record": 126,
  "simple_expression": 112,
  "simple_expression_group": 161,
  "string_literal": 130,
  "tag": 92,
  "type": 85,
  "type_arg_list": 117,
  "type_arguments": 116,
  "type_class": 84,
  "type_class_list": 83,
  "type_classes": 82,
  "type_option": 152,
  "unary_expression": 111,
  "unqualified_constructor": 137,
  "unqualified_identifier": 140,
  "view_construction": 113,
  "view_statement": 79,
  "view_statement_option": 150,
  "view_statement_option2": 151,
  "widget": 94,
  "widget_option": 157,
  "widget_option2": 158,
  "{": 4,
  "{%": 28,
  "{{": 39,
  "|": 15,
  "||": 63,
  "}": 5,
  "}}": 40
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "*",
  4: "{",
  5: "}",
  6: ",",
  7: "(",
  8: ")",
  9: "=",
  10: "[",
  11: "]",
  12: ":",
  13: "<",
  14: ">",
  15: "|",
  16: "!",
  17: ".",
  18: "?",
  19: "@",
  20: ";",
  21: "+",
  22: "/",
  23: "-",
  24: "^",
  25: "IMPORT",
  26: "FROM",
  27: "AS",
  28: "{%",
  29: "MAIN",
  30: "%}",
  31: "ENDMAIN",
  32: "EXPORT",
  33: "VIEW",
  34: "ENDVIEW",
  35: "FUN",
  36: "ENDFUN",
  37: "</",
  38: "/>",
  39: "{{",
  40: "}}",
  41: "FOR",
  42: "IN",
  43: "ENDFOR",
  44: "ELSE",
  45: "IF",
  46: "ENDIF",
  47: "CHARACTERS",
  48: "THEN",
  49: "\\\\",
  50: "=>",
  51: "STRING_LITERAL",
  52: "NUMBER_LITERAL",
  53: "TRUE",
  54: "FALSE",
  55: "IDENTIFIER",
  56: "CONSTRUCTOR",
  57: "->",
  58: ">=",
  59: "<=",
  60: "==",
  61: "!=",
  62: "&&",
  63: "||",
  64: "INSTANCEOF"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [65, 7],
  66,
  66,
  67,
  s,
  [68, 3],
  s,
  [69, 4, 1],
  72,
  73,
  74,
  74,
  75,
  76,
  76,
  s,
  [77, 3],
  78,
  79,
  s,
  [80, 16],
  81,
  82,
  83,
  83,
  s,
  [84, 4],
  s,
  [85, 3],
  s,
  [86, 4],
  87,
  87,
  88,
  88,
  89,
  89,
  90,
  90,
  91,
  92,
  92,
  s,
  [93, 4],
  s,
  [94, 4],
  95,
  95,
  s,
  [96, 4],
  97,
  98,
  98,
  99,
  s,
  [99, 4, 1],
  s,
  [102, 5],
  103,
  104,
  104,
  105,
  106,
  106,
  107,
  107,
  s,
  [108, 7],
  109,
  s,
  [110, 4],
  111,
  s,
  [111, 4, 1],
  114,
  114,
  s,
  [115, 3],
  116,
  117,
  117,
  s,
  [118, 3],
  119,
  s,
  [120, 8],
  s,
  [121, 10],
  s,
  [122, 10],
  123,
  123,
  124,
  124,
  125,
  126,
  126,
  127,
  127,
  128,
  129,
  s,
  [129, 4, 1],
  s,
  [132, 4, 1],
  135,
  136,
  136,
  137,
  138,
  138,
  139,
  s,
  [139, 4, 1],
  142,
  143,
  143,
  144,
  144,
  145,
  145,
  146,
  146,
  147,
  147,
  148,
  148,
  149,
  149,
  150,
  150,
  151,
  151,
  152,
  152,
  153,
  153,
  s,
  [154, 5],
  155,
  155,
  156,
  156,
  157,
  157,
  158,
  158,
  159,
  159,
  160,
  160,
  s,
  [161, 10],
  s,
  [162, 4],
  s,
  [163, 5],
  164,
  164,
  s,
  [165, 14]
]),
  rule: u([
  4,
  3,
  3,
  2,
  3,
  2,
  2,
  1,
  2,
  5,
  s,
  [1, 3],
  s,
  [3, 3],
  1,
  3,
  1,
  11,
  c,
  [4, 3],
  2,
  s,
  [1, 3],
  6,
  13,
  11,
  10,
  10,
  9,
  10,
  9,
  9,
  8,
  9,
  8,
  8,
  7,
  8,
  7,
  7,
  6,
  c,
  [31, 5],
  c,
  [4, 3],
  2,
  4,
  c,
  [5, 3],
  c,
  [54, 3],
  c,
  [6, 4],
  1,
  c,
  [44, 5],
  8,
  7,
  4,
  3,
  c,
  [4, 4],
  c,
  [72, 3],
  c,
  [19, 4],
  3,
  4,
  1,
  c,
  [84, 3],
  10,
  12,
  14,
  14,
  16,
  18,
  6,
  7,
  7,
  1,
  c,
  [42, 4],
  s,
  [1, 6],
  3,
  6,
  3,
  5,
  5,
  7,
  2,
  4,
  1,
  4,
  5,
  c,
  [46, 3],
  c,
  [64, 4],
  c,
  [128, 3],
  4,
  c,
  [131, 3],
  c,
  [135, 4],
  c,
  [19, 3],
  s,
  [3, 7],
  5,
  3,
  6,
  8,
  6,
  8,
  c,
  [4, 4],
  10,
  8,
  c,
  [78, 3],
  c,
  [160, 3],
  c,
  [114, 5],
  c,
  [69, 5],
  c,
  [112, 4],
  c,
  [101, 4],
  c,
  [5, 5],
  0,
  s,
  [1, 7],
  0,
  c,
  [10, 3],
  c,
  [4, 10],
  c,
  [21, 15],
  s,
  [1, 39]
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : module $end */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 1];
    this._$ = yylstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 1:
    /*! Production::    module : imports exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 2:
    /*! Production::    module : imports exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 3:
    /*! Production::    module : imports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 4:
    /*! Production::    module : imports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 1], [], null, this._$); 
    return this.$;
    break;

case 5:
    /*! Production::    module : exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 6:
    /*! Production::    module : exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 7:
    /*! Production::    module : main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 8:
    /*! Production::    imports : import_statement */
case 89:
    /*! Production::    filters : filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =  [yyvstack[yysp]];
    break;

case 9:
    /*! Production::    imports : imports import_statement */
case 24:
    /*! Production::    exports : exports export */
case 68:
    /*! Production::    children : children child */
case 81:
    /*! Production::    attributes : attributes attribute */
case 90:
    /*! Production::    filters : filters filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    break;

case 10:
    /*! Production::    import_statement : IMPORT import_member FROM string_literal import_statement_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ImportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 11:
    /*! Production::    import_member : aggregate_member */
case 12:
    /*! Production::    import_member : aliased_member */
case 13:
    /*! Production::    import_member : composite_member */
case 19:
    /*! Production::    member : member_group */
case 25:
    /*! Production::    export : export_statement */
case 26:
    /*! Production::    export : view_statement */
case 168:
    /*! Production::    literal : literal_group */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp];
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 14:
    /*! Production::    aliased_member : member AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AliasedMember(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 15:
    /*! Production::    aggregate_member : "*" AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AggregateMember(yyvstack[yysp], this._$);
    break;

case 16:
    /*! Production::    composite_member : "{" member_list "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CompositeMember(yyvstack[yysp - 1], this._$);
    break;

case 17:
    /*! Production::    member_list : member_list_group */
case 23:
    /*! Production::    exports : export */
case 48:
    /*! Production::    type_class_list : type_class */
case 57:
    /*! Production::    curried_parameters : parameter */
case 63:
    /*! Production::    parameter_list : parameter */
case 67:
    /*! Production::    children : child */
case 80:
    /*! Production::    attributes : attribute */
case 105:
    /*! Production::    argument_list : expression */
case 130:
    /*! Production::    type_arg_list : type */
case 171:
    /*! Production::    properties : property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp]];
    break;

case 18:
    /*! Production::    member_list : member_list "," member_list_group2 */
case 49:
    /*! Production::    type_class_list : type_class_list "," type_class */
case 58:
    /*! Production::    curried_parameters : curried_parameters curried_parameters_group parameter */
case 64:
    /*! Production::    parameter_list : parameter_list "," parameter */
case 106:
    /*! Production::    argument_list : argument_list "," expression */
case 131:
    /*! Production::    type_arg_list : type_arg_list "," type */
case 172:
    /*! Production::    properties : properties "," property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 2].concat(yyvstack[yysp]);
    break;

case 20:
    /*! Production::    main : "{%" MAIN main_option main_option2 "(" type ")" main_option3 "%}" tag main_option4 */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedMain(yyvstack[yysp - 8], yyvstack[yysp - 7]||[], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 21:
    /*! Production::    main : tag */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedMain(yyvstack[yysp], this._$);
    break;

case 22:
    /*! Production::    end_main : "{%" ENDMAIN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 2];
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 27:
    /*! Production::    export : fun_statement */
case 69:
    /*! Production::    child : child_group */
case 70:
    /*! Production::    tag : node */
case 71:
    /*! Production::    tag : widget */
case 86:
    /*! Production::    attribute_value : attribute_value_group */
case 92:
    /*! Production::    control : control_group */
case 107:
    /*! Production::    expression : if_expression */
case 108:
    /*! Production::    expression : binary_expression */
case 110:
    /*! Production::    expression : simple_expression */
case 111:
    /*! Production::    expression : read_expression */
case 112:
    /*! Production::    expression : function_expression */
case 121:
    /*! Production::    simple_expression : simple_expression_group */
case 126:
    /*! Production::    fun_target : identifier */
case 127:
    /*! Production::    fun_target : context_property */
case 164:
    /*! Production::    readable_expression : readable_expression_group */
case 182:
    /*! Production::    cons : qualified_constructor */
case 183:
    /*! Production::    cons : unqualified_constructor */
case 187:
    /*! Production::    identifier : qualified_identifier */
case 188:
    /*! Production::    identifier : unqualified_identifier */
case 192:
    /*! Production::    binary_operator : binary_operator_group */
case 194:
    /*! Production::    import_statement_option : ";" */
case 195:
    /*! Production::    member_list_group : member */
case 196:
    /*! Production::    member_list_group : aliased_member */
case 197:
    /*! Production::    member_list_group2 : member */
case 198:
    /*! Production::    member_list_group2 : aliased_member */
case 199:
    /*! Production::    member_group : unqualified_identifier */
case 200:
    /*! Production::    member_group : unqualified_constructor */
case 202:
    /*! Production::    main_option : unqualified_constructor */
case 204:
    /*! Production::    main_option2 : type_classes */
case 206:
    /*! Production::    main_option3 : parameters */
case 208:
    /*! Production::    main_option4 : end_main */
case 210:
    /*! Production::    view_statement_option : type_classes */
case 212:
    /*! Production::    view_statement_option2 : parameters */
case 214:
    /*! Production::    type_option : type_classes */
case 215:
    /*! Production::    curried_parameters_group : "->" */
case 216:
    /*! Production::    curried_parameters_group : "," */
case 217:
    /*! Production::    child_group : tag */
case 218:
    /*! Production::    child_group : interpolation */
case 219:
    /*! Production::    child_group : control */
case 220:
    /*! Production::    child_group : characters */
case 221:
    /*! Production::    child_group : identifier */
case 223:
    /*! Production::    node_option : children */
case 225:
    /*! Production::    node_option2 : children */
case 227:
    /*! Production::    widget_option : children */
case 229:
    /*! Production::    widget_option2 : children */
case 230:
    /*! Production::    attribute_value_group : interpolation */
case 231:
    /*! Production::    attribute_value_group : literal */
case 232:
    /*! Production::    control_group : for_statement */
case 233:
    /*! Production::    control_group : if_statement */
case 234:
    /*! Production::    simple_expression_group : view_construction */
case 235:
    /*! Production::    simple_expression_group : fun_application */
case 236:
    /*! Production::    simple_expression_group : construct_expression */
case 237:
    /*! Production::    simple_expression_group : call_expression */
case 238:
    /*! Production::    simple_expression_group : member_expression */
case 239:
    /*! Production::    simple_expression_group : literal */
case 240:
    /*! Production::    simple_expression_group : context_property */
case 241:
    /*! Production::    simple_expression_group : cons */
case 242:
    /*! Production::    simple_expression_group : identifier */
case 243:
    /*! Production::    simple_expression_group : context_variable */
case 244:
    /*! Production::    readable_expression_group : string_literal */
case 245:
    /*! Production::    readable_expression_group : member_expression */
case 246:
    /*! Production::    readable_expression_group : context_property */
case 247:
    /*! Production::    readable_expression_group : call_expression */
case 248:
    /*! Production::    literal_group : record */
case 249:
    /*! Production::    literal_group : list */
case 250:
    /*! Production::    literal_group : string_literal */
case 251:
    /*! Production::    literal_group : number_literal */
case 252:
    /*! Production::    literal_group : boolean_literal */
case 253:
    /*! Production::    property_group : unqualified_identifier */
case 254:
    /*! Production::    property_group : string_literal */
case 255:
    /*! Production::    binary_operator_group : ">" */
case 256:
    /*! Production::    binary_operator_group : ">=" */
case 257:
    /*! Production::    binary_operator_group : "<" */
case 258:
    /*! Production::    binary_operator_group : "<=" */
case 259:
    /*! Production::    binary_operator_group : "==" */
case 260:
    /*! Production::    binary_operator_group : "!=" */
case 261:
    /*! Production::    binary_operator_group : "+" */
case 262:
    /*! Production::    binary_operator_group : "/" */
case 263:
    /*! Production::    binary_operator_group : "-" */
case 264:
    /*! Production::    binary_operator_group : "=" */
case 265:
    /*! Production::    binary_operator_group : "&&" */
case 266:
    /*! Production::    binary_operator_group : "||" */
case 267:
    /*! Production::    binary_operator_group : "^" */
case 268:
    /*! Production::    binary_operator_group : INSTANCEOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp];
    break;

case 28:
    /*! Production::    export_statement : "{%" EXPORT composite_member FROM string_literal "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ExportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 29:
    /*! Production::    view_statement : "{%" VIEW unqualified_constructor view_statement_option "(" type ")" view_statement_option2 "%}" tag "{%" ENDVIEW "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 12, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewStatement(yyvstack[yysp - 10], yyvstack[yysp - 9]||[], yyvstack[yysp - 7], yyvstack[yysp - 5]||[], yyvstack[yysp - 3], this._$);
    break;

case 30:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type curried_parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 8], yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 31:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 32:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes curried_parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], null, yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 33:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], null, [], yyvstack[yysp - 3], this._$);
    break;

case 34:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type curried_parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], [], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 35:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], [], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 36:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier curried_parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6],[],null,yyvstack[yysp - 5],yyvstack[yysp - 3],this._$);
    break;

case 37:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5],[],null,[],yyvstack[yysp - 3],this._$);
    break;

case 38:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type curried_parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 39:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 40:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes curried_parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], null, yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 41:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], yyvstack[yysp - 3], null, [], yyvstack[yysp - 1], this._$);
    break;

case 42:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type curried_parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], [], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 43:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], [], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 44:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier curried_parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4],[],null,yyvstack[yysp - 3],yyvstack[yysp - 1],this._$);
    break;

case 45:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 3],[],null,[],yyvstack[yysp - 1],this._$);
    break;

case 46:
    /*! Production::    context_type : "(" type ")" */
case 47:
    /*! Production::    type_classes : "[" type_class_list "]" */
case 59:
    /*! Production::    curried_parameters : "(" curried_parameters ")" */
case 62:
    /*! Production::    parameters : "(" parameter_list ")" */
case 104:
    /*! Production::    arguments : "(" argument_list ")" */
case 113:
    /*! Production::    expression : "(" expression ")" */
case 128:
    /*! Production::    fun_target : "(" expression ")" */
case 129:
    /*! Production::    type_arguments : "[" type_arg_list "]" */
case 165:
    /*! Production::    readable_expression : "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1];
    break;

case 50:
    /*! Production::    type_class : unqualified_identifier */
case 52:
    /*! Production::    type_class : unqualified_constructor */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp], null, this._$);
    break;

case 51:
    /*! Production::    type_class : unqualified_identifier ":" type */
case 53:
    /*! Production::    type_class : unqualified_constructor ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 54:
    /*! Production::    type : cons type_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 1], yyvstack[yysp]||[], false, this._$);
    break;

case 55:
    /*! Production::    type : cons type_classes "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 3], yyvstack[yysp - 2], true, this._$);
    break;

case 56:
    /*! Production::    type : cons "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 2], [], true, this._$);
    break;

case 60:
    /*! Production::    curried_parameters : "(" ")" */
case 61:
    /*! Production::    parameters : "(" ")" */
case 103:
    /*! Production::    arguments : "(" ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [];
    break;

case 65:
    /*! Production::    parameter : unqualified_identifier ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedParameter(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 66:
    /*! Production::    parameter : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedParameter(yyvstack[yysp], this._$);
    break;

case 72:
    /*! Production::    node : "<" identifier attributes ">" node_option "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 73:
    /*! Production::    node : "<" identifier ">" node_option2 "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 74:
    /*! Production::    node : "<" identifier attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 75:
    /*! Production::    node : "<" identifier "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 76:
    /*! Production::    widget : "<" cons attributes ">" widget_option "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 77:
    /*! Production::    widget : "<" cons ">" widget_option2 "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 78:
    /*! Production::    widget : "<" cons attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 79:
    /*! Production::    widget : "<" cons "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 82:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 83:
    /*! Production::    attribute : unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Attribute(new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 84:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 2], yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 85:
    /*! Production::    attribute : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(
    new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 87:
    /*! Production::    interpolation : "{{" expression "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 1], [], this._$);
    break;

case 88:
    /*! Production::    interpolation : "{{" expression filters "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 91:
    /*! Production::    filter : "|" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp]
    break;

case 93:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 7], null, null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 94:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 11, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 9], yyvstack[yysp - 7], null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 95:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 96:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], null, null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 97:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 15, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 13], yyvstack[yysp - 11], null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 98:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 17, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 15], yyvstack[yysp - 13], null, yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 3], this._$);
    break;

case 99:
    /*! Production::    if_statement : "{%" IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 100:
    /*! Production::    else_clause : "{%" ELSE "%}" children "{%" ENDIF "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseClause(yyvstack[yysp - 3], this._$);
    break;

case 101:
    /*! Production::    else_clause : "{%" ELSE IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseIfClause(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 102:
    /*! Production::    characters : CHARACTERS */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Characters(yyvstack[yysp], this._$);
    break;

case 109:
    /*! Production::    expression : unary_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =yyvstack[yysp];
    break;

case 114:
    /*! Production::    if_expression : IF expression THEN expression ELSE expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfThenExpression(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 115:
    /*! Production::    binary_expression : simple_expression binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 116:
    /*! Production::    binary_expression : simple_expression binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 117:
    /*! Production::    binary_expression : "(" expression ")" binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 118:
    /*! Production::    binary_expression : "(" expression ")" binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 119:
    /*! Production::    unary_expression : "!" simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 120:
    /*! Production::    unary_expression : "!" "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 122:
    /*! Production::    view_construction : "<" cons arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewConstruction(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 123:
    /*! Production::    fun_application : "<" fun_target type_arguments partial_application ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1]||[], this._$);
    break;

case 124:
    /*! Production::    fun_application : "<" fun_target partial_application ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 2], [], yyvstack[yysp - 1] ||[], this._$);
    break;

case 125:
    /*! Production::    fun_application : "<" fun_target ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 1], [], [], this._$);
    break;

case 132:
    /*! Production::    partial_application : "(" ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = [new yy.ast.UnqualifiedIdentifier('undefined', this._$)];
    break;

case 133:
    /*! Production::    partial_application : "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp - 1]];
    break;

case 134:
    /*! Production::    partial_application : partial_application "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 3].concat(yyvstack[yysp - 1]);
    break;

case 135:
    /*! Production::    construct_expression : cons arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ConstructExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 136:
    /*! Production::    call_expression : identifier type_arguments arguments */
case 138:
    /*! Production::    call_expression : context_property type_arguments arguments */
case 140:
    /*! Production::    call_expression : member_expression type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 137:
    /*! Production::    call_expression : identifier arguments */
case 139:
    /*! Production::    call_expression : context_property arguments */
case 141:
    /*! Production::    call_expression : member_expression arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 1], [], yyvstack[yysp], this._$);
    break;

case 142:
    /*! Production::    call_expression : "(" expression ")" type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 143:
    /*! Production::    call_expression : "(" expression ")" arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], [], yyvstack[yysp], this._$);
    break;

case 144:
    /*! Production::    member_expression : qualified_identifier "." unqualified_identifier */
case 145:
    /*! Production::    member_expression : qualified_constructor "." unqualified_identifier */
case 146:
    /*! Production::    member_expression : context_variable "." unqualified_identifier */
case 147:
    /*! Production::    member_expression : context_property "." unqualified_identifier */
case 148:
    /*! Production::    member_expression : list "." unqualified_identifier */
case 149:
    /*! Production::    member_expression : record "." unqualified_identifier */
case 150:
    /*! Production::    member_expression : string_literal "." unqualified_identifier */
case 151:
    /*! Production::    member_expression : call_expression "." unqualified_identifier */
case 153:
    /*! Production::    member_expression : member_expression "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 152:
    /*! Production::    member_expression : "(" expression ")" "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 3], yyvstack[yysp], this._$);
    break;

case 154:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "]" */
case 156:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "]" */
case 158:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "]" */
case 160:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], null, this._$);
    break;

case 155:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "?" expression "]" */
case 157:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "?" expression "]" */
case 159:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "?" expression "]" */
case 161:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 162:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 163:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], null, this._$);
    break;

case 166:
    /*! Production::    function_expression : "\\" parameter_list "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 167:
    /*! Production::    function_expression : "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression([], yyvstack[yysp], this._$);
    break;

case 169:
    /*! Production::    record : "{" "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record([], this._$);
    break;

case 170:
    /*! Production::    record : "{" properties "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record(yyvstack[yysp - 1], this._$);
    break;

case 173:
    /*! Production::    property : property_group ":" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Property(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 174:
    /*! Production::    list : "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List([], this._$);
    break;

case 175:
    /*! Production::    list : "[" argument_list "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List(yyvstack[yysp - 1], this._$);
    break;

case 176:
    /*! Production::    string_literal : STRING_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.StringLiteral(yyvstack[yysp].slice(1, yyvstack[yysp].length - 1, this._$));
    break;

case 177:
    /*! Production::    number_literal : NUMBER_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.NumberLiteral(yyvstack[yysp], this._$);
    break;

case 178:
    /*! Production::    boolean_literal : TRUE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(true, this._$);
    break;

case 179:
    /*! Production::    boolean_literal : FALSE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(false, this._$);
    break;

case 180:
    /*! Production::    context_property : "@" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextProperty(yyvstack[yysp], this._$)
    break;

case 181:
    /*! Production::    context_variable : "@" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextVariable(this._$);
    break;

case 184:
    /*! Production::    qualified_constructor : IDENTIFIER "." CONSTRUCTOR */
case 185:
    /*! Production::    qualified_constructor : CONSTRUCTOR "." CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedConstructor(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 186:
    /*! Production::    unqualified_constructor : CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedConstructor(yyvstack[yysp], this._$);
    break;

case 189:
    /*! Production::    qualified_identifier : IDENTIFIER "." IDENTIFIER */
case 190:
    /*! Production::    qualified_identifier : CONSTRUCTOR "." IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedIdentifier(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 191:
    /*! Production::    unqualified_identifier : IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedIdentifier(yyvstack[yysp], this._$);
    break;

case 193:
    /*! Production::    import_statement_option : %epsilon */
case 201:
    /*! Production::    main_option : %epsilon */
case 203:
    /*! Production::    main_option2 : %epsilon */
case 205:
    /*! Production::    main_option3 : %epsilon */
case 207:
    /*! Production::    main_option4 : %epsilon */
case 209:
    /*! Production::    view_statement_option : %epsilon */
case 211:
    /*! Production::    view_statement_option2 : %epsilon */
case 213:
    /*! Production::    type_option : %epsilon */
case 222:
    /*! Production::    node_option : %epsilon */
case 224:
    /*! Production::    node_option2 : %epsilon */
case 226:
    /*! Production::    widget_option : %epsilon */
case 228:
    /*! Production::    widget_option2 : %epsilon */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = undefined;
    break;

}
},
table: bt({
  len: u([
  15,
  1,
  14,
  11,
  1,
  0,
  0,
  4,
  0,
  12,
  s,
  [0, 5],
  8,
  c,
  [13, 4],
  c,
  [3, 3],
  0,
  5,
  s,
  [2, 3],
  c,
  [8, 4],
  1,
  1,
  9,
  s,
  [0, 5],
  6,
  6,
  s,
  [0, 4],
  29,
  29,
  c,
  [20, 4],
  4,
  0,
  1,
  4,
  10,
  2,
  6,
  6,
  2,
  0,
  3,
  0,
  5,
  23,
  c,
  [44, 3],
  c,
  [5, 3],
  2,
  2,
  c,
  [55, 3],
  6,
  c,
  [51, 3],
  8,
  7,
  5,
  21,
  20,
  11,
  0,
  8,
  c,
  [48, 5],
  8,
  c,
  [30, 3],
  1,
  21,
  s,
  [0, 7],
  43,
  s,
  [0, 4],
  10,
  1,
  2,
  2,
  17,
  23,
  c,
  [21, 7],
  c,
  [66, 4],
  3,
  1,
  6,
  c,
  [50, 4],
  c,
  [3, 3],
  6,
  21,
  20,
  3,
  0,
  0,
  20,
  1,
  1,
  c,
  [141, 3],
  5,
  12,
  c,
  [64, 4],
  3,
  c,
  [40, 3],
  5,
  c,
  [111, 3],
  0,
  0,
  26,
  c,
  [63, 3],
  43,
  33,
  0,
  28,
  26,
  29,
  29,
  4,
  c,
  [72, 4],
  25,
  0,
  26,
  27,
  28,
  27,
  s,
  [25, 3],
  12,
  0,
  45,
  8,
  s,
  [0, 5],
  1,
  1,
  3,
  43,
  c,
  [42, 4],
  c,
  [12, 5],
  21,
  5,
  1,
  1,
  0,
  5,
  c,
  [180, 3],
  1,
  c,
  [88, 3],
  21,
  20,
  20,
  1,
  c,
  [4, 4],
  20,
  1,
  c,
  [81, 3],
  c,
  [131, 4],
  7,
  c,
  [29, 4],
  c,
  [13, 4],
  c,
  [82, 3],
  s,
  [0, 14],
  c,
  [25, 3],
  43,
  15,
  15,
  14,
  11,
  24,
  2,
  0,
  45,
  20,
  2,
  24,
  c,
  [213, 3],
  c,
  [4, 4],
  2,
  0,
  c,
  [3, 3],
  c,
  [7, 3],
  s,
  [2, 4],
  5,
  c,
  [137, 3],
  c,
  [18, 7],
  c,
  [267, 3],
  2,
  1,
  17,
  5,
  c,
  [175, 3],
  c,
  [275, 3],
  c,
  [97, 6],
  3,
  c,
  [191, 3],
  3,
  c,
  [183, 4],
  1,
  c,
  [325, 5],
  c,
  [44, 3],
  31,
  43,
  1,
  7,
  1,
  2,
  c,
  [252, 3],
  c,
  [304, 4],
  s,
  [1, 3],
  c,
  [45, 3],
  c,
  [7, 4],
  c,
  [31, 4],
  c,
  [3, 3],
  43,
  c,
  [145, 5],
  c,
  [11, 3],
  c,
  [102, 3],
  44,
  c,
  [124, 3],
  0,
  6,
  43,
  43,
  3,
  21,
  c,
  [26, 3],
  c,
  [161, 5],
  c,
  [76, 7],
  c,
  [79, 5],
  c,
  [36, 3],
  33,
  45,
  c,
  [357, 4],
  15,
  6,
  0,
  6,
  c,
  [362, 3],
  c,
  [400, 5],
  c,
  [88, 4],
  c,
  [104, 5],
  1,
  2,
  21,
  c,
  [295, 3],
  2,
  4,
  c,
  [122, 8],
  15,
  0,
  43,
  1,
  22,
  c,
  [170, 5],
  6,
  s,
  [2, 3],
  c,
  [18, 3],
  21,
  c,
  [106, 3],
  3,
  c,
  [440, 3],
  c,
  [73, 5],
  c,
  [59, 3],
  43,
  c,
  [58, 3],
  c,
  [4, 4],
  c,
  [366, 3],
  c,
  [204, 3],
  c,
  [23, 3],
  15,
  c,
  [150, 4],
  1,
  4,
  21,
  43,
  21,
  43,
  1,
  1,
  c,
  [426, 5],
  c,
  [22, 3],
  c,
  [308, 5],
  c,
  [62, 4],
  4,
  21,
  c,
  [150, 3],
  c,
  [44, 3],
  c,
  [329, 3],
  3,
  c,
  [14, 3],
  c,
  [20, 3],
  c,
  [13, 3],
  c,
  [156, 3],
  21,
  1,
  20,
  0,
  3,
  1,
  0
]),
  symbol: u([
  13,
  25,
  28,
  65,
  66,
  67,
  74,
  s,
  [76, 5, 1],
  92,
  93,
  94,
  1,
  1,
  c,
  [17, 3],
  c,
  [15, 11],
  13,
  28,
  74,
  c,
  [11, 8],
  29,
  32,
  33,
  35,
  3,
  4,
  55,
  56,
  s,
  [68, 4, 1],
  73,
  137,
  140,
  145,
  55,
  56,
  s,
  [135, 6, 1],
  c,
  [36, 12],
  1,
  7,
  10,
  56,
  137,
  146,
  4,
  71,
  56,
  137,
  55,
  140,
  26,
  27,
  27,
  55,
  56,
  69,
  72,
  c,
  [43, 3],
  143,
  145,
  14,
  38,
  55,
  95,
  96,
  140,
  c,
  [6, 6],
  s,
  [5, 7, 1],
  13,
  14,
  15,
  17,
  s,
  [21, 4, 1],
  27,
  30,
  38,
  40,
  44,
  48,
  55,
  s,
  [58, 7, 1],
  c,
  [29, 29],
  c,
  [94, 3],
  82,
  147,
  26,
  c,
  [5, 3],
  150,
  7,
  9,
  10,
  30,
  55,
  81,
  82,
  86,
  89,
  140,
  51,
  130,
  55,
  56,
  c,
  [142, 6],
  c,
  [6, 4],
  5,
  6,
  5,
  6,
  27,
  c,
  [103, 3],
  96,
  140,
  13,
  28,
  37,
  39,
  47,
  55,
  56,
  s,
  [90, 5, 1],
  98,
  101,
  102,
  103,
  105,
  c,
  [170, 3],
  154,
  156,
  160,
  9,
  12,
  c,
  [30, 3],
  c,
  [33, 26],
  158,
  160,
  55,
  56,
  55,
  56,
  7,
  55,
  56,
  83,
  84,
  137,
  c,
  [91, 3],
  7,
  7,
  9,
  c,
  [103, 3],
  c,
  [102, 3],
  c,
  [8, 4],
  c,
  [7, 3],
  6,
  9,
  30,
  57,
  153,
  13,
  28,
  c,
  [56, 18],
  160,
  c,
  [21, 6],
  c,
  [20, 14],
  7,
  8,
  55,
  56,
  85,
  86,
  89,
  c,
  [294, 3],
  140,
  6,
  8,
  9,
  12,
  30,
  42,
  50,
  57,
  1,
  13,
  20,
  25,
  28,
  142,
  c,
  [279, 3],
  c,
  [173, 3],
  144,
  145,
  c,
  [131, 21],
  155,
  160,
  37,
  c,
  [24, 7],
  c,
  [78, 14],
  s,
  [4, 6, 3],
  45,
  s,
  [49, 8, 1],
  s,
  [108, 7, 1],
  s,
  [119, 4, 1],
  124,
  125,
  126,
  s,
  [129, 12, 1],
  161,
  163,
  13,
  14,
  17,
  28,
  30,
  c,
  [67, 5],
  17,
  41,
  45,
  55,
  140,
  4,
  10,
  39,
  c,
  [52, 4],
  97,
  98,
  c,
  [40, 6],
  159,
  163,
  c,
  [120, 21],
  157,
  c,
  [120, 23],
  c,
  [196, 3],
  c,
  [88, 3],
  6,
  11,
  6,
  11,
  12,
  c,
  [3, 3],
  30,
  c,
  [15, 6],
  c,
  [272, 53],
  c,
  [318, 49],
  c,
  [98, 3],
  c,
  [47, 41],
  55,
  c,
  [44, 8],
  c,
  [23, 14],
  30,
  8,
  6,
  8,
  57,
  153,
  c,
  [383, 3],
  10,
  11,
  18,
  c,
  [385, 4],
  82,
  152,
  6,
  8,
  12,
  17,
  57,
  c,
  [17, 5],
  14,
  17,
  c,
  [19, 5],
  c,
  [210, 6],
  c,
  [568, 3],
  c,
  [256, 24],
  c,
  [7, 3],
  15,
  40,
  99,
  100,
  5,
  c,
  [53, 3],
  c,
  [665, 4],
  c,
  [664, 6],
  c,
  [663, 3],
  c,
  [662, 7],
  141,
  165,
  c,
  [411, 43],
  c,
  [43, 47],
  19,
  c,
  [39, 6],
  c,
  [35, 6],
  c,
  [33, 16],
  c,
  [812, 10],
  c,
  [147, 16],
  106,
  116,
  c,
  [173, 4],
  c,
  [839, 12],
  c,
  [28, 10],
  c,
  [866, 17],
  c,
  [55, 14],
  c,
  [29, 27],
  55,
  88,
  89,
  140,
  c,
  [192, 43],
  c,
  [304, 8],
  c,
  [130, 22],
  c,
  [183, 21],
  c,
  [127, 27],
  c,
  [209, 19],
  c,
  [1047, 8],
  c,
  [1106, 18],
  c,
  [55, 14],
  c,
  [25, 71],
  7,
  19,
  55,
  56,
  115,
  133,
  c,
  [222, 6],
  c,
  [263, 3],
  11,
  c,
  [264, 12],
  s,
  [107, 8, 1],
  c,
  [265, 22],
  51,
  55,
  127,
  128,
  130,
  140,
  164,
  s,
  [55, 3],
  c,
  [321, 45],
  9,
  c,
  [1192, 3],
  c,
  [660, 24],
  c,
  [36, 3],
  8,
  17,
  55,
  56,
  c,
  [1190, 3],
  c,
  [703, 6],
  c,
  [6, 6],
  8,
  c,
  [867, 46],
  c,
  [41, 47],
  c,
  [858, 15],
  c,
  [62, 68],
  c,
  [21, 15],
  36,
  41,
  45,
  c,
  [939, 10],
  11,
  c,
  [1414, 6],
  56,
  c,
  [1425, 3],
  c,
  [30, 3],
  14,
  15,
  40,
  100,
  c,
  [829, 76],
  8,
  48,
  c,
  [715, 45],
  7,
  8,
  10,
  11,
  15,
  17,
  c,
  [527, 5],
  c,
  [806, 6],
  c,
  [15, 18],
  c,
  [14, 9],
  8,
  c,
  [27, 8],
  c,
  [98, 3],
  19,
  51,
  c,
  [410, 3],
  117,
  120,
  121,
  123,
  c,
  [82, 3],
  c,
  [80, 8],
  162,
  7,
  106,
  4,
  c,
  [50, 3],
  c,
  [576, 41],
  c,
  [71, 7],
  c,
  [69, 8],
  136,
  c,
  [67, 4],
  c,
  [1494, 3],
  c,
  [93, 23],
  55,
  140,
  c,
  [95, 4],
  c,
  [28, 26],
  6,
  50,
  55,
  140,
  55,
  140,
  c,
  [4, 8],
  7,
  106,
  7,
  10,
  14,
  116,
  118,
  c,
  [268, 43],
  55,
  140,
  6,
  11,
  5,
  6,
  12,
  6,
  42,
  30,
  c,
  [1624, 17],
  c,
  [663, 5],
  14,
  7,
  30,
  87,
  148,
  c,
  [4, 3],
  151,
  c,
  [544, 86],
  c,
  [24, 24],
  c,
  [3, 3],
  30,
  11,
  14,
  c,
  [468, 47],
  c,
  [1259, 25],
  c,
  [1492, 45],
  c,
  [2023, 4],
  117,
  c,
  [13, 3],
  27,
  6,
  11,
  c,
  [54, 43],
  17,
  27,
  7,
  10,
  17,
  27,
  106,
  116,
  c,
  [6, 6],
  17,
  27,
  s,
  [17, 3],
  7,
  10,
  106,
  116,
  6,
  8,
  c,
  [10, 3],
  27,
  27,
  c,
  [401, 44],
  89,
  140,
  14,
  7,
  118,
  7,
  c,
  [252, 3],
  c,
  [596, 14],
  c,
  [179, 29],
  c,
  [96, 43],
  51,
  55,
  c,
  [1213, 4],
  c,
  [1764, 86],
  c,
  [1974, 9],
  c,
  [551, 15],
  14,
  30,
  8,
  c,
  [1646, 4],
  c,
  [518, 25],
  c,
  [494, 4],
  c,
  [4, 4],
  30,
  c,
  [201, 5],
  c,
  [1001, 29],
  c,
  [142, 15],
  85,
  c,
  [143, 7],
  117,
  c,
  [733, 23],
  7,
  106,
  44,
  c,
  [991, 15],
  c,
  [1377, 13],
  c,
  [13, 12],
  c,
  [2315, 7],
  c,
  [629, 44],
  8,
  30,
  6,
  42,
  c,
  [212, 14],
  104,
  c,
  [772, 7],
  c,
  [15, 3],
  6,
  8,
  c,
  [6, 4],
  c,
  [215, 5],
  30,
  c,
  [132, 15],
  c,
  [99, 43],
  27,
  6,
  c,
  [2845, 3],
  c,
  [727, 3],
  c,
  [725, 5],
  c,
  [721, 7],
  82,
  106,
  152,
  c,
  [66, 43],
  11,
  18,
  c,
  [660, 6],
  11,
  18,
  11,
  18,
  11,
  18,
  8,
  c,
  [417, 21],
  c,
  [484, 46],
  41,
  44,
  45,
  1,
  28,
  75,
  149,
  28,
  c,
  [470, 3],
  c,
  [308, 5],
  c,
  [2353, 90],
  c,
  [43, 82],
  c,
  [643, 21],
  42,
  30,
  45,
  31,
  34,
  c,
  [420, 15],
  c,
  [301, 3],
  s,
  [11, 3],
  41,
  43,
  44,
  c,
  [1188, 7],
  c,
  [306, 58],
  c,
  [64, 64],
  30,
  30,
  c,
  [45, 45],
  c,
  [1408, 42],
  11,
  c,
  [154, 21],
  c,
  [243, 25],
  41,
  45,
  46,
  c,
  [1541, 41],
  c,
  [135, 37],
  c,
  [813, 7],
  41,
  43,
  c,
  [112, 23],
  c,
  [137, 3],
  c,
  [71, 22],
  30,
  c,
  [51, 24],
  c,
  [47, 21],
  c,
  [45, 3],
  30
]),
  type: u([
  s,
  [2, 3],
  s,
  [0, 12],
  1,
  s,
  [2, 4],
  s,
  [0, 10],
  c,
  [13, 11],
  s,
  [2, 9],
  c,
  [17, 10],
  c,
  [36, 22],
  c,
  [7, 3],
  0,
  2,
  c,
  [4, 4],
  c,
  [45, 11],
  c,
  [10, 6],
  c,
  [6, 9],
  s,
  [2, 58],
  c,
  [69, 7],
  c,
  [92, 10],
  c,
  [104, 4],
  c,
  [142, 10],
  c,
  [39, 13],
  c,
  [203, 14],
  c,
  [198, 14],
  c,
  [33, 32],
  c,
  [91, 8],
  c,
  [11, 8],
  c,
  [187, 10],
  c,
  [34, 7],
  c,
  [55, 21],
  c,
  [20, 18],
  c,
  [317, 16],
  c,
  [66, 7],
  c,
  [108, 17],
  c,
  [164, 22],
  c,
  [22, 20],
  c,
  [53, 23],
  c,
  [43, 26],
  c,
  [103, 18],
  c,
  [120, 47],
  c,
  [83, 15],
  c,
  [272, 62],
  c,
  [46, 44],
  c,
  [26, 23],
  c,
  [47, 22],
  c,
  [116, 26],
  c,
  [258, 9],
  c,
  [504, 12],
  c,
  [332, 16],
  c,
  [347, 25],
  c,
  [135, 7],
  c,
  [696, 26],
  c,
  [411, 59],
  c,
  [43, 40],
  c,
  [76, 37],
  c,
  [147, 28],
  c,
  [861, 43],
  c,
  [29, 27],
  c,
  [646, 60],
  c,
  [128, 37],
  c,
  [1044, 55],
  s,
  [2, 106],
  c,
  [220, 24],
  s,
  [0, 29],
  c,
  [1195, 9],
  c,
  [556, 59],
  c,
  [660, 21],
  c,
  [667, 9],
  c,
  [934, 13],
  c,
  [913, 46],
  c,
  [41, 57],
  c,
  [193, 22],
  c,
  [62, 61],
  c,
  [921, 25],
  c,
  [317, 7],
  c,
  [829, 93],
  c,
  [715, 41],
  c,
  [15, 29],
  c,
  [759, 20],
  c,
  [79, 18],
  c,
  [576, 49],
  c,
  [36, 17],
  c,
  [1494, 19],
  c,
  [26, 10],
  c,
  [28, 32],
  c,
  [1953, 8],
  c,
  [16, 9],
  c,
  [346, 45],
  c,
  [45, 26],
  c,
  [2021, 10],
  c,
  [84, 10],
  c,
  [544, 86],
  c,
  [1130, 39],
  c,
  [1183, 55],
  c,
  [1449, 50],
  c,
  [82, 23],
  c,
  [128, 34],
  c,
  [736, 8],
  c,
  [1410, 31],
  c,
  [401, 30],
  c,
  [367, 4],
  c,
  [253, 62],
  c,
  [44, 30],
  c,
  [2175, 61],
  c,
  [188, 34],
  c,
  [551, 23],
  c,
  [1062, 41],
  c,
  [1001, 45],
  s,
  [0, 30],
  c,
  [829, 11],
  c,
  [402, 11],
  c,
  [262, 13],
  c,
  [13, 12],
  c,
  [1097, 59],
  c,
  [265, 18],
  c,
  [2847, 26],
  c,
  [1911, 65],
  c,
  [448, 52],
  c,
  [1255, 17],
  c,
  [484, 64],
  c,
  [2998, 11],
  c,
  [2353, 97],
  c,
  [43, 81],
  c,
  [356, 33],
  c,
  [852, 33],
  c,
  [115, 63],
  c,
  [515, 61],
  c,
  [45, 36],
  c,
  [1408, 43],
  c,
  [725, 41],
  c,
  [24, 29],
  c,
  [135, 57],
  c,
  [88, 31],
  c,
  [432, 30],
  c,
  [1884, 35],
  c,
  [21, 5]
]),
  state: u([
  1,
  2,
  5,
  4,
  3,
  6,
  10,
  11,
  12,
  8,
  13,
  14,
  19,
  17,
  16,
  c,
  [10, 7],
  20,
  22,
  c,
  [8, 6],
  28,
  30,
  29,
  31,
  33,
  37,
  36,
  35,
  41,
  44,
  45,
  40,
  42,
  43,
  48,
  c,
  [22, 7],
  53,
  52,
  54,
  55,
  56,
  63,
  60,
  62,
  37,
  36,
  61,
  35,
  64,
  67,
  68,
  69,
  67,
  68,
  76,
  75,
  80,
  79,
  82,
  81,
  83,
  87,
  88,
  89,
  91,
  c,
  [46, 3],
  92,
  c,
  [4, 3],
  97,
  68,
  99,
  100,
  102,
  13,
  14,
  103,
  104,
  110,
  111,
  105,
  106,
  42,
  43,
  101,
  98,
  108,
  97,
  68,
  120,
  c,
  [18, 13],
  119,
  108,
  126,
  127,
  129,
  128,
  130,
  132,
  133,
  87,
  88,
  136,
  87,
  88,
  142,
  145,
  c,
  [29, 13],
  108,
  146,
  c,
  [14, 13],
  147,
  148,
  87,
  150,
  44,
  45,
  88,
  154,
  158,
  157,
  37,
  36,
  156,
  35,
  160,
  c,
  [43, 13],
  159,
  108,
  162,
  c,
  [44, 13],
  s,
  [163, 5, 1],
  s,
  [180, 4, 1],
  177,
  168,
  169,
  184,
  190,
  189,
  191,
  196,
  197,
  176,
  175,
  185,
  188,
  45,
  174,
  186,
  43,
  173,
  193,
  205,
  206,
  s,
  [208, 5, 1],
  196,
  197,
  207,
  193,
  214,
  c,
  [69, 13],
  213,
  c,
  [69, 15],
  216,
  c,
  [111, 3],
  223,
  c,
  [4, 3],
  224,
  c,
  [154, 3],
  229,
  c,
  [154, 14],
  230,
  c,
  [14, 13],
  142,
  233,
  c,
  [30, 14],
  234,
  c,
  [14, 13],
  148,
  87,
  88,
  235,
  c,
  [32, 14],
  236,
  c,
  [14, 13],
  237,
  88,
  c,
  [119, 14],
  142,
  243,
  242,
  247,
  c,
  [118, 3],
  c,
  [21, 14],
  249,
  42,
  43,
  251,
  252,
  254,
  255,
  270,
  c,
  [216, 27],
  271,
  c,
  [28, 27],
  272,
  c,
  [24, 4],
  274,
  c,
  [22, 6],
  275,
  277,
  c,
  [22, 3],
  276,
  c,
  [22, 4],
  280,
  279,
  287,
  286,
  291,
  290,
  292,
  293,
  88,
  294,
  c,
  [59, 27],
  296,
  298,
  304,
  306,
  303,
  44,
  45,
  305,
  42,
  43,
  310,
  311,
  c,
  [39, 27],
  313,
  314,
  317,
  316,
  315,
  318,
  88,
  319,
  c,
  [35, 27],
  c,
  [210, 14],
  322,
  44,
  45,
  324,
  129,
  128,
  325,
  c,
  [234, 3],
  326,
  c,
  [4, 3],
  142,
  330,
  c,
  [291, 14],
  331,
  c,
  [14, 13],
  332,
  c,
  [29, 14],
  333,
  c,
  [14, 13],
  c,
  [87, 14],
  336,
  c,
  [43, 14],
  337,
  c,
  [43, 27],
  c,
  [14, 14],
  c,
  [649, 4],
  345,
  42,
  43,
  348,
  349,
  c,
  [194, 27],
  350,
  c,
  [327, 21],
  354,
  c,
  [50, 27],
  291,
  290,
  287,
  286,
  280,
  279,
  360,
  357,
  364,
  362,
  356,
  367,
  366,
  361,
  363,
  365,
  150,
  188,
  45,
  368,
  186,
  43,
  358,
  369,
  371,
  c,
  [332, 28],
  364,
  362,
  372,
  c,
  [45, 5],
  373,
  c,
  [43, 4],
  375,
  c,
  [61, 4],
  376,
  c,
  [61, 12],
  377,
  378,
  c,
  [19, 4],
  379,
  c,
  [19, 12],
  380,
  381,
  s,
  [384, 9, 1],
  395,
  c,
  [89, 27],
  298,
  404,
  c,
  [763, 9],
  405,
  44,
  45,
  408,
  407,
  411,
  410,
  412,
  c,
  [303, 14],
  413,
  c,
  [303, 41],
  c,
  [14, 14],
  426,
  c,
  [117, 27],
  431,
  430,
  427,
  255,
  432,
  c,
  [32, 27],
  360,
  357,
  c,
  [512, 3],
  437,
  c,
  [324, 33],
  442,
  c,
  [34, 27],
  443,
  88,
  445,
  449,
  c,
  [31, 27],
  451,
  c,
  [28, 27],
  452,
  c,
  [695, 3],
  453,
  c,
  [32, 27],
  454,
  c,
  [28, 27],
  455,
  88,
  456,
  c,
  [319, 14],
  460,
  293,
  c,
  [972, 15],
  471,
  c,
  [561, 21],
  360,
  473,
  c,
  [85, 6],
  357,
  c,
  [86, 13],
  474,
  c,
  [86, 7],
  475,
  476,
  431,
  430,
  478,
  c,
  [275, 3],
  479,
  c,
  [4, 3],
  481,
  c,
  [4, 3],
  482,
  c,
  [4, 3],
  483,
  c,
  [4, 3],
  485,
  c,
  [859, 35],
  490,
  c,
  [119, 6],
  492,
  13,
  14,
  494,
  13,
  14,
  431,
  430,
  499,
  c,
  [51, 27],
  243,
  296,
  242,
  501,
  c,
  [438, 29],
  511,
  c,
  [220, 14],
  512,
  c,
  [45, 27],
  513,
  88,
  516,
  515,
  521,
  c,
  [163, 3],
  522,
  c,
  [36, 27],
  523,
  c,
  [28, 27],
  524,
  c,
  [28, 27],
  525,
  c,
  [1106, 41],
  431,
  430,
  541,
  c,
  [179, 14],
  542,
  c,
  [59, 27],
  543,
  c,
  [43, 14],
  544,
  c,
  [43, 27],
  547,
  c,
  [130, 41],
  c,
  [14, 14],
  555,
  c,
  [99, 14],
  558,
  c,
  [15, 14],
  560,
  c,
  [15, 14],
  c,
  [876, 36],
  566,
  c,
  [15, 6],
  568,
  c,
  [58, 28],
  576,
  c,
  [29, 28]
]),
  mode: u([
  s,
  [1, 26],
  2,
  2,
  c,
  [17, 17],
  s,
  [2, 8],
  c,
  [11, 11],
  s,
  [2, 18],
  c,
  [29, 19],
  1,
  c,
  [75, 3],
  c,
  [78, 14],
  c,
  [93, 8],
  c,
  [7, 8],
  c,
  [16, 7],
  c,
  [115, 16],
  c,
  [158, 28],
  c,
  [105, 8],
  c,
  [76, 7],
  c,
  [59, 8],
  c,
  [67, 20],
  c,
  [149, 10],
  c,
  [23, 14],
  c,
  [51, 16],
  c,
  [77, 9],
  s,
  [1, 63],
  c,
  [262, 13],
  c,
  [123, 9],
  c,
  [129, 7],
  c,
  [175, 14],
  c,
  [44, 6],
  c,
  [16, 7],
  c,
  [163, 18],
  c,
  [109, 37],
  c,
  [224, 11],
  c,
  [398, 22],
  c,
  [403, 21],
  c,
  [27, 50],
  c,
  [231, 19],
  c,
  [498, 26],
  s,
  [2, 31],
  c,
  [33, 33],
  c,
  [36, 21],
  c,
  [231, 30],
  c,
  [25, 62],
  c,
  [479, 46],
  c,
  [684, 44],
  c,
  [722, 49],
  c,
  [63, 54],
  c,
  [146, 3],
  c,
  [622, 12],
  c,
  [13, 16],
  c,
  [251, 16],
  s,
  [1, 97],
  c,
  [728, 5],
  c,
  [272, 60],
  c,
  [792, 7],
  c,
  [1051, 7],
  c,
  [180, 48],
  c,
  [420, 8],
  c,
  [135, 63],
  c,
  [295, 98],
  c,
  [428, 12],
  c,
  [61, 77],
  c,
  [504, 16],
  c,
  [96, 23],
  c,
  [117, 33],
  c,
  [320, 79],
  c,
  [241, 61],
  s,
  [1, 126]
]),
  goto: u([
  15,
  9,
  7,
  18,
  c,
  [4, 3],
  21,
  15,
  7,
  s,
  [23, 5, 1],
  32,
  34,
  38,
  39,
  46,
  47,
  49,
  15,
  7,
  50,
  51,
  201,
  201,
  39,
  34,
  39,
  38,
  57,
  58,
  59,
  38,
  39,
  65,
  66,
  38,
  70,
  71,
  38,
  s,
  [191, 10],
  72,
  s,
  [191, 18],
  s,
  [186, 10],
  73,
  s,
  [186, 18],
  74,
  203,
  77,
  78,
  209,
  77,
  86,
  85,
  77,
  84,
  38,
  90,
  38,
  39,
  38,
  39,
  93,
  94,
  195,
  195,
  59,
  95,
  96,
  38,
  15,
  114,
  224,
  107,
  109,
  112,
  113,
  116,
  115,
  s,
  [85, 3],
  117,
  118,
  c,
  [15, 3],
  228,
  c,
  [15, 4],
  s,
  [121, 5, 1],
  38,
  39,
  90,
  131,
  86,
  135,
  134,
  38,
  139,
  138,
  137,
  38,
  144,
  141,
  140,
  143,
  15,
  114,
  c,
  [27, 4],
  c,
  [6, 6],
  139,
  149,
  151,
  152,
  s,
  [66, 3],
  153,
  s,
  [66, 4],
  193,
  193,
  155,
  193,
  193,
  38,
  39,
  15,
  114,
  222,
  c,
  [26, 4],
  161,
  15,
  114,
  225,
  c,
  [8, 4],
  195,
  170,
  194,
  192,
  172,
  187,
  171,
  178,
  179,
  90,
  198,
  199,
  200,
  46,
  47,
  191,
  191,
  201,
  s,
  [191, 7],
  202,
  203,
  204,
  38,
  195,
  194,
  107,
  c,
  [23, 4],
  15,
  114,
  226,
  c,
  [43, 4],
  215,
  15,
  114,
  229,
  c,
  [8, 4],
  217,
  152,
  219,
  218,
  50,
  50,
  220,
  52,
  52,
  221,
  222,
  217,
  152,
  139,
  226,
  225,
  38,
  144,
  228,
  227,
  c,
  [118, 13],
  144,
  232,
  231,
  c,
  [134, 15],
  c,
  [177, 3],
  c,
  [15, 10],
  38,
  15,
  238,
  c,
  [7, 4],
  239,
  240,
  144,
  241,
  143,
  s,
  [213, 3],
  244,
  s,
  [213, 6],
  s,
  [191, 3],
  245,
  c,
  [284, 7],
  246,
  s,
  [186, 5],
  217,
  152,
  197,
  197,
  59,
  248,
  15,
  114,
  223,
  c,
  [45, 4],
  112,
  113,
  253,
  250,
  s,
  [110, 3],
  265,
  110,
  258,
  256,
  110,
  262,
  263,
  264,
  268,
  s,
  [110, 5],
  257,
  259,
  260,
  261,
  266,
  267,
  269,
  c,
  [195, 15],
  c,
  [15, 16],
  273,
  194,
  192,
  187,
  c,
  [11, 6],
  242,
  242,
  281,
  242,
  242,
  278,
  s,
  [242, 20],
  s,
  [243, 4],
  282,
  s,
  [243, 4],
  283,
  s,
  [243, 16],
  240,
  240,
  281,
  240,
  240,
  284,
  s,
  [240, 4],
  285,
  s,
  [240, 16],
  238,
  238,
  281,
  238,
  238,
  288,
  s,
  [238, 4],
  289,
  s,
  [238, 16],
  38,
  c,
  [133, 15],
  s,
  [237, 8],
  295,
  s,
  [237, 16],
  241,
  241,
  281,
  s,
  [241, 22],
  s,
  [187, 10],
  297,
  s,
  [187, 16],
  s,
  [181, 19],
  38,
  s,
  [181, 7],
  s,
  [182, 10],
  299,
  s,
  [182, 16],
  s,
  [249, 8],
  300,
  s,
  [249, 16],
  s,
  [248, 8],
  301,
  s,
  [248, 16],
  s,
  [250, 8],
  302,
  s,
  [250, 16],
  307,
  308,
  c,
  [358, 5],
  309,
  c,
  [226, 12],
  312,
  90,
  38,
  121,
  123,
  c,
  [247, 16],
  320,
  s,
  [84, 3],
  321,
  15,
  114,
  227,
  c,
  [566, 6],
  323,
  245,
  38,
  39,
  217,
  152,
  217,
  152,
  327,
  144,
  329,
  328,
  c,
  [544, 13],
  c,
  [6, 13],
  334,
  c,
  [6, 4],
  335,
  c,
  [19, 13],
  338,
  c,
  [6, 4],
  339,
  15,
  340,
  c,
  [7, 4],
  341,
  342,
  203,
  204,
  s,
  [214, 3],
  343,
  s,
  [214, 6],
  344,
  38,
  39,
  122,
  124,
  112,
  113,
  346,
  253,
  347,
  c,
  [502, 16],
  351,
  c,
  [502, 9],
  352,
  353,
  c,
  [28, 15],
  c,
  [440, 4],
  355,
  c,
  [437, 8],
  c,
  [480, 4],
  355,
  c,
  [477, 8],
  c,
  [545, 4],
  355,
  c,
  [531, 11],
  c,
  [527, 7],
  195,
  359,
  194,
  187,
  90,
  46,
  47,
  281,
  195,
  170,
  370,
  c,
  [101, 14],
  c,
  [24, 5],
  374,
  38,
  c,
  [32, 7],
  38,
  281,
  c,
  [9, 9],
  383,
  382,
  s,
  [38, 6],
  281,
  394,
  355,
  393,
  c,
  [126, 15],
  38,
  397,
  396,
  398,
  399,
  400,
  402,
  401,
  403,
  c,
  [861, 7],
  217,
  152,
  406,
  409,
  205,
  409,
  211,
  c,
  [241, 13],
  414,
  c,
  [6, 4],
  415,
  15,
  416,
  c,
  [7, 4],
  417,
  418,
  203,
  204,
  15,
  419,
  c,
  [10, 4],
  420,
  421,
  203,
  204,
  422,
  203,
  204,
  423,
  424,
  425,
  c,
  [83, 15],
  113,
  113,
  281,
  113,
  265,
  428,
  113,
  258,
  256,
  113,
  429,
  c,
  [796, 4],
  s,
  [113, 5],
  c,
  [796, 22],
  433,
  217,
  152,
  434,
  436,
  435,
  c,
  [21, 15],
  302,
  244,
  281,
  355,
  289,
  245,
  281,
  355,
  285,
  246,
  295,
  247,
  283,
  300,
  301,
  281,
  355,
  397,
  438,
  439,
  299,
  73,
  440,
  441,
  c,
  [185, 16],
  444,
  394,
  447,
  446,
  195,
  170,
  448,
  c,
  [21, 13],
  450,
  c,
  [37, 15],
  90,
  c,
  [515, 16],
  c,
  [69, 16],
  c,
  [226, 6],
  457,
  458,
  459,
  38,
  461,
  15,
  462,
  c,
  [11, 4],
  463,
  464,
  203,
  204,
  465,
  203,
  204,
  466,
  467,
  203,
  204,
  468,
  469,
  470,
  195,
  472,
  c,
  [440, 9],
  c,
  [58, 16],
  281,
  477,
  120,
  120,
  281,
  120,
  355,
  120,
  120,
  429,
  s,
  [120, 5],
  c,
  [586, 4],
  480,
  c,
  [5, 4],
  217,
  152,
  447,
  484,
  c,
  [44, 15],
  486,
  487,
  489,
  488,
  15,
  491,
  c,
  [331, 5],
  383,
  493,
  15,
  495,
  203,
  204,
  496,
  497,
  498,
  116,
  116,
  281,
  116,
  355,
  116,
  116,
  429,
  s,
  [116, 5],
  c,
  [48, 15],
  500,
  213,
  281,
  241,
  244,
  213,
  s,
  [241, 14],
  c,
  [35, 15],
  502,
  503,
  281,
  355,
  429,
  165,
  s,
  [504, 7, 1],
  c,
  [197, 6],
  c,
  [161, 16],
  203,
  514,
  204,
  207,
  s,
  [517, 4, 1],
  217,
  152,
  c,
  [1170, 31],
  c,
  [15, 29],
  15,
  526,
  c,
  [92, 4],
  s,
  [527, 6, 1],
  118,
  118,
  281,
  118,
  355,
  118,
  118,
  429,
  s,
  [118, 5],
  534,
  533,
  s,
  [535, 4, 1],
  203,
  539,
  540,
  204,
  c,
  [127, 21],
  c,
  [21, 21],
  545,
  546,
  c,
  [17, 15],
  548,
  549,
  15,
  550,
  c,
  [40, 4],
  551,
  15,
  552,
  c,
  [7, 4],
  553,
  554,
  c,
  [55, 6],
  203,
  556,
  557,
  c,
  [86, 7],
  203,
  204,
  559,
  c,
  [645, 7],
  561,
  c,
  [6, 4],
  562,
  563,
  15,
  564,
  c,
  [8, 4],
  565,
  c,
  [335, 6],
  203,
  567,
  c,
  [39, 8],
  569,
  570,
  204,
  571,
  15,
  572,
  c,
  [11, 4],
  573,
  574,
  203,
  575,
  c,
  [22, 7],
  577,
  15,
  578,
  c,
  [29, 5],
  579,
  204,
  580
])
}),
defaultActions: bda({
  idx: u([
  5,
  6,
  8,
  s,
  [10, 5, 1],
  18,
  19,
  21,
  22,
  23,
  29,
  30,
  31,
  s,
  [35, 5, 1],
  s,
  [42, 4, 1],
  49,
  50,
  51,
  53,
  61,
  63,
  66,
  67,
  71,
  74,
  76,
  80,
  87,
  s,
  [90, 4, 1],
  96,
  97,
  s,
  [100, 7, 1],
  s,
  [108, 4, 1],
  118,
  s,
  [121, 4, 1],
  127,
  143,
  144,
  149,
  154,
  155,
  156,
  158,
  162,
  164,
  165,
  166,
  168,
  169,
  173,
  180,
  181,
  182,
  184,
  193,
  s,
  [196, 5, 1],
  s,
  [206, 7, 1],
  218,
  222,
  237,
  s,
  [239, 4, 1],
  247,
  250,
  252,
  s,
  [255, 15, 1],
  272,
  280,
  287,
  291,
  293,
  294,
  296,
  298,
  305,
  306,
  309,
  311,
  312,
  314,
  316,
  317,
  324,
  325,
  326,
  335,
  339,
  341,
  344,
  s,
  [346, 5, 1],
  358,
  360,
  369,
  370,
  375,
  377,
  378,
  380,
  381,
  s,
  [384, 6, 1],
  393,
  396,
  398,
  404,
  406,
  408,
  411,
  415,
  417,
  420,
  423,
  424,
  425,
  431,
  435,
  438,
  442,
  443,
  s,
  [444, 4, 2],
  451,
  452,
  453,
  457,
  459,
  463,
  466,
  468,
  469,
  471,
  475,
  476,
  479,
  484,
  486,
  490,
  493,
  496,
  497,
  498,
  501,
  s,
  [502, 5, 2],
  515,
  516,
  519,
  s,
  [534, 5, 1],
  545,
  546,
  548,
  554,
  562,
  565,
  566,
  571,
  573,
  577,
  580
]),
  goto: u([
  8,
  23,
  21,
  25,
  26,
  27,
  70,
  71,
  4,
  9,
  6,
  24,
  7,
  11,
  12,
  13,
  19,
  199,
  200,
  191,
  186,
  187,
  188,
  182,
  183,
  2,
  3,
  5,
  202,
  17,
  196,
  75,
  80,
  79,
  1,
  204,
  210,
  57,
  176,
  15,
  14,
  16,
  74,
  81,
  67,
  69,
  s,
  [217, 5, 1],
  92,
  102,
  232,
  233,
  78,
  189,
  184,
  190,
  185,
  48,
  215,
  216,
  60,
  10,
  194,
  18,
  198,
  68,
  107,
  108,
  109,
  111,
  112,
  121,
  234,
  235,
  236,
  239,
  168,
  251,
  252,
  177,
  178,
  179,
  83,
  86,
  230,
  231,
  248,
  249,
  250,
  47,
  28,
  58,
  45,
  46,
  59,
  54,
  65,
  87,
  89,
  192,
  s,
  [255, 14, 1],
  119,
  137,
  139,
  141,
  63,
  167,
  135,
  180,
  126,
  127,
  174,
  105,
  169,
  171,
  253,
  254,
  49,
  51,
  53,
  41,
  43,
  44,
  56,
  73,
  88,
  90,
  91,
  115,
  164,
  130,
  136,
  103,
  146,
  147,
  138,
  153,
  140,
  151,
  144,
  145,
  148,
  149,
  150,
  125,
  175,
  170,
  82,
  77,
  206,
  212,
  39,
  40,
  42,
  37,
  55,
  72,
  143,
  129,
  104,
  166,
  64,
  122,
  124,
  132,
  128,
  106,
  172,
  173,
  76,
  61,
  38,
  33,
  35,
  36,
  117,
  152,
  142,
  131,
  123,
  133,
  99,
  62,
  31,
  32,
  34,
  114,
  s,
  [154, 4, 2],
  134,
  20,
  208,
  30,
  163,
  s,
  [155, 4, 2],
  22,
  29,
  93,
  162,
  94,
  100,
  101,
  96,
  95,
  97,
  98
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable && typeof this.trace === 'function') {
        this.trace(str);
        hash.destroy(); // destroy... well, *almost*!
    } else {
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack
    var lstack = new Array(128);        // location stack
    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks
    var yyloc;

    var yylineno;


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 581 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function copy_yylloc(loc) {
        var rv = shallow_copy(loc);
        if (rv && rv.range) {
            rv.range = rv.range.slice(0);
        }
        return rv;
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = shallow_copy(l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        rv = shallow_copy(l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: copy_yylloc(lexer.yylloc),
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function lex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        yyloc = lexer.yylloc;
        lstack[sp] = yyloc;
        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p, this.JisonParserError);
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = copy_yylloc(lexer.yylloc);
                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;


                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;






                




                continue;

            // reduce:
            case 2:
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }

                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = this.parseError(p.errStr, p, this.JisonParserError);
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;


/* lexer generated by jison-lex 0.6.1-203 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... true
//   location assignment: ............. true
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.options.trackPosition) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        var pre = this.match;
        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).' + pos_str,
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      var error_size = loc.last_line - loc.first_line;
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');

      //var show_context = (error_size < 5 || context_loc);
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));

      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');

        if (lno === loc.first_line) {
          var offset = loc.first_column + 2;

          var len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );

          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno === loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, loc.last_column + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno > loc.first_line && lno < loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, line.length + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;

        console.log('clip off: ', {
          start: clip_start,
          end: clip_end,
          len: clip_end - clip_start + 1,
          arr: nonempty_line_indexes,
          rv
        });

        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var pos_str = '';

          if (typeof this.showPosition === 'function') {
            pos_str = this.showPosition();

            if (pos_str && pos_str[0] !== '\n') {
              pos_str = '\n' + pos_str;
            }
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!' + pos_str,
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.' + pos_str,
          this.options.lexerErrorsAreRecoverable
        );

        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time:
          if (!this.match.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.options.pre_lex === 'function') {
        r = this.options.pre_lex.call(this);
      }

      while (!r) {
        r = this.next();
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      flex: true,
      trackPosition: true,
      parseActionsUseYYMERGELOCATIONINFO: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: * */
        /*! Rule::       \s+ */
        return;

        break;

      case 5:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 6:
        /*! Conditions:: INITIAL */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 7:
        /*! Conditions:: INITIAL */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 8:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 17:
        /*! Conditions:: TAG */
        /*! Rule::       \/> */
        this.popState();

        return 38;
        break;

      case 19:
        /*! Conditions:: TAG */
        /*! Rule::       > */
        this.begin('CHILDREN');

        return 14;
        break;

      case 20:
        /*! Conditions:: TAG */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 23:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 24:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 25:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 26:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <\/ */
        this.begin('TAG');

        return 37;
        break;

      case 27:
        /*! Conditions:: CHILDREN */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 58:
        /*! Conditions:: CONTROL */
        /*! Rule::       = */
        this.popState();

        this.begin('CONTROL_CHILD');
        return 9;
        break;

      case 61:
        /*! Conditions:: CONTROL */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 64:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 65:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 66:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 84:
        /*! Conditions:: EXPRESSION */
        /*! Rule::       \}\} */
        this.popState();

        return 40;
        break;

      case 87:
        /*! Conditions:: COMMENT */
        /*! Rule::       (.|\r|\n)*?--> */
        this.popState();

        return;
        break;

      case 116:
        /*! Conditions:: INITIAL */
        /*! Rule::       . */
        console.log('', yy_.yytext);

        /* `flex` lexing mode: the last resort rule! */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       import */
      1: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       from */
      2: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       using */
      3: 'USING',

      /*! Conditions:: INITIAL */
      /*! Rule::       as */
      4: 27,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Constructor} */
      9: 56,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Identifier} */
      10: 55,

      /*! Conditions:: INITIAL */
      /*! Rule::       \{ */
      11: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \} */
      12: 5,

      /*! Conditions:: TAG */
      /*! Rule::       true */
      13: 53,

      /*! Conditions:: TAG */
      /*! Rule::       false */
      14: 54,

      /*! Conditions:: TAG */
      /*! Rule::       {Constructor} */
      15: 56,

      /*! Conditions:: TAG */
      /*! Rule::       {Identifier} */
      16: 55,

      /*! Conditions:: TAG */
      /*! Rule::       \/ */
      18: 'NOSE',

      /*! Conditions:: TAG */
      /*! Rule::       \{ */
      21: 4,

      /*! Conditions:: TAG */
      /*! Rule::       \} */
      22: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \{ */
      28: 4,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \} */
      29: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       [^/<>{%}]+ */
      30: 47,

      /*! Conditions:: CONTROL */
      /*! Rule::       main */
      31: 29,

      /*! Conditions:: CONTROL */
      /*! Rule::       endmain */
      32: 31,

      /*! Conditions:: CONTROL */
      /*! Rule::       macro */
      33: 'MACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       endmacro */
      34: 'ENDMACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       for */
      35: 41,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfor */
      36: 43,

      /*! Conditions:: CONTROL */
      /*! Rule::       if */
      37: 45,

      /*! Conditions:: CONTROL */
      /*! Rule::       endif */
      38: 46,

      /*! Conditions:: CONTROL */
      /*! Rule::       else */
      39: 44,

      /*! Conditions:: CONTROL */
      /*! Rule::       elseif */
      40: 'ELSEIF',

      /*! Conditions:: CONTROL */
      /*! Rule::       in */
      41: 42,

      /*! Conditions:: CONTROL */
      /*! Rule::       case */
      42: 'CASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       endcase */
      43: 'ENDCASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       export */
      44: 32,

      /*! Conditions:: CONTROL */
      /*! Rule::       from */
      45: 26,

      /*! Conditions:: CONTROL */
      /*! Rule::       view */
      46: 33,

      /*! Conditions:: CONTROL */
      /*! Rule::       using */
      47: 'USING',

      /*! Conditions:: CONTROL */
      /*! Rule::       endview */
      48: 34,

      /*! Conditions:: CONTROL */
      /*! Rule::       instanceof */
      49: 64,

      /*! Conditions:: CONTROL */
      /*! Rule::       this */
      50: 'THIS',

      /*! Conditions:: CONTROL */
      /*! Rule::       fun */
      51: 35,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfun */
      52: 36,

      /*! Conditions:: CONTROL */
      /*! Rule::       as */
      53: 27,

      /*! Conditions:: CONTROL */
      /*! Rule::       :: */
      54: '::',

      /*! Conditions:: CONTROL */
      /*! Rule::       @ */
      55: 19,

      /*! Conditions:: CONTROL */
      /*! Rule::       \(\) */
      56: '()',

      /*! Conditions:: CONTROL */
      /*! Rule::       -> */
      57: 57,

      /*! Conditions:: CONTROL */
      /*! Rule::       {Constructor} */
      59: 56,

      /*! Conditions:: CONTROL */
      /*! Rule::       {Identifier} */
      60: 55,

      /*! Conditions:: CONTROL */
      /*! Rule::       \{ */
      62: 4,

      /*! Conditions:: CONTROL */
      /*! Rule::       \} */
      63: 5,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Constructor} */
      67: 56,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Identifier} */
      68: 55,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \{ */
      69: 4,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \} */
      70: 5,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \| */
      71: 15,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       => */
      72: 50,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       -> */
      73: 57,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       @ */
      74: 19,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       instanceof */
      75: 64,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       true */
      76: 53,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       false */
      77: 54,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       if */
      78: 45,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       then */
      79: 48,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       else */
      80: 44,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       as */
      81: 27,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Constructor} */
      82: 56,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Identifier} */
      83: 55,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \{ */
      85: 4,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \} */
      86: 5,

      /*! Conditions:: * */
      /*! Rule::       {NumberLiteral} */
      88: 52,

      /*! Conditions:: * */
      /*! Rule::       {StringLiteral} */
      89: 51,

      /*! Conditions:: * */
      /*! Rule::       > */
      90: 14,

      /*! Conditions:: * */
      /*! Rule::       < */
      91: 13,

      /*! Conditions:: * */
      /*! Rule::       \( */
      92: 7,

      /*! Conditions:: * */
      /*! Rule::       \) */
      93: 8,

      /*! Conditions:: * */
      /*! Rule::       \[ */
      94: 10,

      /*! Conditions:: * */
      /*! Rule::       \] */
      95: 11,

      /*! Conditions:: * */
      /*! Rule::       ; */
      96: 20,

      /*! Conditions:: * */
      /*! Rule::       : */
      97: 12,

      /*! Conditions:: * */
      /*! Rule::       = */
      98: 9,

      /*! Conditions:: * */
      /*! Rule::       == */
      99: 60,

      /*! Conditions:: * */
      /*! Rule::       != */
      100: 61,

      /*! Conditions:: * */
      /*! Rule::       >= */
      101: 58,

      /*! Conditions:: * */
      /*! Rule::       <= */
      102: 59,

      /*! Conditions:: * */
      /*! Rule::       \+ */
      103: 21,

      /*! Conditions:: * */
      /*! Rule::       - */
      104: 23,

      /*! Conditions:: * */
      /*! Rule::       \* */
      105: 3,

      /*! Conditions:: * */
      /*! Rule::       \/ */
      106: 22,

      /*! Conditions:: * */
      /*! Rule::       \\ */
      107: 49,

      /*! Conditions:: * */
      /*! Rule::       && */
      108: 62,

      /*! Conditions:: * */
      /*! Rule::       \|\| */
      109: 63,

      /*! Conditions:: * */
      /*! Rule::       \^ */
      110: 24,

      /*! Conditions:: * */
      /*! Rule::       ! */
      111: 16,

      /*! Conditions:: * */
      /*! Rule::       , */
      112: 6,

      /*! Conditions:: * */
      /*! Rule::       \? */
      113: 18,

      /*! Conditions:: * */
      /*! Rule::       \. */
      114: 17,

      /*! Conditions:: * */
      /*! Rule::       $ */
      115: 1
    },

    rules: [
      /*   0: */  /^(?:\s+)/,
      /*   1: */  /^(?:import)/,
      /*   2: */  /^(?:from)/,
      /*   3: */  /^(?:using)/,
      /*   4: */  /^(?:as)/,
      /*   5: */  /^(?:\{%)/,
      /*   6: */  /^(?:<!--)/,
      /*   7: */  /^(?:<)/,
      /*   8: */  /^(?:\{\{)/,
      /*   9: */  /^(?:([A-Z][\w$\-]*))/,
      /*  10: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  11: */  /^(?:\{)/,
      /*  12: */  /^(?:\})/,
      /*  13: */  /^(?:true)/,
      /*  14: */  /^(?:false)/,
      /*  15: */  /^(?:([A-Z][\w$\-]*))/,
      /*  16: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  17: */  /^(?:\/>)/,
      /*  18: */  /^(?:\/)/,
      /*  19: */  /^(?:>)/,
      /*  20: */  /^(?:\{\{)/,
      /*  21: */  /^(?:\{)/,
      /*  22: */  /^(?:\})/,
      /*  23: */  /^(?:\{\{)/,
      /*  24: */  /^(?:\{%)/,
      /*  25: */  /^(?:<!--)/,
      /*  26: */  /^(?:<\/)/,
      /*  27: */  /^(?:<)/,
      /*  28: */  /^(?:\{)/,
      /*  29: */  /^(?:\})/,
      /*  30: */  /^(?:[^\/<>{%}]+)/,
      /*  31: */  /^(?:main)/,
      /*  32: */  /^(?:endmain)/,
      /*  33: */  /^(?:macro)/,
      /*  34: */  /^(?:endmacro)/,
      /*  35: */  /^(?:for)/,
      /*  36: */  /^(?:endfor)/,
      /*  37: */  /^(?:if)/,
      /*  38: */  /^(?:endif)/,
      /*  39: */  /^(?:else)/,
      /*  40: */  /^(?:elseif)/,
      /*  41: */  /^(?:in)/,
      /*  42: */  /^(?:case)/,
      /*  43: */  /^(?:endcase)/,
      /*  44: */  /^(?:export)/,
      /*  45: */  /^(?:from)/,
      /*  46: */  /^(?:view)/,
      /*  47: */  /^(?:using)/,
      /*  48: */  /^(?:endview)/,
      /*  49: */  /^(?:instanceof)/,
      /*  50: */  /^(?:this)/,
      /*  51: */  /^(?:fun)/,
      /*  52: */  /^(?:endfun)/,
      /*  53: */  /^(?:as)/,
      /*  54: */  /^(?:::)/,
      /*  55: */  /^(?:@)/,
      /*  56: */  /^(?:\(\))/,
      /*  57: */  /^(?:->)/,
      /*  58: */  /^(?:=)/,
      /*  59: */  /^(?:([A-Z][\w$\-]*))/,
      /*  60: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  61: */  /^(?:%\})/,
      /*  62: */  /^(?:\{)/,
      /*  63: */  /^(?:\})/,
      /*  64: */  /^(?:<)/,
      /*  65: */  /^(?:\{\{)/,
      /*  66: */  /^(?:%\})/,
      /*  67: */  /^(?:([A-Z][\w$\-]*))/,
      /*  68: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  69: */  /^(?:\{)/,
      /*  70: */  /^(?:\})/,
      /*  71: */  /^(?:\|)/,
      /*  72: */  /^(?:=>)/,
      /*  73: */  /^(?:->)/,
      /*  74: */  /^(?:@)/,
      /*  75: */  /^(?:instanceof)/,
      /*  76: */  /^(?:true)/,
      /*  77: */  /^(?:false)/,
      /*  78: */  /^(?:if)/,
      /*  79: */  /^(?:then)/,
      /*  80: */  /^(?:else)/,
      /*  81: */  /^(?:as)/,
      /*  82: */  /^(?:([A-Z][\w$\-]*))/,
      /*  83: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  84: */  /^(?:\}\})/,
      /*  85: */  /^(?:\{)/,
      /*  86: */  /^(?:\})/,
      /*  87: */  /^(?:(.|\r|\n)*?-->)/,
      /*  88: */  /^(?:((?:([-]?(?:[-]?([0]|((?:[1-9])(?:\d+)*)))\.(?:\d+)*(?:(?:[Ee])(?:[+-]?\d+))?)|(\.(?:\d+)(?:(?:[Ee])(?:[+-]?\d+))?)|((?:[-]?([0]|((?:[1-9])(?:\d+)*)))(?:(?:[Ee])(?:[+-]?\d+))?))|(?:[0][Xx](?:[\dA-Fa-f])+)|(?:[0](?:[0-7])+)))/,
      /*  89: */  /^(?:(("(?:([^\n\r"\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*")|('(?:([^\n\r'\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*')|(`(?:([^\n\r\\`]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*`)))/,
      /*  90: */  /^(?:>)/,
      /*  91: */  /^(?:<)/,
      /*  92: */  /^(?:\()/,
      /*  93: */  /^(?:\))/,
      /*  94: */  /^(?:\[)/,
      /*  95: */  /^(?:\])/,
      /*  96: */  /^(?:;)/,
      /*  97: */  /^(?::)/,
      /*  98: */  /^(?:=)/,
      /*  99: */  /^(?:==)/,
      /* 100: */  /^(?:!=)/,
      /* 101: */  /^(?:>=)/,
      /* 102: */  /^(?:<=)/,
      /* 103: */  /^(?:\+)/,
      /* 104: */  /^(?:-)/,
      /* 105: */  /^(?:\*)/,
      /* 106: */  /^(?:\/)/,
      /* 107: */  /^(?:\\)/,
      /* 108: */  /^(?:&&)/,
      /* 109: */  /^(?:\|\|)/,
      /* 110: */  /^(?:\^)/,
      /* 111: */  /^(?:!)/,
      /* 112: */  /^(?:,)/,
      /* 113: */  /^(?:\?)/,
      /* 114: */  /^(?:\.)/,
      /* 115: */  /^(?:$)/,
      /* 116: */  /^(?:.)/
    ],

    conditions: {
      'CHILDREN': {
        rules: [
          0,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'COMMENT': {
        rules: [
          0,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'CONTROL': {
        rules: [
          0,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'EXPRESSION': {
        rules: [
          0,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'CONTROL_CHILD': {
        rules: [
          0,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'TAG': {
        rules: [
          0,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: false
      },

      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = Parser;
  exports.Parser = Parser.Parser;
  exports.parse = function () {
    return Parser.parse.apply(Parser, arguments);
  };
  
}

},{}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nodes = require("./AST");
var afpl = require("afpl");
var CONTEXT = '___context';
var VIEW = '___view';
var WML = '___wml';
var prims = ['String', 'Boolean', 'Number', 'Object', 'Undefined', 'Null', 'Void', 'Never', 'Any'];
/**
 * Types and functions for generating typescript program text.
 */
var _throwNotKnown = function (n) {
    throw new Error("Unsupported AST node " + (typeof n === 'object' ? n.constructor.name : n) + "!");
};
var noop = function () { return "function () {}"; };
/**
 * view template.
 */
exports.view = function (id, typeClasses, params, ctx, tag) {
    return "export class " + id + typeClasses + " extends " + WML + ".AppView<" + ctx + "> {\n\n    constructor(" + CONTEXT + ": " + ctx + (params ? ',' + params : '') + ") {\n\n        super(" + CONTEXT + ");\n\n        this.template = (" + VIEW + ":" + WML + ".AppView<" + ctx + ">) =>\n          " + (tag ? tag : '<Node>document.createDocumentFragment()') + ";\n\n       }\n\n     }\n";
};
/**
 * code turns an AST into typescript code.
 */
exports.code = function (n, o) { return exports.module2TS(n, o); };
/**
 * module2TS converts a module to a typescript module.
 */
exports.module2TS = function (n, _a) {
    var module = _a.module;
    return "\nimport * as " + WML + " from '" + module + "';\n" + n.imports.map(exports.importStatement2TS).join(';\n') + "\n\n" + n.exports.map(exports.exports2TS).join(';\n') + "\n\n" + (n.main ? exports.main2TS(n.main) : '') + "\n";
};
/**
 * exports2TS converts various exports to typescript.
 */
exports.exports2TS = function (n) {
    if (n instanceof nodes.ExportStatement)
        return exports.exportStatement2TS(n);
    else if (n instanceof nodes.FunStatement)
        return exports.funStatement2TS(n);
    else if (n instanceof nodes.ViewStatement)
        return exports.viewStatement2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * importStatement2TS converts an import statement.
 */
exports.importStatement2TS = function (n) {
    return "import " + exports.importMember2TS(n.member) + " from '" + n.module.value + "'; ";
};
/**
 * importMember2TS converts the members of an import to typescript.
 */
exports.importMember2TS = function (n) {
    if (n instanceof nodes.AggregateMember)
        return exports.aggregateMember2TS(n);
    else if (n instanceof nodes.AliasedMember)
        return exports.aliasedMember2TS(n);
    else if (n instanceof nodes.CompositeMember)
        return exports.compositeMember2TS(n);
    else
        return _throwNotKnown;
};
/**
 * aliasedMember2TS converts a member alias to typescript.
 */
exports.aliasedMember2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.member) + " as " + exports.identifierOrConstructor2TS(n.alias) + " ";
};
/**
 * aggregateMember2TS converts a qualified member to typescript.
 */
exports.aggregateMember2TS = function (n) {
    return "* as " + exports.identifierOrConstructor2TS(n.id) + " ";
};
/**
 * compositeMember2TS coverts to typescript.
 */
exports.compositeMember2TS = function (n) {
    return '{' + (n.members.map(function (m) { return (m instanceof nodes.AliasedMember) ?
        exports.aliasedMember2TS(m) :
        exports.identifierOrConstructor2TS(m); }).join(',')) + '}';
};
/**
 * main2TS converts to typescript.
 */
exports.main2TS = function (n) {
    return (n instanceof nodes.TypedMain) ?
        exports.typedMain2TS(n) :
        exports.untypedMain2TS(n);
};
/**
 * typedMain2TS converts a typed main file to typescript.
 */
exports.typedMain2TS = function (n) {
    return exports.view(n.id ? exports.unqualifiedIdentifier2TS(n.id) : 'Main', exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
/**
 * untypedMain2TS converts an untyped main file to typescript.
 */
exports.untypedMain2TS = function (n) {
    return exports.view('Main', '', '', 'void', exports.tag2TS(n.tag));
};
/**
 * exportStatement2TS converts an export statement to typescript.
 */
exports.exportStatement2TS = function (n) {
    return "export " + exports.compositeMember2TS(n.members) + " from '" + n.module.value + "';\n";
};
/**
 * viewStatement2TS converts a view statement into a typescript class.
 */
exports.viewStatement2TS = function (n) {
    return exports.view(exports.constructor2TS(n.id), exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
var _funContext = function (n) { return "(" + CONTEXT + ":" + exports.type2TS(n) + ")=>"; };
var _funView = function () { return "(" + VIEW + ":" + WML + ".View)=>"; };
var _curry = function (n) {
    return n.map(exports.parameter2TS).map(function (s) { return "(" + s + ")=>"; }).join('');
};
/**
 * funStatement2TS converts a function statement to typescript.
 */
exports.funStatement2TS = function (n) {
    return "export const " + exports.unqualifiedIdentifier2TS(n.id) + " = " +
        ("" + exports.typeClasses2TS(n.typeClasses)) +
        ((n.context != null) ? _funContext(n.context) : '') +
        ("" + _curry(n.parameters) + _funView()) +
        ((Array.isArray(n.body) ? exports.children2TS(n.body) : exports.child2TS(n.body)) + ";");
};
/**
 * typeClasses2TS converts a list of typeclasses into the a list of typescript typeclasses.
 */
exports.typeClasses2TS = function (ns) {
    return (ns.length === 0) ? '' : "< " + ns.map(exports.typeClass2TS).join(',') + ">";
};
/**
 * typeClass2TS converts a typeclass into a typescript typeclass.
 */
exports.typeClass2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.id) + " " +
        ((n.constraint ? 'extends ' + exports.type2TS(n.constraint) : '') + " ");
};
var _toPrim = function (typ) {
    return prims.indexOf(typ) > -1 ? typ.toLowerCase() : typ;
};
/**
 * type2TS converts a type hint to a typescript type hint.
 */
exports.type2TS = function (n) {
    return _toPrim(exports.identifierOrConstructor2TS(n.id)) + " " +
        (exports.typeClasses2TS(n.typeClasses) + " " + (n.list ? '[]' : ''));
};
/**
 * parameter2TS converts a parameter to a typescript parameter.
 */
exports.parameter2TS = function (n) {
    return (n instanceof nodes.TypedParameter) ? exports.typedParameter2TS(n) :
        (n instanceof nodes.UntypedParameter) ? exports.untypedParameter2TS(n) :
            _throwNotKnown;
};
/**
 * typedParameter2TS converts a typed parameter into a non-any typescript parameter.
 */
exports.typedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + ":" + exports.type2TS(n.hint) + " ";
};
/**
 * untypedParameter2TS converts an type inferred parameter to a typescript parameter.
 */
exports.untypedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + " ";
};
/**
 * children2TS converts a list of children to typescript.
 */
exports.children2TS = function (list) {
    return (list.length === 0) ? 'document.createDocumentFragment();' :
        (list.length === 1) ? exports.child2TS(list[0]) :
            WML + ".box(" + list.map(function (l) { return exports.child2TS(l); }).join(',') + ") ";
};
/**
 * child2TS converts children to typescript.
 */
exports.child2TS = function (n) {
    if ((n instanceof nodes.Node) || (n instanceof nodes.Widget))
        return exports.tag2TS(n);
    else if (n instanceof nodes.Interpolation)
        return WML + ".domify(" + exports.interpolation2TS(n) + ") ";
    else if (n instanceof nodes.IfStatement)
        return exports.ifStatement2TS(n);
    else if (n instanceof nodes.ForStatement)
        return exports.forStatement2TS(n);
    else if (n instanceof nodes.Characters)
        return exports.characters2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * tag2TS converts a tag (node/widget) to typescript.
 */
exports.tag2TS = function (n) {
    var children = n.children.map(exports.child2TS);
    var attrs = exports.attrs2String(exports.groupAttrs(n.attributes));
    var name = exports.identifierOrConstructor2TS(n.open);
    return (n.type === 'widget') ? WML + ".widget(" + name + ", " + attrs + ", [" + children + "], " + VIEW + ")" :
        WML + ".node('" + name + "', " + attrs + ", [" + children + "], " + VIEW + ") ";
};
/**
 * attrs2String
 */
exports.attrs2String = function (attrs) { return '{' +
    (Object.keys(attrs).map(function (ns) { return ns + " : { " + attrs[ns].join(',') + " } "; })) + '}'; };
/**
 * groupAttrs groups attributes according to their namespace.
 */
exports.groupAttrs = function (ns) { return ns.reduce(function (p, c) {
    return afpl.util.merge(p, (_a = {},
        _a[c.namespace.id || 'html'] = (p[c.namespace.id || 'html'] || []).concat(exports.attribute2TS(c)),
        _a));
    var _a;
}, { html: [], wml: [] }); };
/**
 * attribute2Value
 */
exports.attribute2TS = function (n) {
    return "'" + exports.unqualifiedIdentifier2TS(n.name) + "' : " + exports.attributeValue2TS(n.value) + " ";
};
/**
 * attributeValue2TS converts an attribute value to typescript.
 */
exports.attributeValue2TS = function (n) {
    return (n instanceof nodes.Interpolation) ? exports.interpolation2TS(n) : exports.literal2TS(n);
};
/**
 * interpolation2TS converts interpolation expressions to typescript.
 */
exports.interpolation2TS = function (n) {
    return n.filters.reduce(function (p, c) { return exports.expression2TS(c) + " (" + p + ")"; }, exports.expression2TS(n.expression));
};
/**
 * forStatement2TS converts a for statement to typescript.
 */
exports.forStatement2TS = function (n) {
    return WML + ".map(" + exports.expression2TS(n.list) + ", function _map" +
        ("(" + [n.variable, n.index, n.all].filter(function (x) { return x; }).map(exports.parameter2TS).join(',') + ") ") +
        ("{ return " + exports.children2TS(n.body) + " }, ") +
        ("function otherwise() { return " + exports.children2TS(n.otherwise) + " }) ");
};
/**
 * ifStatement2TS converts an if statement to typescript.
 */
exports.ifStatement2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ")? " +
        (exports.children2TS(n.then) + ":") +
        ("" + (n.elseClause ? else2TS(n.elseClause) : noop()));
};
var else2TS = function (n) {
    return (n instanceof nodes.ElseClause) ? exports.children2TS(n.children) :
        (n instanceof nodes.ElseIfClause) ? exports.ifStatement2TS(n) :
            _throwNotKnown(n);
};
/**
 * characters2TS converts character text to a typescript string.
 */
exports.characters2TS = function (n) { return WML + ".text(`" + n.value + "`)"; };
/**
 * expression2TS converts a wml expression to a typescript expression.
 */
exports.expression2TS = function (n) {
    if (n instanceof nodes.IfThenExpression)
        return exports.ifThenExpression2TS(n);
    else if (n instanceof nodes.BinaryExpression)
        return exports.binaryExpression2TS(n);
    else if (n instanceof nodes.UnaryExpression)
        return exports.unaryExpression2TS(n);
    else if (n instanceof nodes.ViewConstruction)
        return exports.viewConstruction2TS(n);
    else if (n instanceof nodes.FunApplication)
        return exports.funApplication2TS(n);
    else if (n instanceof nodes.ConstructExpression)
        return exports.constructExpression2TS(n);
    else if (n instanceof nodes.CallExpression)
        return exports.callExpression2TS(n);
    else if (n instanceof nodes.MemberExpression)
        return exports.memberExpression2TS(n);
    else if (n instanceof nodes.ReadExpression)
        return exports.readExpression2TS(n);
    else if (n instanceof nodes.FunctionExpression)
        return exports.functionExpression2TS(n);
    else if (n instanceof nodes.Record)
        return exports.record2TS(n);
    else if (n instanceof nodes.List)
        return exports.list2TS(n);
    else if (n instanceof nodes.BooleanLiteral)
        return exports.boolean2TS(n);
    else if (n instanceof nodes.NumberLiteral)
        return exports.number2TS(n);
    else if (n instanceof nodes.StringLiteral)
        return exports.string2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else if (n instanceof nodes.ContextVariable)
        return exports.contextVariable2TS(n);
    else
        _throwNotKnown(n);
};
/**
 * ifThenExpression2TS converts an if-then-else expression to typescript.
 */
exports.ifThenExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ") ? " + exports.expression2TS(n.iftrue) + " : " + exports.expression2TS(n.iffalse) + " ";
};
/**
 * binaryExpression2TS converts a binary expression to typescript.
 */
exports.binaryExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.left) + " " + exports.convertOperator(n.operator) + " " + exports.expression2TS(n.right) + ") ";
};
/**
 * convertOperator for strictness.
 */
exports.convertOperator = function (op) {
    return (op === '==') ? '===' :
        (op === '!=') ? '!==' :
            op;
};
/**
 * unaryExpression2TS converts a unary expression to typescript.
 */
exports.unaryExpression2TS = function (n) {
    return n.operator + " (" + exports.expression2TS(n.expression) + ")";
};
/**
 * viewConstruction2TS convers a view construction to typescript.
 */
exports.viewConstruction2TS = function (n) {
    return "(new " + exports.constructor2TS(n.cons) + "(" + exports.args2TS(n.context) + ")).render()";
};
exports._curriedApplication = function (ns) {
    return (ns.length === 0) ? '' : ns.map(function (e) { return "(" + exports.expression2TS(e) + ")"; }).join('');
};
/**
 * funApplication2TS converts a fun application to typescript.
 */
exports.funApplication2TS = function (n) {
    return "" + exports.expression2TS(n.target) + exports.typeArgs2TS(n.typeArgs) + " " +
        (exports._curriedApplication(n.args) + "(" + VIEW + ")");
};
/**
 * constructExpression2TS converts a construct expression to a typescript new expression.
 */
exports.constructExpression2TS = function (n) {
    return "new " + exports.constructor2TS(n.cons) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * callExpression2TS converts a call expression (apply) to a typescript invocation.
 */
exports.callExpression2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * typeArgs2TS converts passed type arguments to typescript
 */
exports.typeArgs2TS = function (ns) {
    return ns.length === 0 ? '' : "< " + ns.map(exports.type2TS).join(',') + ">";
};
/**
 * args2TS converts a list of arguments to a typescript argument tupple.
 */
exports.args2TS = function (ns) {
    return (ns.length === 0) ? '' : ns.map(exports.expression2TS).join(',');
};
/**
 * memberExpression2TS converts a member expression into a typescript member expression.
 */
exports.memberExpression2TS = function (n) {
    return exports.expression2TS(n.target) + "." + exports.identifier2TS(n.member) + " ";
};
/**
 * readExpression2TS converts a read expression to side effect full property look up.
 *
 * NOTE: this part of the language is most likely to change.
 */
exports.readExpression2TS = function (n) {
    return WML + ".read < " + exports.type2TS(n.hint) + ">(" + exports.expression2TS(n.path) + ", " + exports.expression2TS(n.target) + " " +
        ((n.defaults ? ',' + exports.expression2TS(n.defaults) : '') + ")");
};
/**
 * functionExpression2TS converts a function expression to a typescript function expression.
 */
exports.functionExpression2TS = function (n) {
    return "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>" +
        ("" + exports.expression2TS(n.body));
};
/**
 * literal2TS converts literals.
 */
exports.literal2TS = function (n) {
    return (n instanceof nodes.BooleanLiteral) ? exports.boolean2TS(n) :
        (n instanceof nodes.StringLiteral) ? exports.string2TS(n) :
            (n instanceof nodes.NumberLiteral) ? exports.number2TS(n) :
                (n instanceof nodes.Record) ? exports.record2TS(n) :
                    (n instanceof nodes.List) ? exports.list2TS(n) :
                        _throwNotKnown(n);
};
/**
 * boolean2TS converts a boolean literal to a typescript boolean literal.
 */
exports.boolean2TS = function (n) { return n.value + " "; };
/**
 * string2TS converts a string literal to a typescript string literal.
 */
exports.string2TS = function (n) { return "`" + n.value + "`"; };
/**
 * number2TS converts a number literal to a typecript number literal.
 */
exports.number2TS = function (n) { return "" + parseFloat(n.value); };
/**
 * record2TS converts a record to a typescript object literal.
 */
exports.record2TS = function (n) {
    return "{" + n.properties.map(exports.property2TS).join(',') + "}";
};
/**
 * list2TS converts a list to a typescript array literal.
 */
exports.list2TS = function (n) {
    return "[" + n.members.map(exports.expression2TS).join(',') + "]";
};
/**
 * property2TS converts a property of a a record to typescript.
 */
exports.property2TS = function (n) {
    return "'" + exports.key2TS(n.key) + "' : " + exports.expression2TS(n.value);
};
/**
 * key2TS converts a single key on a record.
 */
exports.key2TS = function (n) {
    return (n instanceof nodes.StringLiteral) ? exports.string2TS(n) : exports.identifier2TS(n);
};
/**
 * contextProperty2TS turns property access on the context to regular TS
 * property access.
 */
exports.contextProperty2TS = function (n) {
    return CONTEXT + "." + exports.identifier2TS(n.member);
};
/**
 * contextVariable2TS turns the context variable into the context identifier.
 */
exports.contextVariable2TS = function (_) { return "" + CONTEXT; };
/**
 * identifierOrConstructor2TS
 */
exports.identifierOrConstructor2TS = function (n) {
    if ((n instanceof nodes.UnqualifiedIdentifier) ||
        (n instanceof nodes.QualifiedIdentifier))
        return exports.identifier2TS(n);
    else if ((n instanceof nodes.UnqualifiedConstructor) ||
        (n instanceof nodes.QualifiedConstructor))
        return exports.constructor2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * constructor2TS turns a constructor to a typescript identifier.
 *
 * Remember constructors are proper cased.
 */
exports.constructor2TS = function (n) {
    return (n instanceof nodes.QualifiedConstructor) ? exports.qualifiedConstructor2TS(n) :
        (n instanceof nodes.UnqualifiedConstructor) ? exports.unqualifiedConstructor2TS(n) :
            _throwNotKnown(n);
};
/**
 * unqualifiedConstructor2TS converts an unqualified constructor to typescript
 */
exports.unqualifiedConstructor2TS = function (n) { return "" + n.id; };
/**
 * qualifiedConstructor converts a qualified constructor to typescript.
 */
exports.qualifiedConstructor2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * identifier2TS turns an identifier to a typescript identifier.
 */
exports.identifier2TS = function (n) {
    return (n instanceof nodes.QualifiedIdentifier) ? exports.qualifiedIdentifier2TS(n) :
        (n instanceof nodes.UnqualifiedIdentifier) ? exports.unqualifiedIdentifier2TS(n) :
            _throwNotKnown(n);
};
/**
 * qualifiedIdentifier2TS converts a qualified identifier to typescript
 */
exports.qualifiedIdentifier2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * unqualifiedIdentifier2TS converts an unqualified identifier to typescript
 */
exports.unqualifiedIdentifier2TS = function (n) { return "" + n.id; };

},{"./AST":156,"afpl":162}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property = require("property-seek");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var Compiler_1 = require("./Compiler");
exports.parse = Compiler_1.parse;
exports.compile = Compiler_1.compile;
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 *
 */
var Component = /** @class */ (function () {
    /**
     * attrs is the attributes this Component excepts.
     */
    /**
     * children is an array of content passed to this Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;
/**
 * read a value form an object.
 *
 * This is an alternative to regular property access that will throw exceptions
 * if any of the values in the part are null.
 * @param {string} path - The path to look up on the object.
 * @param {object} o - The object
 * @param {A} [defaultValue] - This value is returned if the value is not set.
 * @private
 */
exports.read = function (path, o, defaultValue) {
    var ret = property.get(path.split(':').join('.'), o);
    return (ret != null) ? ret : defaultValue;
};
/**
 * @private
 */
var adopt = function (child, e) {
    switch (typeof child) {
        case 'string':
        case 'number':
        case 'boolean':
            e.appendChild(document.createTextNode('' + child));
        case 'object':
            e.appendChild(child);
            break;
        default:
            throw new TypeError("Can not adopt child " + child + " of type " + typeof child);
    }
};
/**
 * @private
 */
exports.box = function () {
    var content = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        content[_i] = arguments[_i];
    }
    var frag = document.createDocumentFragment();
    content.forEach(function (c) { return frag.appendChild(c); });
    return frag;
};
/**
 * @private
 */
exports.domify = function (a) {
    if (a instanceof Array) {
        return exports.box.apply(null, a.map(exports.domify));
    }
    else if ((typeof a === 'string') ||
        (typeof a === 'number') ||
        (typeof a === 'boolean')) {
        return exports.text(a);
    }
    else if (a instanceof Node) {
        return a;
    }
    else if (a == null) {
        return document.createDocumentFragment();
    }
    else {
        throw new TypeError("Can not use '" + a + "'(typeof " + typeof a + ") as Content!");
    }
};
/**
 * text creates a new TextNode.
 * @private
 */
exports.text = function (value) {
    return document.createTextNode('' + value);
};
/**
 * node is called to create a regular DOM node
 * @private
 */
exports.node = function (tag, attributes, children, view) {
    var e = document.createElement(tag);
    if (typeof attributes['html'] === 'object')
        Object.keys(attributes['html']).forEach(function (key) {
            var value = attributes['html'][key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, "" + value);
            }
        });
    children.forEach(function (c) { return adopt(c, e); });
    var id = attributes['wml'].id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, e);
    if (group)
        view.registerByGroup(group, e);
    return e;
};
/**
 * widget creates and renders a new wml widget instance.
 * @param {function} Construtor
 * @param {object} attributes
 * @param {array<string|number|Widget>} children
 * @param {View} view
 * @private
 * @return {Widget}
 */
exports.widget = function (Constructor, attributes, children, view) {
    var childs = [];
    var w;
    children.forEach(function (child) { return (child instanceof Array) ?
        childs.push.apply(childs, child) : childs.push(child); });
    w = new Constructor(attributes, childs);
    var id = attributes.wml.id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, w);
    if (group)
        view.registerByGroup(group, w);
    view.registerWidget(w);
    return w.render();
};
/**
 * ifthen provides an if then expression
 * @private
 */
exports.ifthen = function (predicate, positive, negative) {
    return (predicate) ? positive() : negative();
};
/**
 * forE provides a for expression
 * @private
 */
exports.map = function (collection, cb, cb2) {
    var frag = document.createDocumentFragment();
    if (collection instanceof Array) {
        if (collection.length > 0)
            collection.forEach(function (v, k, a) { return frag.appendChild(cb(v, k, a)); });
        else
            frag.appendChild(cb2());
    }
    else if (typeof collection === 'object') {
        var l = Object.keys(collection);
        if (l.length > 0)
            l.forEach(function (k) { return frag.appendChild(cb(collection[k], k, collection)); });
        else
            frag.appendChild(cb2());
    }
    return frag;
};
/**
 * AppView is the concrete implementation of a View.
 *
 * @property {<C>} context - The context the view is rendered in.
 */
var AppView = /** @class */ (function () {
    function AppView(context) {
        this.context = context;
        this.ids = {};
        this.groups = {};
        this.widgets = [];
    }
    AppView.prototype.registerWidget = function (w) {
        this.widgets.push(w);
        return this;
    };
    AppView.prototype.registerById = function (id, w) {
        if (this.ids.hasOwnProperty(id))
            throw new Error("Duplicate id '" + id + "' detected!");
        this.ids[id] = w;
        return this;
    };
    AppView.prototype.registerByGroup = function (group, e) {
        this.groups[group] = this.groups[group] || [];
        this.groups[group].push(e);
        return this;
    };
    AppView.prototype.findById = function (id) {
        return Maybe_1.Maybe
            .fromAny(this.ids[id])
            .orElse(function () {
            console.warn("The id '" + id + "' is missing!");
            return Maybe_1.Maybe.nothing();
        });
    };
    AppView.prototype.findGroupByName = function (name) {
        return Maybe_1.Maybe.fromArray(this.groups.hasOwnProperty(name) ? this.groups[name] : []);
    };
    AppView.prototype.invalidate = function () {
        var childs;
        var realFirstChildIndex = -1;
        var tree = (this._fragRoot) ? this._fragRoot : this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            return console.warn('invalidate(): Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            return console.warn('invalidate(): Attempt to invalidate a view that has not been inserted to DOM!');
        childs = tree.parentNode.children;
        // for some reason tree occasionally ends up with a null parentNode
        // when we attempt to call replaceChild. Noticeably after doing work on an array.
        // We do this to use the index instead of passing the reference directly.
        for (var i = 0; i < childs.length; i++)
            if (childs[i] === tree)
                realFirstChildIndex = i;
        // just in case we never got the index.
        if (realFirstChildIndex === -1)
            throw new Error('invaldiate(): Cannot invalidate view, DOM tree appears to have no parent!');
        parent.replaceChild(this.render(), parent.children[realFirstChildIndex]);
    };
    AppView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this._fragRoot = null;
        this.tree = this.template(this);
        this.ids['root'] = (this.ids['root']) ? this.ids['root'] : this.tree;
        if (this.tree.nodeName === (document.createDocumentFragment()).nodeName)
            this._fragRoot = this.tree.firstChild;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return AppView;
}());
exports.AppView = AppView;

},{"./Compiler":157,"afpl/lib/monad/Maybe":167,"property-seek":175}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.f1 = function (f) { return f; };
exports.f2 = function (f) { return function (a) { return function (b) { return f(a, b); }; }; };
exports.f3 = function (f) {
    return function (a) { return function (b) { return function (c) { return f(a, b, c); }; }; };
};
exports.f4 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return f(a, b, c, d); }; }; }; };
};
exports.f5 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return f(a, b, c, d, e); }; }; }; }; };
};
exports.f6 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return function (_f) { return f(a, b, c, d, e, _f); }; }; }; }; }; };
};

},{}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
exports.util = util;
var curry = require("./curry");
exports.curry = curry;
var Identity_1 = require("./monad/Identity");
exports.Identity = Identity_1.Identity;
var Maybe_1 = require("./monad/Maybe");
exports.Maybe = Maybe_1.Maybe;
var Either_1 = require("./monad/Either");
exports.Either = Either_1.Either;
var State_1 = require("./monad/State");
exports.State = State_1.State;
var Free_1 = require("./monad/Free");
exports.Free = Free_1.Free;
var IO_1 = require("./monad/IO");
exports.IO = IO_1.IO;

},{"./curry":161,"./monad/Either":163,"./monad/Free":164,"./monad/IO":165,"./monad/Identity":166,"./monad/Maybe":167,"./monad/State":168,"./util":169}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * left wraps a value on the left side.
 */
exports.left = function (a) { return new Left(a); };
/**
 * right wraps a value on the right side.
 */
exports.right = function (b) { return new Right(b); };
/**
 * fromBoolean constructs an Either using a boolean value.
 */
exports.fromBoolean = function (b) {
    return b ? exports.right(true) : exports.left(false);
};
/**
 * Either monad implementation
 */
var Either = (function () {
    function Either() {
    }
    Either.prototype.of = function (v) {
        return new Right(v);
    };
    Either.left = exports.left;
    Either.right = exports.right;
    Either.fromBoolean = exports.fromBoolean;
    return Either;
}());
exports.Either = Either;
var Left = (function (_super) {
    __extends(Left, _super);
    function Left(l) {
        var _this = _super.call(this) || this;
        _this.l = l;
        return _this;
    }
    Left.prototype.map = function (_) {
        return new Left(this.l);
    };
    Left.prototype.mapLeft = function (f) {
        return new Left(f(this.l));
    };
    Left.prototype.bimap = function (f, _) {
        return exports.left(f(this.l));
    };
    Left.prototype.chain = function (_) {
        return new Left(this.l);
    };
    Left.prototype.orElse = function (f) {
        return f(this.l);
    };
    Left.prototype.orRight = function (f) {
        return new Right(f(this.l));
    };
    Left.prototype.ap = function (_) {
        return new Left(this.l);
    };
    Left.prototype.takeLeft = function () {
        return this.l;
    };
    Left.prototype.takeRight = function () {
        throw new TypeError("Not right!");
    };
    Left.prototype.cata = function (f, _) {
        return f(this.l);
    };
    return Left;
}(Either));
exports.Left = Left;
var Right = (function (_super) {
    __extends(Right, _super);
    function Right(r) {
        var _this = _super.call(this) || this;
        _this.r = r;
        return _this;
    }
    Right.prototype.map = function (f) {
        return new Right(f(this.r));
    };
    Right.prototype.mapLeft = function (_) {
        return new Right(this.r);
    };
    Right.prototype.bimap = function (_, g) {
        return exports.right(g(this.r));
    };
    Right.prototype.chain = function (f) {
        return f(this.r);
    };
    /**
     * orElse returns the result of f if the Either is left.
     */
    Right.prototype.orElse = function (_) {
        return this;
    };
    Right.prototype.orRight = function (_) {
        return this;
    };
    /**
     * ap
     */
    Right.prototype.ap = function (e) {
        var _this = this;
        return e.map(function (f) { return f(_this.r); });
    };
    /**
      * takeLeft extracts the left value of an Either, throwing an error if the Either is right.
      */
    Right.prototype.takeLeft = function () {
        throw new TypeError("Not left!");
    };
    Right.prototype.takeRight = function () {
        return this.r;
    };
    /**
     * cata
     */
    Right.prototype.cata = function (_, g) {
        return g(this.r);
    };
    return Right;
}(Either));
exports.Right = Right;

},{}],164:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var Either_1 = require("./Either");
/**
 * free wraps a value in a free
 */
exports.free = function (a) { return new Return(a); };
/**
 * suspend lifts a function into a Free monad to mimic tail call recursion.
 */
exports.suspend = function (f) { return new Suspend(util_1.compose(exports.free, f)); };
/**
 * liftF lifts a Functor into a Free.
 */
exports.liftF = function (f) { return new Suspend(f.map(exports.free)); };
/**
 * Free is a Free monad that also implements a Free Applicative (almost).
 *
 * Inspired by https://cwmyers.github.io/monet.js/#free
 */
var Free = (function () {
    function Free() {
    }
    /**
     * of
     */
    Free.prototype.of = function (a) {
        return new Return(a);
    };
    /**
     * map
     */
    Free.prototype.map = function (f) {
        return this.chain(function (a) { return exports.free(f(a)); });
    };
    /**
     * chain
     */
    Free.prototype.chain = function (g) {
        if (this instanceof Suspend) {
            var f_1 = this.f;
            return (typeof f_1 === 'function') ?
                new Suspend(function (x) { return f_1(x).chain(g); }) :
                new Suspend(f_1.map(function (free) { return free.chain(g); }));
        }
        else if (this instanceof Return) {
            g(this.a);
        }
    };
    /**
     * resume the next stage of the computation
     */
    Free.prototype.resume = function () {
        if (this instanceof Suspend) {
            return Either_1.left(this.f);
        }
        else if (this instanceof Return) {
            return Either_1.right(this.a);
        }
    };
    /**
     * hoist
    hoist<B>(func: (fb: Functor<B>) => Functor<B>): Free<F, A> {

        if (this instanceof Suspend) {

            return new Suspend((func(this.f))
                .map((fr: Free<F, B>) => fr.hoist<any>(func)))
        } else {

            return this;

        }

    }
    */
    /**
     * cata
     */
    Free.prototype.cata = function (f, g) {
        return this.resume().cata(f, g);
    };
    /**
     * go runs the computation to completion using f to extract each stage.
     * @summmary go :: Free<F<*>, A> →  (F<Free<F,A>> →  Free<F,A>) →  A
     */
    Free.prototype.go = function (f) {
        if (this instanceof Suspend) {
            var r = this.resume();
            while (r instanceof Either_1.Left)
                r = (f(r.takeLeft())).resume();
            return r.takeRight();
        }
        else if (this instanceof Return) {
            return this.a;
        }
    };
    /**
     * run the Free chain to completion
     * @summary run :: Free<A→ A,A> →  A
     */
    Free.prototype.run = function () {
        return this.go(function (next) { return next(); });
    };
    Free.free = exports.free;
    Free.suspend = exports.suspend;
    Free.liftF = exports.liftF;
    return Free;
}());
exports.Free = Free;
var Suspend = (function (_super) {
    __extends(Suspend, _super);
    function Suspend(f) {
        var _this = _super.call(this) || this;
        _this.f = f;
        return _this;
    }
    return Suspend;
}(Free));
exports.Suspend = Suspend;
var Return = (function (_super) {
    __extends(Return, _super);
    function Return(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    return Return;
}(Free));
exports.Return = Return;

},{"../util":169,"./Either":163}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * wrapIO a value in the IO monad
 */
exports.wrapIO = function (a) { return new IO(function () { return a; }); };
/**
 * safeIO accepts a function that has side effects and wrapIOs it in an IO Monad.
 */
exports.safeIO = function (f) { return new IO(f); };
exports.pure = exports.wrapIO;
exports.suspend = exports.safeIO;
/**
 * IO monadic type for containing interactions with the 'real world'.
 */
var IO = (function () {
    function IO(effect) {
        this.effect = effect;
    }
    IO.prototype.of = function (v) {
        return new IO(function () { return v; });
    };
    IO.prototype.map = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()); });
    };
    IO.prototype.mapIn = function (b) {
        return this.map(function () { return b; });
    };
    /**
     * chain
     */
    IO.prototype.chain = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()).run(); });
    };
    IO.prototype.chainIn = function (b) {
        return this.chain(function () { return exports.wrapIO(b); });
    };
    /**
     * run
     */
    IO.prototype.run = function () {
        return this.effect();
    };
    IO.safeIO = exports.safeIO;
    IO.pure = exports.pure;
    IO.suspend = exports.suspend;
    IO.chain = function (f) { return function (m) { return m.chain(f); }; };
    return IO;
}());
exports.IO = IO;

},{}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Identity
 */
var Identity = (function () {
    function Identity(a) {
        this.a = a;
    }
    /**
     * of
     */
    Identity.prototype.of = function (a) {
        return new Identity(a);
    };
    /**
     * map
     */
    Identity.prototype.map = function (f) {
        return new Identity(f(this.get()));
    };
    /**
     * chain
     */
    Identity.prototype.chain = function (f) {
        return f(this.get());
    };
    /**
     * ap
     */
    Identity.prototype.ap = function (i) {
        var _this = this;
        return i.map(function (f) { return f(_this.get()); });
    };
    /**
     * get the value of an Identity
     * @summary get :: Identity<A> →  A
     */
    Identity.prototype.get = function () {
        return this.a;
    };
    return Identity;
}());
exports.Identity = Identity;

},{}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("./Either");
/**
 * just wraps a value in a Just
 */
exports.just = function (a) { return new Just(a); };
;
/**
 * nothing constructs nothing
 */
exports.nothing = function () { return new Nothing(); };
/**
 * fromAny constructs a Maybe from a value that may be null.
 */
exports.fromAny = function (a) { return a == null ? exports.nothing() : exports.just(a); };
/**
 * fromArray checks an array to see if it's empty (or full of nulls)
 * and returns a Maybe.
 */
exports.fromArray = function (a) {
    return ((a.length === 0) || (a.reduce(function (c, v) { return (v == null) ? c + 1 : c; }, 0) === a.length)) ?
        exports.nothing() : exports.just(a);
};
/**
 * fromOBject uses Object.keys to turn see if an object has any own properties.
 */
exports.fromObject = function (o) {
    return Object.keys(o).length === 0 ? exports.nothing() : exports.just(o);
};
/**
 * fromString constructs nothing if the string is empty or just otherwise.
 */
exports.fromString = function (s) {
    return (s === '') ? exports.nothing() : exports.just(s);
};
/**
 * fromBoolean constructs nothing if b is false, just otherwise
 */
exports.fromBoolean = function (b) {
    return (b === false) ? exports.nothing() : exports.just(b);
};
/**
 * fromNumber constructs nothing if n is 0 just otherwise.
 */
exports.fromNumber = function (n) {
    return (n === 0) ? exports.nothing() : exports.just(n);
};
/**
 * Maybe
 */
var Maybe = (function () {
    function Maybe() {
    }
    Maybe.prototype.of = function (a) {
        return new Just(a);
    };
    Maybe.just = exports.just;
    Maybe.nothing = exports.nothing;
    Maybe.fromAny = exports.fromAny;
    Maybe.fromObject = exports.fromObject;
    Maybe.fromArray = exports.fromArray;
    Maybe.fromString = exports.fromString;
    Maybe.fromBoolean = exports.fromBoolean;
    Maybe.fromNumber = exports.fromNumber;
    return Maybe;
}());
exports.Maybe = Maybe;
/**
 * Nothing
 */
var Nothing = (function (_super) {
    __extends(Nothing, _super);
    function Nothing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Nothing.prototype.map = function (_) {
        return new Nothing();
    };
    Nothing.prototype.chain = function (_) {
        return new Nothing();
    };
    Nothing.prototype.get = function () {
        throw new TypeError('Cannot get anything from Nothing!');
    };
    Nothing.prototype.orElse = function (f) {
        return f();
    };
    /**
     * orJust will turn Nothing into Just, wrapping the value specified.
     */
    Nothing.prototype.orJust = function (f) {
        return exports.just(f());
    };
    /**
     * cata applies the corresponding function to the Maybe
     */
    Nothing.prototype.cata = function (f, _g) {
        return f();
    };
    Nothing.prototype.toEither = function () {
        return Either_1.left(undefined);
    };
    return Nothing;
}(Maybe));
exports.Nothing = Nothing;
/**
 * Just
 */
var Just = (function (_super) {
    __extends(Just, _super);
    function Just(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    Just.prototype.map = function (f) {
        return new Just(f(this.a));
    };
    Just.prototype.join = function () {
        return this.a;
    };
    Just.prototype.chain = function (f) {
        return f(this.a);
    };
    Just.prototype.get = function () {
        return this.a;
    };
    Just.prototype.orElse = function (_f) {
        return this;
    };
    Just.prototype.orJust = function (_f) {
        return this;
    };
    Just.prototype.cata = function (_f, g) {
        return g(this.a);
    };
    Just.prototype.toEither = function () {
        return Either_1.right(this.a);
    };
    return Just;
}(Maybe));
exports.Just = Just;

},{"./Either":163}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * get the state from the internals of the monad
 */
exports.get = function () { return new State(function (s) { return ([s, s]); }); };
/**
 * put
 */
exports.put = function (s) { return new State(function () { return ([null, s]); }); };
/**
 * modify the state
 * @summary  (S →  S) →  State<S →  {A, S} >
 */
exports.modify = function (f) { return exports.get().chain(function (s) { return exports.put(f(s)); }); };
/**
 * gets applies a function to the state putting using the result
 * as the result of the computation.
 * @summary (S →  A) →  State<S →  {A, S}>
 */
exports.gets = function (f) { return exports.get().chain(function (s) { return exports.state(f(s)); }); };
/**
 * state create a new State monad
 */
exports.state = function (a) { return new State(function (s) { return ([a, s]); }); };
/**
 * State is a monadic class that we use to hold information that changes
 * during computation.
 *
 * This implementation is influenced by:
 * @link https://en.wikipedia.org/wiki/Monad_(functional_programming)#State_monads
 * @property {s →  (a, s)} a
 */
var State = (function () {
    function State(f) {
        this.f = f;
    }
    /**
     * of wraps a value in the State monad.
     * @summary A →  State<S→ {A,S}>
     */
    State.prototype.of = function (a) {
        return new State(function (s) { return ([a, s]); });
    };
    /**
     * map
     * @summary State<S → {A,S}> →  (A →  B) →  State<S →  {C, S}>
     */
    State.prototype.map = function (f) {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return [f(a), s];
        });
    };
    /**
     * join replaces the outer State with an inner State
     */
    State.prototype.join = function () {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return a.run(s);
        });
    };
    /**
     * chain
     */
    State.prototype.chain = function (f) {
        return this.map(f).join();
    };
    /**
     * evaluate the State returning the final value
     */
    State.prototype.evaluate = function (s) {
        return this.run(s)[0];
    };
    /**
     * execute the State returning the final state.
     */
    State.prototype.execute = function (s) {
        return this.run(s)[1];
    };
    /**
     * run the State yielding the final value and state.
     * @summary State<S→ {A<S}> →  S →  {A,S}
     */
    State.prototype.run = function (s) {
        return this.f(s);
    };
    State.get = exports.get;
    State.put = exports.put;
    State.modify = exports.modify;
    State.gets = exports.gets;
    State.state = exports.state;
    return State;
}());
exports.State = State;

},{}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * identity is the famed identity function.
 */
exports.identity = function (a) { return a; };
/**
 * merge two objects easily
 */
exports.merge = function () {
    var o = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        o[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, [{}].concat(o));
};
/**
 * fuse is the deep version of merge
 */
exports.fuse = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.reduce(function (o, c) {
        if (c === void 0) { c = {}; }
        return exports.reduce(c, function (co, cc, k) {
            return Array.isArray(cc) ?
                (Array.isArray(co[k]) ?
                    exports.merge(co, (_a = {}, _a[k] = (co[k]).map(exports.copy).concat(cc.map(exports.copy)), _a)) :
                    exports.merge(co, (_b = {}, _b[k] = cc.map(exports.copy), _b))) :
                typeof cc !== 'object' ?
                    exports.merge(co, (_c = {}, _c[k] = cc, _c)) :
                    exports.merge(co, (_d = {},
                        _d[k] = (typeof co[k] !== 'object') ?
                            exports.merge(co[k], cc) :
                            exports.fuse(co[k], cc),
                        _d));
            var _a, _b, _c, _d;
        }, o);
    }, {});
};
exports.copy = function (o) {
    return (Array.isArray(o)) ?
        o.map(exports.copy) :
        (typeof o === 'object') ?
            exports.reduce(o, function (p, c, k) {
                return exports.merge(p, (_a = {}, _a[k] = exports.copy(c), _a));
                var _a;
            }, {}) : o;
};
/**
 * reduce an object's keys (in no guaranteed order)
 */
exports.reduce = function (o, f, accum) {
    return Object.keys(o).reduce(function (p, k) { return f(p, o[k], k, o); }, accum);
};
/**
 * map over an object (in no guaranteed oreder)
 */
exports.map = function (o, f) {
    return Object.keys(o).map((function (k) { return f(o[k], k, o); }));
};
/**
 * compose two functions into one.
 */
exports.compose = function (f, g) { return function (x) { return f(g(x)); }; };
/**
 * fling removes a key from an object
 * @param {string} key
 * @param {object} object
 * @return {Object}
 * @summary {(string,Object) →  Object}
 */
exports.fling = function (s, o) {
    if ((o == null) || (o.constructor !== Object))
        throw new TypeError('fling(): only works with object literals!');
    return Object.keys(o).reduce(function (o2, k) {
        return k === s ? o2 : exports.merge(o2, (_a = {},
            _a[k] = o[k],
            _a));
        var _a;
    }, {});
};
/**
 * head returns the item at index 0 of an array
 * @param {Array} list
 * @return {*}
 * @summary { Array →  * }
 */
exports.head = function (list) { return list[0]; };
/**
 * tail returns the last item in an array
 * @param {Array} list
 * @return {*}
 * @summary {Array →  *}
 */
exports.tail = function (list) { return list[list.length - 1]; };
/**
 * constant given a value, return a function that always returns this value.
 * @summary constant X →  * →  X
 *
 */
exports.constant = function (a) { return function () { return a; }; };
/**
 * f1 partial application.
 */
exports.f1 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return f.apply(null, args.concat(a)); };
};
/**
 * f2 partial application
 */
exports.f2 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return f.apply(null, args.concat(a, aa)); }; };
};
/**
 * f3 partial application
 */
exports.f3 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return f.apply(null, args.concat(a, aa, aaa)); }; }; };
};
/**
 * f4 partial application
 */
exports.f4 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa));
    }; }; }; };
};
/**
 * f5 partial application
 */
exports.f5 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) { return function (aaaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa, aaaaa));
    }; }; }; }; };
};
/**
 * except copies an object removing a single key.
 */
exports.except = function (keys, o) {
    return exports.reduce(o, function (p, c, k) {
        return keys.indexOf(k) > -1 ? p : exports.merge(p, (_a = {}, _a[k] = c, _a));
        var _a;
    }, {});
};

},{}],170:[function(require,module,exports){
/*
  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
    // the default is js
    var beautify = function(src, config) {
        return js_beautify.js_beautify(src, config);
    };

    // short aliases
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;

    // legacy aliases
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;

    return beautify;
}

if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([
        "./lib/beautify",
        "./lib/beautify-css",
        "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
    });
} else {
    (function(mod) {
        var js_beautify = require('./lib/beautify');
        var css_beautify = require('./lib/beautify-css');
        var html_beautify = require('./lib/beautify-html');

        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

    })(module);
}
},{"./lib/beautify":173,"./lib/beautify-css":171,"./lib/beautify-html":172}],171:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
        http://jsbeautifier.org/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                         — indentation size,
        indent_char (space)                     — character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {
var legacy_beautify_css =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);
var Output = __webpack_require__(3).Output;


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

function Beautifier(source_text, options) {
    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'css');

    source_text = source_text || '';

    var newlinesFromLastWSEat = 0;
    var indentSize = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    var indentCharacter = options.indent_char || ' ';
    var preserve_newlines = (options.preserve_newlines === undefined) ? false : options.preserve_newlines;
    var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
    var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
    var space_around_combinator = (options.space_around_combinator === undefined) ? false : options.space_around_combinator;
    space_around_combinator = space_around_combinator || ((options.space_around_selector_separator === undefined) ? false : options.space_around_selector_separator);
    var eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indentCharacter = '\t';
        indentSize = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (source_text && lineBreak.test(source_text || '')) {
            eol = source_text.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    source_text = source_text.replace(allLineBreaks, '\n');

    // tokenizer
    var whiteRe = /^\s+$/;

    var pos = -1,
        ch;
    var parenLevel = 0;

    function next() {
        ch = source_text.charAt(++pos);
        return ch || '';
    }

    function peek(skipWhitespace) {
        var result = '';
        var prev_pos = pos;
        if (skipWhitespace) {
            eatWhitespace();
        }
        result = source_text.charAt(pos + 1) || '';
        pos = prev_pos - 1;
        next();
        return result;
    }

    function eatString(endChars) {
        var start = pos;
        while (next()) {
            if (ch === "\\") {
                next();
            } else if (endChars.indexOf(ch) !== -1) {
                break;
            } else if (ch === "\n") {
                break;
            }
        }
        return source_text.substring(start, pos + 1);
    }

    function peekString(endChar) {
        var prev_pos = pos;
        var str = eatString(endChar);
        pos = prev_pos - 1;
        next();
        return str;
    }

    function eatWhitespace(preserve_newlines_local) {
        var result = 0;
        while (whiteRe.test(peek())) {
            next();
            if (ch === '\n' && preserve_newlines_local && preserve_newlines) {
                output.add_new_line(true);
                result++;
            }
        }
        newlinesFromLastWSEat = result;
        return result;
    }

    function skipWhitespace() {
        var result = '';
        if (ch && whiteRe.test(ch)) {
            result = ch;
        }
        while (whiteRe.test(next())) {
            result += ch;
        }
        return result;
    }

    function eatComment() {
        var start = pos;
        var singleLine = peek() === "/";
        next();
        while (next()) {
            if (!singleLine && ch === "*" && peek() === "/") {
                next();
                break;
            } else if (singleLine && ch === "\n") {
                return source_text.substring(start, pos);
            }
        }

        return source_text.substring(start, pos) + ch;
    }


    function lookBack(str) {
        return source_text.substring(pos - str.length, pos).toLowerCase() ===
            str;
    }

    // Nested pseudo-class if we are insideRule
    // and the next special character found opens
    // a new block
    function foundNestedPseudoClass() {
        var openParen = 0;
        for (var i = pos + 1; i < source_text.length; i++) {
            var ch = source_text.charAt(i);
            if (ch === "{") {
                return true;
            } else if (ch === '(') {
                // pseudoclasses can contain ()
                openParen += 1;
            } else if (ch === ')') {
                if (openParen === 0) {
                    return false;
                }
                openParen -= 1;
            } else if (ch === ";" || ch === "}") {
                return false;
            }
        }
        return false;
    }

    // printer
    var baseIndentString = '';
    var preindent_index = 0;
    if (source_text && source_text.length) {
        while ((source_text.charAt(preindent_index) === ' ' ||
                source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = source_text.substring(0, preindent_index);
        js_source_text = source_text.substring(preindent_index);
    }


    var singleIndent = new Array(indentSize + 1).join(indentCharacter);
    var indentLevel;
    var nestedLevel;
    var output;

    function print_string(output_string) {
        if (output.just_added_newline()) {
            output.set_indent(indentLevel);
        }
        output.add_token(output_string);
    }

    function preserveSingleSpace(isAfterSpace) {
        if (isAfterSpace) {
            output.space_before_token = true;
        }
    }

    function indent() {
        indentLevel++;
    }

    function outdent() {
        if (indentLevel > 0) {
            indentLevel--;
        }
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        // reset
        output = new Output(singleIndent, baseIndentString);
        indentLevel = 0;
        nestedLevel = 0;

        pos = -1;
        ch = null;
        parenLevel = 0;

        var insideRule = false;
        var insidePropertyValue = false;
        var enteringConditionalGroup = false;
        var top_ch = '';
        var last_top_ch = '';

        while (true) {
            var whitespace = skipWhitespace();
            var isAfterSpace = whitespace !== '';
            var isAfterNewline = whitespace.indexOf('\n') !== -1;
            last_top_ch = top_ch;
            top_ch = ch;

            if (!ch) {
                break;
            } else if (ch === '/' && peek() === '*') { /* css comment */
                var header = indentLevel === 0;

                if (isAfterNewline || header) {
                    output.add_new_line();
                }

                print_string(eatComment());
                output.add_new_line();
                if (header) {
                    output.add_new_line(true);
                }
            } else if (ch === '/' && peek() === '/') { // single line comment
                if (!isAfterNewline && last_top_ch !== '{') {
                    output.trim(true);
                }
                output.space_before_token = true;
                print_string(eatComment());
                output.add_new_line();
            } else if (ch === '@') {
                preserveSingleSpace(isAfterSpace);

                // deal with less propery mixins @{...}
                if (peek() === '{') {
                    print_string(eatString('}'));
                } else {
                    print_string(ch);

                    // strip trailing space, if present, for hash property checks
                    var variableOrRule = peekString(": ,;{}()[]/='\"");

                    if (variableOrRule.match(/[ :]$/)) {
                        // we have a variable or pseudo-class, add it and insert one space before continuing
                        next();
                        variableOrRule = eatString(": ").replace(/\s$/, '');
                        print_string(variableOrRule);
                        output.space_before_token = true;
                    }

                    variableOrRule = variableOrRule.replace(/\s$/, '');

                    // might be a nesting at-rule
                    if (variableOrRule in this.NESTED_AT_RULE) {
                        nestedLevel += 1;
                        if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                            enteringConditionalGroup = true;
                        }
                    }
                }
            } else if (ch === '#' && peek() === '{') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString('}'));
            } else if (ch === '{') {
                if (peek(true) === '}') {
                    eatWhitespace();
                    next();
                    output.space_before_token = true;
                    print_string("{}");
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                        output.add_new_line(true);
                    }
                } else {
                    indent();
                    output.space_before_token = true;
                    print_string(ch);
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    // when entering conditional groups, only rulesets are allowed
                    if (enteringConditionalGroup) {
                        enteringConditionalGroup = false;
                        insideRule = (indentLevel > nestedLevel);
                    } else {
                        // otherwise, declarations are also allowed
                        insideRule = (indentLevel >= nestedLevel);
                    }
                }
            } else if (ch === '}') {
                outdent();
                output.add_new_line();
                print_string(ch);
                insideRule = false;
                insidePropertyValue = false;
                if (nestedLevel) {
                    nestedLevel--;
                }

                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }

                if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                    output.add_new_line(true);
                }
            } else if (ch === ":") {
                eatWhitespace();
                if ((insideRule || enteringConditionalGroup) &&
                    !(lookBack("&") || foundNestedPseudoClass()) &&
                    !lookBack("(")) {
                    // 'property: value' delimiter
                    // which could be in a conditional group query
                    print_string(':');
                    if (!insidePropertyValue) {
                        insidePropertyValue = true;
                        output.space_before_token = true;
                    }
                } else {
                    // sass/less parent reference don't use a space
                    // sass nested pseudo-class don't use a space

                    // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
                    if (lookBack(" ")) {
                        output.space_before_token = true;
                    }
                    if (peek() === ":") {
                        // pseudo-element
                        next();
                        print_string("::");
                    } else {
                        // pseudo-class
                        print_string(':');
                    }
                }
            } else if (ch === '"' || ch === '\'') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString(ch));
            } else if (ch === ';') {
                insidePropertyValue = false;
                print_string(ch);
                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }
            } else if (ch === '(') { // may be a url
                if (lookBack("url")) {
                    print_string(ch);
                    eatWhitespace();
                    if (next()) {
                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
                            print_string(eatString(')'));
                        } else {
                            pos--;
                        }
                    }
                } else {
                    parenLevel++;
                    preserveSingleSpace(isAfterSpace);
                    print_string(ch);
                    eatWhitespace();
                }
            } else if (ch === ')') {
                print_string(ch);
                parenLevel--;
            } else if (ch === ',') {
                print_string(ch);
                if (!eatWhitespace(true) && selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
                    output.add_new_line();
                } else {
                    output.space_before_token = true;
                }
            } else if ((ch === '>' || ch === '+' || ch === '~') &&
                !insidePropertyValue && parenLevel < 1) {
                //handle combinator spacing
                if (space_around_combinator) {
                    output.space_before_token = true;
                    print_string(ch);
                    output.space_before_token = true;
                } else {
                    print_string(ch);
                    eatWhitespace();
                    // squash extra whitespace
                    if (ch && whiteRe.test(ch)) {
                        ch = '';
                    }
                }
            } else if (ch === ']') {
                print_string(ch);
            } else if (ch === '[') {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            } else if (ch === '=') { // no whitespace before or after
                eatWhitespace();
                print_string('=');
                if (whiteRe.test(ch)) {
                    ch = '';
                }

            } else {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            }
        }

        var sweetCode = output.get_code(end_with_newline, eol);

        return sweetCode;
    };

    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    this.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        // also in CONDITIONAL_GROUP_RULE below
        "@media": true,
        "@supports": true,
        "@document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
}

module.exports = css_beautify;

/***/ })
/******/ ]);
var css_beautify = legacy_beautify_css;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return {
            css_beautify: css_beautify
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    exports.css_beautify = css_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.css_beautify = css_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.css_beautify = css_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],172:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)  — indent <head> and <body> sections,
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to pre tag) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/

(function() {
var legacy_beautify_html =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

// function trim(s) {
//     return s.replace(/^\s+|\s+$/g, '');
// }

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

function rtrim(s) {
    return s.replace(/\s+$/g, '');
}

function Beautifier(html_source, options, js_beautify, css_beautify) {
    //Wrapper function to invoke all the necessary constructors and deal with the output.
    html_source = html_source || '';

    var multi_parser,
        indent_inner_html,
        indent_body_inner_html,
        indent_head_inner_html,
        indent_size,
        indent_character,
        wrap_line_length,
        brace_style,
        unformatted,
        content_unformatted,
        preserve_newlines,
        max_preserve_newlines,
        indent_handlebars,
        wrap_attributes,
        wrap_attributes_indent_size,
        is_wrap_attributes_force,
        is_wrap_attributes_force_expand_multiline,
        is_wrap_attributes_force_aligned,
        end_with_newline,
        extra_liners,
        eol;

    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'html');

    // backwards compatibility to 1.3.4
    if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
        (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
        options.wrap_line_length = options.max_char;
    }

    indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
    indent_body_inner_html = (options.indent_body_inner_html === undefined) ? true : options.indent_body_inner_html;
    indent_head_inner_html = (options.indent_head_inner_html === undefined) ? true : options.indent_head_inner_html;
    indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
    indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
    brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
    wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
    unformatted = options.unformatted || [
        // https://www.w3.org/TR/html5/dom.html#phrasing-content
        'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
        'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
        'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
        'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
        'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
        'video', 'wbr', 'text',
        // prexisting - not sure of full effect of removing, leaving in
        'acronym', 'address', 'big', 'dt', 'ins', 'strike', 'tt',
    ];
    content_unformatted = options.content_unformatted || [
        'pre',
    ];
    preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    max_preserve_newlines = preserve_newlines ?
        (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) :
        0;
    indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
    wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
    wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);
    is_wrap_attributes_force = wrap_attributes.substr(0, 'force'.length) === 'force';
    is_wrap_attributes_force_expand_multiline = (wrap_attributes === 'force-expand-multiline');
    is_wrap_attributes_force_aligned = (wrap_attributes === 'force-aligned');
    end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    extra_liners = (typeof options.extra_liners === 'object') && options.extra_liners ?
        options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
        options.extra_liners.split(',') : 'head,body,/html'.split(',');
    eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indent_character = '\t';
        indent_size = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (html_source && lineBreak.test(html_source || '')) {
            eol = html_source.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    html_source = html_source.replace(allLineBreaks, '\n');

    function Parser() {

        this.pos = 0; //Parser position
        this.token = '';
        this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
        this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
            parent: 'parent1',
            parentcount: 1,
            parent1: ''
        };
        this.tag_type = '';
        this.token_text = this.last_token = this.last_text = this.token_type = '';
        this.newlines = 0;
        this.indent_content = indent_inner_html;
        this.indent_body_inner_html = indent_body_inner_html;
        this.indent_head_inner_html = indent_head_inner_html;

        this.Utils = { //Uilities made available to the various functions
            whitespace: "\n\r\t ".split(''),

            single_token: options.void_elements || [
                // HTLM void elements - aka self-closing tags - aka singletons
                // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
                'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
                'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
                // NOTE: Optional tags - are not understood.
                // https://www.w3.org/TR/html5/syntax.html#optional-tags
                // The rules for optional tags are too complex for a simple list
                // Also, the content of these tags should still be indented in many cases.
                // 'li' is a good exmple.

                // Doctype and xml elements
                '!doctype', '?xml',
                // ?php tag
                '?php',
                // other tags that were in this list, keeping just in case
                'basefont', 'isindex'
            ],
            extra_liners: extra_liners, //for tags that need a line of whitespace before them
            in_array: function(what, arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (what === arr[i]) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Return true if the given text is composed entirely of whitespace.
        this.is_whitespace = function(text) {
            for (var n = 0; n < text.length; n++) {
                if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
                    return false;
                }
            }
            return true;
        };

        this.traverse_whitespace = function() {
            var input_char = '';

            input_char = this.input.charAt(this.pos);
            if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                this.newlines = 0;
                while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
                        this.newlines += 1;
                    }

                    this.pos++;
                    input_char = this.input.charAt(this.pos);
                }
                return true;
            }
            return false;
        };

        // Append a space to the given content (string array) or, if we are
        // at the wrap_line_length, append a newline/indentation.
        // return true if a newline was added, false if a space was added
        this.space_or_wrap = function(content) {
            if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
                this.print_newline(false, content);
                this.print_indentation(content);
                return true;
            } else {
                this.line_char_count++;
                content.push(' ');
                return false;
            }
        };

        this.get_content = function() { //function to capture regular content between tags
            var input_char = '',
                content = [],
                handlebarsStarted = 0;

            while (this.input.charAt(this.pos) !== '<' || handlebarsStarted === 2) {
                if (this.pos >= this.input.length) {
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                if (handlebarsStarted < 2 && this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                    continue;
                }

                input_char = this.input.charAt(this.pos);

                if (indent_handlebars) {
                    if (input_char === '{') {
                        handlebarsStarted += 1;
                    } else if (handlebarsStarted < 2) {
                        handlebarsStarted = 0;
                    }

                    if (input_char === '}' && handlebarsStarted > 0) {
                        if (handlebarsStarted-- === 0) {
                            break;
                        }
                    }
                    // Handlebars parsing is complicated.
                    // {{#foo}} and {{/foo}} are formatted tags.
                    // {{something}} should get treated as content, except:
                    // {{else}} specifically behaves like {{#if}} and {{/if}}
                    var peek3 = this.input.substr(this.pos, 3);
                    if (peek3 === '{{#' || peek3 === '{{/') {
                        // These are tags and not content.
                        break;
                    } else if (peek3 === '{{!') {
                        return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
                    } else if (this.input.substr(this.pos, 2) === '{{') {
                        if (this.get_tag(true) === '{{else}}') {
                            break;
                        }
                    }
                }

                this.pos++;
                this.line_char_count++;
                content.push(input_char); //letter at-a-time (or string) inserted to an array
            }
            return content.length ? content.join('') : '';
        };

        this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
            if (this.pos === this.input.length) {
                return ['', 'TK_EOF'];
            }
            var content = '';
            var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
            reg_match.lastIndex = this.pos;
            var reg_array = reg_match.exec(this.input);
            var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
            if (this.pos < end_script) { //get everything in between the script tags
                content = this.input.substring(this.pos, end_script);
                this.pos = end_script;
            }
            return content;
        };

        this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
            if (this.tags[tag + 'count']) { //check for the existence of this tag type
                this.tags[tag + 'count']++;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            } else { //otherwise initialize this tag type
                this.tags[tag + 'count'] = 1;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            }
            this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
            this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
        };

        this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
            if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
                var temp_parent = this.tags.parent; //check to see if it's a closable tag.
                while (temp_parent) { //till we reach '' (the initial value);
                    if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
                        break;
                    }
                    temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
                }
                if (temp_parent) { //if we caught something
                    this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
                    this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
                }
                delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
                delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
                if (this.tags[tag + 'count'] === 1) {
                    delete this.tags[tag + 'count'];
                } else {
                    this.tags[tag + 'count']--;
                }
            }
        };

        this.indent_to_tag = function(tag) {
            // Match the indentation level to the last use of this tag, but don't remove it.
            if (!this.tags[tag + 'count']) {
                return;
            }
            var temp_parent = this.tags.parent;
            while (temp_parent) {
                if (tag + this.tags[tag + 'count'] === temp_parent) {
                    break;
                }
                temp_parent = this.tags[temp_parent + 'parent'];
            }
            if (temp_parent) {
                this.indent_level = this.tags[tag + this.tags[tag + 'count']];
            }
        };

        this.get_tag = function(peek) { //function to get a full tag and parse its type
            var input_char = '',
                content = [],
                comment = '',
                space = false,
                first_attr = true,
                has_wrapped_attrs = false,
                tag_start, tag_end,
                tag_start_char,
                orig_pos = this.pos,
                orig_line_char_count = this.line_char_count,
                is_tag_closed = false,
                tail;

            peek = peek !== undefined ? peek : false;

            do {
                if (this.pos >= this.input.length) {
                    if (peek) {
                        this.pos = orig_pos;
                        this.line_char_count = orig_line_char_count;
                    }
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
                    space = true;
                    continue;
                }

                if (input_char === "'" || input_char === '"') {
                    input_char += this.get_unformatted(input_char);
                    space = true;
                }

                if (input_char === '=') { //no space before =
                    space = false;
                }
                tail = this.input.substr(this.pos - 1);
                if (is_wrap_attributes_force_expand_multiline && has_wrapped_attrs && !is_tag_closed && (input_char === '>' || input_char === '/')) {
                    if (tail.match(/^\/?\s*>/)) {
                        space = false;
                        is_tag_closed = true;
                        this.print_newline(false, content);
                        this.print_indentation(content);
                    }
                }
                if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
                    //no space after = or before >
                    var wrapped = this.space_or_wrap(content);
                    var indentAttrs = wrapped && input_char !== '/' && !is_wrap_attributes_force;
                    space = false;

                    if (is_wrap_attributes_force && input_char !== '/') {
                        var force_first_attr_wrap = false;
                        if (is_wrap_attributes_force_expand_multiline && first_attr) {
                            var is_only_attribute = tail.match(/^\S*(="([^"]|\\")*")?\s*\/?\s*>/) !== null;
                            force_first_attr_wrap = !is_only_attribute;
                        }
                        if (!first_attr || force_first_attr_wrap) {
                            this.print_newline(false, content);
                            this.print_indentation(content);
                            indentAttrs = true;
                        }
                    }
                    if (indentAttrs) {
                        has_wrapped_attrs = true;

                        //indent attributes an auto, forced, or forced-align line-wrap
                        var alignment_size = wrap_attributes_indent_size;
                        if (is_wrap_attributes_force_aligned) {
                            alignment_size = content.indexOf(' ') + 1;
                        }

                        for (var count = 0; count < alignment_size; count++) {
                            // only ever further indent with spaces since we're trying to align characters
                            content.push(' ');
                        }
                    }
                    if (first_attr) {
                        for (var i = 0; i < content.length; i++) {
                            if (content[i] === ' ') {
                                first_attr = false;
                                break;
                            }
                        }
                    }
                }

                if (indent_handlebars && tag_start_char === '<') {
                    // When inside an angle-bracket tag, put spaces around
                    // handlebars not inside of strings.
                    if ((input_char + this.input.charAt(this.pos)) === '{{') {
                        input_char += this.get_unformatted('}}');
                        if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
                            input_char = ' ' + input_char;
                        }
                        space = true;
                    }
                }

                if (input_char === '<' && !tag_start_char) {
                    tag_start = this.pos - 1;
                    tag_start_char = '<';
                }

                if (indent_handlebars && !tag_start_char) {
                    if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
                        if (input_char === '#' || input_char === '/' || input_char === '!') {
                            tag_start = this.pos - 3;
                        } else {
                            tag_start = this.pos - 2;
                        }
                        tag_start_char = '{';
                    }
                }

                this.line_char_count++;
                content.push(input_char); //inserts character at-a-time (or string)

                if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
                    break;
                }
            } while (input_char !== '>');

            var tag_complete = content.join('');
            var tag_index;
            var tag_offset;

            // must check for space first otherwise the tag could have the first attribute included, and
            // then not un-indent correctly
            if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
                tag_index = tag_complete.indexOf(' ');
            } else if (tag_complete.indexOf('\n') !== -1) { //if there's a line break, thats where the tag name ends
                tag_index = tag_complete.indexOf('\n');
            } else if (tag_complete.charAt(0) === '{') {
                tag_index = tag_complete.indexOf('}');
            } else { //otherwise go with the tag ending
                tag_index = tag_complete.indexOf('>');
            }
            if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
                tag_offset = 1;
            } else {
                tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
            }
            var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
            if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
                this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
                if (!peek) {
                    this.tag_type = 'SINGLE';
                }
            } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
                if (!peek) {
                    this.indent_to_tag('if');
                    this.tag_type = 'HANDLEBARS_ELSE';
                    this.indent_content = true;
                    this.traverse_whitespace();
                }
            } else if (this.is_unformatted(tag_check, unformatted) ||
                this.is_unformatted(tag_check, content_unformatted)) {
                // do not reformat the "unformatted" or "content_unformatted" tags
                comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
                content.push(comment);
                tag_end = this.pos - 1;
                this.tag_type = 'SINGLE';
            } else if (tag_check === 'script' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 &&
                        tag_complete.search(/\b(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'SCRIPT';
                }
            } else if (tag_check === 'style' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'STYLE';
                }
            } else if (tag_check.charAt(0) === '!') { //peek for <! comment
                // for comments content is already correct.
                if (!peek) {
                    this.tag_type = 'SINGLE';
                    this.traverse_whitespace();
                }
            } else if (!peek) {
                if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
                    this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
                    this.tag_type = 'END';
                } else { //otherwise it's a start-tag
                    this.record_tag(tag_check); //push it on the tag stack
                    if (tag_check.toLowerCase() !== 'html') {
                        this.indent_content = true;
                    }
                    this.tag_type = 'START';
                }

                // Allow preserving of newlines after a start or end tag
                if (this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                }

                if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
                    this.print_newline(false, this.output);
                    if (this.output.length && this.output[this.output.length - 2] !== '\n') {
                        this.print_newline(true, this.output);
                    }
                }
            }

            if (peek) {
                this.pos = orig_pos;
                this.line_char_count = orig_line_char_count;
            }

            return content.join(''); //returns fully formatted tag
        };

        this.get_comment = function(start_pos) { //function to return comment content in its entirety
            // this is will have very poor perf, but will work for now.
            var comment = '',
                delimiter = '>',
                matched = false;

            this.pos = start_pos;
            var input_char = this.input.charAt(this.pos);
            this.pos++;

            while (this.pos <= this.input.length) {
                comment += input_char;

                // only need to check for the delimiter if the last chars match
                if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
                    comment.indexOf(delimiter) !== -1) {
                    break;
                }

                // only need to search for custom delimiter for the first few characters
                if (!matched && comment.length < 10) {
                    if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
                        delimiter = '<![endif]>';
                        matched = true;
                    } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
                        delimiter = ']]>';
                        matched = true;
                    } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
                        delimiter = ']>';
                        matched = true;
                    } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
                        delimiter = '-->';
                        matched = true;
                    } else if (comment.indexOf('{{!--') === 0) { // {{!-- handlebars comment
                        delimiter = '--}}';
                        matched = true;
                    } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
                        if (comment.length === 5 && comment.indexOf('{{!--') === -1) {
                            delimiter = '}}';
                            matched = true;
                        }
                    } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
                        delimiter = '?>';
                        matched = true;
                    } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
                        delimiter = '%>';
                        matched = true;
                    }
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;
            }

            return comment;
        };

        function tokenMatcher(delimiter) {
            var token = '';

            var add = function(str) {
                var newToken = token + str.toLowerCase();
                token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);
            };

            var doesNotMatch = function() {
                return token.indexOf(delimiter) === -1;
            };

            return {
                add: add,
                doesNotMatch: doesNotMatch
            };
        }

        this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety
            if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
                return '';
            }
            var input_char = '';
            var content = '';
            var space = true;

            var delimiterMatcher = tokenMatcher(delimiter);

            do {

                if (this.pos >= this.input.length) {
                    return content;
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (!space) {
                        this.line_char_count--;
                        continue;
                    }
                    if (input_char === '\n' || input_char === '\r') {
                        content += '\n';
                        /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            */
                        this.line_char_count = 0;
                        continue;
                    }
                }
                content += input_char;
                delimiterMatcher.add(input_char);
                this.line_char_count++;
                space = true;

                if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
                    // Handlebars expressions in strings should also be unformatted.
                    content += this.get_unformatted('}}');
                    // Don't consider when stopping for delimiters.
                }
            } while (delimiterMatcher.doesNotMatch());

            return content;
        };

        this.get_token = function() { //initial handler for token-retrieval
            var token;

            if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
                var type = this.last_token.substr(7);
                token = this.get_contents_to(type);
                if (typeof token !== 'string') {
                    return token;
                }
                return [token, 'TK_' + type];
            }
            if (this.current_mode === 'CONTENT') {
                token = this.get_content();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    return [token, 'TK_CONTENT'];
                }
            }

            if (this.current_mode === 'TAG') {
                token = this.get_tag();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    var tag_name_type = 'TK_TAG_' + this.tag_type;
                    return [token, tag_name_type];
                }
            }
        };

        this.get_full_indent = function(level) {
            level = this.indent_level + level || 0;
            if (level < 1) {
                return '';
            }

            return Array(level + 1).join(this.indent_string);
        };

        this.is_unformatted = function(tag_check, unformatted) {
            //is this an HTML5 block-level link?
            if (!this.Utils.in_array(tag_check, unformatted)) {
                return false;
            }

            if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
                return true;
            }

            //at this point we have an  tag; is its first child something we want to remain
            //unformatted?
            var next_tag = this.get_tag(true /* peek. */ );

            // test next_tag to see if it is just html tag (no external content)
            var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

            // if next_tag comes back but is not an isolated tag, then
            // let's treat the 'a' tag as having content
            // and respect the unformatted option
            if (!tag || this.Utils.in_array(tag[1], unformatted)) {
                return true;
            } else {
                return false;
            }
        };

        this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

            this.input = js_source || ''; //gets the input for the Parser

            // HACK: newline parsing inconsistent. This brute force normalizes the input.
            this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n');

            this.output = [];
            this.indent_character = indent_character;
            this.indent_string = '';
            this.indent_size = indent_size;
            this.brace_style = brace_style;
            this.indent_level = 0;
            this.wrap_line_length = wrap_line_length;
            this.line_char_count = 0; //count to see if wrap_line_length was exceeded

            for (var i = 0; i < this.indent_size; i++) {
                this.indent_string += this.indent_character;
            }

            this.print_newline = function(force, arr) {
                this.line_char_count = 0;
                if (!arr || !arr.length) {
                    return;
                }
                if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
                    if ((arr[arr.length - 1] !== '\n')) {
                        arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
                    }
                    arr.push('\n');
                }
            };

            this.print_indentation = function(arr) {
                for (var i = 0; i < this.indent_level; i++) {
                    arr.push(this.indent_string);
                    this.line_char_count += this.indent_string.length;
                }
            };

            this.print_token = function(text) {
                // Avoid printing initial whitespace.
                if (this.is_whitespace(text) && !this.output.length) {
                    return;
                }
                if (text || text !== '') {
                    if (this.output.length && this.output[this.output.length - 1] === '\n') {
                        this.print_indentation(this.output);
                        text = ltrim(text);
                    }
                }
                this.print_token_raw(text);
            };

            this.print_token_raw = function(text) {
                // If we are going to print newlines, truncate trailing
                // whitespace, as the newlines will represent the space.
                if (this.newlines > 0) {
                    text = rtrim(text);
                }

                if (text && text !== '') {
                    if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
                        // unformatted tags can grab newlines as their last character
                        this.output.push(text.slice(0, -1));
                        this.print_newline(false, this.output);
                    } else {
                        this.output.push(text);
                    }
                }

                for (var n = 0; n < this.newlines; n++) {
                    this.print_newline(n > 0, this.output);
                }
                this.newlines = 0;
            };

            this.indent = function() {
                this.indent_level++;
            };

            this.unindent = function() {
                if (this.indent_level > 0) {
                    this.indent_level--;
                }
            };
        };
        return this;
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        multi_parser = new Parser(); //wrapping functions Parser
        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values
        while (true) {
            var t = multi_parser.get_token();
            multi_parser.token_text = t[0];
            multi_parser.token_type = t[1];

            if (multi_parser.token_type === 'TK_EOF') {
                break;
            }

            switch (multi_parser.token_type) {
                case 'TK_TAG_START':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) &&
                            (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {

                            multi_parser.indent();
                        }

                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_STYLE':
                case 'TK_TAG_SCRIPT':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_END':
                    //Print new line only if the tag has no content and has child
                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
                        var tag_name = (multi_parser.token_text.match(/\w+/) || [])[0];
                        var tag_extracted_from_last_output = null;
                        if (multi_parser.output.length) {
                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
                        }
                        if (tag_extracted_from_last_output === null ||
                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
                            multi_parser.print_newline(false, multi_parser.output);
                        }
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_SINGLE':
                    // Don't add a newline before elements that should remain unformatted.
                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_ELSE':
                    // Don't add a newline if opening {{#if}} tag is on the current line
                    var foundIfOnCurrentLine = false;
                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
                        if (multi_parser.output[lastCheckedOutput] === '\n') {
                            break;
                        } else {
                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {
                                foundIfOnCurrentLine = true;
                                break;
                            }
                        }
                    }
                    if (!foundIfOnCurrentLine) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_COMMENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_CONTENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_STYLE':
                case 'TK_SCRIPT':
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_newline(false, multi_parser.output);
                        var text = multi_parser.token_text,
                            _beautifier,
                            script_indent_level = 1;
                        if (multi_parser.token_type === 'TK_SCRIPT') {
                            _beautifier = typeof js_beautify === 'function' && js_beautify;
                        } else if (multi_parser.token_type === 'TK_STYLE') {
                            _beautifier = typeof css_beautify === 'function' && css_beautify;
                        }

                        if (options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (options.indent_scripts === "separate") {
                            script_indent_level = -multi_parser.indent_level;
                        }

                        var indentation = multi_parser.get_full_indent(script_indent_level);
                        if (_beautifier) {

                            // call the Beautifier if avaliable
                            var Child_options = function() {
                                this.eol = '\n';
                            };
                            Child_options.prototype = options;
                            var child_options = new Child_options();
                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
                        } else {
                            // simply indent the string otherwise
                            var white = text.match(/^\s*/)[0];
                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
                            text = text.replace(/^\s*/, indentation)
                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
                                .replace(/\s+$/, '');
                        }
                        if (text) {
                            multi_parser.print_token_raw(text);
                            multi_parser.print_newline(true, multi_parser.output);
                        }
                    }
                    multi_parser.current_mode = 'TAG';
                    break;
                default:
                    // We should not be getting here but we don't want to drop input on the floor
                    // Just output the text and move on
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_token(multi_parser.token_text);
                    }
                    break;
            }
            multi_parser.last_token = multi_parser.token_type;
            multi_parser.last_text = multi_parser.token_text;
        }
        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

        // establish end_with_newline
        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function style_html(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
}

module.exports = style_html;

/***/ })
/******/ ]);
var style_html = legacy_beautify_html;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define(["require", "./beautify", "./beautify-css"], function(requireamd) {
        var js_beautify = requireamd("./beautify");
        var css_beautify = requireamd("./beautify-css");

        return {
            html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
            }
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    var js_beautify = require('./beautify.js');
    var css_beautify = require('./beautify-css.js');

    exports.html_beautify = function(html_source, options) {
        return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
    };
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.html_beautify = function(html_source, options) {
        return style_html(html_source, options, window.js_beautify, window.css_beautify);
    };
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.html_beautify = function(html_source, options) {
        return style_html(html_source, options, global.js_beautify, global.css_beautify);
    };
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./beautify-css.js":171,"./beautify.js":173}],173:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/* see js/src/javascript/index.js */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {
var legacy_beautify_js =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var mergeOpts = __webpack_require__(3).mergeOpts;
var acorn = __webpack_require__(0);
var Output = __webpack_require__(4).Output;
var Tokenizer = __webpack_require__(7).Tokenizer;

function remove_redundant_indentation(output, frame) {
    // This implementation is effective but has some issues:
    //     - can cause line wrap to happen too soon due to indent removal
    //           after wrap points are calculated
    // These issues are minor compared to ugly indentation.

    if (frame.multiline_frame ||
        frame.mode === MODE.ForInitializer ||
        frame.mode === MODE.Conditional) {
        return;
    }

    // remove one indent from each line inside this section
    var start_index = frame.start_line_index;

    output.remove_indent(start_index);
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

// function rtrim(s) {
//     return s.replace(/\s+$/g, '');
// }


function generateMapFromStrings(list) {
    var result = {};
    for (var x = 0; x < list.length; x++) {
        // make the mapped names underscored instead of dash
        result[list[x].replace(/-/g, '_')] = list[x];
    }
    return result;
}

function sanitizeOperatorPosition(opPosition) {
    opPosition = opPosition || OPERATOR_POSITION.before_newline;

    if (!in_array(opPosition, validPositionValues)) {
        throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
            validPositionValues +
            "\nYou passed in: '" + opPosition + "'");
    }

    return opPosition;
}

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
    BlockStatement: 'BlockStatement', // 'BLOCK'
    Statement: 'Statement', // 'STATEMENT'
    ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
    ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
    ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
    Conditional: 'Conditional', //'(COND-EXPRESSION)',
    Expression: 'Expression' //'(EXPRESSION)'
};

function Beautifier(js_source_text, options) {
    "use strict";
    var output;
    var tokens = [],
        token_pos;
    var tokenizer;
    var current_token;
    var last_type, last_last_text, indent_string;
    var flags, previous_flags, flag_store;
    var prefix;

    var handlers, opt;
    var baseIndentString = '';

    handlers = {
        'TK_START_EXPR': handle_start_expr,
        'TK_END_EXPR': handle_end_expr,
        'TK_START_BLOCK': handle_start_block,
        'TK_END_BLOCK': handle_end_block,
        'TK_WORD': handle_word,
        'TK_RESERVED': handle_word,
        'TK_SEMICOLON': handle_semicolon,
        'TK_STRING': handle_string,
        'TK_EQUALS': handle_equals,
        'TK_OPERATOR': handle_operator,
        'TK_COMMA': handle_comma,
        'TK_BLOCK_COMMENT': handle_block_comment,
        'TK_COMMENT': handle_comment,
        'TK_DOT': handle_dot,
        'TK_UNKNOWN': handle_unknown,
        'TK_EOF': handle_eof
    };

    function create_flags(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
            next_indent_level = flags_base.indentation_level;
            if (!output.just_added_newline() &&
                flags_base.line_indent_level > next_indent_level) {
                next_indent_level = flags_base.line_indent_level;
            }
        }

        var next_flags = {
            mode: mode,
            parent: flags_base,
            last_text: flags_base ? flags_base.last_text : '', // last token text
            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
            declaration_statement: false,
            declaration_assignment: false,
            multiline_frame: false,
            inline_frame: false,
            if_block: false,
            else_block: false,
            do_block: false,
            do_while: false,
            import_block: false,
            in_case_statement: false, // switch(..){ INSIDE HERE }
            in_case: false, // we're on the exact line with "case 0:"
            case_body: false, // the indented case-action block
            indentation_level: next_indent_level,
            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
            start_line_index: output.get_line_number(),
            ternary_depth: 0
        };
        return next_flags;
    }

    // Some interpreters have unexpected results with foo = baz || bar;
    options = options ? options : {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'js');

    opt = {};

    // compatibility, re
    if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
        options.brace_style = "expand";
    } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
        options.brace_style = "collapse,preserve-inline";
    } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
        options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
    } else if (!options.brace_style) //Nothing exists to set it
    {
        options.brace_style = "collapse";
    }


    var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
    opt.brace_style = brace_style_split[0];
    opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    opt.indent_char = options.indent_char ? options.indent_char : ' ';
    opt.eol = options.eol ? options.eol : 'auto';
    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    opt.unindent_chained_methods = (options.unindent_chained_methods === undefined) ? false : options.unindent_chained_methods;
    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
    opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
    opt.e4x = (options.e4x === undefined) ? false : options.e4x;
    opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
    opt.operator_position = sanitizeOperatorPosition(options.operator_position);

    // For testing of beautify ignore:start directive
    opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

    // force opt.space_after_anon_function to true if opt.jslint_happy
    if (opt.jslint_happy) {
        opt.space_after_anon_function = true;
    }

    if (options.indent_with_tabs) {
        opt.indent_char = '\t';
        opt.indent_size = 1;
    }

    if (opt.eol === 'auto') {
        opt.eol = '\n';
        if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
            opt.eol = js_source_text.match(acorn.lineBreak)[0];
        }
    }

    opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    //----------------------------------
    indent_string = '';
    while (opt.indent_size > 0) {
        indent_string += opt.indent_char;
        opt.indent_size -= 1;
    }

    var preindent_index = 0;
    if (js_source_text && js_source_text.length) {
        while ((js_source_text.charAt(preindent_index) === ' ' ||
                js_source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = js_source_text.substring(0, preindent_index);
        js_source_text = js_source_text.substring(preindent_index);
    }

    last_type = 'TK_START_BLOCK'; // last token type
    last_last_text = ''; // pre-last token text
    output = new Output(indent_string, baseIndentString);

    // If testing the ignore directive, start with output disable set to true
    output.raw = opt.test_output_raw;


    // Stack of parsing/formatting states, including MODE.
    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
    // and formatted output.  This makes the beautifier less accurate than full parsers
    // but also far more tolerant of syntax errors.
    //
    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
    // most full parsers would die, but the beautifier gracefully falls back to
    // MODE.BlockStatement and continues on.
    flag_store = [];
    set_mode(MODE.BlockStatement);

    this.beautify = function() {

        /*jshint onevar:true */
        var sweet_code;
        tokenizer = new Tokenizer(js_source_text, opt, indent_string);
        tokens = tokenizer.tokenize();
        token_pos = 0;

        current_token = get_token();
        while (current_token) {
            handlers[current_token.type]();

            last_last_text = flags.last_text;
            last_type = current_token.type;
            flags.last_text = current_token.text;

            token_pos += 1;
            current_token = get_token();
        }

        sweet_code = output.get_code(opt.end_with_newline, opt.eol);

        return sweet_code;
    };

    function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
        var newlines = local_token.newlines;
        var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
        var temp_token = current_token;

        for (var h = 0; h < local_token.comments_before.length; h++) {
            // The cleanest handling of inline comments is to treat them as though they aren't there.
            // Just continue formatting and the behavior should be logical.
            // Also ignore unknown tokens.  Again, this should result in better behavior.
            current_token = local_token.comments_before[h];
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
            handlers[current_token.type](preserve_statement_flags);
        }
        current_token = temp_token;

        if (keep_whitespace) {
            for (var i = 0; i < newlines; i += 1) {
                print_newline(i > 0, preserve_statement_flags);
            }
        } else {
            if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
                newlines = opt.max_preserve_newlines;
            }

            if (opt.preserve_newlines) {
                if (local_token.newlines > 1) {
                    print_newline(false, preserve_statement_flags);
                    for (var j = 1; j < newlines; j += 1) {
                        print_newline(true, preserve_statement_flags);
                    }
                }
            }
        }

    }

    // we could use just string.split, but
    // IE doesn't like returning empty strings
    function split_linebreaks(s) {
        //return s.split(/\x0d\x0a|\x0a/);

        s = s.replace(acorn.allLineBreaks, '\n');
        var out = [],
            idx = s.indexOf("\n");
        while (idx !== -1) {
            out.push(s.substring(0, idx));
            s = s.substring(idx + 1);
            idx = s.indexOf("\n");
        }
        if (s.length) {
            out.push(s);
        }
        return out;
    }

    var newline_restricted_tokens = ['break', 'continue', 'return', 'throw', 'yield'];

    function allow_wrap_or_preserved_newline(force_linewrap) {
        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

        // Never wrap the first token on a line
        if (output.just_added_newline()) {
            return;
        }

        var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
        var operatorLogicApplies = in_array(flags.last_text, tokenizer.positionable_operators) || in_array(current_token.text, tokenizer.positionable_operators);

        if (operatorLogicApplies) {
            var shouldPrintOperatorNewline = (
                    in_array(flags.last_text, tokenizer.positionable_operators) &&
                    in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
                ) ||
                in_array(current_token.text, tokenizer.positionable_operators);
            shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }

        if (shouldPreserveOrForce) {
            print_newline(false, true);
        } else if (opt.wrap_line_length) {
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
                // These tokens should never have a newline inserted
                // between them and the following expression.
                return;
            }
            var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
                (output.space_before_token ? 1 : 0);
            if (proposed_line_length >= opt.wrap_line_length) {
                print_newline(false, true);
            }
        }
    }

    function print_newline(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                var next_token = get_token(1);
                while (flags.mode === MODE.Statement &&
                    !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
                    !flags.do_block) {
                    restore_mode();
                }
            }
        }

        if (output.add_new_line(force_newline)) {
            flags.multiline_frame = true;
        }
    }

    function print_token_line_indentation() {
        if (output.just_added_newline()) {
            if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
                output.current_line.push(current_token.whitespace_before);
                output.space_before_token = false;
            } else if (output.set_indent(flags.indentation_level)) {
                flags.line_indent_level = flags.indentation_level;
            }
        }
    }

    function print_token(printable_token) {
        if (output.raw) {
            output.add_raw_token(current_token);
            return;
        }

        if (opt.comma_first && last_type === 'TK_COMMA' &&
            output.just_added_newline()) {
            if (output.previous_line.last() === ',') {
                var popped = output.previous_line.pop();
                // if the comma was already at the start of the line,
                // pull back onto that line and reprint the indentation
                if (output.previous_line.is_empty()) {
                    output.previous_line.push(popped);
                    output.trim(true);
                    output.current_line.pop();
                    output.trim();
                }

                // add the comma in front of the next token
                print_token_line_indentation();
                output.add_token(',');
                output.space_before_token = true;
            }
        }

        printable_token = printable_token || current_token.text;
        print_token_line_indentation();
        output.add_token(printable_token);
    }

    function indent() {
        flags.indentation_level += 1;
    }

    function deindent() {
        if (flags.indentation_level > 0 &&
            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
            flags.indentation_level -= 1;

        }
    }

    function set_mode(mode) {
        if (flags) {
            flag_store.push(flags);
            previous_flags = flags;
        } else {
            previous_flags = create_flags(null, mode);
        }

        flags = create_flags(previous_flags, mode);
    }

    function is_array(mode) {
        return mode === MODE.ArrayLiteral;
    }

    function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
    }

    function restore_mode() {
        if (flag_store.length > 0) {
            previous_flags = flags;
            flags = flag_store.pop();
            if (previous_flags.mode === MODE.Statement && !opt.unindent_chained_methods) {
                remove_redundant_indentation(output, previous_flags);
            }
        }
    }

    function start_of_object_property() {
        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
            (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
    }

    function start_of_statement() {
        if (
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens) && !current_token.wanted_newline) ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
                !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
            (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
            (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
                !flags.in_case &&
                !(current_token.text === '--' || current_token.text === '++') &&
                last_last_text !== 'function' &&
                current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
            (flags.mode === MODE.ObjectLiteral && (
                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
        ) {

            set_mode(MODE.Statement);
            if (!opt.unindent_chained_methods) {
                indent();
            }

            handle_whitespace_and_comments(current_token, true);

            // Issue #276:
            // If starting a new statement with [if, for, while, do], push to a new line.
            // if (a) if (b) if(c) d(); else e(); else f();
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline(
                    current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
            }

            return true;
        }
        return false;
    }

    function all_lines_start_with(lines, c) {
        for (var i = 0; i < lines.length; i++) {
            var line = trim(lines[i]);
            if (line.charAt(0) !== c) {
                return false;
            }
        }
        return true;
    }

    function each_line_matches_indent(lines, indent) {
        var i = 0,
            len = lines.length,
            line;
        for (; i < len; i++) {
            line = lines[i];
            // allow empty lines to pass through
            if (line && line.indexOf(indent) !== 0) {
                return false;
            }
        }
        return true;
    }

    function is_special_word(word) {
        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
    }

    function get_token(offset) {
        var index = token_pos + (offset || 0);
        return (index < 0 || index >= tokens.length) ? null : tokens[index];
    }

    function handle_start_expr() {
        // The conditional starts the statement if appropriate.
        if (!start_of_statement()) {
            handle_whitespace_and_comments(current_token);
        }

        var next_mode = MODE.Expression;
        if (current_token.text === '[') {

            if (last_type === 'TK_WORD' || flags.last_text === ')') {
                // this is array index specifier, break immediately
                // a[x], fn()[x]
                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, tokenizer.line_starters)) {
                    output.space_before_token = true;
                }
                set_mode(next_mode);
                print_token();
                indent();
                if (opt.space_in_paren) {
                    output.space_before_token = true;
                }
                return;
            }

            next_mode = MODE.ArrayLiteral;
            if (is_array(flags.mode)) {
                if (flags.last_text === '[' ||
                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                    // ], [ goes to new line
                    // }, [ goes to new line
                    if (!opt.keep_array_indentation) {
                        print_newline();
                    }
                }
            }

        } else {
            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                next_mode = MODE.ForInitializer;
            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                next_mode = MODE.Conditional;
            } else {
                // next_mode = MODE.Expression;
            }
        }

        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
            print_newline();
        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
            allow_wrap_or_preserved_newline(current_token.wanted_newline);
            // do nothing on (( and )( and ][ and ]( and .(
        } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
            output.space_before_token = true;
        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            // function() vs function ()
            // yield*() vs yield* ()
            // function*() vs function* ()
            if (opt.space_after_anon_function) {
                output.space_before_token = true;
            }
        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, tokenizer.line_starters) || flags.last_text === 'catch')) {
            if (opt.space_before_conditional) {
                output.space_before_token = true;
            }
        }

        // Should be a space between await and an IIFE, or async and an arrow function
        if (current_token.text === '(' && last_type === 'TK_RESERVED' && in_array(flags.last_word, ['await', 'async'])) {
            output.space_before_token = true;
        }

        // Support of this kind of newline preservation.
        // a = (b &&
        //     (c || d));
        if (current_token.text === '(') {
            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
        }

        // Support preserving wrapped arrow function expressions
        // a.b('c',
        //     () => d.e
        // )
        if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
            allow_wrap_or_preserved_newline();
        }

        set_mode(next_mode);
        print_token();
        if (opt.space_in_paren) {
            output.space_before_token = true;
        }

        // In all cases, if we newline while inside an expression it should be indented.
        indent();
    }

    function handle_end_expr() {
        // statements inside expressions are not valid syntax, but...
        // statements must all be closed when their container closes
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        handle_whitespace_and_comments(current_token);

        if (flags.multiline_frame) {
            allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
        }

        if (opt.space_in_paren) {
            if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
                // () [] no inner space in empty parens like these, ever, ref #320
                output.trim();
                output.space_before_token = false;
            } else {
                output.space_before_token = true;
            }
        }
        if (current_token.text === ']' && opt.keep_array_indentation) {
            print_token();
            restore_mode();
        } else {
            restore_mode();
            print_token();
        }
        remove_redundant_indentation(output, previous_flags);

        // do {} while () // no statement required after
        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
            previous_flags.mode = MODE.Expression;
            flags.do_block = false;
            flags.do_while = false;

        }
    }

    function handle_start_block() {
        handle_whitespace_and_comments(current_token);

        // Check if this is should be treated as a ObjectLiteral
        var next_token = get_token(1);
        var second_token = get_token(2);
        if (second_token && (
                (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
                (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
            )) {
            // We don't support TypeScript,but we didn't break it for a very long time.
            // We'll try to keep not breaking it.
            if (!in_array(last_last_text, ['class', 'interface'])) {
                set_mode(MODE.ObjectLiteral);
            } else {
                set_mode(MODE.BlockStatement);
            }
        } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
            // arrow function: (param1, paramN) => { statements }
            set_mode(MODE.BlockStatement);
        } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
        ) {
            // Detecting shorthand function syntax is difficult by scanning forward,
            //     so check the surrounding context.
            // If the block is being returned, imported, export default, passed as arg,
            //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
            set_mode(MODE.ObjectLiteral);
        } else {
            set_mode(MODE.BlockStatement);
        }

        var empty_braces = !next_token.comments_before.length && next_token.text === '}';
        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
            last_type === 'TK_END_EXPR';

        if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
        {
            // search forward for a newline wanted inside this block
            var index = 0;
            var check_token = null;
            flags.inline_frame = true;
            do {
                index += 1;
                check_token = get_token(index);
                if (check_token.wanted_newline) {
                    flags.inline_frame = false;
                    break;
                }
            } while (check_token.type !== 'TK_EOF' &&
                !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
        }

        if ((opt.brace_style === "expand" ||
                (opt.brace_style === "none" && current_token.wanted_newline)) &&
            !flags.inline_frame) {
            if (last_type !== 'TK_OPERATOR' &&
                (empty_anonymous_function ||
                    last_type === 'TK_EQUALS' ||
                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                output.space_before_token = true;
            } else {
                print_newline(false, true);
            }
        } else { // collapse || inline_frame
            if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
                if (last_type === 'TK_COMMA' || opt.space_in_paren) {
                    output.space_before_token = true;
                }

                if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
                    allow_wrap_or_preserved_newline();
                    previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
                    flags.multiline_frame = false;
                }
            }
            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
                    print_newline();
                } else {
                    output.space_before_token = true;
                }
            }
        }
        print_token();
        indent();
    }

    function handle_end_block() {
        // statements must all be closed when their container closes
        handle_whitespace_and_comments(current_token);

        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        var empty_braces = last_type === 'TK_START_BLOCK';

        if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
            output.space_before_token = true;
        } else if (opt.brace_style === "expand") {
            if (!empty_braces) {
                print_newline();
            }
        } else {
            // skip {}
            if (!empty_braces) {
                if (is_array(flags.mode) && opt.keep_array_indentation) {
                    // we REALLY need a newline here, but newliner would skip that
                    opt.keep_array_indentation = false;
                    print_newline();
                    opt.keep_array_indentation = true;

                } else {
                    print_newline();
                }
            }
        }
        restore_mode();
        print_token();
    }

    function handle_word() {
        if (current_token.type === 'TK_RESERVED') {
            if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
                current_token.type = 'TK_WORD';
            } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
                current_token.type = 'TK_WORD';
            } else if (flags.mode === MODE.ObjectLiteral) {
                var next_token = get_token(1);
                if (next_token.text === ':') {
                    current_token.type = 'TK_WORD';
                }
            }
        }

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
                flags.declaration_statement = true;
            }
        } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
            last_type !== 'TK_EQUALS' &&
            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
            handle_whitespace_and_comments(current_token);
            print_newline();
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.do_block && !flags.do_while) {
            if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
                // do {} ## while ()
                output.space_before_token = true;
                print_token();
                output.space_before_token = true;
                flags.do_while = true;
                return;
            } else {
                // do {} should always have while as the next word.
                // if we don't see the expected while, recover
                print_newline();
                flags.do_block = false;
            }
        }

        // if may be followed by else, or not
        // Bare/inline ifs are tricky
        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
        if (flags.if_block) {
            if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
                flags.else_block = true;
            } else {
                while (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                flags.if_block = false;
                flags.else_block = false;
            }
        }

        if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
            print_newline();
            if (flags.case_body || opt.jslint_happy) {
                // switch cases following one another
                deindent();
                flags.case_body = false;
            }
            print_token();
            flags.in_case = true;
            flags.in_case_statement = true;
            return;
        }

        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline();
            }
        }

        if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
            if (in_array(flags.last_text, ['}', ';']) ||
                (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
                // make sure there is a nice clean space of at least one blank line
                // before a new function definition
                if (!output.just_added_blankline() && !current_token.comments_before.length) {
                    print_newline();
                    print_newline(true);
                }
            }
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                if (last_type === 'TK_RESERVED' && (
                        in_array(flags.last_text, ['get', 'set', 'new', 'export', 'async']) ||
                        in_array(flags.last_text, newline_restricted_tokens))) {
                    output.space_before_token = true;
                } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
                    output.space_before_token = true;
                } else {
                    print_newline();
                }
            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                // foo = function
                output.space_before_token = true;
            } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
                // (function
            } else {
                print_newline();
            }

            print_token();
            flags.last_word = current_token.text;
            return;
        }

        prefix = 'NONE';

        if (last_type === 'TK_END_BLOCK') {

            if (previous_flags.inline_frame) {
                prefix = 'SPACE';
            } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
                prefix = 'NEWLINE';
            } else {
                if (opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) {
                    prefix = 'NEWLINE';
                } else {
                    prefix = 'SPACE';
                    output.space_before_token = true;
                }
            }
        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
            // TODO: Should this be for STATEMENT as well?
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_STRING') {
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_START_BLOCK') {
            if (flags.inline_frame) {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }
        } else if (last_type === 'TK_END_EXPR') {
            output.space_before_token = true;
            prefix = 'NEWLINE';
        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
            if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }

        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
            if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
                    opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) &&
                !flags.inline_frame) {
                print_newline();
            } else {
                output.trim(true);
                var line = output.current_line;
                // If we trimmed and there's something other than a close block before us
                // put a newline back in.  Handles '} // comment' scenario.
                if (line.last() !== '}') {
                    print_newline();
                }
                output.space_before_token = true;
            }
        } else if (prefix === 'NEWLINE') {
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // no newline between 'return nnn'
                output.space_before_token = true;
            } else if (last_type !== 'TK_END_EXPR') {
                if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                    // no need to force newline on 'var': for (var x = 0...)
                    if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                        // no newline for } else if {
                        output.space_before_token = true;
                    } else {
                        print_newline();
                    }
                }
            } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
                print_newline();
            }
        } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
            print_newline(); // }, in lists get a newline treatment
        } else if (prefix === 'SPACE') {
            output.space_before_token = true;
        }
        print_token();
        flags.last_word = current_token.text;

        if (current_token.type === 'TK_RESERVED') {
            if (current_token.text === 'do') {
                flags.do_block = true;
            } else if (current_token.text === 'if') {
                flags.if_block = true;
            } else if (current_token.text === 'import') {
                flags.import_block = true;
            } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
                flags.import_block = false;
            }
        }
    }

    function handle_semicolon() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // Semicolon can be the start (and end) of a statement
            output.space_before_token = false;
        } else {
            handle_whitespace_and_comments(current_token);
        }

        var next_token = get_token(1);
        while (flags.mode === MODE.Statement &&
            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
            !flags.do_block) {
            restore_mode();
        }

        // hacky but effective for the moment
        if (flags.import_block) {
            flags.import_block = false;
        }
        print_token();
    }

    function handle_string() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // One difference - strings want at least a space before
            output.space_before_token = true;
        } else {
            handle_whitespace_and_comments(current_token);
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
                output.space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
        }
        print_token();
    }

    function handle_equals() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.declaration_statement) {
            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
            flags.declaration_assignment = true;
        }
        output.space_before_token = true;
        print_token();
        output.space_before_token = true;
    }

    function handle_comma() {
        handle_whitespace_and_comments(current_token, true);

        print_token();
        output.space_before_token = true;
        if (flags.declaration_statement) {
            if (is_expression(flags.parent.mode)) {
                // do not break on comma, for(var a = 1, b = 2)
                flags.declaration_assignment = false;
            }

            if (flags.declaration_assignment) {
                flags.declaration_assignment = false;
                print_newline(false, true);
            } else if (opt.comma_first) {
                // for comma-first, we want to allow a newline before the comma
                // to turn into a newline after the comma, which we will fixup later
                allow_wrap_or_preserved_newline();
            }
        } else if (flags.mode === MODE.ObjectLiteral ||
            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
            if (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (!flags.inline_frame) {
                print_newline();
            }
        } else if (opt.comma_first) {
            // EXPR or DO_BLOCK
            // for comma-first, we want to allow a newline before the comma
            // to turn into a newline after the comma, which we will fixup later
            allow_wrap_or_preserved_newline();
        }
    }

    function handle_operator() {
        var isGeneratorAsterisk = current_token.text === '*' &&
            ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
                (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
            );
        var isUnary = in_array(current_token.text, ['-', '+']) && (
            in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
            in_array(flags.last_text, tokenizer.line_starters) ||
            flags.last_text === ','
        );

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            var preserve_statement_flags = !isGeneratorAsterisk;
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            // "return" had a special handling in TK_WORD. Now we need to return the favor
            output.space_before_token = true;
            print_token();
            return;
        }

        // hack for actionscript's import .*;
        if (current_token.text === '*' && last_type === 'TK_DOT') {
            print_token();
            return;
        }

        if (current_token.text === '::') {
            // no spaces around exotic namespacing syntax operator
            print_token();
            return;
        }

        // Allow line wrapping between operators when operator_position is
        //   set to before or preserve
        if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
            allow_wrap_or_preserved_newline();
        }

        if (current_token.text === ':' && flags.in_case) {
            flags.case_body = true;
            indent();
            print_token();
            print_newline();
            flags.in_case = false;
            return;
        }

        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ':') {
            if (flags.ternary_depth === 0) {
                // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                space_before = false;
            } else {
                flags.ternary_depth -= 1;
                in_ternary = true;
            }
        } else if (current_token.text === '?') {
            flags.ternary_depth += 1;
        }

        // let's handle the operator_position option prior to any conflicting logic
        if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, tokenizer.positionable_operators)) {
            var isColon = current_token.text === ':';
            var isTernaryColon = (isColon && in_ternary);
            var isOtherColon = (isColon && !in_ternary);

            switch (opt.operator_position) {
                case OPERATOR_POSITION.before_newline:
                    // if the current token is : and it's not a ternary statement then we set space_before to false
                    output.space_before_token = !isOtherColon;

                    print_token();

                    if (!isColon || isTernaryColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.after_newline:
                    // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
                    //   then print a newline.

                    output.space_before_token = true;

                    if (!isColon || isTernaryColon) {
                        if (get_token(1).wanted_newline) {
                            print_newline(false, true);
                        } else {
                            allow_wrap_or_preserved_newline();
                        }
                    } else {
                        output.space_before_token = false;
                    }

                    print_token();

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.preserve_newline:
                    if (!isOtherColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    // if we just added a newline, or the current token is : and it's not a ternary statement,
                    //   then we set space_before to false
                    space_before = !(output.just_added_newline() || isOtherColon);

                    output.space_before_token = space_before;
                    print_token();
                    output.space_before_token = true;
                    return;
            }
        }

        if (isGeneratorAsterisk) {
            allow_wrap_or_preserved_newline();
            space_before = false;
            var next_token = get_token(1);
            space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
        } else if (current_token.text === '...') {
            allow_wrap_or_preserved_newline();
            space_before = last_type === 'TK_START_BLOCK';
            space_after = false;
        } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
            // unary operators (and binary +/- pretending to be unary) special cases

            space_before = false;
            space_after = false;

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
                print_newline(false, true);
            }

            if (flags.last_text === ';' && is_expression(flags.mode)) {
                // for (;; ++i)
                //        ^^^
                space_before = true;
            }

            if (last_type === 'TK_RESERVED') {
                space_before = true;
            } else if (last_type === 'TK_END_EXPR') {
                space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
            } else if (last_type === 'TK_OPERATOR') {
                // a++ + ++b;
                // a - -b
                space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
                // + and - are not unary when preceeded by -- or ++ operator
                // a-- + b
                // a * +b
                // a - -b
                if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
                    space_after = true;
                }
            }


            if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
                (flags.last_text === '{' || flags.last_text === ';')) {
                // { foo; --i }
                // foo(); --bar;
                print_newline();
            }
        }

        output.space_before_token = output.space_before_token || space_before;
        print_token();
        output.space_before_token = space_after;
    }

    function handle_block_comment(preserve_statement_flags) {
        if (output.raw) {
            output.add_raw_token(current_token);
            if (current_token.directives && current_token.directives.preserve === 'end') {
                // If we're testing the raw output behavior, do not allow a directive to turn it off.
                output.raw = opt.test_output_raw;
            }
            return;
        }

        if (current_token.directives) {
            print_newline(false, preserve_statement_flags);
            print_token();
            if (current_token.directives.preserve === 'start') {
                output.raw = true;
            }
            print_newline(false, true);
            return;
        }

        // inline block
        if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
            return;
        }

        var lines = split_linebreaks(current_token.text);
        var j; // iterator for this case
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;

        // block comment starts with a new line
        print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
            javadoc = all_lines_start_with(lines.slice(1), '*');
            starless = each_line_matches_indent(lines.slice(1), lastIndent);
        }

        // first line always indented
        print_token(lines[0]);
        for (j = 1; j < lines.length; j++) {
            print_newline(false, true);
            if (javadoc) {
                // javadoc: reformat and re-indent
                print_token(' ' + ltrim(lines[j]));
            } else if (starless && lines[j].length > lastIndentLength) {
                // starless: re-indent non-empty content, avoiding trim
                print_token(lines[j].substring(lastIndentLength));
            } else {
                // normal comments output raw
                output.add_token(lines[j]);
            }
        }

        // for comments of more than one line, make sure there's a new line after
        print_newline(false, preserve_statement_flags);
    }

    function handle_comment(preserve_statement_flags) {
        if (current_token.wanted_newline) {
            print_newline(false, preserve_statement_flags);
        } else {
            output.trim(true);
        }

        output.space_before_token = true;
        print_token();
        print_newline(false, preserve_statement_flags);
    }

    function handle_dot() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token, true);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            output.space_before_token = true;
        } else {
            // allow preserved newlines before dots in general
            // force newlines on dots after close paren when break_chained - for bar().baz()
            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
        }

        print_token();
    }

    function handle_unknown(preserve_statement_flags) {
        print_token();

        if (current_token.text[current_token.text.length - 1] === '\n') {
            print_newline(false, preserve_statement_flags);
        }
    }

    function handle_eof() {
        // Unwind any open statements
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }
        handle_whitespace_and_comments(current_token);
    }
}

module.exports.Beautifier = Beautifier;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function InputScanner(input) {
    var _input = input;
    var _input_length = _input.length;
    var _position = 0;

    this.back = function() {
        _position -= 1;
    };

    this.hasNext = function() {
        return _position < _input_length;
    };

    this.next = function() {
        var val = null;
        if (this.hasNext()) {
            val = _input.charAt(_position);
            _position += 1;
        }
        return val;
    };

    this.peek = function(index) {
        var val = null;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charAt(index);
        }
        return val;
    };

    this.peekCharCode = function(index) {
        var val = 0;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charCodeAt(index);
        }
        return val;
    };

    this.test = function(pattern, index) {
        index = index || 0;
        pattern.lastIndex = _position + index;
        return pattern.test(_input);
    };

    this.testChar = function(pattern, index) {
        var val = this.peek(index);
        return val !== null && pattern.test(val);
    };

    this.match = function(pattern) {
        pattern.lastIndex = _position;
        var pattern_match = pattern.exec(_input);
        if (pattern_match && pattern_match.index === _position) {
            _position += pattern_match[0].length;
        } else {
            pattern_match = null;
        }
        return pattern_match;
    };
}


module.exports.InputScanner = InputScanner;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function Token(type, text, newlines, whitespace_before, parent) {
    this.type = type;
    this.text = text;

    // comments_before are
    // comments that have a new line before them
    // and may or may not have a newline after
    // this is a set of comments before
    this.comments_before = /* inline comment*/ [];


    this.comments_after = []; // no new line before and newline after
    this.newlines = newlines || 0;
    this.wanted_newline = newlines > 0;
    this.whitespace_before = whitespace_before || '';
    this.parent = parent || null;
    this.opened = null;
    this.directives = null;
}

module.exports.Token = Token;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(1).Beautifier;

function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
}

module.exports = js_beautify;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var InputScanner = __webpack_require__(2).InputScanner;
var Token = __webpack_require__(5).Token;
var acorn = __webpack_require__(0);

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function Tokenizer(input_string, opts) {

    var whitespace = "\n\r\t ".split('');
    var digit = /[0-9]/;
    var digit_bin = /[01]/;
    var digit_oct = /[01234567]/;
    var digit_hex = /[0123456789abcdefABCDEF]/;

    this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
    var punct = this.positionable_operators.concat(
        // non-positionable operators - these do not follow operator position settings
        '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

    // words which should always start on new line.
    this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
    var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

    //  /* ... */ comment ends with nearest */ or end of file
    var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

    // comment ends just before nearest linefeed or end of file
    var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

    var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
    var directive_pattern = / (\w+)[:](\w+)/g;
    var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

    var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

    var n_newlines, whitespace_before_token, in_html_comment, tokens;
    var input;

    this.tokenize = function() {
        input = new InputScanner(input_string);
        in_html_comment = false;
        tokens = [];

        var next, last;
        var token_values;
        var open = null;
        var open_stack = [];
        var comments = [];

        while (!(last && last.type === 'TK_EOF')) {
            token_values = tokenize_next();
            next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
                if (next.type === 'TK_BLOCK_COMMENT') {
                    next.directives = token_values[2];
                }
                comments.push(next);
                token_values = tokenize_next();
                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            }

            if (comments.length) {
                next.comments_before = comments;
                comments = [];
            }

            if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
                next.parent = last;
                open_stack.push(open);
                open = next;
            } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
                (open && (
                    (next.text === ']' && open.text === '[') ||
                    (next.text === ')' && open.text === '(') ||
                    (next.text === '}' && open.text === '{')))) {
                next.parent = open.parent;
                next.opened = open;

                open = open_stack.pop();
            }

            tokens.push(next);
            last = next;
        }

        return tokens;
    };

    function get_directives(text) {
        if (!text.match(directives_block_pattern)) {
            return null;
        }

        var directives = {};
        directive_pattern.lastIndex = 0;
        var directive_match = directive_pattern.exec(text);

        while (directive_match) {
            directives[directive_match[1]] = directive_match[2];
            directive_match = directive_pattern.exec(text);
        }

        return directives;
    }

    function tokenize_next() {
        var resulting_string;
        var whitespace_on_this_line = [];

        n_newlines = 0;
        whitespace_before_token = '';

        var c = input.next();

        if (c === null) {
            return ['', 'TK_EOF'];
        }

        var last_token;
        if (tokens.length) {
            last_token = tokens[tokens.length - 1];
        } else {
            // For the sake of tokenizing we can pretend that there was on open brace to start
            last_token = new Token('TK_START_BLOCK', '{');
        }

        while (in_array(c, whitespace)) {

            if (acorn.newline.test(c)) {
                if (!(c === '\n' && input.peek(-2) === '\r')) {
                    n_newlines += 1;
                    whitespace_on_this_line = [];
                }
            } else {
                whitespace_on_this_line.push(c);
            }

            c = input.next();

            if (c === null) {
                return ['', 'TK_EOF'];
            }
        }

        if (whitespace_on_this_line.length) {
            whitespace_before_token = whitespace_on_this_line.join('');
        }

        if (digit.test(c) || (c === '.' && input.testChar(digit))) {
            var allow_decimal = true;
            var allow_e = true;
            var local_digit = digit;

            if (c === '0' && input.testChar(/[XxOoBb]/)) {
                // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
                allow_decimal = false;
                allow_e = false;
                if (input.testChar(/[Bb]/)) {
                    local_digit = digit_bin;
                } else if (input.testChar(/[Oo]/)) {
                    local_digit = digit_oct;
                } else {
                    local_digit = digit_hex;
                }
                c += input.next();
            } else if (c === '.') {
                // Already have a decimal for this literal, don't allow another
                allow_decimal = false;
            } else {
                // we know this first loop will run.  It keeps the logic simpler.
                c = '';
                input.back();
            }

            // Add the digits
            while (input.testChar(local_digit)) {
                c += input.next();

                if (allow_decimal && input.peek() === '.') {
                    c += input.next();
                    allow_decimal = false;
                }

                // a = 1.e-7 is valid, so we test for . then e in one loop
                if (allow_e && input.testChar(/[Ee]/)) {
                    c += input.next();

                    if (input.testChar(/[+-]/)) {
                        c += input.next();
                    }

                    allow_e = false;
                    allow_decimal = false;
                }
            }

            return [c, 'TK_WORD'];
        }

        if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
            if (input.hasNext()) {
                while (acorn.isIdentifierChar(input.peekCharCode())) {
                    c += input.next();
                    if (!input.hasNext()) {
                        break;
                    }
                }
            }

            if (!(last_token.type === 'TK_DOT' ||
                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
                in_array(c, reserved_words)) {
                if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
                    return [c, 'TK_OPERATOR'];
                }
                return [c, 'TK_RESERVED'];
            }

            return [c, 'TK_WORD'];
        }

        if (c === '(' || c === '[') {
            return [c, 'TK_START_EXPR'];
        }

        if (c === ')' || c === ']') {
            return [c, 'TK_END_EXPR'];
        }

        if (c === '{') {
            return [c, 'TK_START_BLOCK'];
        }

        if (c === '}') {
            return [c, 'TK_END_BLOCK'];
        }

        if (c === ';') {
            return [c, 'TK_SEMICOLON'];
        }

        if (c === '/') {
            var comment = '';
            var comment_match;
            // peek for comment /* ... */
            if (input.peek() === '*') {
                input.next();
                comment_match = input.match(block_comment_pattern);
                comment = '/*' + comment_match[0];
                var directives = get_directives(comment);
                if (directives && directives.ignore === 'start') {
                    comment_match = input.match(directives_end_ignore_pattern);
                    comment += comment_match[0];
                }
                comment = comment.replace(acorn.allLineBreaks, '\n');
                return [comment, 'TK_BLOCK_COMMENT', directives];
            }
            // peek for comment // ...
            if (input.peek() === '/') {
                input.next();
                comment_match = input.match(comment_pattern);
                comment = '//' + comment_match[0];
                return [comment, 'TK_COMMENT'];
            }

        }

        var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

        if (c === '`' || c === "'" || c === '"' || // string
            (
                (c === '/') || // regexp
                (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
            ) && ( // regex and xml can only appear in specific locations during parsing
                (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
                (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
                    last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
                (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                ]))
            )) {

            var sep = c,
                esc = false,
                has_char_escapes = false;

            resulting_string = c;

            if (sep === '/') {
                //
                // handle regexp
                //
                var in_char_class = false;
                while (input.hasNext() &&
                    ((esc || in_char_class || input.peek() !== sep) &&
                        !input.testChar(acorn.newline))) {
                    resulting_string += input.peek();
                    if (!esc) {
                        esc = input.peek() === '\\';
                        if (input.peek() === '[') {
                            in_char_class = true;
                        } else if (input.peek() === ']') {
                            in_char_class = false;
                        }
                    } else {
                        esc = false;
                    }
                    input.next();
                }
            } else if (opts.e4x && sep === '<') {
                //
                // handle e4x xml literals
                //

                var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
                input.back();
                var xmlStr = '';
                var match = input.match(startXmlRegExp);
                if (match) {
                    // Trim root tag to attempt to
                    var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
                    var isCurlyRoot = rootTag.indexOf('{') === 0;
                    var depth = 0;
                    while (match) {
                        var isEndTag = !!match[1];
                        var tagName = match[2];
                        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                        if (!isSingletonTag &&
                            (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
                            if (isEndTag) {
                                --depth;
                            } else {
                                ++depth;
                            }
                        }
                        xmlStr += match[0];
                        if (depth <= 0) {
                            break;
                        }
                        match = input.match(xmlRegExp);
                    }
                    // if we didn't close correctly, keep unformatted.
                    if (!match) {
                        xmlStr += input.match(/[\s\S]*/g)[0];
                    }
                    xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
                    return [xmlStr, "TK_STRING"];
                }
            } else {
                //
                // handle string
                //
                var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
                    // Template strings can travers lines without escape characters.
                    // Other strings cannot
                    var current_char;
                    while (input.hasNext()) {
                        current_char = input.peek();
                        if (!(esc || (current_char !== delimiter &&
                                (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
                            break;
                        }

                        // Handle \r\n linebreaks after escapes or in template strings
                        if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
                            if (current_char === '\r' && input.peek(1) === '\n') {
                                input.next();
                                current_char = input.peek();
                            }
                            resulting_string += '\n';
                        } else {
                            resulting_string += current_char;
                        }

                        if (esc) {
                            if (current_char === 'x' || current_char === 'u') {
                                has_char_escapes = true;
                            }
                            esc = false;
                        } else {
                            esc = current_char === '\\';
                        }

                        input.next();

                        if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
                            if (delimiter === '`') {
                                parse_string('}', allow_unescaped_newlines, '`');
                            } else {
                                parse_string('`', allow_unescaped_newlines, '${');
                            }

                            if (input.hasNext()) {
                                resulting_string += input.next();
                            }
                        }
                    }
                };

                if (sep === '`') {
                    parse_string('`', true, '${');
                } else {
                    parse_string(sep);
                }
            }

            if (has_char_escapes && opts.unescape_strings) {
                resulting_string = unescape_string(resulting_string);
            }

            if (input.peek() === sep) {
                resulting_string += sep;
                input.next();

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                    while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
                        resulting_string += input.next();
                    }
                }
            }
            return [resulting_string, 'TK_STRING'];
        }

        if (c === '#') {

            if (tokens.length === 0 && input.peek() === '!') {
                // shebang
                resulting_string = c;
                while (input.hasNext() && c !== '\n') {
                    c = input.next();
                    resulting_string += c;
                }
                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
            }



            // Spidermonkey-specific sharp variables for circular references
            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
            var sharp = '#';
            if (input.hasNext() && input.testChar(digit)) {
                do {
                    c = input.next();
                    sharp += c;
                } while (input.hasNext() && c !== '#' && c !== '=');
                if (c === '#') {
                    //
                } else if (input.peek() === '[' && input.peek(1) === ']') {
                    sharp += '[]';
                    input.next();
                    input.next();
                } else if (input.peek() === '{' && input.peek(1) === '}') {
                    sharp += '{}';
                    input.next();
                    input.next();
                }
                return [sharp, 'TK_WORD'];
            }
        }

        if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
            input.back();
            var template_match = input.match(template_pattern);
            if (template_match) {
                c = template_match[0];
                c = c.replace(acorn.allLineBreaks, '\n');
                return [c, 'TK_STRING'];
            }
        }

        if (c === '<' && input.match(/\!--/g)) {
            c = '<!--';
            while (input.hasNext() && !input.testChar(acorn.newline)) {
                c += input.next();
            }
            in_html_comment = true;
            return [c, 'TK_COMMENT'];
        }

        if (c === '-' && in_html_comment && input.match(/->/g)) {
            in_html_comment = false;
            return ['-->', 'TK_COMMENT'];
        }

        if (c === '.') {
            if (input.peek() === '.' && input.peek(1) === '.') {
                c += input.next() + input.next();
                return [c, 'TK_OPERATOR'];
            }
            return [c, 'TK_DOT'];
        }

        if (in_array(c, punct)) {
            while (input.hasNext() && in_array(c + input.peek(), punct)) {
                c += input.next();
                if (!input.hasNext()) {
                    break;
                }
            }

            if (c === ',') {
                return [c, 'TK_COMMA'];
            } else if (c === '=') {
                return [c, 'TK_EQUALS'];
            } else {
                return [c, 'TK_OPERATOR'];
            }
        }

        return [c, 'TK_UNKNOWN'];
    }


    function unescape_string(s) {
        // You think that a regex would work for this
        // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
        //         return String.fromCharCode(parseInt(val, 16));
        //     })
        // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
        var out = '',
            escaped = 0;

        var input_scan = new InputScanner(s);
        var matched = null;

        while (input_scan.hasNext()) {
            // Keep any whitespace, non-slash characters
            // also keep slash pairs.
            matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

            if (matched) {
                out += matched[0];
            }

            if (input_scan.peek() === '\\') {
                input_scan.next();
                if (input_scan.peek() === 'x') {
                    matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
                } else if (input_scan.peek() === 'u') {
                    matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
                } else {
                    out += '\\';
                    if (input_scan.hasNext()) {
                        out += input_scan.next();
                    }
                    continue;
                }

                // If there's some error decoding, return the original string
                if (!matched) {
                    return s;
                }

                escaped = parseInt(matched[1], 16);

                if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
                    // we bail out on \x7f..\xff,
                    // leaving whole string escaped,
                    // as it's probably completely binary
                    return s;
                } else if (escaped >= 0x00 && escaped < 0x20) {
                    // leave 0x00...0x1f escaped
                    out += '\\' + matched[0];
                    continue;
                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                    // single-quote, apostrophe, backslash - escape these
                    out += '\\' + String.fromCharCode(escaped);
                } else {
                    out += String.fromCharCode(escaped);
                }
            }
        }

        return out;
    }
}

module.exports.Tokenizer = Tokenizer;

/***/ })
/******/ ]);
var js_beautify = legacy_beautify_js;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return { js_beautify: js_beautify };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var js_beautify = require("beautify").js_beautify`.
    exports.js_beautify = js_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.js_beautify = js_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.js_beautify = js_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],174:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return globalLocale;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
        else {
            if ((typeof console !==  'undefined') && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
            }
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var locale, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                    parentConfig = locale._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config
                    });
                    return null;
                }
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports

hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.21.0';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function boundary_to_dot(value) {
    return value.split('][').join('.').split('[').join('.');
}
function strip_braces(value) {
    return value.split('[').join('.').split(']').join('');
}
function escape_dots(value) {
    var val = value.split('\'');
    return (val.length < 3) ? val.join('\'') : val.map(function (seg) {
        if (seg.length < 3)
            return seg;
        if ((seg[0] === '.') || (seg[seg.length - 1] === '.'))
            return seg;
        return seg.split('.').join('&&');
    }).join('');
}
function unescape_dots(value) {
    return value.split('&&').join('.');
}
function partify(value) {
    if (!value)
        return;
    return escape_dots(strip_braces(boundary_to_dot('' + value))).split('.');
}
function canClone(o) {
    return (typeof o.__CLONE__ === 'function');
}
function clone(o) {
    if ((typeof o !== 'object') || (o === null))
        return o;
    if (Array.isArray(o))
        return o.map(clone);
    return (canClone(o)) ?
        o.__CLONE__(clone) : (o.constructor !== Object) ? o :
        Object.keys(o).reduce(function (pre, k) {
            pre[k] = (typeof o[k] === 'object') ?
                clone(o[k]) : o[k];
            return pre;
        }, {});
}
function get(path, o) {
    var parts = partify(path);
    var first;
    if (typeof o === 'object') {
        if (parts.length === 1)
            return o[unescape_dots(parts[0])];
        if (parts.length === 0)
            return;
        first = o[parts.shift()];
        return ((typeof o === 'object') && (o !== null)) ?
            parts.reduce(function (target, prop) {
                if (target == null)
                    return target;
                return target[unescape_dots(prop)];
            }, first) : null;
    }
    else {
        throw new TypeError('get(): expects an object got ' + typeof o);
    }
}
exports.get = get;
;
function set(path, value, obj) {
    var parts = partify(path);
    if ((typeof obj !== 'object') || (obj == null)) {
        return clone(obj);
    }
    else {
        return _set(obj, value, parts);
    }
}
exports.set = set;
;
function _set(obj, value, parts) {
    var o;
    var k;
    if (parts.length === 0)
        return value;
    o = ((typeof obj !== 'object') || (obj === null)) ? {} : clone(obj);
    k = unescape_dots(parts[0]);
    o[k] = _set(o[k], value, parts.slice(1));
    return o;
}
function default_1(k, v, o) {
    if (o == null)
        return get(k, v);
    else
        return set(k, v, o);
}
exports.default = default_1;
;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2J1aWxkL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZS1leGFtcGxlL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlLWV4YW1wbGUvd21sL3BhZ2UtZXhhbXBsZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvUGFnZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYWN0aXZpdHktaW5kaWNhdG9yL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9hY3Rpdml0eS1pbmRpY2F0b3Ivd21sL2FjdGl2aXR5LWluZGljYXRvci5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnJlYWRjcnVtYi9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnJlYWRjcnVtYi93bWwvYnJlYWRjcnVtYi5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLWdyb3VwL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9idXR0b24tZ3JvdXAvd21sL2J1dHRvbi1ncm91cC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9idXR0b24vd21sL2J1dHRvbi5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvY2hlY2tib3gvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2NoZWNrYm94L3dtbC9jaGVja2JveC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS93bWwvZGF0ZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZHJvcC1kb3duL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9kcm9wLWRvd24vd21sL2Ryb3AtZG93bi5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvaG9yaXpvbnRhbC1sYXlvdXQvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2hvcml6b250YWwtbGF5b3V0L3dtbC9ob3Jpem9udGFsLWxheW91dC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbGlzdC1sYXlvdXQvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2xpc3QtbGF5b3V0L3dtbC9saXN0LWxheW91dC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS93bWwvbWVudS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbXVsdGktc2VsZWN0L2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9tdWx0aS1zZWxlY3Qvd21sL211bHRpLXNlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbmF2L2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9uYXYvd21sL25hdi5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvcGFuZWwvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3BhbmVsL3dtbC9wYW5lbC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc2VsZWN0L2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3RhY2svaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3N0YWNrL3dtbC9zdGFjay5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3dpdGNoL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zd2l0Y2gvd21sL3N3aXRjaC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFiLWJhci9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFiLWJhci93bWwvdGFiLWJhci5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFiLWxheW91dC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFiLWxheW91dC93bWwvdGFiLWxheW91dC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvZGF0YS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3RhYmxlL3dtbC90YWJsZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdG9vbGJhci9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdG9vbGJhci93bWwvdG9vbGJhci5qcyIsImV4YW1wbGUvYnVpbGQvd21sL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL25hdmlnYXRpb24uanMiLCJsaWIvYXBwL2FjdGlvbi1iYXIvaW5kZXguanMiLCJsaWIvYXBwL2FjdGlvbi1iYXIvd21sL2FjdGlvbi1iYXIuanMiLCJsaWIvYXBwL2Rhc2gvaW5kZXguanMiLCJsaWIvYXBwL2Rhc2gvd21sL2Rhc2guanMiLCJsaWIvYXBwL2luZGljYXRvci9hY3Rpdml0eS9pbmRleC5qcyIsImxpYi9hcHAvaW5kaWNhdG9yL2FjdGl2aXR5L3dtbC9hY3Rpdml0eS1pbmRpY2F0b3IuanMiLCJsaWIvY29udGVudC9Hcm91cC5qcyIsImxpYi9jb250ZW50L25hdi9icmVhZGNydW1iL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbmF2L2JyZWFkY3J1bWIvd21sL2JyZWFkY3J1bWIuanMiLCJsaWIvY29udGVudC9uYXYvaW5kZXguanMiLCJsaWIvY29udGVudC9uYXYvaXRlbS9pbmRleC5qcyIsImxpYi9jb250ZW50L25hdi9pdGVtL3dtbC9pdGVtLmpzIiwibGliL2NvbnRlbnQvbmF2L2xpbmsvaW5kZXguanMiLCJsaWIvY29udGVudC9uYXYvbGluay93bWwvbGluay5qcyIsImxpYi9jb250ZW50L25hdi9uYXYtaGVhZGVyL2luZGV4LmpzIiwibGliL2NvbnRlbnQvbmF2L25hdi1oZWFkZXIvd21sL25hdi1oZWFkZXIuanMiLCJsaWIvY29udGVudC9uYXYvd21sL25hdi5qcyIsImxpYi9jb250ZW50L29yaWVudGF0aW9uL2luZGV4LmpzIiwibGliL2NvbnRlbnQvc2l6ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2FjdGl2ZS5qcyIsImxpYi9jb250ZW50L3N0YXRlL2hpZGRlbi5qcyIsImxpYi9jb250ZW50L3N0eWxlLmpzIiwibGliL2NvbnRlbnQveC9jYXJldC9pbmRleC5qcyIsImxpYi9jb250ZW50L3gvY2FyZXQvd21sL2NhcmV0LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwL0J1dHRvbkdyb3VwLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwL2luZGV4LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwL3dtbC9idXR0b24tZ3JvdXAuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi93bWwvYnV0dG9uLmpzIiwibGliL2NvbnRyb2wvY2hlY2tib3gvaW5kZXguanMiLCJsaWIvY29udHJvbC9jaGVja2JveC93bWwvY2hlY2tib3guanMiLCJsaWIvY29udHJvbC9kYXRlL2luZGV4LmpzIiwibGliL2NvbnRyb2wvZGF0ZS93bWwvZGF0ZS5qcyIsImxpYi9jb250cm9sL2Ryb3AtZG93bi9pbmRleC5qcyIsImxpYi9jb250cm9sL2Ryb3AtZG93bi93bWwvZHJvcC1kb3duLmpzIiwibGliL2NvbnRyb2wvZmVlZGJhY2suanMiLCJsaWIvY29udHJvbC9mb3JtLmpzIiwibGliL2NvbnRyb2wvaW5kZXguanMiLCJsaWIvY29udHJvbC9tZW51L2luZGV4LmpzIiwibGliL2NvbnRyb2wvbWVudS93bWwvZGl2aWRlci5qcyIsImxpYi9jb250cm9sL21lbnUvd21sL2hlYWRlci5qcyIsImxpYi9jb250cm9sL21lbnUvd21sL21lbnUuanMiLCJsaWIvY29udHJvbC9tdWx0aS1zZWxlY3QvaW5kZXguanMiLCJsaWIvY29udHJvbC9tdWx0aS1zZWxlY3Qvd21sL211bHRpLXNlbGVjdC5qcyIsImxpYi9jb250cm9sL3NlYXJjaC9pbmRleC5qcyIsImxpYi9jb250cm9sL3NlYXJjaC93bWwvc2VhcmNoLmpzIiwibGliL2NvbnRyb2wvc2VsZWN0L2luZGV4LmpzIiwibGliL2NvbnRyb2wvc2VsZWN0L3dtbC9zZWxlY3QuanMiLCJsaWIvY29udHJvbC9zdGFjay9pbmRleC5qcyIsImxpYi9jb250cm9sL3N0YWNrL3dtbC9zdGFjay5qcyIsImxpYi9jb250cm9sL3N3aXRjaC9pbmRleC5qcyIsImxpYi9jb250cm9sL3N3aXRjaC93bWwvc3dpdGNoLmpzIiwibGliL2NvbnRyb2wvdGFiLWJhci9UYWIuanMiLCJsaWIvY29udHJvbC90YWItYmFyL1RhYkJhci5qcyIsImxpYi9jb250cm9sL3RhYi1iYXIvVGFiQ2xpY2tlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvdGFiLWJhci9pbmRleC5qcyIsImxpYi9jb250cm9sL3RhYi1iYXIvd21sL3RhYi1iYXIuanMiLCJsaWIvY29udHJvbC90YWItYmFyL3dtbC90YWIuanMiLCJsaWIvY29udHJvbC90ZXh0LWZpZWxkL2luZGV4LmpzIiwibGliL2NvbnRyb2wvdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsImxpYi9jb250cm9sL3Rvb2xiYXIvaW5kZXguanMiLCJsaWIvY29udHJvbC90b29sYmFyL3dtbC90b29sYmFyLmpzIiwibGliL2NvbnRyb2wvd21sL2luZGV4LmpzIiwibGliL2RhdGEvdGFibGUvQWxsU2VsZWN0ZWRFdmVudC5qcyIsImxpYi9kYXRhL3RhYmxlL0NlbGwuanMiLCJsaWIvZGF0YS90YWJsZS9DZWxsQ2xpY2tlZEV2ZW50LmpzIiwibGliL2RhdGEvdGFibGUvRGVmYXVsdERlbGVnYXRlLmpzIiwibGliL2RhdGEvdGFibGUvSGVhZGluZ0NsaWNrZWRFdmVudC5qcyIsImxpYi9kYXRhL3RhYmxlL1Jvd0NsaWNrZWRFdmVudC5qcyIsImxpYi9kYXRhL3RhYmxlL1Jvd1NlbGVjdGVkRXZlbnQuanMiLCJsaWIvZGF0YS90YWJsZS9Tb3J0RGVsZWdhdGUuanMiLCJsaWIvZGF0YS90YWJsZS9UYWJsZS5qcyIsImxpYi9kYXRhL3RhYmxlL2luZGV4LmpzIiwibGliL2RhdGEvdGFibGUvd21sL3RhYmxlLmpzIiwibGliL2xheW91dC9kcmF3ZXItbGF5b3V0L2luZGV4LmpzIiwibGliL2xheW91dC9kcmF3ZXItbGF5b3V0L3dtbC9kcmF3ZXItbGF5b3V0LmpzIiwibGliL2xheW91dC9kcmF3ZXIvaW5kZXguanMiLCJsaWIvbGF5b3V0L2RyYXdlci93bWwvZHJhd2VyLmpzIiwibGliL2xheW91dC9mcmFnbWVudC9pbmRleC5qcyIsImxpYi9sYXlvdXQvZnJhZ21lbnQvd21sL2ZyYWdtZW50LmpzIiwibGliL2xheW91dC9ncmlkLWxheW91dC9pbmRleC5qcyIsImxpYi9sYXlvdXQvZ3JpZC1sYXlvdXQvd21sL2dyaWQtbGF5b3V0LmpzIiwibGliL2xheW91dC9ob3Jpem9udGFsLWxheW91dC9pbmRleC5qcyIsImxpYi9sYXlvdXQvaG9yaXpvbnRhbC1sYXlvdXQvd21sL2hvcml6b250YWwtbGF5b3V0LmpzIiwibGliL2xheW91dC9pbmRleC5qcyIsImxpYi9sYXlvdXQvbGlzdC1sYXlvdXQvaW5kZXguanMiLCJsaWIvbGF5b3V0L2xpc3QtbGF5b3V0L3dtbC9saXN0LWxheW91dC1pdGVtLmpzIiwibGliL2xheW91dC9saXN0LWxheW91dC93bWwvbGlzdC1sYXlvdXQuanMiLCJsaWIvbGF5b3V0L21haW4tbGF5b3V0L2luZGV4LmpzIiwibGliL2xheW91dC9tYWluLWxheW91dC93bWwvbWFpbi1sYXlvdXQuanMiLCJsaWIvbGF5b3V0L3BhbmVsL1BhbmVsLmpzIiwibGliL2xheW91dC9wYW5lbC9QYW5lbEJvZHkuanMiLCJsaWIvbGF5b3V0L3BhbmVsL1BhbmVsRm9vdGVyLmpzIiwibGliL2xheW91dC9wYW5lbC9QYW5lbEhlYWRlci5qcyIsImxpYi9sYXlvdXQvcGFuZWwvaW5kZXguanMiLCJsaWIvbGF5b3V0L3BhbmVsL3dtbC9wYW5lbC1ib2R5LmpzIiwibGliL2xheW91dC9wYW5lbC93bWwvcGFuZWwtZm9vdGVyLmpzIiwibGliL2xheW91dC9wYW5lbC93bWwvcGFuZWwtaGVhZGVyLmpzIiwibGliL2xheW91dC9wYW5lbC93bWwvcGFuZWwuanMiLCJsaWIvbGF5b3V0L3RhYi1sYXlvdXQvaW5kZXguanMiLCJsaWIvbGF5b3V0L3RhYi1sYXlvdXQvd21sL3RhYi1sYXlvdXQuanMiLCJsaWIvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvd21sL2xpYi9BU1QuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvQ29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbGliL1R5cGVTY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvY3VycnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvRWl0aGVyLmpzIiwibm9kZV9tb2R1bGVzL2FmcGwvbGliL21vbmFkL0ZyZWUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSU8uanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvTWF5YmUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvU3RhdGUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb3BlcnR5LXNlZWsvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMzJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3B3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcImFmcGwvbGliL3V0aWxcIik7XG52YXIgYXBwXzEgPSByZXF1aXJlKFwiLi93bWwvYXBwXCIpO1xudmFyIG5hdmlnYXRpb25fMSA9IHJlcXVpcmUoXCIuL3dtbC9uYXZpZ2F0aW9uXCIpO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9wYW5lbFwiKTtcbnZhciBsaXN0X2xheW91dF8xID0gcmVxdWlyZShcIi4vcGFnZXMvbGlzdC1sYXlvdXRcIik7XG52YXIgdGFibGVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3RhYmxlXCIpO1xudmFyIHRleHRfZmllbGRfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3RleHQtZmllbGRcIik7XG52YXIgZGF0ZV8xID0gcmVxdWlyZShcIi4vcGFnZXMvZGF0ZVwiKTtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2J1dHRvblwiKTtcbnZhciB0b29sYmFyXzEgPSByZXF1aXJlKFwiLi9wYWdlcy90b29sYmFyXCIpO1xudmFyIGJ1dHRvbl9zZWxlY3RfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2J1dHRvbi1zZWxlY3RcIik7XG52YXIgY2hlY2tib3hfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2NoZWNrYm94XCIpO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZShcIi4vcGFnZXMvc3dpdGNoXCIpO1xudmFyIHRhYl9iYXJfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3RhYi1iYXJcIik7XG52YXIgc3RhY2tfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL3N0YWNrXCIpO1xudmFyIG11bHRpX3NlbGVjdF8xID0gcmVxdWlyZShcIi4vcGFnZXMvbXVsdGktc2VsZWN0XCIpO1xudmFyIHNlbGVjdF8xID0gcmVxdWlyZShcIi4vcGFnZXMvc2VsZWN0XCIpO1xudmFyIGJyZWFkY3J1bWJfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2JyZWFkY3J1bWJcIik7XG52YXIgYWN0aXZpdHlfaW5kaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9hY3Rpdml0eS1pbmRpY2F0b3JcIik7XG52YXIgbWVudV8xID0gcmVxdWlyZShcIi4vcGFnZXMvbWVudVwiKTtcbnZhciBidXR0b25fZ3JvdXBfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2J1dHRvbi1ncm91cFwiKTtcbnZhciBkcm9wX2Rvd25fMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2Ryb3AtZG93blwiKTtcbnZhciB0YWJfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9wYWdlcy90YWItbGF5b3V0XCIpO1xudmFyIGhvcml6b250YWxfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9ob3Jpem9udGFsLWxheW91dFwiKTtcbnZhciBuYXZfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL25hdlwiKTtcbnZhciBkaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIFtzWzBdLnRvVXBwZXJDYXNlKCldXG4gICAgICAgIC5jb25jYXQoc1xuICAgICAgICAuc3BsaXQoc1swXSlcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5qb2luKHNbMF0pKVxuICAgICAgICAuam9pbignJylcbiAgICAgICAgLnJlcGxhY2UoLyhcXC18X3xcXHMpKyguKT8vZywgZnVuY3Rpb24gKF8sIF9fLCBjKSB7IHJldHVybiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKTsgfSk7XG59O1xudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAobGlua3MpIHtcbiAgICByZXR1cm4gdXRpbF8xLnJlZHVjZShsaW5rcywgZnVuY3Rpb24gKGZsYXRMaW5rcywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLnJlZHVjZShjdXJyZW50LCBmdW5jdGlvbiAocCwgYywgaykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBjLCBfYSkpO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9LCBmbGF0TGlua3MpO1xuICAgIH0sIHt9KTtcbn07XG52YXIgQXBwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhZ2UgY3VycmVudGx5IGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogbGlua3MgdG8gdGhlIHBhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5rcyA9IHtcbiAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiBuZXcgcGFuZWxfMS5QYW5lbFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ2xpc3QtbGF5b3V0JzogbmV3IGxpc3RfbGF5b3V0XzEuTGlzdExheW91dFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ3RhYi1sYXlvdXQnOiBuZXcgdGFiX2xheW91dF8xLlRhYkxheW91dFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ2hvcml6b250YWwtbGF5b3V0JzogbmV3IGhvcml6b250YWxfbGF5b3V0XzEuSG9yaXpvbnRhbExheW91dFBhZ2UodGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdGFibGU6IG5ldyB0YWJsZV8xLlRhYmxlUGFnZSh0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAndGV4dC1maWVsZCc6IG5ldyB0ZXh0X2ZpZWxkXzEuVGV4dEZpZWxkUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgZGF0ZV8xLkRhdGVQYWdlKHRoaXMpLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogbmV3IHNlbGVjdF8xLlNlbGVjdFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ211bHRpLXNlbGVjdCc6IG5ldyBtdWx0aV9zZWxlY3RfMS5NdWx0aVNlbGVjdFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBuZXcgYnV0dG9uXzEuQnV0dG9uUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICAgICAnYnV0dG9uLWdyb3VwJzogbmV3IGJ1dHRvbl9ncm91cF8xLkJ1dHRvbkdyb3VwUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICAgICAndG9vbGJhcic6IG5ldyB0b29sYmFyXzEuVG9vbGJhclBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ2J1dHRvbi1zZWxlY3QnOiBuZXcgYnV0dG9uX3NlbGVjdF8xLkJ1dHRvblNlbGVjdFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ3RhYi1iYXInOiBuZXcgdGFiX2Jhcl8xLlRhYkJhclBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgbWVudTogbmV3IG1lbnVfMS5NZW51UGFnZSh0aGlzKSxcbiAgICAgICAgICAgICAgICAnZHJvcC1kb3duJzogbmV3IGRyb3BfZG93bl8xLkRyb3BEb3duUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBzdGFjazogbmV3IHN0YWNrXzEuU3RhY2tQYWdlKHRoaXMpLFxuICAgICAgICAgICAgICAgIGNoZWNrYm94OiBuZXcgY2hlY2tib3hfMS5DaGVja2JveFBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgJ3N3aXRjaCc6IG5ldyBzd2l0Y2hfMS5Td2l0Y2hQYWdlKHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIG5hdjogbmV3IG5hdl8xLk5hdlBhZ2UodGhpcyksXG4gICAgICAgICAgICAgICAgYnJlYWRjcnVtYjogbmV3IGJyZWFkY3J1bWJfMS5CcmVhZGNydW1iUGFnZSh0aGlzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICAnYWN0aXZpdHktaW5kaWNhdG9yJzogbmV3IGFjdGl2aXR5X2luZGljYXRvcl8xLkFjdGl2aXR5SW5kaWNhdG9yUGFnZSh0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogbmF2aWdhdGlvbiB2aWV3XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgbmF2aWdhdGlvbl8xLk5hdmlnYXRpb24odGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgdXNlZCB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGxheW91dDogJ2xheW91dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZpZXcgaXMgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24gdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBhcHBfMS5NYWluKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogZGlzcGxheU5hbWUgcHJvdmlkZXMgdGhlIGRpc3BsYXkgbmFtZSBmb3IgYSB0aGUgbGlua3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzb3J0IGFuIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobykuc29ydCgpLnJlZHVjZShmdW5jdGlvbiAocCwgaykgeyBwW2tdID0gb1trXTsgcmV0dXJuIHA7IH0sIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZ2dsZURyYXdlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2dnbGVEcmF3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pZC5sYXlvdXQpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC50b2dnbGUoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYXZpZ2F0ZSBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYVxuICAgICAgICAgKiBuYXZpZ2F0aW9uIGxpbmsuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucm91dGUobmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAucHJvdG90eXBlLCBcInBhZ2VzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhZ2VzIHRvIHNob3cgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsYXR0ZW4odGhpcy5saW5rcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHJvdXRlIHRoZSBtYWluIGNvbnRlbnQgYmFzZWQgb24gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMucGFnZSA9IG5hbWU7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLnBhZ2VzW25hbWVdLnZpZXc7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogcnVuIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBBcHAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJyk7XG4gICAgICAgIHdoaWxlIChyb290Lmxhc3RDaGlsZClcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQocm9vdC5sYXN0Q2hpbGQpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHRoaXMudmlldy5yZW5kZXIoKSk7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLmxheW91dCk7XG4gICAgICAgIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoJyMnKVsxXTtcbiAgICAgICAgcGF0aCA9IHBhdGggPyBwYXRoLnNwbGl0KCcvJykuam9pbignJykgOiAnJztcbiAgICAgICAgdGhpcy5yb3V0ZShwYXRoKTtcbiAgICB9O1xuICAgIEFwcC5tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFwcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcDtcbn0oKSk7XG5leHBvcnRzLkFwcCA9IEFwcDtcbnZhciB3ID0gd2luZG93O1xudy5hcHAgPSBBcHAubWFpbigpO1xudy5hcHAucnVuKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9wYWdlLWV4YW1wbGVcIik7XG52YXIgUGFnZUV4YW1wbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhZ2VFeGFtcGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2VFeGFtcGxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgc2l6ZTogX3RoaXMuYXR0cnMuc2l6ZSxcbiAgICAgICAgICAgIG9mZnNldDogX3RoaXMuYXR0cnMub2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhZ2VFeGFtcGxlO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLlBhZ2VFeGFtcGxlID0gUGFnZUV4YW1wbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGdyaWRfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkLWxheW91dFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogX19fY29udGV4dC52YWx1ZXMuc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlLWV4YW1wbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdlKGFwcCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB9XG4gICAgUGFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkLCBmbikge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKGlkKVxuICAgICAgICAgICAgLm1hcChmbilcbiAgICAgICAgICAgIC5vckp1c3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc29sZS53YXJuKGlkICsgXCI6IGlzIG1pc3NpbmdcIik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhZ2U7XG59KCkpO1xuZXhwb3J0cy5QYWdlID0gUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9hY3Rpdml0eS1pbmRpY2F0b3JcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgQWN0aXZpdHlJbmRpY2F0b3JQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpdml0eUluZGljYXRvclBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aXZpdHlJbmRpY2F0b3JQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWN0aXZpdHlJbmRpY2F0b3JQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5BY3Rpdml0eUluZGljYXRvclBhZ2UgPSBBY3Rpdml0eUluZGljYXRvclBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGFjdGl2aXR5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2FwcC9pbmRpY2F0b3IvYWN0aXZpdHlcIik7XG47XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYWN0aXZpdHlfMS5BY3Rpdml0eUluZGljYXRvciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5LWluZGljYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIGJyZWFkY3J1bWJfMSA9IHJlcXVpcmUoXCIuL3dtbC9icmVhZGNydW1iXCIpO1xudmFyIEJyZWFkY3J1bWJQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmVhZGNydW1iUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcmVhZGNydW1iUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYnJlYWRjcnVtYl8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCcmVhZGNydW1iUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQnJlYWRjcnVtYlBhZ2UgPSBCcmVhZGNydW1iUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIGJyZWFkY3J1bWJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9uYXYvYnJlYWRjcnVtYlwiKTtcbjtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbmF2L2xpbmtcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQocGFnZV9leGFtcGxlXzEuUGFnZUV4YW1wbGUsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChicmVhZGNydW1iXzEuQnJlYWRjcnVtYiwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGJyZWFkY3J1bWJfMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJPbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJyZWFkY3J1bWJfMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJUd29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJyZWFkY3J1bWJfMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJUaHJlZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoYnJlYWRjcnVtYl8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiXFxuXFxuXFx0Rm91clxcblxcbiAgICAgXCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFkY3J1bWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tZ3JvdXBcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgQnV0dG9uR3JvdXBQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25Hcm91cFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uR3JvdXBQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uR3JvdXBQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5CdXR0b25Hcm91cFBhZ2UgPSBCdXR0b25Hcm91cFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHBhZ2VfZXhhbXBsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3BhZ2UtZXhhbXBsZVwiKTtcbjtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9idXR0b25cIik7XG47XG52YXIgYnV0dG9uX2dyb3VwXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYnV0dG9uX2dyb3VwXzEuQnV0dG9uR3JvdXAsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcInRocmVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiZm91clwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLWdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uLXNlbGVjdFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBCdXR0b25TZWxlY3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25TZWxlY3RQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQobmFtZSArIFwiLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZU11bHRpID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKG5hbWUgKyBcIi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uU2VsZWN0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQnV0dG9uU2VsZWN0UGFnZSA9IEJ1dHRvblNlbGVjdFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGdyaWRfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkLWxheW91dFwiKTtcbjtcbnZhciBidXR0b25fc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3QtY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCIoTm9uZSlcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGJ1dHRvbl9zZWxlY3RfMS5CdXR0b25TZWxlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzogXCItcHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbnMnOiBfX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiWW91IGNhbiBhbHNvIHVzZSBNdWx0aUJ1dHRvblNlbGVjdCBpbnN0ZWFkOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcIm11bHRpLWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiKE5vbmUpXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChidXR0b25fc2VsZWN0XzEuTXVsdGlCdXR0b25TZWxlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJtdWx0aVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwibXVsdGlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHlsZSc6IFwiLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJzogX19fY29udGV4dC52YWx1ZXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VNdWx0aVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2J1dHRvblwiKTtcbnZhciBzdHlsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvY29udGVudC9zdHlsZVwiKTtcbnZhciBzaXplID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9jb250ZW50L3NpemVcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgQnV0dG9uUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25QYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiXCIgKyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpOyB9LFxuICAgICAgICAgICAgc3R5bGVzOiBzdHlsZSxcbiAgICAgICAgICAgIHNpemVzOiBzaXplXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkJ1dHRvblBhZ2UgPSBCdXR0b25QYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBncmlkX2xheW91dF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvZ3JpZC1sYXlvdXRcIik7XG47XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuR3JpZExheW91dCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2gxJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkJ1dHRvbnNcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdoMicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJTdHlsZVwiKV0sIF9fX3ZpZXcpLCBfX193bWwubWFwKF9fX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gX21hcCh2LCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwuYm94KF9fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3R5bGUnOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogX19fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZShrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaDInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiT3V0bGluZVwiKV0sIF9fX3ZpZXcpLCBfX193bWwubWFwKF9fX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gX21hcChzdHlsZSwgdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwuYm94KF9fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzogc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3V0bGluZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShcIiBcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2gyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkFjdGl2ZVwiKV0sIF9fX3ZpZXcpLCBfX193bWwubWFwKF9fX2NvbnRleHQudmFsdWVzLnN0eWxlcywgZnVuY3Rpb24gX21hcCh2LCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwuYm94KF9fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3R5bGUnOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogX19fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZShrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2gyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkRpc2FibGVkXCIpXSwgX19fdmlldyksIF9fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc3R5bGVzLCBmdW5jdGlvbiBfbWFwKHYsIGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ib3goX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzogdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQudmFsdWVzLmNhcGl0YWxpemUoaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwuZG9taWZ5KFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2gyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlNpemVcIildLCBfX192aWV3KSwgX19fd21sLm1hcChfX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uIF9tYXAoc3R5bGUsIF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc2l6ZXMsIGZ1bmN0aW9uIF9tYXAoc2l6ZVZhbHVlLCBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLmJveChfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3R5bGUnOiBzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiBzaXplVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogX19fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZShzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShcIiBcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaDInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiQmxvY2tcIildLCBfX192aWV3KSwgX19fd21sLm1hcChfX19jb250ZXh0LnZhbHVlcy5zdHlsZXMsIGZ1bmN0aW9uIF9tYXAoc3R5bGUsIHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLmJveChfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHlsZSc6IHN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Jsb2NrJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogX19fY29udGV4dC52YWx1ZXMuY2FwaXRhbGl6ZSh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwuZG9taWZ5KFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2NoZWNrYm94XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIENoZWNrYm94UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hlY2tib3hQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoZWNrYm94UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXMudmlldy5maW5kQnlJZCgnY29udGVudCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlID09PSB0cnVlID9cbiAgICAgICAgICAgICAgICAgICAgJ29uJyA6XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gZmFsc2UgPyAnb2ZmJyA6ICdlcnJvcicpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hlY2tib3hQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5DaGVja2JveFBhZ2UgPSBDaGVja2JveFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHBhZ2VfZXhhbXBsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3BhZ2UtZXhhbXBsZVwiKTtcbjtcbnZhciBjaGVja2JveF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2NoZWNrYm94XCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoZSBjaGVja2JveCBpcyBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcImNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJ1bnRvdWNoZWRcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGNoZWNrYm94XzEuQ2hlY2tib3gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGF0ZVwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBEYXRlUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKCdzZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERhdGVQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5EYXRlUGFnZSA9IERhdGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBwYWdlX2V4YW1wbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWdlLWV4YW1wbGVcIik7XG47XG52YXIgZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL2RhdGVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQocGFnZV9leGFtcGxlXzEuUGFnZUV4YW1wbGUsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIGRhdGUgaXMgOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiKE5vbmUgc2VsZWN0ZWQpXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChkYXRlXzEuRGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtZG93blwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBEcm9wRG93blBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyb3BEb3duUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcm9wRG93blBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERyb3BEb3duUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuRHJvcERvd25QYWdlID0gRHJvcERvd25QYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBwYWdlX2V4YW1wbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWdlLWV4YW1wbGVcIik7XG47XG52YXIgZHJvcF9kb3duXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvZHJvcC1kb3duXCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9tZW51XCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGRyb3BfZG93bl8xLkRyb3BEb3duLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdidXR0b25UZXh0JzogXCJDbGljayBNZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQub25DbGljayhcIllvdSBjbGlja2VkIG9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiT25lXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC5vbkNsaWNrKFwiWW91IGNsaWNrZWQgdHdvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUd29cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0Lm9uQ2xpY2soXCJZb3UgY2xpY2tlZCB0aHJlZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhyZWVcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChkcm9wX2Rvd25fMS5Ecm9wRG93biwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0dG9uVGV4dCc6IFwiTWUgVG9vXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG9DbG9zZSc6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaDEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiQW55IGZsb3cgY29udGVudCBjYW4gZ28gaGVyZSFcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wLWRvd24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9ob3Jpem9udGFsLWxheW91dFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBIb3Jpem9udGFsTGF5b3V0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9yaXpvbnRhbExheW91dFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSG9yaXpvbnRhbExheW91dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIb3Jpem9udGFsTGF5b3V0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuSG9yaXpvbnRhbExheW91dFBhZ2UgPSBIb3Jpem9udGFsTGF5b3V0UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIGhvcml6b250YWxfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ob3Jpem9udGFsLWxheW91dFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGhvcml6b250YWxfbGF5b3V0XzEuSG9yaXpvbnRhbExheW91dCwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgndGV4dGFyZWEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiQXJlYSAxXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCd0ZXh0YXJlYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJBcmVhIDJcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3RleHRhcmVhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkFyZWEgM1wiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3Jpem9udGFsLWxheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIGxpc3RfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi93bWwvbGlzdC1sYXlvdXRcIik7XG52YXIgTGlzdExheW91dFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3RMYXlvdXRQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RMYXlvdXRQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBsaXN0X2xheW91dF8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0TGF5b3V0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuTGlzdExheW91dFBhZ2UgPSBMaXN0TGF5b3V0UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIGxpc3RfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9saXN0LWxheW91dFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGxpc3RfbGF5b3V0XzEuTGlzdExheW91dCwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGxpc3RfbGF5b3V0XzEuTGlzdExheW91dEl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhpcyBpcyB0aGUgZmlyc3QgaXRlbS5cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGxpc3RfbGF5b3V0XzEuTGlzdExheW91dEl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhpcyBpcyB0aGUgc2Vjb25kIGl0ZW0uXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChsaXN0X2xheW91dF8xLkxpc3RMYXlvdXRJdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdoMycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJXaG9hIVwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGlzIGlzIGEgdGhpcmQgaXRlbSFcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWxheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuL3dtbC9tZW51XCIpO1xudmFyIE1lbnVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51UGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW51UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgbWVudV8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZW51UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuTWVudVBhZ2UgPSBNZW51UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9tZW51XCIpO1xuO1xudmFyIGxpbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9uYXYvbGlua1wiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdoNicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJNZW51XCIpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChsaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkJhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJSZWZyZXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuRGl2aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL21lbnVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiUXVpdFwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tdWx0aS1zZWxlY3RcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgb3B0aW9ucyA9IFtcbiAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYXMnLCB2YWx1ZTogJ0dpZ2FzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzVGVrJywgdmFsdWU6ICdBc3VzVGVrJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzdWdhJywgdmFsdWU6ICdBc3VzdWdhJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsY29tbScsIHZhbHVlOiAnUXVhbGNvbW0nIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxpdGF0aXZlJywgdmFsdWU6ICdRdWFsaXRhdHZlJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VuZGVyJywgdmFsdWU6ICdBc3VuZGVyJyB9XG5dO1xudmFyIE11bHRpU2VsZWN0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlTZWxlY3RQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpU2VsZWN0UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2gnLFxuICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudmFsdWVzLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5sYWJlbDsgfSkuam9pbignLCcpOyB9LFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IFtdLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlYXJjaCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pZCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudXBkYXRlKG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTsgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuTXVsdGlTZWxlY3RQYWdlID0gTXVsdGlTZWxlY3RQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBncmlkX2xheW91dF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9sYXlvdXQvZ3JpZC1sYXlvdXRcIik7XG47XG52YXIgbXVsdGlfc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvbXVsdGktc2VsZWN0XCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuR3JpZExheW91dCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA2XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJZb3Ugc2VsZWN0ZWQ6IFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50ZXh0KCkpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtdWx0aV9zZWxlY3RfMS5NdWx0aVNlbGVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb3JhdG9yJzogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubGFiZWw7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VhcmNoJzogX19fY29udGV4dC5vblNlYXJjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGktc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbmF2XCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIE5hdlBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hdlBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2UGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLmFjdGl2ZSA9ICcnO1xuICAgICAgICBfdGhpcy5saW5rcyA9IHtcbiAgICAgICAgICAgIEhvbWU6IHt9LFxuICAgICAgICAgICAgUHJvZmlsZToge30sXG4gICAgICAgICAgICBNZXNzYWdlczoge31cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubmF2aWdhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kR3JvdXBCeU5hbWUoJ2xpbmtzJylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChscykgeyByZXR1cm4gbHMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmRlYWN0aXZhdGUoKTsgfSk7IH0pXG4gICAgICAgICAgICAgICAgLmNoYWluKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZpZXcuZmluZEJ5SWQoZS5uYW1lKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmFjdGl2YXRlKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOYXZQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5OYXZQYWdlID0gTmF2UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbmF2XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbmF2XCIpO1xuO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udGVudC9uYXYvaXRlbVwiKTtcbjtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRlbnQvbmF2L2xpbmtcIik7XG47XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobmF2XzEuTmF2LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC5saW5rcywgZnVuY3Rpb24gX21hcChfLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0Jzoga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi93bWwvcGFuZWxcIik7XG52YXIgUGFuZWxQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBwYW5lbF8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlBhbmVsUGFnZSA9IFBhbmVsUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgZ3JpZF9sYXlvdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvbGF5b3V0L2dyaWQtbGF5b3V0XCIpO1xuO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9wYW5lbFwiKTtcbjtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChwYW5lbF8xLlBhbmVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQocGFuZWxfMS5QYW5lbEJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJQYW5lbEJvZHkgb25seS5cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHBhbmVsXzEuUGFuZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChwYW5lbF8xLlBhbmVsSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiV2l0aCBQYW5lbEhlYWRlclwiKV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KHBhbmVsXzEuUGFuZWxCb2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiTG9yZW0gaW1wc3VtIGRpbGl1bSBuZXQgc2V0LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQocGFuZWxfMS5QYW5lbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHBhbmVsXzEuUGFuZWxIZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJXaXRoIFBhbmVsRm9vdGVyXCIpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQocGFuZWxfMS5QYW5lbEJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJMb3JlbSBpbXBzdW0gZGlsaXVtIG5ldCBzZXQuXCIpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQocGFuZWxfMS5QYW5lbEZvb3Rlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIk1laCBmb290LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWxlY3RcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgcmVzdWx0cyA9IFtcbiAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYXMnLCB2YWx1ZTogJ0dpZ2FzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzVGVrJywgdmFsdWU6ICdBc3VzVGVrJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VzdWdhJywgdmFsdWU6ICdBc3VzdWdhJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsY29tbScsIHZhbHVlOiAnUXVhbGNvbW0nIH0sXG4gICAgeyBsYWJlbDogJ1F1YWxpdGF0aXZlJywgdmFsdWU6ICdRdWFsaXRhdHZlJyB9LFxuICAgIHsgbGFiZWw6ICdLaXJwYWxhbmlcXCdzJywgdmFsdWU6ICdLaXJwYWxhbmlcXCdzJyB9LFxuICAgIHsgbGFiZWw6ICdBc3VuZGVyJywgdmFsdWU6ICdBc3VuZGVyJyB9XG5dO1xudmFyIG9uU2VhcmNoID0gZnVuY3Rpb24gKHBhZ2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIHBhZ2VcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKGlkKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBoaXQgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMudmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHMudXBkYXRlKGhpdCk7XG4gICAgfSk7XG59OyB9OyB9O1xudmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gKHBhZ2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gcGFnZS52aWV3LmZpbmRCeUlkKG5hbWUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUudmFsdWUpKTtcbiAgICB9KTtcbn07IH07XG52YXIgU2VsZWN0UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsZWN0UGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdXRvY29tcGxldGVOYW1lJyxcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogb25TZWFyY2goX3RoaXMpKCdhdXRvY29tcGxldGUnKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UoX3RoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmF0aXZlOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICduYXRpdmUnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICduYXRpdmVOYW1lJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiByZXN1bHRzLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBvblNlYXJjaChfdGhpcykoJ25hdGl2ZScpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZShfdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuU2VsZWN0UGFnZSA9IFNlbGVjdFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGdyaWRfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkLWxheW91dFwiKTtcbjtcbnZhciBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9zZWxlY3RcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5HcmlkTGF5b3V0LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuYXV0b2NvbXBsZXRlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihub3RoaW5nKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoc2VsZWN0XzEuU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmF1dG9jb21wbGV0ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5hdXRvY29tcGxldGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmdpZmllcic6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbHVlOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VhcmNoJzogX19fY29udGV4dC52YWx1ZXMuYXV0b2NvbXBsZXRlLm9uU2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuYXV0b2NvbXBsZXRlLm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMubmF0aXZlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihub3RoaW5nKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoc2VsZWN0XzEuU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLm5hdGl2ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5uYXRpdmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWFkT25seSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5naWZpZXInOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJzogX19fY29udGV4dC52YWx1ZXMubmF0aXZlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25TZWFyY2gnOiBfX19jb250ZXh0LnZhbHVlcy5uYXRpdmUub25TZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5uYXRpdmUub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3N0YWNrXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIF9nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnR2lnYWJ5dGUnLCB2YWx1ZTogJ0dpZ2FieXRlJyB9XG5dOyB9O1xudmFyIF9nZXRUZXh0ID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsO1xuICAgIHJldHVybiBsYWJlbDtcbn0pLmpvaW4oJywnKTsgfTtcbnZhciBTdGFja1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja1BhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZXM6IF9nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHRleHQ6IF9nZXRUZXh0KF9nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBkZWNvcmF0b3I6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmxhYmVsOyB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnZhbHVlcyA9IF9nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy50ZXh0ID0gX2dldFRleHQoX3RoaXMudmFsdWVzLnZhbHVlcyk7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5TdGFja1BhZ2UgPSBTdGFja1BhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGdyaWRfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkLWxheW91dFwiKTtcbjtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3N0YWNrXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuR3JpZExheW91dCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJNZW1iZXJzOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChzdGFja18xLlN0YWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInN0YWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBfX19jb250ZXh0LnZhbHVlcy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb3JhdG9yJzogX19fY29udGV4dC52YWx1ZXMuZGVjb3JhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zd2l0Y2hcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgU3dpdGNoUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZpbmRCeUlkKCdjb250ZW50JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgPT09IHRydWUgP1xuICAgICAgICAgICAgICAgICAgICAnb24nIDpcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSBmYWxzZSA/ICdvZmYnIDogJ2Vycm9yJykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2hQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5Td2l0Y2hQYWdlID0gU3dpdGNoUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcGFnZV9leGFtcGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFnZS1leGFtcGxlXCIpO1xuO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3N3aXRjaFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGUgc3dpdGNoIGlzIFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcInVudG91Y2hlZFwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoc3dpdGNoXzEuU3dpdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzd2l0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiLWJhclwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBUYWJCYXJQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJCYXJQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYkJhclBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy50YWIgPSAnRmlyc3QnO1xuICAgICAgICBfdGhpcy5jb250ZW50ID0gJ0ZpcnN0IFRhYic7XG4gICAgICAgIF90aGlzLmNsaWNrZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIF90aGlzLnRhYiA9IG5hbWU7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50ID0gbmFtZSArIFwiIFRhYlwiO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYkJhclBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlRhYkJhclBhZ2UgPSBUYWJCYXJQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBwYWdlX2V4YW1wbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWdlLWV4YW1wbGVcIik7XG47XG52YXIgdGFiX2Jhcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9jb250cm9sL3RhYi1iYXJcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQocGFnZV9leGFtcGxlXzEuUGFnZUV4YW1wbGUsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldCh0YWJfYmFyXzEuVGFiQmFyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQodGFiX2Jhcl8xLlRhYiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQudGFiID09PSBcIkZpcnN0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJGaXJzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJGaXJzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5jbGlja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldCh0YWJfYmFyXzEuVGFiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC50YWIgPT09IFwiU2Vjb25kXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJTZWNvbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiU2Vjb25kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0LmNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KHRhYl9iYXJfMS5UYWIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnRhYiA9PT0gXCJUaGlyZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVGhpcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVGhpcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQuY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNvbnRlbnQpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiLWxheW91dFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBUYWJMYXlvdXRQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJMYXlvdXRQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYkxheW91dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy50YWJzID0ge1xuICAgICAgICAgICAgZmlyc3Q6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50VGVtcGxhdGU6IHZpZXdzLmZpcnN0VGFiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Vjb25kOiB7XG4gICAgICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiB2aWV3cy5zZWNvbmRUYWJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlyZDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogdmlld3MudGhpcmRUYWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFiTGF5b3V0UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGFiTGF5b3V0UGFnZSA9IFRhYkxheW91dFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHBhZ2VfZXhhbXBsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3BhZ2UtZXhhbXBsZVwiKTtcbjtcbnZhciB0YWJfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC90YWItbGF5b3V0XCIpO1xuO1xuZXhwb3J0cy5maXJzdFRhYiA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgaHRtbDoge30sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC50ZXh0KFwiQ2xpY2sgYSB0YWIgdG8gY2hhbmdlIGNvbnRlbnQuXCIpXSwgX19fdmlldyk7IH07IH07XG47XG5leHBvcnRzLnNlY29uZFRhYiA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgaHRtbDoge30sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC50ZXh0KFwiU2Vjb25kIHRhYi5cIildLCBfX192aWV3KTsgfTsgfTtcbjtcbmV4cG9ydHMudGhpcmRUYWIgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCdwJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwudGV4dChcIlRoaXJkIHRhYi5cIildLCBfX192aWV3KTsgfTsgfTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHRhYl9sYXlvdXRfMS5UYWJMYXlvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGFicyc6IF9fX2NvbnRleHQudGFic1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkNsaWNrIGEgdGFiIHRvIGNoYW5nZSBjb250ZW50LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItbGF5b3V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VycyA9IFtcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGNjYzIxZmY3MjhjZjdmM2NlXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMCxcbiAgICAgICAgXCJndWlkXCI6IFwiZmQ5NGNkNTItZTdmMS00NGFiLWE3NGYtMDU2MDRlZWU0NmRkXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDg0OS45M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDM0LFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obnMgTGV3aXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIlBST0ZMRVhcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcImpvaG5zbGV3aXNAcHJvZmxleC5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5MjUpIDQwOS0zNDAwXCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjg3NCBHcm92ZSBTdHJlZXQsIEVkZ2V3YXRlciwgR2VvcmdpYSwgODExMlwiLFxuICAgICAgICBcImFib3V0XCI6IFwiRXggZXNzZSBkb2xvcmUgZXQgc2ludCBzaW50IHByb2lkZW50IG5vc3RydWQgdXQgb2ZmaWNpYS4gRG8gbnVsbGEgbW9sbGl0IGRvbG9yZSB1dCBhdXRlIGV4Y2VwdGV1ciBkZXNlcnVudCBsYWJvcmlzIHV0IHByb2lkZW50LiBVbGxhbWNvIGVzdCBkZXNlcnVudCBleCBjb21tb2RvIHZlbmlhbSBkdWlzIGVsaXQgZXhjZXB0ZXVyIHZlbGl0IHVsbGFtY28gZGVzZXJ1bnQgY3VscGEgZG8gZXN0LlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE1LTAyLTIyVDEwOjI1OjMyICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDU2LjI3ODg2MixcbiAgICAgICAgXCJsb25naXR1ZGVcIjogLTc5LjQ1OTEwMSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwibGFib3JlXCIsXG4gICAgICAgICAgICBcInByb2lkZW50XCIsXG4gICAgICAgICAgICBcImFsaXF1YVwiLFxuICAgICAgICAgICAgXCJhbWV0XCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwib2ZmaWNpYVwiLFxuICAgICAgICAgICAgXCJlbmltXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWFzb24gTm9ibGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ29mZmV5IE1lbmRlelwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJEaW9ubmUgQ29sZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgSm9obnMgTGV3aXMhIFlvdSBoYXZlIDUgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJiYW5hbmFcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjMDlkYzFiY2RjNTczMjQ5MVwiLFxuICAgICAgICBcImluZGV4XCI6IDEsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjMzMjU1OTk1LTA0MzEtNDI3MS05ODc2LTM3ZWFiYzExN2E3YlwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IGZhbHNlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMiwxNjcuNDBcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyMyxcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJsdWVcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGlhbXNvbiBHcmVnb3J5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJORVRBR1lcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcIndpbGxpYW1zb25ncmVnb3J5QG5ldGFneS5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5MTApIDQ2Mi0zOTE4XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjE1OCBTZWRnd2ljayBTdHJlZXQsIEdsYXNnb3csIFV0YWgsIDU0OThcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkV4Y2VwdGV1ciBzaXQgbmlzaSBldCB2ZWxpdC4gTGFib3JpcyBtaW5pbSBpZCBkdWlzIGFkIHF1aSBjdXBpZGF0YXQuIEVzdCBMb3JlbSBxdWlzIGR1aXMgTG9yZW0gbGFib3JpcyB2ZWxpdCBsYWJvcmlzIG5vbiBleGNlcHRldXIgZXQgdmVsaXQgdm9sdXB0YXRlIHF1aS4gRG9sb3JlIHF1aSBhbmltIGV4ZXJjaXRhdGlvbiB2ZW5pYW0gaW5jaWRpZHVudCBsYWJvcmlzIGxhYm9yZS4gSWQgbWluaW0gbGFib3JlIGFtZXQgc3VudCBleGNlcHRldXIgdGVtcG9yIHByb2lkZW50LlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE2LTA0LTI1VDA0OjI1OjI0ICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDU0LjQ1NzgzMyxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogMTIyLjgwMzc2NSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwidGVtcG9yXCIsXG4gICAgICAgICAgICBcImV4ZXJjaXRhdGlvblwiLFxuICAgICAgICAgICAgXCJldFwiLFxuICAgICAgICAgICAgXCJlbGl0XCIsXG4gICAgICAgICAgICBcImV4XCIsXG4gICAgICAgICAgICBcImNpbGx1bVwiLFxuICAgICAgICAgICAgXCJsYWJvcmlzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTmF2YXJybyBSZWV2ZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3RhbnRvbiBWaW5jZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFsZXhpcyBHdXptYW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIFdpbGxpYW1zb24gR3JlZ29yeSEgWW91IGhhdmUgMSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImFwcGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0YzlkNzk5Nzg5YmM0OTRhM2NcIixcbiAgICAgICAgXCJpbmRleFwiOiAyLFxuICAgICAgICBcImd1aWRcIjogXCIxNThmZmE1ZC0xNWRhLTRhOWYtYTFkYS0wYTQ4Yjc2YjgyMjZcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDEsMjg5LjM1XCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMzMsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJncmVlblwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYWx0b24gSG91c2VcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIkVZRVdBWFwiLFxuICAgICAgICBcImVtYWlsXCI6IFwiZGFsdG9uaG91c2VAZXlld2F4LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDk1OSkgNTUwLTIyNjNcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiMTE2IEhvd2FyZCBBdmVudWUsIFJvc3Ntb3JlLCBOZXcgWW9yaywgNjMwMlwiLFxuICAgICAgICBcImFib3V0XCI6IFwiRWxpdCBldSBpcHN1bSBwYXJpYXR1ciBkdWlzIG1vbGxpdCBleCBxdWlzLiBBbWV0IG51bGxhIGV4ZXJjaXRhdGlvbiBsYWJvcmlzIG1pbmltIGZ1Z2lhdCB0ZW1wb3IgaW4gYWxpcXVhIG5pc2kgbm9zdHJ1ZCBhdXRlLiBEdWlzIG1pbmltIGVzc2UgaXJ1cmUgaXJ1cmUgZnVnaWF0IHNpdCBudWxsYSBldCB0ZW1wb3IgbmlzaSBjaWxsdW0gcHJvaWRlbnQgaWQgYWRpcGlzaWNpbmcuIEV1IGVsaXQgbWFnbmEgTG9yZW0gaXJ1cmUgbGFib3JlLiBBbGlxdWlwIGlkIHNpbnQgdmVuaWFtIGFkaXBpc2ljaW5nLiBBbWV0IGVpdXNtb2QgbW9sbGl0IHJlcHJlaGVuZGVyaXQgcmVwcmVoZW5kZXJpdCBkb2xvcmUuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTctMDItMjhUMDg6NTM6MDAgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogLTI1LjY3OTc3NCxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogMjkuMzc0NzgxLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJxdWlcIixcbiAgICAgICAgICAgIFwiY2lsbHVtXCIsXG4gICAgICAgICAgICBcImFuaW1cIixcbiAgICAgICAgICAgIFwiaXJ1cmVcIixcbiAgICAgICAgICAgIFwibm9uXCIsXG4gICAgICAgICAgICBcImNvbW1vZG9cIixcbiAgICAgICAgICAgIFwiZGVzZXJ1bnRcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDYXJtZWxhIFdpbGNveFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFbGJhIEdhcnphXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdhcnJpc29uIENodXJjaFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgRGFsdG9uIEhvdXNlISBZb3UgaGF2ZSAxIHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwiYXBwbGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjZDE1MThjM2E0NGQ2OWZmZlwiLFxuICAgICAgICBcImluZGV4XCI6IDMsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjUxMDliYzUwLTlhOGUtNDE4NC1hYmEwLTY3NDBkYzAwYjYwNlwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IHRydWUsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQzLDg5MS44M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDIyLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSYXkgV2lsa2luc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiRVhQT1NBXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJyYXl3aWxraW5zQGV4cG9zYS5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg4MTIpIDQxNC0zMjU4XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjgzNyBCZWRmb3JkIEF2ZW51ZSwgSGFybGVpZ2gsIFNvdXRoIENhcm9saW5hLCAyMzIzXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFc3QgYW1ldCBxdWlzIGV1IHByb2lkZW50IGlwc3VtIHZlbmlhbSBzaXQuIElydXJlIGxhYm9yZSBhZCBjb25zZWN0ZXR1ciB1bGxhbWNvIHNpdCBpcHN1bSBwcm9pZGVudC4gQWQgcGFyaWF0dXIgaXJ1cmUgbmlzaSBpcnVyZSBjb21tb2RvIGFsaXF1aXAgbmlzaSBldSBhbmltIGlydXJlIGRvbG9yIGRvbG9yIHZlbmlhbSBxdWlzLlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE1LTA5LTE3VDA0OjUyOjQyICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDM0LjM1NDgwMSxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogLTE2OC4zMDM5NTIsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcIm5pc2lcIixcbiAgICAgICAgICAgIFwibGFib3Jpc1wiLFxuICAgICAgICAgICAgXCJpbmNpZGlkdW50XCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwiYXV0ZVwiLFxuICAgICAgICAgICAgXCJxdWlzXCIsXG4gICAgICAgICAgICBcIm1vbGxpdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk9saXZpYSBSdXNzb1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSaXRhIFR5bGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkxvcmllIFdhbGtlclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgUmF5IFdpbGtpbnMhIFlvdSBoYXZlIDEgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJzdHJhd2JlcnJ5XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0YzY5MDFiZGEwMDNlNTJmYTZcIixcbiAgICAgICAgXCJpbmRleFwiOiA0LFxuICAgICAgICBcImd1aWRcIjogXCIwYWIzMzQ3Ny1iMTUyLTRiMTItYWYzNS1mNWI5MjU0ZDVjMmFcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiB0cnVlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMyw3MzAuNzFcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyNyxcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJyb3duXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1hZGRlbiBIYXRmaWVsZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiWk9HQUtcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcIm1hZGRlbmhhdGZpZWxkQHpvZ2FrLmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDgzMikgNTUyLTIyOTRcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiNTMwIENsZXJtb250IEF2ZW51ZSwgQmV0aHBhZ2UsIFZpcmdpbiBJc2xhbmRzLCA1NjA3XCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJDb21tb2RvIHRlbXBvciBhbmltIHRlbXBvciBkZXNlcnVudCBsYWJvcmlzIHF1aSBldSByZXByZWhlbmRlcml0IGNvbnNlcXVhdC4gTm9uIGxhYm9ydW0gdWxsYW1jbyBxdWkgcHJvaWRlbnQuIEVzdCBjdXBpZGF0YXQgZG8gZG9sb3IgZXhjZXB0ZXVyIGVzdCBub3N0cnVkIGxhYm9ydW0uIEV1IGV4Y2VwdGV1ciBleCBjb21tb2RvIGFsaXF1aXAgYWRpcGlzaWNpbmcgZXhjZXB0ZXVyLiBFdCByZXByZWhlbmRlcml0IGxhYm9yaXMgcmVwcmVoZW5kZXJpdCBhdXRlIHV0IGV4Y2VwdGV1ciBkZXNlcnVudCBub3N0cnVkIHZlbGl0LiBVbGxhbWNvIGVzdCBzaXQgZnVnaWF0IGlydXJlIGFsaXF1YSBhbGlxdWlwIHByb2lkZW50LiBWb2x1cHRhdGUgYWQgY3VscGEgZG9sb3IgaWQgZW5pbSB0ZW1wb3IgbGFib3J1bS5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNi0wNC0xMFQwMzozNzoxNyArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiA4MC44ODg4NzYsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDExNy44NDMzNyxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwib2NjYWVjYXRcIixcbiAgICAgICAgICAgIFwibmlzaVwiLFxuICAgICAgICAgICAgXCJlc3RcIixcbiAgICAgICAgICAgIFwiYWRcIixcbiAgICAgICAgICAgIFwibm9zdHJ1ZFwiLFxuICAgICAgICAgICAgXCJldVwiLFxuICAgICAgICAgICAgXCJkb2xvcmVcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJWaW5jZW50IEdheVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSb3NhcmlvIEZvcmJlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJCYXh0ZXIgR3JlZW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIE1hZGRlbiBIYXRmaWVsZCEgWW91IGhhdmUgNCB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImJhbmFuYVwiXG4gICAgfVxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciB0YWJsZV8xID0gcmVxdWlyZShcIi4vd21sL3RhYmxlXCIpO1xudmFyIGRhdGFfMSA9IHJlcXVpcmUoXCIuL2RhdGFcIik7XG52YXIgY29sdW1ucyA9IFtcbiAgICB7IG5hbWU6ICdpbmRleCcsIGhlYWRpbmc6ICcjJyB9LFxuICAgIHsgbmFtZTogJ25hbWUnLCBoZWFkaW5nOiAnTmFtZScgfSxcbiAgICB7IG5hbWU6ICdiYWxhbmNlJywgaGVhZGluZzogJ0JhbGFuY2UnIH1cbl07XG52YXIgVGFibGVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB0YWJsZV8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB1c2VyczogZGF0YV8xLnVzZXJzLFxuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIG9uQ2VsbENsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIllvdSBjbGlja2VkIFwiICsgZS5jb2x1bW4gKyBlLnJvd051bWJlciArIFwiIVwiKSk7XG4gICAgICAgICAgICAgICAgZS5jZWxsLnNldENvbnRlbnQoeyByZW5kZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYW47IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGFibGVQYWdlID0gVGFibGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBwYWdlX2V4YW1wbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWdlLWV4YW1wbGVcIik7XG47XG52YXIgVGFibGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvZGF0YS90YWJsZS9UYWJsZVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChwYWdlX2V4YW1wbGVfMS5QYWdlRXhhbXBsZSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFRhYmxlXzEuVGFibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0YWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IF9fX2NvbnRleHQudmFsdWVzLnVzZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMnOiBfX19jb250ZXh0LnZhbHVlcy5jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2VsbENsaWNrZWQnOiBfX19jb250ZXh0LnZhbHVlcy5vbkNlbGxDbGlja2VkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RleHQtZmllbGRcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgVGV4dEZpZWxkUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEZpZWxkUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmllbGRQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWQgPSAndGV4dCc7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2Vycm9yJykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmdldChfdGhpcy5pZCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuZXJyb3IoJ1RoaXMgY29udHJvbCBpcyBub3cgaW4gdGhlIGVycm9yIHN0YXRlIScpO1xuICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdzdWNjZXNzJykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXQoX3RoaXMuaWQsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWNjZXNzKCdUaGlzIGNvbnRyb2wgaXMgbm93IGluIHRoZSBzdWNjZXNzIHN0YXRlIScpO1xuICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3dhcm5pbmcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXQoX3RoaXMuaWQsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMud2FybmluZygnVGhpcyBjb250cm9sIG5vdyBpbiB0aGUgd2FybmluZyBzdGF0ZSEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ25ldXRyYWwnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0KF90aGlzLmlkLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5uZXV0cmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kQnlJZCgnY29udGVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dEZpZWxkUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGV4dEZpZWxkUGFnZSA9IFRleHRGaWVsZFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGdyaWRfbGF5b3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2xheW91dC9ncmlkLWxheW91dFwiKTtcbjtcbnZhciB0ZXh0X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdGV4dC1maWVsZFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaXM6XCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcImNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KFwiKE5vdGhpbmcpXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3N0cm9uZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJTdWNjZXNzXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQodGV4dF9maWVsZF8xLlRleHRGaWVsZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VjY2Vzcyc6IFwiVGhpcyB0ZXh0ZmllbGQgaGFzIGEgc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGdyaWRfbGF5b3V0XzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdzdHJvbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiV2FybmluZ1wiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dhcm5pbmcnOiBcIlRoaXMgdGV4dGZpZWxkIGhhcyBhIHdhcm5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3N0cm9uZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJFcnJvclwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJzogXCJUaGlzIHRleHRmaWVsZCBoYXMgYW4gZXJyb3IuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoZ3JpZF9sYXlvdXRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChncmlkX2xheW91dF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaGUgb25lIHVzZXMgcm93cyB0byByZW5kZXIgYSB0ZXh0IGFyZWE6XCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jvd3MnOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3Rvb2xiYXJcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgVG9vbGJhclBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvb2xiYXJQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVG9vbGJhclBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlRvb2xiYXJQYWdlID0gVG9vbGJhclBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHBhZ2VfZXhhbXBsZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3BhZ2UtZXhhbXBsZVwiKTtcbjtcbnZhciB0b29sYmFyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvdG9vbGJhclwiKTtcbjtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvY29udHJvbC9idXR0b25cIik7XG47XG52YXIgYnV0dG9uX2dyb3VwXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL2NvbnRyb2wvYnV0dG9uLWdyb3VwXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHBhZ2VfZXhhbXBsZV8xLlBhZ2VFeGFtcGxlLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQodG9vbGJhcl8xLlRvb2xiYXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlN0YXJ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJ1dHRvbl9ncm91cF8xLkJ1dHRvbkdyb3VwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiVXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJEb3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiUmVzZXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiU3RvcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbGJhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGRyYXdlcl9sYXlvdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvbGF5b3V0L2RyYXdlci1sYXlvdXRcIik7XG47XG52YXIgYWN0aW9uX2Jhcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9hcHAvYWN0aW9uLWJhclwiKTtcbjtcbjtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvY29udHJvbC9idXR0b25cIik7XG47XG52YXIgZGFzaF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9hcHAvZGFzaFwiKTtcbjtcbnZhciBtYWluX2xheW91dF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9sYXlvdXQvbWFpbi1sYXlvdXRcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoZHJhd2VyX2xheW91dF8xLkRyYXdlckxheW91dCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5sYXlvdXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICdkcmF3ZXInOiBfX19jb250ZXh0Lm5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChhY3Rpb25fYmFyXzEuQWN0aW9uQmFyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYnV0dG9uXzEuQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJ0b2dnbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudG9nZ2xlRHJhd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtYWluX2xheW91dF8xLk1haW5MYXlvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQuY29udGVudCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY29udGVudC5yZW5kZXIoKSkgOiBfX193bWwuZG9taWZ5KFwiXCIpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbnZhciBuYXZfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvY29udGVudC9uYXZcIik7XG47XG52YXIgaXRlbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9jb250ZW50L25hdi9pdGVtXCIpO1xuO1xudmFyIG5hdl9oZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvY29udGVudC9uYXYvbmF2LWhlYWRlclwiKTtcbjtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2NvbnRlbnQvbmF2L2xpbmtcIik7XG52YXIgTmF2aWdhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQobmF2XzEuTmF2LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAndmVydGljYWwnOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoaXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChsaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImhvbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImhvbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiSG9tZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwubWFwKF9fX2NvbnRleHQubGlua3MsIGZ1bmN0aW9uIF9tYXAoaXRlbXMsIHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoaXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChuYXZfaGVhZGVyXzEuTmF2SGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQuZGlzcGxheU5hbWUoc2VjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobmF2XzEuTmF2LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmVydGljYWwnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC5zb3J0KGl0ZW1zKSwgZnVuY3Rpb24gX21hcChfLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KGl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL1wiICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJcIiArIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQuZGlzcGxheU5hbWUobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOYXZpZ2F0aW9uO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3JpZW50YXRpb24gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9vcmllbnRhdGlvblwiKTtcbnZhciBHcm91cF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgYWN0aW9uX2Jhcl8xID0gcmVxdWlyZShcIi4vd21sL2FjdGlvbi1iYXJcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIEFDVElPTl9CQVIgY2xhc3MgbmFtZS4gZm9yIHRoZSBBY3Rpb25CYXIgcm9vdC5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSID0gJ3d3LWFjdGlvbi1iYXInO1xuLyoqXG4gKiBBQ1RJT05fQkFSX0NPTlRFTlQgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSX0NPTlRFTlQgPSAnd3ctYWN0aW9uLWJhcl9fY29udGVudCc7XG4vKipcbiAqIEFjdGlvbkJhciBwcm92aWRlcyBhIGJhciBhY3Jvc3MgdGhlIHNjcmVlbiB0aGF0IGNhbiBiZVxuICogdXNlZCBhcyBhIHRvb2xiYXIsIG5hdmlnYXRpb24gbWVudSBvciBzb21ldGhpbmcgc2ltaWxsYXIuXG4gKi9cbnZhciBBY3Rpb25CYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbkJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25CYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGFjdGlvbl9iYXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnY29udGVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWwuY29tYmluZShbXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuQUNUSU9OX0JBUixcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24uUklHSFRfUFVTSEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLlBPU0lUSU9ORURcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBleHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY3Rpb25CYXI7XG59KEdyb3VwXzEuR3JvdXApKTtcbmV4cG9ydHMuQWN0aW9uQmFyID0gQWN0aW9uQmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQuY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbi1iYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGRhc2hfMSA9IHJlcXVpcmUoXCIuL3dtbC9kYXNoXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBEQVNIXG4gKi9cbmV4cG9ydHMuREFTSCA9ICd3dy1kYXNoJztcbi8vL2NsYXNzTmFtZXM6ZW5kXG4vKipcbiAqIERhc2ggYXJlIGxpdGVyYWwgaG9yaXpvbnRhbCBkYXNoZXMuXG4gKlxuICogVGhlc2UgY2FuIGJlIHVzZWQgd2l0aCBhcHAvbWVudS9CdXR0b24gdG8gY3JlYXRlICdoYW1idXJnZXInIG1lbnVzLlxuICovXG52YXIgRGFzaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGFzaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXNoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkYXNoXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogZXhwb3J0cy5EQVNIXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERhc2g7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EYXNoID0gRGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBhY3Rpdml0eV9pbmRpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL3dtbC9hY3Rpdml0eS1pbmRpY2F0b3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkFDVElWSVRZX0lORElDQVRPUiA9ICd3dy1hY3Rpdml0eS1pbmRpY2F0b3InO1xuLyoqXG4gKiBCdXN5IHByb3ZpZGVzIGEgY3NzIGRyaXZlbiBhbmltYXRpb24gdGhhdCBpbmRpY2F0ZXNcbiAqIHNvbWUgYWN0aW9uIG9yIGFjdGl2aXR5IGlzIGJlaW5nIGNhcnJpZWQgb3V0LlxuICovXG52YXIgQWN0aXZpdHlJbmRpY2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGl2aXR5SW5kaWNhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGl2aXR5SW5kaWNhdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBhY3Rpdml0eV9pbmRpY2F0b3JfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuQUNUSVZJVFlfSU5ESUNBVE9SLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjdGl2aXR5SW5kaWNhdG9yO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkFjdGl2aXR5SW5kaWNhdG9yID0gQWN0aXZpdHlJbmRpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5LWluZGljYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIEdyb3VwIGlzIGFuIGFic3RyYWN0IGNsYXNzIHByb3ZpZGluZyBhbiBhcGkgZm9yXG4gKiB3aWRnZXRzIHdob3NlIHByaW1hcnkgcHVycG9zZSBpcyBkaXNwbGF5aW5nIGNvbnRlbnQuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0Q29udGVudCBjaGFuZ2VzIHRoZSBjb250ZW50IHZhbHVlLlxuICAgICAqL1xuICAgIEdyb3VwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZW1vdmVDb250ZW50IHJlbW92ZXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgKi9cbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXA7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9icmVhZGNydW1iXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkJSRUFEQ1JVTUIgPSAnd3ctYnJlYWRjcnVtYic7IC8vQHRvZG8gdW4tYm9vdHN0cmFwXG4vLy9jbGFzc05hbWVzOmVuZFxudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuLi9pdGVtXCIpO1xuZXhwb3J0cy5JdGVtID0gaXRlbV8xLkl0ZW07XG4vKipcbiAqIEJyZWFkY3J1bWJcbiAqL1xudmFyIEJyZWFkY3J1bWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyZWFkY3J1bWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJlYWRjcnVtYigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkJSRUFEQ1JVTUIsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnJlYWRjcnVtYjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkJyZWFkY3J1bWIgPSBCcmVhZGNydW1iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ29sJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVhZGNydW1iLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL25hdlwiKTtcbnZhciBvcmllbnRhdGlvbl8xID0gcmVxdWlyZShcIi4uL29yaWVudGF0aW9uXCIpO1xudmFyIGl0ZW1fMSA9IHJlcXVpcmUoXCIuL2l0ZW1cIik7XG5leHBvcnRzLkl0ZW0gPSBpdGVtXzEuSXRlbTtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiLi9saW5rXCIpO1xuZXhwb3J0cy5MaW5rID0gbGlua18xLkxpbms7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIE5BVlxuICovXG5leHBvcnRzLk5BViA9ICd3dy1uYXYnO1xuLyoqXG4gKiBOYXYgcHJvdmlkZXMgc3R5bGluZyBmb3IgZGlzcGxheWluZyBhIGxpc3Qgb2YgYW5jaG9yIGxpbmtzLlxuICovXG52YXIgTmF2ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsLmNvbmNhdChleHBvcnRzLk5BViwgX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MsIF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZlcnRpY2FsICYmIG9yaWVudGF0aW9uXzEuVkVSVElDQUwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5hdjtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5OYXYgPSBOYXY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2l0ZW1cIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RhdGUvYWN0aXZlXCIpO1xudmFyIGFjdGl2ZV8yID0gcmVxdWlyZShcIi4uLy4uL3N0YXRlL2FjdGl2ZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbFwiKTtcbnZhciBnZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBpLnZpZXcuZmluZEJ5SWQoaS52YWx1ZXMucm9vdC5pZCkubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlOyB9KTsgfTtcbn07XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIElURU1cbiAqL1xuZXhwb3J0cy5JVEVNID0gJ3d3LWl0ZW0nO1xuLyoqXG4gKiBJdGVtQ2xpY2tlZEV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGl0ZW0gaW5cbiAqIGEgbmF2IGxpc3QuXG4gKi9cbnZhciBJdGVtQ2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEl0ZW1DbGlja2VkRXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbUNsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkl0ZW1DbGlja2VkRXZlbnQgPSBJdGVtQ2xpY2tlZEV2ZW50O1xuLyoqXG4gKiBJdGVtIHdyYXBzIGNvbnRlbnQgaW4gYSBuYXZpZ2F0aW9uIGxpc3QuXG4gKlxuICogSXRlbXMgc2hvdWxkIG5vdCBoYXZlIGFueSBzaWJsaW5ncyB0aGF0IGFyZSBub3Qgb3RoZXIgSXRlbXMuXG4gKi9cbnZhciBJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IGFjdGl2ZV8xLmFjdGl2YXRlKF90aGlzKShnZXQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IGFjdGl2ZV8xLmRlYWN0aXZhdGUoX3RoaXMpKGdldChfdGhpcykpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLklURU0sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gYWN0aXZlXzIuQUNUSVZFIDogbnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogX3RoaXMuY2hpbGRyZW47IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5JdGVtID0gSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQucmVuZGVyKCkpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpbmtcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RhdGUvYWN0aXZlXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBMSU5LXG4gKi9cbmV4cG9ydHMuTElOSyA9ICd3dy1saW5rJztcbi8qKlxuICogTGlua0NsaWNrZWRFdmVudCBpbmRpY2F0ZXMgYW4gTGluayBoYXMgYmVlbiBjbGlja2VkLlxuICovXG52YXIgTGlua0NsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rQ2xpY2tlZEV2ZW50KG5hbWUsIGhyZWYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5MaW5rQ2xpY2tlZEV2ZW50ID0gTGlua0NsaWNrZWRFdmVudDtcbi8qKlxuICogTGluayBnZW5lcmF0ZXMgYW4gPGE+IGVsZW1lbnQuXG4gKi9cbnZhciBMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZSBhc3NpZ25lZCB0byB0aGlzIExpbmsuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpdGxlIGFzc2lnbmVkIHRvIHRoaXMgTGluay5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRpdGxlID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRpdGxlKSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogaHJlZiBhc3NpZ25lZCB0byB0aGlzIExpbmtcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmhyZWYgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaHJlZikgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcnO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkxJTkssIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVfMS5BQ1RJVkUgOiAnJyksXG4gICAgICAgICAgICAgICAgdGl0bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgaHJlZjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhyZWYpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcjJyxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYWN0aXZlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IF90aGlzLmNoaWxkcmVuOyB9LFxuICAgICAgICAgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuYXR0cnMud3csIG5hbWVfMSA9IF9hLm5hbWUsIGhyZWYgPSBfYS5ocmVmLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25DbGljaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKG5ldyBMaW5rQ2xpY2tlZEV2ZW50KG5hbWVfMSwgaHJlZikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuYS5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LnJlbW92ZShhY3RpdmVfMS5BQ1RJVkUpO1xuICAgICAgICAgICAgdy5jbGFzc0xpc3QuYWRkKGFjdGl2ZV8xLkFDVElWRSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGRlYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBpdGVtLlxuICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5hLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZV8xLkFDVElWRSk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBMaW5rO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkxpbmsgPSBMaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5hLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAnaHJlZic6IF9fX2NvbnRleHQudmFsdWVzLmEuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogX19fY29udGV4dC52YWx1ZXMuYS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuYS5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy5hLmNsaWNrZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmEuY29udGVudCgpKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9uYXYtaGVhZGVyXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBOQVZfSEVBREVSXG4gKi9cbmV4cG9ydHMuTkFWX0hFQURFUiA9ICd3dy1uYXYtaGVhZGVyJztcbi8qKlxuICogTmF2SGVhZGVyIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgbm9uLWNsaWNrYWJsZSBoZWFkaW5nIHRleHQgaW4gYSBuYXYgbGlzdC5cbiAqL1xudmFyIE5hdkhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2SGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hdkhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICBjbGFzczogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5OQVZfSEVBREVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOYXZIZWFkZXI7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTmF2SGVhZGVyID0gTmF2SGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5zcGFuLmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLnRleHQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA6IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXYtaGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd1bCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBWRVJUSUNBTCBpbmRpY2F0ZXMgYW4gZWxlbWVudCBpcyB2ZXJ0aWNhbCByZW5kZXJlcmQuXG4gKi9cbmV4cG9ydHMuVkVSVElDQUwgPSAnLXZlcnRpY2FsJztcbi8qKlxuICogUklHSFRfUFVTSEFCTEUgaW5kaWNhdGVzIGFuIGVsZW1lbnQgY2FuIHN1cHBvcnRzIGJlaW5nIHB1c2hlZCByaWdodFxuICogYnkgc3BlY2lmeWluZyBzdHlsZXMgYXJvdW5kIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydHMuUklHSFRfUFVTSEFCTEUgPSAnLXJpZ2h0LXB1c2hhYmxlJztcbi8qKlxuICogUE9TSVRJT05FRCBpbmRpY2F0ZXMgYW4gZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFuZCByZXNwb25kc1xuICogdG8gdGhlIGxlZnQgLHJpZ2h0IG1vZGlmaWVycyBldGMuXG4gKi9cbmV4cG9ydHMuUE9TSVRJT05FRCA9ICctcG9zaXRpb25lZCc7XG4vKipcbiAqIEJMT0NLIGluZGljYXRlcyBhbiBlbGVtZW50IHNob3VsZCBiZSBibG9jayBkaXNwbGF5ZWQuXG4gKi9cbmV4cG9ydHMuQkxPQ0sgPSAnLWJsb2NrJztcbi8qKlxuICogQ0xFQVJGSVggaGFjay5cbiAqL1xuZXhwb3J0cy5DTEVBUkZJWCA9ICctY2xlYXJmaXgnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5FWFRSQV9TTUFMTCA9ICcteHMtc21hbGwnO1xuZXhwb3J0cy5TTUFMTCA9ICctc21hbGwnO1xuZXhwb3J0cy5NRURJVU0gPSAnLW1lZGl1bSc7XG5leHBvcnRzLkxBUkdFID0gJy1sYXJnZSc7XG5leHBvcnRzLkVYVFJBX0xBUkdFID0gJy14cy1sYXJnZSc7XG4vLy9jbGFzc05hbWVzOmVuZFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogQUNUSVZFXG4gKi9cbmV4cG9ydHMuQUNUSVZFID0gJy1hY3RpdmUnO1xuLyoqXG4gKiBkZWFjdGl2YXRlIHRoaXMgbmF2IGxpc3QgaXRlbS5cbiAqL1xuZXhwb3J0cy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZShleHBvcnRzLkFDVElWRSk7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBhOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLyoqXG4gKiBhY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IEl0ZW0uXG4gKi9cbmV4cG9ydHMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoZXhwb3J0cy5BQ1RJVkUpO1xuICAgICAgICBlLmNsYXNzTGlzdC5hZGQoZXhwb3J0cy5BQ1RJVkUpO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBhOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiYWZwbC9saWIvbW9uYWQvTWF5YmVcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG4vKipcbiAqIEhJRERFTiBtZWFucyBhbiBlbGVtZW50IHNob3VsZCBub3QgYmUgdmlzaWJsZSBidXQgbm90IHJlbW92ZWRcbiAqIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0cy5ISURERU4gPSAnLWhpZGRlbic7XG4vKipcbiAgKiB2aXNpYmxlIHF1ZXJpZXMgd2hldGhlciB0aGUgSGlkYWJsZSBpcyB2aXNpYmxlIG9yIG5vdC5cbiAgKlxuICAqIEl0IHJldHJpZXZlcyBhbiBIVE1MRWxlbWVudCBieSBpZCBhbmQgY2hlY2tzIHdoZXRoZXJcbiAgKiBpdCBkb2VzIG5vdCBoYXZlIGEgaGlkZGVuIGNsYXNzLlxuICAqL1xuZXhwb3J0cy5pc0hpZGRlbiA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKGV4cG9ydHMuSElEREVOKTsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSlcbiAgICAgICAgLmdldCgpO1xufTsgfTtcbi8qKlxuICogaGlkZSB0aGUgSGlkYWJsZS5cbiAqXG4gKiBUaGlzIGlzIGFjaGVpdmVkIGJ5IGFkZGluZyBhICdoaWRkZW4nIGNsYXNzIG5hbWVcbiAqIHRvIGFuIEhUTUxFbGVtZW50IHJldHJpZXZlZCBieSBpZC5cbiAqL1xuZXhwb3J0cy5oaWRlID0gZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgZS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuSElEREVOKTsgZS5jbGFzc0xpc3QuYWRkKGV4cG9ydHMuSElEREVOKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBoOyB9KVxuICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGg7IH0pXG4gICAgICAgIC5nZXQoKTtcbn07IH07IH07XG4vKipcbiAqIHNob3cgdGhlIEhpZGFibGVcbiAqXG4gKiBUaGlzIGlzIGFjaGVpdmVkIGJ5IHJlbW92aW5nIGEgJ2hpZGRlbicgY2xhc3MgbmFtZVxuICogdG8gYW4gSFRNTEVsZW1lbnQgcmV0cmlldmVkIGJ5IGlkLlxuICovXG5leHBvcnRzLnNob3cgPSBmdW5jdGlvbiAoaCkgeyByZXR1cm4gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1heWJlXzEuTWF5YmVcbiAgICAgICAgLmZyb21Cb29sZWFuKGguaXNIaWRkZW4oKSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBmbigpLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QucmVtb3ZlKGV4cG9ydHMuSElEREVOKTsgfSk7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaDsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBoOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLyoqXG4gKiB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEhpZGFibGUuXG4gKi9cbmV4cG9ydHMudG9nZ2xlID0gZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LnRvZ2dsZShleHBvcnRzLkhJRERFTik7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaDsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBoOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGlkZGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBERUZBVUxUIHN0eWxlLlxuICovXG5leHBvcnRzLkRFRkFVTFQgPSAnLWRlZmF1bHQnO1xuLyoqXG4gKiBQUklNQVJZIHN0eWxlLlxuICovXG5leHBvcnRzLlBSSU1BUlkgPSAnLXByaW1hcnknO1xuLyoqXG4gKiBTVUNDRVNTIHN0eWxlLlxuICovXG5leHBvcnRzLlNVQ0NFU1MgPSAnLXN1Y2Nlc3MnO1xuLyoqXG4gKiBJTkZPIHN0eWxlLlxuICovXG5leHBvcnRzLklORk8gPSAnLWluZm8nO1xuLyoqXG4gKiBXQVJOSU5HIHN0eWxlLlxuICovXG5leHBvcnRzLldBUk5JTkcgPSAnLXdhcm5pbmcnO1xuLyoqXG4gKiBFUlJPUiBzdHlsZS5cbiAqL1xuZXhwb3J0cy5FUlJPUiA9ICctZXJyb3InO1xuLyoqXG4gKiBPVVRMSU5FIHN0eWxlLlxuICovXG5leHBvcnRzLk9VVExJTkUgPSAnLW91dGxpbmUnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvY2FyZXRcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuQ0FSRVQgPSAnd3ctY2FyZXQnO1xudmFyIENhcmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXJldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXJldCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkNBUkVULCBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2FyZXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5DYXJldCA9IENhcmV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tZ3JvdXBcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4uL3Rvb2xiYXJcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkJVVFRPTl9HUk9VUCA9ICd3dy1idXR0b24tZ3JvdXAnO1xuLy8vY2xhc3NOYW1lczplbmRcbi8qKlxuICogQnV0dG9uR3JvdXAgZ3JvdXBzIG11bHRpcGxlIGJ1dHRvbnMgaW50byBvbmUgZWxlbWVudC5cbiAqL1xudmFyIEJ1dHRvbkdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25Hcm91cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25Hcm91cCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkJVVFRPTl9HUk9VUCwgdG9vbGJhcl8xLlRPT0xCQVJfQ09NUEFULCAoX3RoaXMuYXR0cnMud3cpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uR3JvdXA7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuQnV0dG9uR3JvdXAgPSBCdXR0b25Hcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbkdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1dHRvbkdyb3VwXzEgPSByZXF1aXJlKFwiLi9CdXR0b25Hcm91cFwiKTtcbmV4cG9ydHMuQnV0dG9uR3JvdXAgPSBCdXR0b25Hcm91cF8xLkJ1dHRvbkdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLWdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uLXNlbGVjdFwiKTtcbnZhciBzdHlsZSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0eWxlXCIpO1xudmFyIGFjdGl2ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZTpiZWdpblxuZXhwb3J0cy5CVVRUT05fU0VMRUNUID0gJ3d3LWJ1dHRvbi1zZWxlY3QnO1xuZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiA9ICd3dy1idXR0b24tc2VsZWN0X19vcHRpb24nO1xuLyoqXG4gKiBCdXR0b25DaGFuZ2VkRXZlbnRcbiAqL1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uQ2hhbmdlZEV2ZW50O1xufShfMS5FdmVudCkpO1xuZXhwb3J0cy5CdXR0b25DaGFuZ2VkRXZlbnQgPSBCdXR0b25DaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIEJ1dHRvblNlbGVjdFxuICovXG52YXIgQnV0dG9uU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25TZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uU2VsZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLkJVVFRPTl9TRUxFQ1RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmF0dHJzLnd3LnZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IF90aGlzLmF0dHJzLnd3Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy52YWx1ZXMuYnV0dG9ucy52YWx1ZSA9PT0gdjsgfSxcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5idXR0b25zLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBCdXR0b25DaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRDbGFzczogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiwgby5jbGFzcywgKF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHlsZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5ERUZBVUxULCBfdGhpcy52YWx1ZXMuYnV0dG9ucy5pc0FjdGl2ZShvLnZhbHVlKSA/IGFjdGl2ZS5BQ1RJVkUgOiAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b25TZWxlY3Q7XG59KF8xLkdlbmVyaWNDb250cm9sKSk7XG5leHBvcnRzLkJ1dHRvblNlbGVjdCA9IEJ1dHRvblNlbGVjdDtcbi8qKlxuICogTXVsdGlCdXR0b25TZWxlY3RcbiAqL1xudmFyIE11bHRpQnV0dG9uU2VsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aUJ1dHRvblNlbGVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aUJ1dHRvblNlbGVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5CVVRUT05fU0VMRUNUXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSB8fCBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBfdGhpcy5hdHRycy53dy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMudmFsdWVzLmJ1dHRvbnMudmFsdWUuaW5kZXhPZih2KSA+IC0xOyB9LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuYnV0dG9ucy52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXliZV8xLk1heWJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZyb21BcnJheShfdGhpcy52YWx1ZXMuYnV0dG9ucy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB2YWx1ZS5pbmRleE9mKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudChfdGhpcy5hdHRycy53dy5uYW1lLCB2YWx1ZS5zbGljZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt2XTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRDbGFzczogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiwgby5jbGFzcywgKF90aGlzLmF0dHJzLnd3LnN0eWxlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHlsZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5ERUZBVUxULCBfdGhpcy52YWx1ZXMuYnV0dG9ucy5pc0FjdGl2ZShvLnZhbHVlKSA/IGFjdGl2ZS5BQ1RJVkUgOiAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNdWx0aUJ1dHRvblNlbGVjdDtcbn0oXzEuR2VuZXJpY0NvbnRyb2wpKTtcbmV4cG9ydHMuTXVsdGlCdXR0b25TZWxlY3QgPSBNdWx0aUJ1dHRvblNlbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgYnV0dG9uX2dyb3VwXzEgPSByZXF1aXJlKFwiLi4vLi4vYnV0dG9uLWdyb3VwXCIpO1xuO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uL2J1dHRvblwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChidXR0b25fZ3JvdXBfMS5CdXR0b25Hcm91cCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuYnV0dG9ucy5vcHRpb25zLCBmdW5jdGlvbiBfbWFwKG9wdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChidXR0b25fMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9ucy5nZXRDbGFzcyhvcHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBfX19jb250ZXh0LnZhbHVlcy5idXR0b25zLmlzQWN0aXZlKG9wdC52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX19jb250ZXh0LnZhbHVlcy5idXR0b25zLmNsaWNrKG9wdC52YWx1ZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBvcHQudGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b25cIik7XG52YXIgc3R5bGUgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbnZhciBhY3RpdmUgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG52YXIgb3JpZW50YXRpb24gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9vcmllbnRhdGlvblwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB0b29sYmFyXzEgPSByZXF1aXJlKFwiLi4vdG9vbGJhclwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkJVVFRPTiA9ICd3dy1idXR0b24nO1xuO1xuLyoqXG4gKiBCdXR0b25DbGlja2VkRXZlbnRcbiAqL1xudmFyIEJ1dHRvbkNsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uQ2xpY2tlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkNsaWNrZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uQ2xpY2tlZEV2ZW50O1xufShfMS5FdmVudCkpO1xuZXhwb3J0cy5CdXR0b25DbGlja2VkRXZlbnQgPSBCdXR0b25DbGlja2VkRXZlbnQ7XG4vKipcbiAqIEJ1dHRvbiBpcyBhbiBpbXByb3ZlbWVudCBvdmVyIEhUTUxCdXR0aW9uRWxlbWVudFxuICovXG52YXIgQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dyA/XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jb25jYXQoZXhwb3J0cy5CVVRUT04sIHRvb2xiYXJfMS5UT09MQkFSX0NPTVBBVCwgX3RoaXMuYXR0cnMud3cuY2xhc3MsIF90aGlzLmF0dHJzLnd3LnN0eWxlIHx8IHN0eWxlLkRFRkFVTFQsIF90aGlzLmF0dHJzLnd3LnNpemUgJiYgX3RoaXMuYXR0cnMud3cuc2l6ZSwgX3RoaXMuYXR0cnMud3cub3V0bGluZSAmJiBzdHlsZS5PVVRMSU5FLCBfdGhpcy5hdHRycy53dy5ibG9jayAmJiBvcmllbnRhdGlvbi5CTE9DSywgX3RoaXMuYXR0cnMud3cuYWN0aXZlICYmIGFjdGl2ZS5BQ1RJVkUpIDogZXhwb3J0cy5CVVRUT04sXG4gICAgICAgICAgICAgICAgdHlwZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnR5cGUpID8gX3RoaXMuYXR0cnMud3cudHlwZSA6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/IF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRpc2FibGVkKSA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmF0dHJzLnd3ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DbGljayhuZXcgQnV0dG9uQ2xpY2tlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUgfHwgJycsIF90aGlzLmF0dHJzLnd3LnZhbHVlKSk7IH0sXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID8gX3RoaXMuYXR0cnMud3cudGV4dCA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSB0aGlzIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuYnV0dG9uLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYikgeyByZXR1cm4gYi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZW5hYmxlIHRoaXMgYnV0dG9uLlxuICAgICAqL1xuICAgIEJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmJ1dHRvbi5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuYnV0dG9uLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYikgeyByZXR1cm4gYi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgP1xuICAgICAgICAgICAgX3RoaXMuZW5hYmxlKCkgOlxuICAgICAgICAgICAgX3RoaXMuZGlzYWJsZSgpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b247XG59KF8xLkdlbmVyaWNDb250cm9sKSk7XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdidXR0b24nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5idXR0b24uaWQsXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbmNsaWNrXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnRleHQpLCBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2hlY2tib3hfMSA9IHJlcXVpcmUoXCIuL3dtbC9jaGVja2JveFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkNIRUNLQk9YID0gJ3d3LWNoZWNrYm94Jztcbi8qKlxuICogQ2hlY2tDaGFuZ2VkRXZlbnQgc2lnbmFscyB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgY2hlY2tib3ggc3RhdGUuXG4gKi9cbnZhciBDaGVja0NoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hlY2tDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hlY2tDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENoZWNrQ2hhbmdlZEV2ZW50O1xufShfMS5FdmVudCkpO1xuZXhwb3J0cy5DaGVja0NoYW5nZWRFdmVudCA9IENoZWNrQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBDaGVja2JveCBjb250cm9sLlxuICpcbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIG5hdGl2ZSBjaGVja2JveCB0aGF0IGNhbiBiZSBzdHlsZWQuXG4gKi9cbnZhciBDaGVja2JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hlY2tib3gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGNoZWNrYm94XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5DSEVDS0JPWCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmF0dHJzLnd3LnZhbHVlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlID0gKCFfdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKG5ldyBDaGVja0NoYW5nZWRFdmVudChfdGhpcy52YWx1ZXMuaW5wdXQubmFtZSwgX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlIHx8IGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveDtcbn0oXzEuR2VuZXJpY0NvbnRyb2wpKTtcbmV4cG9ydHMuQ2hlY2tib3ggPSBDaGVja2JveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2xhYmVsJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kYXRlXCIpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgX3ByZWZpeCA9IGZ1bmN0aW9uIChzLCBpbmMpIHtcbiAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gZmFsc2U7IH1cbiAgICB2YXIgbiA9IE51bWJlcihzKTtcbiAgICBpZiAoaW5jKVxuICAgICAgICBuID0gbiArIDE7XG4gICAgaWYgKGlzTmFOKG4pKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIChuIDwgMTApID8gXCIwXCIgKyBuIDogXCJcIiArIG47XG59O1xudmFyIF9tb250aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuTU9OVEhTLm1hcChmdW5jdGlvbiAobGFiZWwsIHZhbHVlKSB7IHJldHVybiAoeyBsYWJlbDogbGFiZWwsIHZhbHVlOiBfcHJlZml4KHZhbHVlICsgMSkgfSk7IH0pO1xufTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8qKlxuICogREFURSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBVEUgPSAnd3ctZGF0ZSc7XG4vKipcbiAqIERBVEVfREFZIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuREFURV9EQVkgPSBleHBvcnRzLkRBVEUgKyBcIl9fZGF5XCI7XG4vKipcbiAqIERBVEVfTU9OVEggY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5EQVRFX01PTlRIID0gZXhwb3J0cy5EQVRFICsgXCJfX21vbnRoXCI7XG4vKipcbiAqIERBVEVfWUVBUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBVEVfWUVBUiA9IGV4cG9ydHMuREFURSArIFwiX195ZWFyIGZvcm0tY29udHJvbFwiO1xuLyoqXG4gKiBEYXRlQ2hhbmdlZEV2ZW50IGlzIGdlbmVyYXRlZCB3aGVuIHRoZSBkYXRlIGhhc1xuICogYmVlbiBjaGFuZ2VkIHRvIGEgdmFsaWQgZGF0ZS5cbiAqL1xudmFyIERhdGVDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGVDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZUNoYW5nZWRFdmVudDtcbn0oXzEuRXZlbnQpKTtcbmV4cG9ydHMuRGF0ZUNoYW5nZWRFdmVudCA9IERhdGVDaGFuZ2VkRXZlbnQ7XG5leHBvcnRzLmZvcm1hdCA9IHtcbiAgICBZWVlZRERNTTogJ1lZWVktTU0tREQnLFxuICAgIEREOiAnREQnLFxuICAgIE1NOiAnTU0nLFxuICAgIFlZWVk6ICdZWVlZJ1xufTtcbmV4cG9ydHMuTU9OVEhTID0gW1xuICAgICdKYW4nLCAnRmViJywgJ01hcicsXG4gICAgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgICAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICdPY3QnLCAnTm92JywgJ0RlYydcbl07XG4vKipcbiAqIERhdGUgaW5wdXQuXG4gKi9cbnZhciBEYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jYWxjdWxhdGUoKS5mb3JtYXQoX3RoaXMudmFsdWVzLmRhdGUuZm9ybWF0KTsgfTtcbiAgICAgICAgX3RoaXMuc2V0ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzOyB9O1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRBVEUsICdmb3JtLWdyb3VwJywgX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MsIGZlZWRiYWNrXzEuc2VsZWN0U3RhdGUoX3RoaXMuYXR0cnMud3cpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmxpbmU6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm0taW5saW5lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBtb250aHM6IF9tb250aHMoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudChfdGhpcy5hdHRycy53dy52YWx1ZSwgZXhwb3J0cy5mb3JtYXQuWVlZWURETU0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXA6ICctJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGV4cG9ydHMuZm9ybWF0LllZWVlERE1NLFxuICAgICAgICAgICAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlICYmIF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlLmlzVmFsaWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgRGF0ZUNoYW5nZWRFdmVudChfdGhpcy52YWx1ZXMubmFtZSwgX3RoaXMudmFsdWVzLmRhdGUudmFsdWUuZm9ybWF0KF90aGlzLnZhbHVlcy5kYXRlLmZvcm1hdCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9udGg6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21vbnRoJyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRBVEVfTU9OVEgsICdmb3JtLWNvbnRyb2wnKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlICYmIF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlLmlzVmFsaWQoKSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuZGF0ZS52YWx1ZS5mb3JtYXQoZXhwb3J0cy5mb3JtYXQuTU0pIDogJyc7IH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5kaXNhYmxlZCA9PT0gdHJ1ZSkgP1xuICAgICAgICAgICAgICAgICAgICB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmRheS5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgZS5mb2N1cygpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMubW9udGgudmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGUudGFyZ2V0LnZhbHVlOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmRhdGUudmFsdWUgPSBfdGhpcy5jYWxjdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5kYXRlLmZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRheToge1xuICAgICAgICAgICAgICAgIGlkOiAnZGF5JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRBVEVfREFZLCAnZm9ybS1jb250cm9sJyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy52YWx1ZXMuZGF0ZS52YWx1ZSAmJiBfdGhpcy52YWx1ZXMuZGF0ZS52YWx1ZS5pc1ZhbGlkKCkpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmRhdGUudmFsdWUuZm9ybWF0KGV4cG9ydHMuZm9ybWF0LkREKSA6ICcnOyB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPT09IHRydWUpID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgb25pbnB1dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQub25pbnB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5kYXkub25rZXl1cChlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9ua2V5dXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuZGF5LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9wcmVmaXgodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuZGF0ZS52YWx1ZSA9IF90aGlzLmNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuZGF0ZS5maXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodmFsdWUsIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmRCeUlkKF90aGlzLnZhbHVlcy55ZWFyLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZm9jdXMoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHllYXI6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3llYXInLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLkRBVEVfWUVBUixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlICYmIF90aGlzLnZhbHVlcy5kYXRlLnZhbHVlLmlzVmFsaWQoKSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuZGF0ZS52YWx1ZS5mb3JtYXQoZXhwb3J0cy5mb3JtYXQuWVlZWSkgOiAnJzsgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRpc2FibGVkID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uaW5wdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0Lm9uaW5wdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMueWVhci5vbmtleXVwKGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25rZXl1cDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnllYXIudmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlLnRhcmdldC52YWx1ZTsgfTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmRhdGUudmFsdWUgPSBfdGhpcy5jYWxjdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLmRhdGUuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgfHwgJzxuYW1lPicsXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZXMnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5zdWNjZXNzKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5lcnJvcikgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy53YXJuaW5nKSB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgfHwgJzxuYW1lPicsXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmxhYmVsKSB8fCAnPGxhYmVsPidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGRhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0cy5cbiAgICAgKi9cbiAgICBEYXRlLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRlID0gW1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMueWVhci52YWx1ZSgpLFxuICAgICAgICAgICAgdGhpcy52YWx1ZXMubW9udGgudmFsdWUoKSxcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmRheS52YWx1ZSgpXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkOyB9KTtcbiAgICAgICAgcmV0dXJuIChkYXRlLmxlbmd0aCAhPSAzKSA/XG4gICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgIG1vbWVudChkYXRlLmpvaW4odGhpcy52YWx1ZXMuZGF0ZS5zZXApLCBtb21lbnQuSVNPXzg2MDEpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBEYXRlO1xufShmZWVkYmFja18xLkdlbmVyaWNGZWVkYmFja0NvbnRyb2wpKTtcbmV4cG9ydHMuRGF0ZSA9IERhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIi4uLy4uL3dtbFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KHdtbF8xLmxhYmVsKF9fX2NvbnRleHQudmFsdWVzLmxhYmVsLmlkKShfX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0KShfX192aWV3KSksIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmlubGluZS5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5vbmNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZWQnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5jbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLm1vbnRoLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnb3B0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGVjdGVkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiTW9udGhcIildLCBfX192aWV3KSwgX19fd21sLm1hcChfX19jb250ZXh0LnZhbHVlcy5kYXRlLm1vbnRocywgZnVuY3Rpb24gX21hcChvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ29wdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogb3B0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShvcHQubGFiZWwpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25pbnB1dCc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5vbmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmtleXVwJzogX19fY29udGV4dC52YWx1ZXMuZGF5Lm9ua2V5dXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMuZGF5LnZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuZGF5LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IFwiMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IFwiRERcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLnllYXIuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uaW5wdXQnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLm9uaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ua2V5dXAnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLm9ua2V5dXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogX19fY29udGV4dC52YWx1ZXMueWVhci52YWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLnllYXIuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMueWVhci5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInOiBcIllZWVlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IFwiNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMueWVhci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5tZXNzYWdlcy5pZCkoX19fY29udGV4dC52YWx1ZXMubWVzc2FnZXMpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2Ryb3AtZG93blwiKTtcbnZhciBoaWRkZW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdGF0ZS9oaWRkZW5cIik7XG52YXIgc3R5bGUgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGNvbnRlbnQgPSBmdW5jdGlvbiAoZG0pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZG0udmlldy5maW5kQnlJZChkbS52YWx1ZXMuY29udGVudC5pZCk7XG59OyB9O1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5EUk9QX0RPV04gPSAnd3ctZHJvcC1kb3duLW1lbnUnO1xuZXhwb3J0cy5EUk9QX0RPV05fVE9HR0xFID0gJ3d3LWRyb3AtZG93bi1tZW51X190b2dnbGUnO1xuZXhwb3J0cy5EUk9QX0RPV05fQ09OVEVOVCA9ICd3dy1kcm9wLWRvd25fX2NvbnRlbnQnO1xuLyoqXG4gKiBEcm9wRG93biBwcm92aWRlcyBhIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhIHBvcCB1cCBtZW51LlxuICpcbiAqXG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICB8ICBNZW51ICB8XG4gKiAgICArLS0tLS0tLS0rXG4gKiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKi9cbnZhciBEcm9wRG93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJvcERvd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJvcERvd24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5pc0hpZGRlbiA9IGhpZGRlbi5pc0hpZGRlbihjb250ZW50KF90aGlzKSk7XG4gICAgICAgIF90aGlzLmhpZGUgPSBoaWRkZW4uaGlkZShfdGhpcykoY29udGVudChfdGhpcykpO1xuICAgICAgICBfdGhpcy5zaG93ID0gaGlkZGVuLnNob3coX3RoaXMpKGNvbnRlbnQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMudG9nZ2xlID0gaGlkZGVuLnRvZ2dsZShfdGhpcykoY29udGVudChfdGhpcykpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRST1BfRE9XTiwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogX3RoaXMuYXR0cnMud3cuYnV0dG9uVGV4dCA/IF90aGlzLmF0dHJzLnd3LmJ1dHRvblRleHQgOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzczogc3R5bGUuREVGQVVMVCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXR0cnMud3cuYnV0dG9uVGVtcGxhdGUgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5idXR0b25UZW1wbGF0ZSA6IHZpZXdzLmJ1dHRvbjsgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGU6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRST1BfRE9XTl9UT0dHTEUsIHN0eWxlLlBSSU1BUlkpLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmFsdWVzLmNvbnRlbnQuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2hpbGRyZW5baV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5oaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jaGlsZHJlbltpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLmhpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoX3RoaXMudG9nZ2xlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcyk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkRST1BfRE9XTl9DT05URU5ULCBoaWRkZW4uSElEREVOKSxcbiAgICAgICAgICAgICAgICBhdXRvQ2xvc2U6IChfdGhpcy5hdHRycy53dy5hdXRvQ2xvc2UgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNoaWxkcmVuOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJvcERvd24ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5yb290LmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMpO1xuICAgICAgICAgICAgaWYgKCghcm9vdC5jb250YWlucyhlLnRhcmdldCkpKVxuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcERvd247XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Ecm9wRG93biA9IERyb3BEb3duO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi8uLi9idXR0b25cIik7XG47XG52YXIgY2FyZXRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250ZW50L3gvY2FyZXRcIik7XG47XG5leHBvcnRzLmJ1dHRvbiA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLmJveChfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge30sXG4gICAgd3c6IHtcbiAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudmFsdWVzLnRvZ2dsZS5vbkNsaWNrLFxuICAgICAgICAndGV4dCc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZXh0XG4gICAgfVxufSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge30sXG4gICAgd3c6IHtcbiAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMudG9nZ2xlLmNsYXNzLFxuICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudmFsdWVzLnRvZ2dsZS5vbkNsaWNrXG4gICAgfVxufSwgW19fX3dtbC53aWRnZXQoY2FyZXRfMS5DYXJldCwge1xuICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpKTsgfTsgfTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnRlbXBsYXRlKCkoX19fY29udGV4dCkoX19fdmlldykpLCBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5pZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuY29udGVudC5yZW5kZXIoKSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3AtZG93bi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0eWxlID0gcmVxdWlyZShcIi4uL2NvbnRlbnQvc3R5bGVcIik7XG52YXIgTWF5YmVfMSA9IHJlcXVpcmUoXCJhZnBsL2xpYi9tb25hZC9NYXliZVwiKTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiLi4vY29udHJvbFwiKTtcbmV4cG9ydHMuTkVVVFJBTCA9IDB4MDtcbmV4cG9ydHMuRVJST1IgPSAweDE7XG5leHBvcnRzLlNVQ0NFU1MgPSAweDI7XG5leHBvcnRzLldBUk5JTkcgPSAweDM7XG4vKipcbiAqIFZhbGlkYXRpb25TdGF0ZVxuICovXG52YXIgVmFsaWRhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChWYWxpZGF0aW9uU3RhdGUpIHtcbiAgICBWYWxpZGF0aW9uU3RhdGVbVmFsaWRhdGlvblN0YXRlW1wiTkVVVFJBTFwiXSA9IDBdID0gXCJORVVUUkFMXCI7XG4gICAgVmFsaWRhdGlvblN0YXRlW1ZhbGlkYXRpb25TdGF0ZVtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgVmFsaWRhdGlvblN0YXRlW1ZhbGlkYXRpb25TdGF0ZVtcIlNVQ0NFU1NcIl0gPSAyXSA9IFwiU1VDQ0VTU1wiO1xuICAgIFZhbGlkYXRpb25TdGF0ZVtWYWxpZGF0aW9uU3RhdGVbXCJXQVJOSU5HXCJdID0gM10gPSBcIldBUk5JTkdcIjtcbn0pKFZhbGlkYXRpb25TdGF0ZSA9IGV4cG9ydHMuVmFsaWRhdGlvblN0YXRlIHx8IChleHBvcnRzLlZhbGlkYXRpb25TdGF0ZSA9IHt9KSk7XG4vKipcbiAqIEdlbmVyaWNGZWVkYmFja0NvbnRyb2wgcHJvdmlkZXMgYSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGEgRmVlZGJhY2tDb250cm9sLlxuICovXG52YXIgR2VuZXJpY0ZlZWRiYWNrQ29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2VuZXJpY0ZlZWRiYWNrQ29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZW5lcmljRmVlZGJhY2tDb250cm9sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2V0TWVzc2FnZSA9IGV4cG9ydHMuc2V0TWVzc2FnZShfdGhpcykoX3Jvb3QoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuc3VjY2VzcyA9IGV4cG9ydHMuc3VjY2VzcyhfdGhpcykoX3Jvb3QoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMud2FybmluZyA9IGV4cG9ydHMud2FybmluZyhfdGhpcykoX3Jvb3QoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuZXJyb3IgPSBleHBvcnRzLmVycm9yKF90aGlzKShfcm9vdChfdGhpcykpO1xuICAgICAgICBfdGhpcy5uZXV0cmFsID0gZXhwb3J0cy5uZXV0cmFsKF90aGlzKShfcm9vdChfdGhpcykpO1xuICAgICAgICBfdGhpcy5nZXRWYWxpZGF0aW9uU3RhdGUgPSBleHBvcnRzLmdldFZhbGlkYXRpb25TdGF0ZShfcm9vdChfdGhpcykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHZW5lcmljRmVlZGJhY2tDb250cm9sO1xufShjb250cm9sXzEuR2VuZXJpY0NvbnRyb2wpKTtcbmV4cG9ydHMuR2VuZXJpY0ZlZWRiYWNrQ29udHJvbCA9IEdlbmVyaWNGZWVkYmFja0NvbnRyb2w7XG52YXIgX3Jvb3QgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYy52aWV3LmZpbmRCeUlkKGMudmFsdWVzLnJvb3QuaWQpOyB9OyB9O1xuLyoqXG4gKiBzZXRTdGF0ZSBoZWxwZXIuXG4gKi9cbmV4cG9ydHMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgaWYgKG0gPT09IHZvaWQgMCkgeyBtID0gJyc7IH1cbiAgICByZXR1cm4gTWF5YmVfMS5NYXliZVxuICAgICAgICAuZnJvbUFueShjLm5ldXRyYWwoKSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXRNZXNzYWdlKG0pOyB9KVxuICAgICAgICAuY2hhaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuYWRkKHN0YXRlKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBjOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9OyB9O1xuLyoqXG4gKiBzdWNjZXNzIGhlbHBlci5cbiAqL1xuZXhwb3J0cy5zdWNjZXNzID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZXhwb3J0cy5zZXRTdGF0ZShjKShmbikoc3R5bGUuU1VDQ0VTUyk7IH07IH07XG4vKipcbiAqIHdhcm5pbmcgaGVscGVyLlxuICovXG5leHBvcnRzLndhcm5pbmcgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBleHBvcnRzLnNldFN0YXRlKGMpKGZuKShzdHlsZS5XQVJOSU5HKTsgfTsgfTtcbi8qKlxuICogZXJyb3IgaGVscGVyLlxuICovXG5leHBvcnRzLmVycm9yID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZXhwb3J0cy5zZXRTdGF0ZShjKShmbikoc3R5bGUuRVJST1IpOyB9OyB9O1xuLyoqXG4gKiBzZXRNZXNzYWdlIGhlbHBlci5cbiAqL1xuZXhwb3J0cy5zZXRNZXNzYWdlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKG1zZykge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtc2cpO1xuICAgICAgICBpZiAobWVzc2FnZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJlcGxhY2VDaGlsZChub2RlLCBtZXNzYWdlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gYzsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBjOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLyoqXG4gKiBuZXV0cmFsIGNsZWFycyB2YWxpZGF0aW9uIHN0YXRlcyBmcm9tIGEgY29udHJvbC5cbiAqL1xuZXhwb3J0cy5uZXV0cmFsID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKHN0eWxlLlNVQ0NFU1MpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuRVJST1IpO1xuICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoc3R5bGUuV0FSTklORyk7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBjLnNldE1lc3NhZ2UoJycpOyB9KVxuICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGM7IH0pXG4gICAgICAgIC5nZXQoKTtcbn07IH07IH07XG4vKipcbiAqIGdldFZhbGlkYXRpb25TdGF0ZSBkZWZhdWx0LlxuICovXG5leHBvcnRzLmdldFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGguY2xhc3NMaXN0LmNvbnRhaW5zKHN0eWxlLlNVQ0NFU1MpID9cbiAgICAgICAgZXhwb3J0cy5TVUNDRVNTIDpcbiAgICAgICAgaC5jbGFzc0xpc3QuY29udGFpbnMoc3R5bGUuV0FSTklORykgP1xuICAgICAgICAgICAgZXhwb3J0cy5XQVJOSU5HIDpcbiAgICAgICAgICAgIGguY2xhc3NMaXN0LmNvbnRhaW5zKHN0eWxlLkVSUk9SKSA/XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5FUlJPUiA6IGV4cG9ydHMuTkVVVFJBTDsgfSlcbiAgICAgICAgLmdldCgpO1xufTsgfTtcbi8qKlxuICogc2VsZWN0U3RhdGUgZnJvbSBhbiBhdHRyaWJ1dGUgbGlzdC5cbiAqL1xuZXhwb3J0cy5zZWxlY3RTdGF0ZSA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiBhdHRycy5zdWNjZXNzID8gc3R5bGUuU1VDQ0VTUyA6XG4gICAgICAgIGF0dHJzLmVycm9yID8gc3R5bGUuRVJST1IgOlxuICAgICAgICAgICAgYXR0cnMud2FybmluZyA/IHN0eWxlLldBUk5JTkcgOiAnJztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWVkYmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi9mZWVkYmFja1wiKTtcbi8qKlxuICogR2VuZXJpY0Zvcm1Db250cm9sIHByb3ZpZGVzIGEgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBhXG4gKiBGb3JtQ29udHJvbC5cbiAqL1xudmFyIEdlbmVyaWNGb3JtQ29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2VuZXJpY0Zvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlbmVyaWNGb3JtQ29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR2VuZXJpY0Zvcm1Db250cm9sO1xufShmZWVkYmFja18xLkdlbmVyaWNGZWVkYmFja0NvbnRyb2wpKTtcbmV4cG9ydHMuR2VuZXJpY0Zvcm1Db250cm9sID0gR2VuZXJpY0Zvcm1Db250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIEV2ZW50IGlzIHRoZSBwYXJlbnQgY2xhc3Mgb2YgYWxsIGV2ZW50cyBnZW5lcmF0ZWQgYnkgY29udHJvbHMuXG4gKi9cbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBFdmVudDtcbn0oKSk7XG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG4vKipcbiAqIEdlbmVyaWNDb250cm9sIGltcGxlbWVudHMgdGhlIG1ldGhvZHMgb2YgdGhlIENvbnRyb2wgaW50ZXJmYWNlLlxuICovXG52YXIgR2VuZXJpY0NvbnRyb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyaWNDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlbmVyaWNDb250cm9sKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBHZW5lcmljQ29udHJvbDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkdlbmVyaWNDb250cm9sID0gR2VuZXJpY0NvbnRyb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhpZGRlbiA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2hpZGRlblwiKTtcbnZhciBkaXZpZGVyVmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGl2aWRlclwiKTtcbnZhciBoZWFkZXJWaWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9oZWFkZXJcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBtZW51XzEgPSByZXF1aXJlKFwiLi93bWwvbWVudVwiKTtcbnZhciBpdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9uYXYvaXRlbVwiKTtcbmV4cG9ydHMuSXRlbSA9IGl0ZW1fMS5JdGVtO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5NRU5VID0gJ3d3LW1lbnUnO1xuZXhwb3J0cy5NRU5VX0RJVklERVIgPSAnd3ctbWVudV9fZGl2aWRlcic7XG5leHBvcnRzLk1FTlVfSEVBREVSID0gJ3d3LW1lbnVfX2hlYWRlcic7XG4vLy9jbGFzc05hbWVzOmVuZFxuZXhwb3J0cy5OQVZfTU9ERSA9ICduYXYnO1xuZXhwb3J0cy5DT05URU5UX01PREUgPSAnY29udGVudCc7XG52YXIgZ2V0ID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG0udmlldy5maW5kQnlJZChtLnZhbHVlcy5yb290LmlkKTsgfTsgfTtcbi8qKlxuICogSGVhZGVyXG4gKi9cbnZhciBIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGhlYWRlclZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5NRU5VX0hFQURFUiwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuLyoqXG4gKiBEaXZpZGVyXG4gKi9cbnZhciBEaXZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpdmlkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGRpdmlkZXJWaWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLk1FTlVfRElWSURFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEaXZpZGVyO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGl2aWRlciA9IERpdmlkZXI7XG4vKipcbiAqIE1lbnUgcHJvdmlkZXMgYSBET00gY29udGFpbmVyIGZvciByZW5kZXJpbmdcbiAqIGEgZHJvcGRvd24gc3R5bGUgbWVudS5cbiAqL1xudmFyIE1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbnUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVudSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgbWVudV8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5pc0hpZGRlbiA9IGhpZGRlbi5pc0hpZGRlbihnZXQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuaGlkZSA9IGhpZGRlbi5oaWRlKF90aGlzKShnZXQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuc2hvdyA9IGhpZGRlbi5zaG93KF90aGlzKShnZXQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMudG9nZ2xlID0gaGlkZGVuLnRvZ2dsZShfdGhpcykoZ2V0KF90aGlzKSk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcm9vdCBsZXZlbCB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUVOVSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5oaWRkZW4pID9cbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuLkhJRERFTiA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lbnUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2hpbGRyZW47IH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXRDb250ZW50IG9mIHRoaXMgTWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt2aWV3LnJlbmRlcigpXTsgfTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbnU7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5NZW51ID0gTWVudTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFsoX19fY29udGV4dC52YWx1ZXMudGV4dCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQoKSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbXVsdGktc2VsZWN0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi4uL1wiKTtcbnZhciBzZWxlY3RfMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3RcIik7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBzZWxlY3RfMS5UZXJtQ2hhbmdlZEV2ZW50O1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5NVUxUSV9TRUxFQ1QgPSAnd3ctbXVsdGktc2VsZWN0Jztcbi8qKlxuICogSXRlbXNDaGFuZ2VkRXZlbnRcbiAqL1xudmFyIEl0ZW1zQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtc0NoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtc0NoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbXNDaGFuZ2VkRXZlbnQ7XG59KF8xLkV2ZW50KSk7XG5leHBvcnRzLkl0ZW1zQ2hhbmdlZEV2ZW50ID0gSXRlbXNDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIE11bHRpU2VsZWN0IHByb3ZpZGVzIGEgY29udHJvbCBmb3IgYWxsb3dpbmcgYSB1c2VyIHRvIHNlbGVjdFxuICogbXVsdGlwbGUgaXRlbXMgZnJvbSBhIGxpc3QuXG4gKlxuICogSXQgdXNlIGEgc3RhY2sgdG8gZGlzcGxheSB0aGUgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogICAgICs9PT09PT09PT09PT09PT09PT09PT09PT09K1xuICogICAgIHwgIDxzZWxlY3Q+ICAgICAgICAgICAgICAgfFxuICogICAgICs9PT09PT09PT09PT09PT09PT09PT09PT09K1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICAgIHwgICA8aXRlbT4gICAgICAgICAgICAgIHggfFxuICogICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICovXG52YXIgTXVsdGlTZWxlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpU2VsZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpU2VsZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogJ3NlYXJjaCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ21lc3NhZ2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5NVUxUSV9TRUxFQ1QsIF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2hlbHAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgIG5hbWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSB8fCAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2goZXZ0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhY2s6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3N0YWNrJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudmFsdWUpID8gX3RoaXMuYXR0cnMud3cudmFsdWUgOiBbXSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBTdHJpbmcodik7IH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMgZGlzcGxheWVkIHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnNlYXJjaC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudXBkYXRlKGxpc3QpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBwdXNoIGEgdmFsdWUgb250byB0aGUgc3RhY2suXG4gICAgICovXG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnN0YWNrLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5wdXNoKHYpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGlTZWxlY3Q7XG59KF8xLkdlbmVyaWNDb250cm9sKSk7XG5leHBvcnRzLk11bHRpU2VsZWN0ID0gTXVsdGlTZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHNlbGVjdF8xID0gcmVxdWlyZShcIi4uLy4uL3NlbGVjdFwiKTtcbjtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4uLy4uL3N0YWNrXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoc2VsZWN0XzEuU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmdpZmllcic6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvblNlYXJjaCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlYXJjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KHN0YWNrXzEuU3RhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2suaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2submFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlY29yYXRvcic6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWFyY2hcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuLyoqXG4gKiBFU0NBUEUga2V5IGNvZGUuXG4gKi9cbmV4cG9ydHMuRVNDQVBFID0gMjc7XG4vLy9jbGFzc05hbWU6YmVnaW5cbmV4cG9ydHMuU0VBUkNIID0gJ3d3LXNlYXJjaCBmb3JtLWNvbnRyb2wnO1xuLyoqXG4gKiBUZXJtQ2hhbmdlZEV2ZW50IHNpZ25hbHMgdGhlIHNlYXJjaCB0ZXJtIGhhcyBjaGFuZ2VkLlxuICovXG52YXIgVGVybUNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVybUNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXJtQ2hhbmdlZEV2ZW50KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRlcm1DaGFuZ2VkRXZlbnQ7XG59KF8xLkV2ZW50KSk7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBUZXJtQ2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBTZWFyY2ggcHJvdmlkZXMgYW4gaW5wdXQgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgdWkgZm9yIGEgc2VhcmNoIGVuZ2luZS5cbiAqL1xudmFyIFNlYXJjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VhcmNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLlNFQVJDSCwgX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cucmVhZE9ubHkpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy52YWx1ZSkgfHwgJycsXG4gICAgICAgICAgICAgICAgb25mb2N1czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25Gb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25rZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAoZS5rZXlDb2RlID09PSBleHBvcnRzLkVTQ0FQRSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkVzY2FwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uRXNjYXBlKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vblNlYXJjaCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uU2VhcmNoKG5ldyBUZXJtQ2hhbmdlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUsIGUudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbmtleXVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBleHBvcnRzLkVTQ0FQRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uaW5wdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRm9yIGNvbXBhdGFiaWxpdHkgcmVhc29uc1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5vbmlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnJvb3Qub25rZXlkb3duKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTZWFyY2gucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IGUudmFsdWUgPSB2YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZhbHVlOyB9KVxuICAgICAgICAgICAgLmdldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaDtcbn0oXzEuR2VuZXJpY0NvbnRyb2wpKTtcbmV4cG9ydHMuU2VhcmNoID0gU2VhcmNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgJ29ua2V5ZG93bic6IF9fX2NvbnRleHQudmFsdWVzLnJvb3Qub25rZXlkb3duLFxuICAgICAgICAgICAgICAgICAgICAnb25rZXl1cCc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3Qub25rZXl1cCxcbiAgICAgICAgICAgICAgICAgICAgJ29uaW5wdXQnOiBfX19jb250ZXh0LnZhbHVlcy5yb290Lm9uaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICdvbmZvY3VzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5vbmZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInOiBfX19jb250ZXh0LnZhbHVlcy5yb290LnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAncmVhZE9ubHknOiBfX19jb250ZXh0LnZhbHVlcy5yb290LnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LnZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zZWxlY3RcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZmVlZGJhY2tfMSA9IHJlcXVpcmUoXCIuLi9mZWVkYmFja1wiKTtcbnZhciBzZWFyY2hfMSA9IHJlcXVpcmUoXCIuLi9zZWFyY2hcIik7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBzZWFyY2hfMS5UZXJtQ2hhbmdlZEV2ZW50O1xudmFyIF8xID0gcmVxdWlyZShcIi4uL1wiKTtcbmV4cG9ydHMuRVNDQVBFID0gMjc7XG5leHBvcnRzLklOUFVUX0lEID0gJ2lucHV0Jztcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuU0VMRUNUID0gJ3d3LXNlbGVjdCc7XG4vKipcbiAqIEl0ZW1DaGFuZ2VkRXZlbnRcbiAqL1xudmFyIEl0ZW1DaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW1DaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbUNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbUNoYW5nZWRFdmVudDtcbn0oXzEuRXZlbnQpKTtcbmV4cG9ydHMuSXRlbUNoYW5nZWRFdmVudCA9IEl0ZW1DaGFuZ2VkRXZlbnQ7XG4vKiAqXG4gKiBBdXRvY29tcGxhdGUgcHJvdmlkZXMgYW4gaW5wdXQgd2l0aCBhIGRyb3Bkb3duIG1lbnUgdGhhdCBhbGxvd3NcbiAqIHRoZSB1c2VyIHRvIHNlYXJjaCBhbmQgc2VsZWN0IGZvcm0gYSBsaXN0IG9mIG9wdGlvbnMuXG4gKi9cbnZhciBTZWxlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWxlY3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdyb290JyxcbiAgICAgICAgICAgICAgICBpbnB1dDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICBtZW51OiAnbWVudScsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ21lc2FnZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiAnJyxcbiAgICAgICAgICAgICAgICBpbnB1dDogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLlNFTEVDVCwgX3RoaXMuYXR0cnMud3cuY2xhc3MpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVscDoge1xuICAgICAgICAgICAgICAgIGlkOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX3RoaXMuYXR0cnMud3cuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogX3RoaXMuYXR0cnMud3cuZXJyb3IsXG4gICAgICAgICAgICAgICAgd2FybmluZzogX3RoaXMuYXR0cnMud3cud2FybmluZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lbnUnLFxuICAgICAgICAgICAgICAgIGhpZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9wdGlvbnMpIHx8IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy5sYWJlbCB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlYXJjaDoge1xuICAgICAgICAgICAgICAgIGlkOiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICBjbGFzczogX3RoaXMuYXR0cnMud3cuaW5wdXRDbGFzcyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5wbGFjZWhvbGRlciA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5tZW51Lm9wdGlvbnMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZShfdGhpcy52YWx1ZXMubWVudS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25TZWFyY2gpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2ggOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgb25Fc2NhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlKCk7IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50VGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5pdGVtQ29udGVudFRlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5pdGVtQ29udGVudFRlbXBsYXRlIDogdmlld3MuaXRlbUNvbnRlbnRUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5vSXRlbXNUZW1wbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5vSXRlbXNUZW1wbGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubm9JdGVtc1RlbXBsYXRlIDogdmlld3Mubm9JdGVtc1RlbXBsYXRlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIgOiBmdW5jdGlvbiAodikgeyByZXR1cm4gU3RyaW5nKHYpOyB9LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMudmFsdWVzLm1lbnUub3B0aW9uc1tOdW1iZXIoaW5kZXgpXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IEl0ZW1DaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgc2VsZWN0ZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLnNlYXJjaC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2V0KF90aGlzLnZhbHVlcy5pdGVtLnN0cmluZ2lmeShzZWxlY3RlZCkpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VsZWN0LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMucm9vdC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSlcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzKTtcbiAgICAgICAgICAgIGlmICgoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5tZW51KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zaG93KCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlbGVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubWVudSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uaGlkZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIFNlbGVjdCB3aXRoIG5ldyBpdGVtIG9wdGlvbnMgdG9cbiAgICAgKiBwcmVzZW50IHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFNlbGVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YWx1ZXMubWVudS5vcHRpb25zID0gcmVzdWx0cztcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLm1lbnUpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldENvbnRlbnQobmV3IHZpZXdzLlJlc3VsdHMoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdDtcbn0oZmVlZGJhY2tfMS5HZW5lcmljRmVlZGJhY2tDb250cm9sKSk7XG5leHBvcnRzLlNlbGVjdCA9IFNlbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgc2VhcmNoXzEgPSByZXF1aXJlKFwiLi4vLi4vc2VhcmNoXCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuLi8uLi9tZW51XCIpO1xuO1xudmFyIGxpbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250ZW50L25hdi9saW5rXCIpO1xuO1xudmFyIGZyYWdtZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGF5b3V0L2ZyYWdtZW50XCIpO1xuO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIi4uLy4uL3dtbFwiKTtcbjtcbmV4cG9ydHMuaXRlbUNvbnRlbnRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBmdW5jdGlvbiAoX2luZGV4KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLnN0cmluZ2lmeShvcHRpb24pKTsgfTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMubm9JdGVtc1RlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwuZG9taWZ5KFwiTm8gcmVzdWx0cyB0byBkaXNwbGF5LlwiKTsgfTsgfTtcbjtcbnZhciBSZXN1bHRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN1bHRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3VsdHMoX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChmcmFnbWVudF8xLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMubWVudS5vcHRpb25zLCBmdW5jdGlvbiBfbWFwKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQobWVudV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiAoXCJcIiArIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChsaW5rXzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX19jb250ZXh0LnZhbHVlcy5pdGVtLmNsaWNrKGluZGV4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLml0ZW0uaXRlbUNvbnRlbnRUZW1wbGF0ZSgpKF9fX2NvbnRleHQpKG9wdGlvbikoaW5kZXgpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLm5vSXRlbXNUZW1wbGF0ZSgpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXN1bHRzO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5SZXN1bHRzID0gUmVzdWx0cztcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KHdtbF8xLmxhYmVsKF9fX2NvbnRleHQudmFsdWVzLmxhYmVsLmlkKShfX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0KShfX192aWV3KSksIF9fX3dtbC53aWRnZXQoc2VhcmNoXzEuU2VhcmNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRPbmx5JzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uRXNjYXBlJzogX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLm9uRXNjYXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uRm9jdXMnOiBfX19jb250ZXh0LnZhbHVlcy5zZWFyY2gub25Gb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvblNlYXJjaCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlYXJjaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLm1lbnUuaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaWRkZW4nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkKShfX19jb250ZXh0LnZhbHVlcy5oZWxwKShfX192aWV3KSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFja1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlNUQUNLID0gJ3d3LXN0YWNrJztcbmV4cG9ydHMuU1RBQ0tfRUxFTUVOVCA9ICd3dy1zdGFja19fZWxlbWVudCc7XG5leHBvcnRzLlNUQUNLX0VMRU1FTlRfQ09OVEVOVCA9ICd3dy1zdGFja19fZWxlbWVudF9fY29udGVudCc7XG5leHBvcnRzLlNUQUNLX0NMT1NFX0JVVFRPTiA9ICd3dy1zdGFja19fYnV0dG9uJztcbi8qKlxuICogU3RhY2tDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgcmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIHN0YWNrLlxuICovXG52YXIgU3RhY2tDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrQ2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGFja0NoYW5nZWRFdmVudDtcbn0oXzEuRXZlbnQpKTtcbmV4cG9ydHMuU3RhY2tDaGFuZ2VkRXZlbnQgPSBTdGFja0NoYW5nZWRFdmVudDtcbi8qKlxuICogU3RhY2sgZGlzcGxheXMgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgY2FuIGJlIG1vZGlmaWVkXG4gKiBieSByZWxlYXNpbmcgb25lIG9yIG1vcmUgYXQgYSB0aW1lLlxuICovXG52YXIgU3RhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAnc3RhY2snLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuU1RBQ0ssIF90aGlzLmF0dHJzLnd3LmNsYXNzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cnMud3cudmFsdWUgPyBfdGhpcy5hdHRycy53dy52YWx1ZSA6IFtdLFxuICAgICAgICAgICAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IFN0YWNrQ2hhbmdlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUsIF90aGlzLnZhbHVlcy5yb290LnZhbHVlLnNsaWNlKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5TVEFDS19FTEVNRU5ULFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hdHRycy53dy5lbGVtZW50VGVtcGxhdGUgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5lbGVtZW50VGVtcGxhdGUoX3RoaXMpIDogdmlld3MuY29udGVudChfdGhpcyk7IH0sXG4gICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5TVEFDS19FTEVNRU5UX0NPTlRFTlRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnJvb3QudmFsdWUuc3BsaWNlKE51bWJlcihpbmRleCksIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMucm9vdC5maXJlKCk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA/IF90aGlzLmF0dHJzLnd3LmRlY29yYXRvciA6IGZ1bmN0aW9uICh2KSB7IHJldHVybiBTdHJpbmcodik7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZToge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLlNUQUNLX0NMT1NFX0JVVFRPTlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHB1c2ggYSBuZXcgbWVtYmVyIG9udG8gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnJvb3QuZmlyZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdGFjaztcbn0oXzEuR2VuZXJpY0NvbnRyb2wpKTtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG5leHBvcnRzLmNvbnRlbnQgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uIChfKSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmVsZW1lbnQuY29udGVudC5jbGFzc1xuICAgIH0sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuZWxlbWVudC5kZWNvcmF0b3IodikpXSwgX19fdmlldyk7IH07IH07IH07IH07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd1bCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubWFwKF9fX2NvbnRleHQudmFsdWVzLnJvb3QudmFsdWUsIGZ1bmN0aW9uIF9tYXAodiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5lbGVtZW50LmNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5lbGVtZW50LnRlbXBsYXRlKCkodikoaW5kZXgpKF9fX3ZpZXcpKSwgX19fd21sLm5vZGUoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsb3NlLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmVsZW1lbnQuY2xvc2UoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJcXHUwMEQ3XCIpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgfSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250cm9sXCIpO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZShcIi4vd21sL3N3aXRjaFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuU1dJVENIID0gJ3d3LXN3aXRjaCc7XG5leHBvcnRzLlNXSVRDSF9TTElERVIgPSAnd3ctc3dpdGNoX19zbGlkZXInO1xuLyoqXG4gKiBTd2l0Y2hDaGFuZ2VkRXZlbnQgc2lnbmFscyB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgc3dpdGNoLlxuICovXG52YXIgU3dpdGNoQ2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2hDaGFuZ2VkRXZlbnQ7XG59KGNvbnRyb2xfMS5FdmVudCkpO1xuZXhwb3J0cy5Td2l0Y2hDaGFuZ2VkRXZlbnQgPSBTd2l0Y2hDaGFuZ2VkRXZlbnQ7XG4vKipcbiAqIFN3aXRjaCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGJldHdlZW4gb25lIG9yIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBTd2l0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHN3aXRjaF8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuU1dJVENIXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xpZGVyOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuU1dJVENIX1NMSURFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cnMud3cudmFsdWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQudmFsdWUgPSAoIV90aGlzLnZhbHVlcy5pbnB1dC52YWx1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IFN3aXRjaENoYW5nZWRFdmVudChfdGhpcy52YWx1ZXMuaW5wdXQubmFtZSwgX3RoaXMudmFsdWVzLmlucHV0LnZhbHVlIHx8IGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2g7XG59KGNvbnRyb2xfMS5HZW5lcmljQ29udHJvbCkpO1xuZXhwb3J0cy5Td2l0Y2ggPSBTd2l0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGFiZWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZWQnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnNsaWRlci5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIHZpZXcgPSByZXF1aXJlKFwiLi93bWwvdGFiXCIpO1xudmFyIGFjdGl2ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2FjdGl2ZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBUYWJDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1RhYkNsaWNrZWRFdmVudFwiKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgXzEgPSByZXF1aXJlKFwiLlwiKTtcbi8qKlxuICogVGFiIHByb3ZpZGVzIGEgc2luZ2xlIHRhYiBpdGVtLlxuICpcbiAqIFdoZW4gYSB0YWIgaXMgY2xpY2tlZCwgaXQgYXR0ZW1wdHMgdG8gcmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbVxuICogaXQncyBzaWJsaW5ncyBhbmQgYXBwbHkgaXQgdG8gaXRzZWxmLiBUaGVyZWZvcmUgdGhlIHNpYmxpbmcgb2YgYVxuICogdGFiIHNob3VsZCBhbHdheXMgYmUgYSBUYWIuXG4gKi9cbnZhciBUYWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXcuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KF8xLlRBQiwgX3RoaXMuYXR0cnMud3cuYWN0aXZlID8gYWN0aXZlLkFDVElWRSA6ICcnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy50ZXh0LFxuICAgICAgICAgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2hhaW4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlLkFDVElWRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kQnlJZChfdGhpcy52YWx1ZXMucm9vdC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChhY3RpdmUuQUNUSVZFKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hhaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gYWZwbC5NYXliZS5mcm9tQW55KF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2spOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihuZXcgVGFiQ2xpY2tlZEV2ZW50XzEuVGFiQ2xpY2tlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xpY2sgdGhpcyBUYWJcbiAgICAgKi9cbiAgICBUYWIucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5hLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGljaygpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSlcbiAgICAgICAgICAgIC5nZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWI7XG59KF9fMS5HZW5lcmljQ29udHJvbCkpO1xuZXhwb3J0cy5UYWIgPSBUYWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3ID0gcmVxdWlyZShcIi4vd21sL3RhYi1iYXJcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuLyoqXG4gKiBUYWJCYXIgYWN0cyBhcyBhIHBhcmVudCBjb250YWluZXIgZm9yIGEgZ3JvdXAgb2YgVGFiLlxuICpcbiAqIFVzZSBpdCB0byBjcmVhdGUgYSB0YWJiZWQgbmF2aWdhdGlvbiBvciB2aWV3IGZvciBtYWluIGxheW91dCxcbiAqIHN1YiB2aWV3cyBvciBmb3JtcyBldGMuXG4gKi9cbnZhciBUYWJCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJCYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXcuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChfMS5UQUJfQkFSLCAnbmF2IG5hdi10YWJzJywgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJCYXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWJCYXIgPSBUYWJCYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJCYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udHJvbFwiKTtcbi8qKlxuICogVGFiQ2xpY2tlZEV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIHRhYi5cbiAqXG4gKiBJdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFiIHRoYXQgd2FzIGNsaWNrZWQuXG4gKi9cbnZhciBUYWJDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkNsaWNrZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJDbGlja2VkRXZlbnQobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFiQ2xpY2tlZEV2ZW50O1xufShjb250cm9sXzEuRXZlbnQpKTtcbmV4cG9ydHMuVGFiQ2xpY2tlZEV2ZW50ID0gVGFiQ2xpY2tlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFiQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRhYkNsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vVGFiQ2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5UYWJDbGlja2VkRXZlbnQgPSBUYWJDbGlja2VkRXZlbnRfMS5UYWJDbGlja2VkRXZlbnQ7XG52YXIgVGFiQmFyXzEgPSByZXF1aXJlKFwiLi9UYWJCYXJcIik7XG5leHBvcnRzLlRhYkJhciA9IFRhYkJhcl8xLlRhYkJhcjtcbnZhciBUYWJfMSA9IHJlcXVpcmUoXCIuL1RhYlwiKTtcbmV4cG9ydHMuVGFiID0gVGFiXzEuVGFiO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBUQUJfQkFSXG4gKi9cbmV4cG9ydHMuVEFCX0JBUiA9ICd3dy10YWItYmFyJztcbi8qKlxuICogVEFCXG4gKi9cbmV4cG9ydHMuVEFCID0gJ3d3LXRhYic7XG4vLy9jbGFzc05hbWVzOmVuZFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItYmFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdhJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy5hLmNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5hLmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLmEudGV4dCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmEudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90ZXh0LWZpZWxkXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGZvcm1fMSA9IHJlcXVpcmUoXCIuLi9mb3JtXCIpO1xudmFyIGZlZWRiYWNrXzEgPSByZXF1aXJlKFwiLi4vZmVlZGJhY2tcIik7XG52YXIgXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xudmFyIG9uaW5wdXQgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZi5hdHRycy53dy5vbkNoYW5nZShuZXcgVGV4dENoYW5nZWRFdmVudChmLmF0dHJzLnd3Lm5hbWUsIGUudGFyZ2V0LnZhbHVlKSk7XG59OyB9O1xudmFyIGlucHV0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZi52aWV3LmZpbmRCeUlkKGYudmFsdWVzLmNvbnRyb2wuaWQpO1xufTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVEVYVF9GSUVMRCA9ICdmb3JtLWNvbnRyb2wnO1xuLyoqXG4gKiBUZXh0Q2hhbmdlZEV2ZW50XG4gKi9cbnZhciBUZXh0Q2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0Q2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHRDaGFuZ2VkRXZlbnQ7XG59KF8xLkV2ZW50KSk7XG5leHBvcnRzLlRleHRDaGFuZ2VkRXZlbnQgPSBUZXh0Q2hhbmdlZEV2ZW50O1xuLyoqXG4gKiBUZXh0RmllbGQgcHJvdmlkZXMgYSB3cmFwcGVkIG5hdGl2ZSB0ZXh0IGlucHV0IGNvbnRyb2wuXG4gKi9cbnZhciBUZXh0RmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRGaWVsZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmllbGQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dChfdGhpcykubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZhbHVlOyB9KS5nZXQoKTsgfTtcbiAgICAgICAgX3RoaXMuc2V0ID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGlucHV0KF90aGlzKS5tYXAoZnVuY3Rpb24gKGUpIHsgZS52YWx1ZSA9IHY7IHJldHVybiBfdGhpczsgfSkuZ2V0KCk7IH07XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdmb3JtLWdyb3VwJywgX3RoaXMuYXR0cnMud3cuY2xhc3MsIGZlZWRiYWNrXzEuc2VsZWN0U3RhdGUoX3RoaXMuYXR0cnMud3cpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF90aGlzLmF0dHJzLnd3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF90aGlzLmF0dHJzLnd3LmVycm9yLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IF90aGlzLmF0dHJzLnd3Lndhcm5pbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LmxhYmVsIHx8ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgICAgIGlkOiAnY29udHJvbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmF0dHJzLnd3LmNvbnRyb2xUZW1wbGF0ZSB8fCB2aWV3cy5ncm91cDsgfSxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLlRFWFRfRklFTEQsIF90aGlzLmF0dHJzLnd3LmNsYXNzKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLmF0dHJzLnd3LnR5cGUgfHwgJ3RleHQnLFxuICAgICAgICAgICAgICAgIGZvY3VzOiBfdGhpcy5hdHRycy53dy5mb2N1cyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgfHwgJycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmF0dHJzLnd3LnZhbHVlIHx8ICcnLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPT09IHRydWUpID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IChfdGhpcy5hdHRycy53dy5yZWFkT25seSA9PT0gdHJ1ZSkgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICByb3dzOiBfdGhpcy5hdHRycy53dy5yb3dzIHx8IDEsXG4gICAgICAgICAgICAgICAgb25pbnB1dDogX3RoaXMuYXR0cnMud3cub25DaGFuZ2UgPyBvbmlucHV0KF90aGlzKSA6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZXh0RmllbGQ7XG59KGZvcm1fMS5HZW5lcmljRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuVGV4dEZpZWxkID0gVGV4dEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCIuLi8uLi93bWxcIik7XG47XG52YXIgd21sXzIgPSByZXF1aXJlKFwiLi4vLi4vd21sXCIpO1xuZXhwb3J0cy5sYWJlbCA9IHdtbF8yLmxhYmVsO1xuZXhwb3J0cy5tZXNzYWdlID0gd21sXzIubWVzc2FnZTtcbjtcbmV4cG9ydHMuaW5wdXQgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5uYW1lLFxuICAgICAgICAndHlwZSc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wudHlwZSxcbiAgICAgICAgJ2ZvY3VzJzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5mb2N1cyxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5wbGFjZWhvbGRlcixcbiAgICAgICAgJ29uaW5wdXQnOiBfX19jb250ZXh0LnZhbHVlcy5jb250cm9sLm9uaW5wdXQsXG4gICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wudmFsdWUsXG4gICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuZGlzYWJsZWQsXG4gICAgICAgICdyZWFkb25seSc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wucmVhZE9ubHksXG4gICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuY2xhc3NcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBcImNvbnRyb2xcIlxuICAgIH1cbn0sIFtdLCBfX192aWV3KTsgfTsgfTtcbjtcbmV4cG9ydHMudGV4dGFyZWEgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCd0ZXh0YXJlYScsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5uYW1lLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBfX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnBsYWNlaG9sZGVyLFxuICAgICAgICAnb25pbnB1dCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wub25pbnB1dCxcbiAgICAgICAgJ2Rpc2FibGVkJzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5kaXNhYmxlZCxcbiAgICAgICAgJ3JlYWRvbmx5JzogX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5yZWFkT25seSxcbiAgICAgICAgJ3Jvd3MnOiBfX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnJvd3MsXG4gICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wuY2xhc3NcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBcImNvbnRyb2xcIlxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmNvbnRyb2wudmFsdWUpXSwgX19fdmlldyk7IH07IH07XG47XG5leHBvcnRzLmNvbnRyb2wgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuICgoX19fY29udGV4dC52YWx1ZXMuY29udHJvbC5yb3dzID09PSAxKSkgPyBfX193bWwuZG9taWZ5KGV4cG9ydHMuaW5wdXQoX19fY29udGV4dCkoX19fdmlldykpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnRleHRhcmVhKF9fX2NvbnRleHQpKF9fX3ZpZXcpKTsgfTsgfTtcbjtcbmV4cG9ydHMuZ3JvdXAgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ib3goX19fd21sLmRvbWlmeSh3bWxfMS5sYWJlbChfX19jb250ZXh0LnZhbHVlcy5sYWJlbC5pZCkoX19fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCkoX19fdmlldykpLCBfX193bWwuZG9taWZ5KGV4cG9ydHMuY29udHJvbChfX19jb250ZXh0KShfX192aWV3KSksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkKShfX19jb250ZXh0LnZhbHVlcy5oZWxwKShfX192aWV3KSkpOyB9OyB9O1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5jb250cm9sLnRlbXBsYXRlKCkoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3Rvb2xiYXJcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuVE9PTEJBUiA9ICd3dy10b29sYmFyJztcbmV4cG9ydHMuVE9PTEJBUl9DT01QQVQgPSAnLXRvb2xiYXItY29tcGF0Jztcbi8qKlxuICogVG9vbGJhciBwcm92aWRlcyBhIHdpZGdldCBmb3IgZ3JvdXBpbmcgcmVsYXRlZCBjb250cm9scyBpbnRvIGFcbiAqIHNpbmdsZSByb3cuXG4gKi9cbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb29sYmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5UT09MQkFSLCBfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVG9vbGJhcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRvb2xiYXIgPSBUb29sYmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbGJhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbmV4cG9ydHMubGFiZWwgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ2xhYmVsJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2Zvcic6IGlkLFxuICAgICAgICAnY2xhc3MnOiBcImNvbnRyb2wtbGFiZWxcIlxuICAgIH0sXG4gICAgd21sOiB7fVxufSwgW19fX3dtbC5kb21pZnkodGV4dCldLCBfX192aWV3KTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMubWVzc2FnZSA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiAobS5zdWNjZXNzKSA/IF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogXCJoZWxwLWJsb2NrXCJcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBpZFxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KG0uc3VjY2VzcyldLCBfX192aWV3KSA6IChtLmVycm9yKSA/IF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogXCJoZWxwLXRleHRcIlxuICAgIH0sXG4gICAgd21sOiB7XG4gICAgICAgICdpZCc6IGlkXG4gICAgfVxufSwgW19fX3dtbC5kb21pZnkobS5lcnJvcildLCBfX192aWV3KSA6IChtLndhcm5pbmcpID8gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgaHRtbDoge1xuICAgICAgICAnY2xhc3MnOiBcImhlbHAtdGV4dFwiXG4gICAgfSxcbiAgICB3bWw6IHtcbiAgICAgICAgJ2lkJzogaWRcbiAgICB9XG59LCBbX19fd21sLmRvbWlmeShtLndhcm5pbmcpXSwgX19fdmlldykgOiBfX193bWwubm9kZSgnc3BhbicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IFwiaGVscC10ZXh0XCJcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBpZFxuICAgIH1cbn0sIFtdLCBfX192aWV3KTsgfTsgfTsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBbGxTZWxlY3RlZEV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYWxsIHRoZSBmaWVsZHMgb24gdGhlIHRhYmxlLlxuICovXG52YXIgQWxsU2VsZWN0ZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbGxTZWxlY3RlZEV2ZW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIEFsbFNlbGVjdGVkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5BbGxTZWxlY3RlZEV2ZW50ID0gQWxsU2VsZWN0ZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFsbFNlbGVjdGVkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENlbGwgd3JhcHMgYXJvdW5kIGEgPHRkPiB0byBwcm92aWRlIGFuIGVhc2llciB0byB1c2UgYXBpLlxuICovXG52YXIgQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWxsKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0Q29udGVudCBjaGFuYWdlcyB0aGUgY29udGVudCBvZiB0aGUgQ2VsbCdzIDx0ZD4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBDZWxsLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChyLnJlbmRlcigpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbDtcbn0oKSk7XG5leHBvcnRzLkNlbGwgPSBDZWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2VsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2VsbENsaWNrZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgd2hpdGVzcGFjZSBvZiBhIGNlbGwgaXMgY2xpY2tlZC5cbiAqL1xudmFyIENlbGxDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbENsaWNrZWRFdmVudCh2YWx1ZSwgY29sdW1uLCByb3dEYXRhLCByb3dOdW1iZXIsIGNlbGwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5yb3dEYXRhID0gcm93RGF0YTtcbiAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgICAgIHRoaXMuY2VsbCA9IGNlbGw7XG4gICAgfVxuICAgIHJldHVybiBDZWxsQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IENlbGxDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZWxsQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZWZhdWx0RGVsZWdhdGUgd2lsbCBoYW5kbGUgdGFibGUgZXZlbnRzIGlmIG5vIERlbGVnYXRlIGlzXG4gKiBzcGVjaWZpZWQuXG4gKlxuICogSXQgcGFzc2VzIGl0J3MgZXZlbnRzIG9udG8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKi9cbnZhciBEZWZhdWx0RGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdERlbGVnYXRlKHRhYmxlKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICB9XG4gICAgRGVmYXVsdERlbGVnYXRlLnByb3RvdHlwZS5vbkFsbFNlbGVjdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFibGUuYXR0cnMud3cub25BbGxTZWxlY3RlZClcbiAgICAgICAgICAgIHRoaXMudGFibGUuYXR0cnMud3cub25BbGxTZWxlY3RlZChlKTtcbiAgICB9O1xuICAgIERlZmF1bHREZWxlZ2F0ZS5wcm90b3R5cGUub25DZWxsQ2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uQ2VsbENsaWNrZWQpXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uQ2VsbENsaWNrZWQoZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0RGVsZWdhdGUucHJvdG90eXBlLm9uSGVhZGluZ0NsaWNrZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50YWJsZS5hdHRycy53dy5vbkhlYWRpbmdDbGlja2VkKVxuICAgICAgICAgICAgdGhpcy50YWJsZS5hdHRycy53dy5vbkhlYWRpbmdDbGlja2VkKGUpO1xuICAgIH07XG4gICAgRGVmYXVsdERlbGVnYXRlLnByb3RvdHlwZS5vblJvd0NsaWNrZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50YWJsZS5hdHRycy53dy5vblJvd0NsaWNrZWQpXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uUm93Q2xpY2tlZChlKTtcbiAgICB9O1xuICAgIERlZmF1bHREZWxlZ2F0ZS5wcm90b3R5cGUub25Sb3dTZWxlY3RlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uUm93U2VsZWN0ZWQpXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uUm93U2VsZWN0ZWQoZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdERlbGVnYXRlO1xufSgpKTtcbmV4cG9ydHMuRGVmYXVsdERlbGVnYXRlID0gRGVmYXVsdERlbGVnYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdERlbGVnYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBIZWFkaW5nQ2xpY2tlZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25cbiAqIG9uZSBvZiB0aGUgY29sdW1uIGhlYWRpbmdzLlxuICovXG52YXIgSGVhZGluZ0NsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFkaW5nQ2xpY2tlZEV2ZW50KGZpZWxkKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmdDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5IZWFkaW5nQ2xpY2tlZEV2ZW50ID0gSGVhZGluZ0NsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhlYWRpbmdDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJvd0NsaWNrZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gd2hpdGVzcGFjZSBpblxuICogdGhlIHJvdyBvZiBhIHRhYmxlLlxuICovXG52YXIgUm93Q2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvd0NsaWNrZWRFdmVudCh2YWx1ZSwgcm93LCBkYXRhKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yb3cgPSByb3c7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSb3dDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Sb3dDbGlja2VkRXZlbnQgPSBSb3dDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3dDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSb3dDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1Jvd0NsaWNrZWRFdmVudFwiKTtcbi8qKlxuICogUm93U2VsZWN0ZWRFdmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2hlY2tib3ggKGlmIGRpc3BsYXllZCkgaXMgY2xpY2tlZFxuICogb24gZm9yIGEgcm93LlxuICovXG52YXIgUm93U2VsZWN0ZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93U2VsZWN0ZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3dTZWxlY3RlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3dTZWxlY3RlZEV2ZW50O1xufShSb3dDbGlja2VkRXZlbnRfMS5Sb3dDbGlja2VkRXZlbnQpKTtcbmV4cG9ydHMuUm93U2VsZWN0ZWRFdmVudCA9IFJvd1NlbGVjdGVkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3dTZWxlY3RlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVmYXVsdERlbGVnYXRlXzEgPSByZXF1aXJlKFwiLi9EZWZhdWx0RGVsZWdhdGVcIik7XG52YXIgU29ydERlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb3J0RGVsZWdhdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29ydERlbGVnYXRlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNvcnREZWxlZ2F0ZS5wcm90b3R5cGUub25IZWFkaW5nQ2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMudGFibGUuc29ydChlLmZpZWxkKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkhlYWRpbmdDbGlja2VkLmNhbGwodGhpcywgZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU29ydERlbGVnYXRlO1xufShEZWZhdWx0RGVsZWdhdGVfMS5EZWZhdWx0RGVsZWdhdGUpKTtcbmV4cG9ydHMuU29ydERlbGVnYXRlID0gU29ydERlbGVnYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29ydERlbGVnYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlldyA9IHJlcXVpcmUoXCIuL3dtbC90YWJsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHByb3BlcnR5X3NlZWtfMSA9IHJlcXVpcmUoXCJwcm9wZXJ0eS1zZWVrXCIpO1xudmFyIENlbGxDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0NlbGxDbGlja2VkRXZlbnRcIik7XG52YXIgUm93Q2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9Sb3dDbGlja2VkRXZlbnRcIik7XG52YXIgUm93U2VsZWN0ZWRFdmVudF8xID0gcmVxdWlyZShcIi4vUm93U2VsZWN0ZWRFdmVudFwiKTtcbnZhciBIZWFkaW5nQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9IZWFkaW5nQ2xpY2tlZEV2ZW50XCIpO1xudmFyIEFsbFNlbGVjdGVkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0FsbFNlbGVjdGVkRXZlbnRcIik7XG52YXIgU29ydERlbGVnYXRlXzEgPSByZXF1aXJlKFwiLi9Tb3J0RGVsZWdhdGVcIik7XG52YXIgQ2VsbF8xID0gcmVxdWlyZShcIi4vQ2VsbFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuLyoqXG4gKiBUYWJsZSBwcm92aWRlcyBhIHNtYXJ0ZXIgaHRtbCB0YWJsZS5cbiAqXG4gKiBAdG9kbyBzcGxpdCBzb3J0IGFuZCBzZWxlY3QgYXBpIGludG8gb3duIHRhYmxlIHdpZGdldHMuXG4gKi9cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcmlnaW5hbERhdGEgPSBfdGhpcy5hdHRycy53dy5kYXRhO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXcuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgOiBuZXcgU29ydERlbGVnYXRlXzEuU29ydERlbGVnYXRlKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgZW1wdHk6IF90aGlzLmF0dHJzLnd3LmVtcHR5LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IF90aGlzLmF0dHJzLnd3LnNlbGVjdGFibGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWJsZToge1xuICAgICAgICAgICAgICAgIGlkOiBfMS5UQUJMRSxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChfMS5UQUJMRSwgX3RoaXMuYXR0cnMud3cuY2xhc3MpLFxuICAgICAgICAgICAgICAgIHRoZWFkOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBfMS5USEVBRCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF90aGlzLmF0dHJzLnd3LnRoZWFkQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAoX3RoaXMuYXR0cnMud3cudGhlYWQgfHwgdmlldy50aGVhZCksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hlY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vbkFsbFNlbGVjdGVkKG5ldyBBbGxTZWxlY3RlZEV2ZW50XzEuQWxsU2VsZWN0ZWRFdmVudChfdGhpcy5vcmlnaW5hbERhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dy50aENsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uSGVhZGluZ0NsaWNrZWQobmV3IEhlYWRpbmdDbGlja2VkRXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50KGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9OyB9LFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0Ym9keToge1xuICAgICAgICAgICAgICAgICAgICBpZDogXzEuVEJPRFksXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAoX3RoaXMuYXR0cnMud3cudGJvZHkgfHwgdmlldy50Ym9keSksXG4gICAgICAgICAgICAgICAgICAgIHRyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogX3RoaXMuYXR0cnMud3cudHJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChyb3csIGluZGV4LCBkYXRhKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uUm93Q2xpY2tlZChuZXcgUm93Q2xpY2tlZEV2ZW50XzEuUm93Q2xpY2tlZEV2ZW50KHJvdywgaW5kZXgsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrOiBmdW5jdGlvbiAocm93LCBpbmRleCwgZGF0YSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vblJvd1NlbGVjdGVkKG5ldyBSb3dTZWxlY3RlZEV2ZW50XzEuUm93U2VsZWN0ZWRFdmVudChyb3csIGluZGV4LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9OyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZnVuY3Rpb24gKGNvbHVtbiwgY29sTnVtYmVyLCByb3dOdW1iZXIpIHsgcmV0dXJuIFwiXCIgKyBjb2x1bW4gKyBjb2xOdW1iZXIgKyBcIixcIiArIHJvd051bWJlcjsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dy50ZENsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKHZhbHVlLCBjb2x1bW4sIHJvd0RhdGEsIHJvd051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2VsbENsaWNrZWQobmV3IENlbGxDbGlja2VkRXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50KHZhbHVlLCBjb2x1bW4sIHJvd0RhdGEsIHJvd051bWJlciwgbmV3IENlbGxfMS5DZWxsKGUudGFyZ2V0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ydGVkT246ICcnLFxuICAgICAgICAgICAgZGF0YTogX3RoaXMub3JpZ2luYWxEYXRhLnNsaWNlKCksXG4gICAgICAgICAgICBjb2x1bW5zOiBfdGhpcy5hdHRycy53dy5jb2x1bW5zLFxuICAgICAgICAgICAgYXJyb3c6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW9kaWZ5Qm9keSBhbGxvd3MgYSBmdW5jdGlvbiB0byBtb2RpZnkgdGhlIGNvbnRlbnRzXG4gICAgICogb2YgdGhlIDx0Ym9keT5cbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUubW9kaWZ5Qm9keSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZChfMS5UQk9EWSkubWFwKGYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmF0dHJzLnd3ID8gdGhpcy5hdHRycy53dy5jb2x1bW5zID8gdGhpcy5hdHRycy53dy5jb2x1bW5zIDogW10gOiBbXTtcbiAgICAgICAgdmFyIGZpZWxkID0gY29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHsgcmV0dXJuIHAgPyBwIDogKGMubmFtZSA9PT0gbmFtZSA/IGMgOiBudWxsKTsgfSk7XG4gICAgICAgIHZhciBzb3J0T247XG4gICAgICAgIHZhciBzdHJhdGVneTtcbiAgICAgICAgaWYgKCFmaWVsZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhYmxlI3NvcnQ6IHVua25vd24gZmllbGQgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgc29ydE9uID0gZmllbGQuc29ydEFzIHx8IG5hbWU7XG4gICAgICAgIHN0cmF0ZWd5ID0gZmllbGQuc3RyYXRlZ3kgfHwgXzEuc3RyaW5nU29ydDtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLnNvcnRlZE9uID09PSBuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpcy52YWx1ZXMuZGF0YS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9ICh0aGlzLnZhbHVlcy5hcnJvdyA9PT0gXzEuQVNDX0FSUk9XKSA/IF8xLkRFU0NfQVJST1cgOiBfMS5BU0NfQVJST1c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9IF8xLkRFU0NfQVJST1c7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpc1xuICAgICAgICAgICAgICAgIC5vcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzdHJhdGVneShwcm9wZXJ0eV9zZWVrXzEuZ2V0KHNvcnRPbiwgYSksIHByb3BlcnR5X3NlZWtfMS5nZXQoc29ydE9uLCBiKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnNvcnRlZE9uID0gbmFtZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGRhdGEgdGhlIHRhYmxlIGRpc3BsYXlzXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gZGF0YS5zbGljZSgpO1xuICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gZGF0YS5zbGljZSgpO1xuICAgICAgICAodGhpcy52YWx1ZXMuc29ydGVkT24gPT09ICcnKSA/IHRoaXMudmlldy5pbnZhbGlkYXRlKCkgOiB0aGlzLnNvcnQodGhpcy52YWx1ZXMuc29ydGVkT24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNlbGxBdCBwcm9kdWNlcyBhIENlbGwgaW5zdGFuY2UgZm9yIHRoZSBjb29yZGluYXRlcyBwYXNzZWQgKGlmIGZvdW5kKS5cbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUuY2VsbEF0ID0gZnVuY3Rpb24gKGNvbHVtbiwgcm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKFwiXCIgKyBjb2x1bW4gKyByb3cpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBuZXcgQ2VsbF8xLkNlbGwoZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcHJlcGVuZCBhZGRzIG9uZSBvciBtb3JlIG5ldyBkYXRhIHJvd3MgdG8gdGhlIGJlZ2luaW5nIG9mIHRoZSB0YWJsZS5cbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gICAgICAgIHRoaXMubW9kaWZ5Qm9keShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRvbSA9IHZpZXcucm93cyhfdGhpcykoZCkoX3RoaXMudmFsdWVzLmNvbHVtbnMpKF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgaWYgKGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlLnJlcGxhY2VDaGlsZChkb20sIGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhZGRzIG9uZSBvciBtb3JlIG5ldyBkYXRhIHJvd3MgdG8gdGhlIGVuZCBvZiB0aGUgdGFibGUuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gICAgICAgIHRoaXMubW9kaWZ5Qm9keShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQodmlldy5yb3dzKF90aGlzKShkKShfdGhpcy52YWx1ZXMuY29sdW1ucykoX3RoaXMudmlldykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBwcmVwZW5kUm93IHByZXBlbmRzIGN1c3RvbWlzYWJsZSBET00gY29udGVudCB0byB0aGVcbiAgICAgKiBiZWdpbmluZyBvZiB0aGUgdGFibGUgYm9keS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgRE9NIGNvbnRlbnQgb2YgbXVzdCBiZSBiZXR3ZWVuIDx0cj4gZWxlbWVudHMuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnByZXBlbmRSb3cgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlCb2R5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5maXJzdENoaWxkID09IG51bGwpXG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChyZW5kZXJlci5yZW5kZXIoKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZS5yZXBsYWNlQ2hpbGQocmVuZGVyZXIucmVuZGVyKCksIGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwcGVuZFJvdyBhcHBlbmRzIGN1c3RvbWlzYWJsZSBET00gY29udGVudCB0byB0aGVcbiAgICAgKiBiZWdpbmluZyBvZiB0aGUgdGFibGUgYm9keS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgRE9NIGNvbnRlbnQgb2YgbXVzdCBiZSBiZXR3ZWVuIDx0cj4gZWxlbWVudHMuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLmFwcGVuZFJvdyA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICB0aGlzLm1vZGlmeUJvZHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQocmVuZGVyZXIucmVuZGVyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZW1vdmVSb3cgd2lsbCByZW1vdmUgYW4gZW50aXJlIHJvdyBmcm9tIHRoZSB0YWJsZSBnaXZlbiBpdHMgaW5kZXguXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLm1vZGlmeUJvZHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGUucm93cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGUucm93c1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUucm93c1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBbGxTZWxlY3RlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9BbGxTZWxlY3RlZEV2ZW50XCIpO1xuZXhwb3J0cy5BbGxTZWxlY3RlZEV2ZW50ID0gQWxsU2VsZWN0ZWRFdmVudF8xLkFsbFNlbGVjdGVkRXZlbnQ7XG52YXIgQ2VsbENsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQ2VsbENsaWNrZWRFdmVudFwiKTtcbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IENlbGxDbGlja2VkRXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50O1xudmFyIFJvd0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vUm93Q2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5Sb3dDbGlja2VkRXZlbnQgPSBSb3dDbGlja2VkRXZlbnRfMS5Sb3dDbGlja2VkRXZlbnQ7XG52YXIgSGVhZGluZ0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vSGVhZGluZ0NsaWNrZWRFdmVudFwiKTtcbmV4cG9ydHMuSGVhZGluZ0NsaWNrZWRFdmVudCA9IEhlYWRpbmdDbGlja2VkRXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50O1xudmFyIFRhYmxlXzEgPSByZXF1aXJlKFwiLi9UYWJsZVwiKTtcbmV4cG9ydHMuVGFibGUgPSBUYWJsZV8xLlRhYmxlO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuZXhwb3J0cy5UQUJMRSA9ICd0YWJsZSc7IC8vQHRvZG8gdW4tYm9vdHN0cmFwXG52YXIgQ2VsbF8xID0gcmVxdWlyZShcIi4vQ2VsbFwiKTtcbmV4cG9ydHMuQ2VsbCA9IENlbGxfMS5DZWxsO1xuZXhwb3J0cy5BU0NfQVJST1cgPSAnXFx1MjFlNyc7XG5leHBvcnRzLkRFU0NfQVJST1cgPSAnXFx1MjFlOSc7XG5leHBvcnRzLlRIRUFEID0gJ3RoZWFkJztcbmV4cG9ydHMuVEJPRFkgPSAndGJvZHknO1xuZXhwb3J0cy5kYXRlU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG5hID0gbmV3IERhdGUoYSkuZ2V0VGltZSgpO1xuICAgIHZhciBuYiA9IG5ldyBEYXRlKGIpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmEgPiBuYiA/IC0xIDogbmEgPCBuYiA/IDEgOiAwO1xufTtcbmV4cG9ydHMuc3RyaW5nU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGxhID0gU3RyaW5nKGEpLnJlcGxhY2UoL1xccysvLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbGIgPSBTdHJpbmcoYikucmVwbGFjZSgvXFxzKy8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobGEgPiBsYikgPyAtMSA6IChsYSA8IGxiKSA/IDEgOiAwO1xufTtcbmV4cG9ydHMubmF0dXJhbFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHsgYSA9ICcnOyB9XG4gICAgaWYgKGIgPT09IHZvaWQgMCkgeyBiID0gJyc7IH1cbiAgICAvL1NvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzQwMjI3L3NvcnQtbWl4ZWQtYWxwaGEtbnVtZXJpYy1hcnJheVxuICAgIHZhciByZUEgPSAvW15hLXpBLVpdL2c7XG4gICAgdmFyIHJlTiA9IC9bXjAtOV0vZztcbiAgICB2YXIgQUludCA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICB2YXIgQkludCA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICBpZiAoaXNOYU4oQUludCkgJiYgaXNOYU4oQkludCkpIHtcbiAgICAgICAgdmFyIGFBID0gYS5yZXBsYWNlKHJlQSwgJycpO1xuICAgICAgICB2YXIgYkEgPSBiLnJlcGxhY2UocmVBLCAnJyk7XG4gICAgICAgIGlmIChhQSA9PT0gYkEpIHtcbiAgICAgICAgICAgIHZhciBhTiA9IHBhcnNlSW50KGEucmVwbGFjZShyZU4sICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIGJOID0gcGFyc2VJbnQoYi5yZXBsYWNlKHJlTiwgJycpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gYU4gPT09IGJOID8gMCA6IGFOID4gYk4gPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYUEgPiBiQSA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihBSW50KSkgeyAvL0EgaXMgbm90IGFuIEludFxuICAgICAgICByZXR1cm4gLTE7IC8vdG8gbWFrZSBhbHBoYW51bWVyaWMgc29ydCBmaXJzdCByZXR1cm4gLTEgaGVyZVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihCSW50KSkgeyAvL0IgaXMgbm90IGFuIEludFxuICAgICAgICByZXR1cm4gMTsgLy90byBtYWtlIGFscGhhbnVtZXJpYyBzb3J0IGZpcnN0IHJldHVybiAxIGhlcmVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBBSW50ID4gQkludCA/IC0xIDogMTtcbiAgICB9XG59O1xuZXhwb3J0cy5udW1iZXJTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgbmEgPSBwYXJzZUZsb2F0KGEpO1xuICAgIHZhciBuYiA9IHBhcnNlRmxvYXQoYik7XG4gICAgbmEgPSAoaXNOYU4oYSkpID8gLUluZmluaXR5IDogYTtcbiAgICBuYiA9IChpc05hTihiKSkgPyAtSW5maW5pdHkgOiBiO1xuICAgIHJldHVybiAobmEgPiBuYikgPyAtMSA6IChuYSA8IG5iKSA/IDEgOiAwO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG47XG52YXIgcHJvcGVydHlfc2Vla18xID0gcmVxdWlyZShcInByb3BlcnR5LXNlZWtcIik7XG47XG52YXIgZnJhZ21lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYXlvdXQvZnJhZ21lbnRcIik7XG47XG52YXIgYWN0aXZlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udGVudC9zdGF0ZS9hY3RpdmVcIik7XG47XG5leHBvcnRzLnRoZWFkID0gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChjb2x1bW5zKSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RoZWFkJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC5pZFxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KGV4cG9ydHMuaGVhZHMoX19fY29udGV4dCkoY29sdW1ucykoX19fdmlldykpXSwgX19fdmlldyk7IH07IH07IH07XG47XG5leHBvcnRzLmhlYWRzID0gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChjb2x1bW5zKSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RyJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFsoX19fY29udGV4dC52YWx1ZXMub3B0aW9ucy5zZWxlY3RhYmxlKSA/IF9fX3dtbC5ib3goX19fd21sLmRvbWlmeShleHBvcnRzLmFsbFNlbGVjdGVkQ2hlY2tib3goX19fY29udGV4dCkoX19fdmlldykpLCBfX193bWwuZG9taWZ5KGV4cG9ydHMuaGVhZGluZ3MoX19fY29udGV4dCkoY29sdW1ucykoX19fdmlldykpKSA6IF9fX3dtbC5kb21pZnkoZXhwb3J0cy5oZWFkaW5ncyhfX19jb250ZXh0KShjb2x1bW5zKShfX192aWV3KSldLCBfX192aWV3KTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMuYWxsU2VsZWN0ZWRDaGVja2JveCA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RoJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICd0eXBlJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC5vbkNoZWNrXG4gICAgICAgIH0sXG4gICAgICAgIHdtbDoge31cbiAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTsgfTsgfTtcbjtcbmV4cG9ydHMuaGVhZGluZ3MgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIF9tYXAoZmllbGQpIHtcbiAgICByZXR1cm4gKGZpZWxkLnNvcnRBcykgPyBfX193bWwubm9kZSgndGgnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IHV0aWxfMS5jb25jYXQoX19fY29udGV4dC52YWx1ZXMudGFibGUudGhlYWQudGguY2xhc3MsICgoX19fY29udGV4dC52YWx1ZXMuc29ydGVkT24gPT09IGZpZWxkLm5hbWUpKSA/IGFjdGl2ZV8xLkFDVElWRSA6IFwiXCIpLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC50aC5vbmNsaWNrKGZpZWxkLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHdtbDoge31cbiAgICB9LCBbX19fd21sLmRvbWlmeShmaWVsZC5oZWFkaW5nKSwgKChfX19jb250ZXh0LnZhbHVlcy5zb3J0ZWRPbiA9PT0gZmllbGQubmFtZSkpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5hcnJvdykgOiBfX193bWwuZG9taWZ5KFwiXCIpXSwgX19fdmlldykgOiBfX193bWwubm9kZSgndGgnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IHV0aWxfMS5jb25jYXQoX19fY29udGV4dC52YWx1ZXMudGFibGUudGhlYWQudGguY2xhc3MsICgoX19fY29udGV4dC52YWx1ZXMuc29ydGVkT24gPT09IGZpZWxkLm5hbWUpKSA/IGFjdGl2ZV8xLkFDVElWRSA6IFwiXCIpLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC50aC5vbmNsaWNrKGZpZWxkLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHdtbDoge31cbiAgICB9LCBbX19fd21sLmRvbWlmeShmaWVsZC5oZWFkaW5nKSwgX19fd21sLmRvbWlmeSgoKF9fX2NvbnRleHQudmFsdWVzLnNvcnRlZE9uID09PSBmaWVsZC5uYW1lKSkgPyBfX19jb250ZXh0LnZhbHVlcy5hcnJvdyA6IFwiXCIpXSwgX19fdmlldyk7XG59LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn0pOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy50Ym9keSA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZnVuY3Rpb24gKGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubm9kZSgndGJvZHknLCB7XG4gICAgaHRtbDoge30sXG4gICAgd21sOiB7XG4gICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRib2R5LmlkXG4gICAgfVxufSwgW19fX3dtbC5kb21pZnkoZXhwb3J0cy5yb3dzKF9fX2NvbnRleHQpKGRhdGEpKGNvbHVtbnMpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpOyB9OyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5yb3dzID0gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBmdW5jdGlvbiAoY29sdW1ucykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5tYXAoZGF0YSwgZnVuY3Rpb24gX21hcChyb3dEYXRhLCBpbmRleCkge1xuICAgIHJldHVybiBfX193bWwubm9kZSgndHInLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRib2R5LnRyLmNsYXNzLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ci5vbmNsaWNrKHJvd0RhdGEsIGluZGV4LCBkYXRhKVxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW19fX3dtbC5kb21pZnkoZXhwb3J0cy5jZWxscyhfX19jb250ZXh0KShyb3dEYXRhKShpbmRleCkoY29sdW1ucykoX19fdmlldykpXSwgX19fdmlldyk7XG59LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn0pOyB9OyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5jZWxscyA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAocm93RGF0YSkgeyByZXR1cm4gZnVuY3Rpb24gKHJvd051bWJlcikgeyByZXR1cm4gZnVuY3Rpb24gKGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwuYm94KChfX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLnNlbGVjdGFibGUpID8gX19fd21sLmRvbWlmeShleHBvcnRzLnJvd1NlbGVjdENoZWNrYm94KF9fX2NvbnRleHQpKHJvd0RhdGEpKHJvd051bWJlcikoX19fdmlldykpIDogX19fd21sLmRvbWlmeShcIlwiKSwgX19fd21sLm1hcChjb2x1bW5zLCBmdW5jdGlvbiBfbWFwKGZpZWxkLCBpbmRleCkge1xuICAgIHJldHVybiBfX193bWwubm9kZSgndGQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRib2R5LnRkLmNsYXNzLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ZC5vbmNsaWNrKHByb3BlcnR5X3NlZWtfMS5nZXQoZmllbGQubmFtZSwgcm93RGF0YSksIGZpZWxkLm5hbWUsIHJvd0RhdGEsIHJvd051bWJlcilcbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ZC5pZChmaWVsZC5uYW1lLCBpbmRleCwgcm93TnVtYmVyKVxuICAgICAgICB9XG4gICAgfSwgWyhmaWVsZC5mcmFnbWVudCkgPyBfX193bWwuZG9taWZ5KGZpZWxkLmZyYWdtZW50KHByb3BlcnR5X3NlZWtfMS5nZXQoZmllbGQubmFtZSwgcm93RGF0YSkpKGZpZWxkLm5hbWUpKHJvd0RhdGEpKF9fX3ZpZXcpKSA6IF9fX3dtbC5kb21pZnkocHJvcGVydHlfc2Vla18xLmdldChmaWVsZC5uYW1lLCByb3dEYXRhKSldLCBfX192aWV3KTtcbn0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufSkpOyB9OyB9OyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5yb3dTZWxlY3RDaGVja2JveCA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAocm93KSB7IHJldHVybiBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiAoX19fY29udGV4dC52YWx1ZXMub3B0aW9ucy5zZWxlY3RhYmxlKSA/IF9fX3dtbC5ub2RlKCd0ZCcsIHtcbiAgICBodG1sOiB7fSxcbiAgICB3bWw6IHt9XG59LCBbX19fd21sLm5vZGUoJ2lucHV0Jywge1xuICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAndHlwZSc6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC52YWx1ZXMudGFibGUudGJvZHkudHIub25DaGVjayhyb3csIGluZGV4LCBfX19jb250ZXh0LnZhbHVlcy5kYXRhKVxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldykgOiBfX193bWwuZG9taWZ5KFwiXCIpOyB9OyB9OyB9OyB9O1xuO1xuZXhwb3J0cy50YWJsZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RhYmxlJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMudGFibGUuY2xhc3NcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS5pZFxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRoZWFkLnRlbXBsYXRlKF9fX2NvbnRleHQpKF9fX2NvbnRleHQudmFsdWVzLmNvbHVtbnMpKF9fX3ZpZXcpKSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ZW1wbGF0ZShfX19jb250ZXh0KShfX19jb250ZXh0LnZhbHVlcy5kYXRhKShfX19jb250ZXh0LnZhbHVlcy5jb2x1bW5zKShfX192aWV3KSldLCBfX192aWV3KTsgfTsgfTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChmcmFnbWVudF8xLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWygoX19fY29udGV4dC52YWx1ZXMuZGF0YS5sZW5ndGggPT09IDApKSA/IChfX19jb250ZXh0LnZhbHVlcy5lbXB0eSkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmVtcHR5KF9fX3ZpZXcpKSA6IF9fX3dtbC5kb21pZnkoZXhwb3J0cy50YWJsZShfX19jb250ZXh0KShfX192aWV3KSkgOiBfX193bWwuZG9taWZ5KGV4cG9ydHMudGFibGUoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGRyYXdlcl9sYXlvdXRfMSA9IHJlcXVpcmUoXCIuL3dtbC9kcmF3ZXItbGF5b3V0XCIpO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBEUkFXRVJfTEFZT1VUXG4gKi9cbmV4cG9ydHMuRFJBV0VSX0xBWU9VVCA9ICd3dy1kcmF3ZXItbGF5b3V0Jztcbi8vL2NsYXNzTmFtZXM6ZW5kXG52YXIgZHJhd2VyID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGxcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKGwudmFsdWVzLmRyYXdlci5pZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZTsgfSlcbiAgICAgICAgLm1hcChmKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGw7IH0pXG4gICAgICAgIC5vckp1c3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbDsgfSlcbiAgICAgICAgLmdldCgpO1xufTsgfTtcbjtcbi8qKlxuICogRHJhd2VyTGF5b3V0IHByb3ZpZGVzIGEgMSBjb2x1bW4gYXBwbGljYXRpb24gbGF5b3V0IHdpdGggYSBkcmF3ZXIgdGhhdCBjYW5cbiAqIGJlIHNob3duIG9yIGhpZGRlbiB1cG9uIHJlcXVlc3RzLlxuICpcbiAqIFRoZSBkcmF3ZXIgdGFrZXMgdXAgbW9zdCBvZiB0aGUgc2NyZWVuIG9uIG1vYmlsZSBhbmQgYWJvdXQgcm91Z2hseSAxLzYgLSAxLzggb25cbiAqIGEgZGVza3RvcCAobm90IGZhY3QgY2hlY2tlZCB5ZXQpLlxuICpcbiAqICBNb2JpbGU6XG4gKiAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgPGRyYXdlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqXG4gKiAgRGVza3RvcDpcbiAqICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgPGRyYXdlcj4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKlxuICovXG52YXIgRHJhd2VyTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3ZXJMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd2VyTGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkcmF3ZXJfbGF5b3V0XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmRyYXdlci5pZClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmlzSGlkZGVuKCk7IH0pXG4gICAgICAgICAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSlcbiAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkcmF3ZXIoX3RoaXMpKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmhpZGUoKTsgfSk7IH07XG4gICAgICAgIF90aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkcmF3ZXIoX3RoaXMpKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnNob3coKTsgfSk7IH07XG4gICAgICAgIF90aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRyYXdlcihfdGhpcykoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudG9nZ2xlKCk7IH0pOyB9O1xuICAgICAgICBfdGhpcy5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy5jb250ZW50LnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtjXTsgfTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVtb3ZlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy5jb250ZW50LnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzIGlzIGEgaGFzaCBvZiB2YWx1ZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuRFJBV0VSX0xBWU9VVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3ZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2RyYXdlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRyYXdlcikgPyBfdGhpcy5hdHRycy53dy5kcmF3ZXIgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGlkOiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jaGlsZHJlbjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEcmF3ZXJMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EcmF3ZXJMYXlvdXQgPSBEcmF3ZXJMYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIGRyYXdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2RyYXdlclwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGRyYXdlcl8xLkRyYXdlciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5kcmF3ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50JzogX19fY29udGV4dC52YWx1ZXMuZHJhd2VyLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LnJlbmRlcigpKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdlci1sYXlvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoaWRkZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZW50L3N0YXRlL2hpZGRlblwiKTtcbnZhciBHcm91cF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgZHJhd2VyXzEgPSByZXF1aXJlKFwiLi93bWwvZHJhd2VyXCIpO1xudmFyIGdldERvbSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRcbiAgICAgICAgLnZpZXdcbiAgICAgICAgLmZpbmRCeUlkKGQudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGU7IH0pO1xufTsgfTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuRFJBV0VSID0gJ3d3LWRyYXdlcic7XG5leHBvcnRzLkRSQVdFUl9DT05URU5UID0gJ3d3LWRyYXdlcl9fY29udGVudCc7XG4vKipcbiAqIERyYXdlciBwcm92aWRlcyBhIHdpZGdldCBmb3IgZGlzcGxheWluZyBuYXZpZ2F0aW9uIGFuZCBvdGhlciBzaWRlYmFyIGNvbnRlbnQuXG4gKlxuICogSXQncyBhcGkgYWxsb3dzIGZvciB0b2dnbGluZyBiZXR3ZWVuIGhpZGRlbiBhbmQgc2hvd24gc3RhdGVzIGFzIHdlbGwgYXMgcXVlcnlpbmcgdGhlXG4gKiBjdXJyZW50IHN0YXRlLlxuICpcbiAqIFRoaXMgd2lkZ2V0J3Mgc3R5bGUgaW50ZW50aW9uYWxseSBnaXZlcyBpdCBhIGhpZ2ggei1pbmRleCBzbyB0aGF0IGl0IGFwcGVhcnMgaW4tZnJvbnRcbiAqIG9mIG90aGVyIGNvbnRlbnQuIEFkanVzdCB0aGUgcmVzcGVjdGl2ZSBzdHlsZSB2YXJpYWJsZXMgdG8gY2hhbmdlLlxuICovXG52YXIgRHJhd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkcmF3ZXJfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaXNIaWRkZW4gPSBoaWRkZW5fMS5pc0hpZGRlbihnZXREb20oX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuaGlkZSA9IGhpZGRlbl8xLmhpZGUoX3RoaXMpKGdldERvbShfdGhpcykpO1xuICAgICAgICBfdGhpcy5zaG93ID0gaGlkZGVuXzEuc2hvdyhfdGhpcykoZ2V0RG9tKF90aGlzKSk7XG4gICAgICAgIF90aGlzLnRvZ2dsZSA9IGhpZGRlbl8xLnRvZ2dsZShfdGhpcykoZ2V0RG9tKF90aGlzKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgaXMgYSBoYXNoIG9mIHZhbHVlcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAnZHJhd2VyJyxcbiAgICAgICAgICAgICAgICBjbGFzczogZXhwb3J0cy5EUkFXRVIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLkRSQVdFUl9DT05URU5ULFxuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNvbnRlbnQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY29udGVudC5yZW5kZXIoKSA6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkcmVuOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERyYXdlcjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5EcmF3ZXIgPSBEcmF3ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuY29udGVudC5yZW5kZXIoKSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2ZyYWdtZW50XCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIEZyYWdtZW50IGFsbG93cyBmb3IgdGhlIGdyb3VwaW5nIG9mIHdpZGdldHMgaW4gYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gZmFjaWxpdGF0ZSB2aWV3IHRlbXBsYXRlcyB0aGF0IGRvIG5vdCBoYXZlIGEgc2luZ2xlXG4gKiByb290IGJ1dCBpbnN0ZWFkIGdlbmVyYXRlZCBtdWx0aXBsZSBzaWJsaW5nIGNvbnRlbnQuXG4gKi9cbnZhciBGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJhZ21lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJhZ21lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4odW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGcmFnbWVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfTtcbiAgICByZXR1cm4gRnJhZ21lbnQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2ZyYWdtZW50Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2dyaWQtbGF5b3V0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi4uL1wiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbi8vQHRvZG86IHJlZmFjdG9yIHRoaXMgdG8gYmUgaW5saW5lIHdpdGggb3RoZXIgY2xhc3MgbmFtZXNcbmV4cG9ydHMuR1JJRF9MQVlPVVQgPSAnY29udGFpbmVyLWZsdWlkJztcbmV4cG9ydHMuQ09MVU1OID0gJ3d3LWNvbHVtbic7XG5leHBvcnRzLlJPVyA9ICdyb3cnO1xuO1xuLyoqXG4gKiBHcmlkTGF5b3V0XG4gKi9cbnZhciBHcmlkTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWRMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyaWQoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkdSSURfTEFZT1VULCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JpZExheW91dDtcbn0oXzEuR2VuZXJpY0xheW91dCkpO1xuZXhwb3J0cy5HcmlkTGF5b3V0ID0gR3JpZExheW91dDtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLlJvdyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3JvdycsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoZXhwb3J0cy5ST1csIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3c7XG59KF8xLkdlbmVyaWNMYXlvdXQpKTtcbmV4cG9ydHMuUm93ID0gUm93O1xudmFyIENvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sdW1uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbHVtbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuQ29sdW1uKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGlkOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICBjbGFzczogX3RoaXMuYXR0cnMud3cgPyB1dGlsXzEuY29uY2F0KF90aGlzLmF0dHJzLnd3LnNpemUgP1xuICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC1cIiArIF90aGlzLmF0dHJzLnd3LnNpemUgOiAnY29sLW1kLTEyJywgX3RoaXMuYXR0cnMud3cuY2xhc3MpIDogJ2NvbC1tZC0xMidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29sdW1uO1xufShfMS5HZW5lcmljTGF5b3V0KSk7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JpZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmlkKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdzZWN0aW9uJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcmlkO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5HcmlkID0gR3JpZDtcbjtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3coX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm93O1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5Sb3cgPSBSb3c7XG47XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2x1bW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sdW1uKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuQ29sdW1uID0gQ29sdW1uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZC1sYXlvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9ob3Jpem9udGFsLWxheW91dFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbi8vL2NsYXNzTmFtZXM6YmVnaW5cbmV4cG9ydHMuSE9SSVpPTlRBTF9MQVlPVVQgPSAnd3ctaG9yaXpvbnRhbC1sYXlvdXQnO1xuLyoqXG4gKiBIb3Jpem9udGFsTGF5b3V0IHVzZXMgdGhlIGNzcyBmbGV4Ym94IHRvIHByb3ZpZGUgYSBjb250YWluZXJcbiAqIHdoZXJlIGFsbCBpdGVtcyBhcmUgbGFpZCBvdXQgaW4gYSBzaW5nbGUgcm93LlxuICovXG52YXIgSG9yaXpvbnRhbExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9yaXpvbnRhbExheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIb3Jpem9udGFsTGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByb290IGVsZW1lbnQgdmFsdWVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogY2xhc3MgbmFtZXMgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChleHBvcnRzLkhPUklaT05UQUxfTEFZT1VUKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIb3Jpem9udGFsTGF5b3V0O1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhvcml6b250YWxMYXlvdXQgPSBIb3Jpem9udGFsTGF5b3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9yaXpvbnRhbC1sYXlvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIF9nZXQgPSBmdW5jdGlvbiAoZ2VuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdlblxuICAgICAgICAudmlld1xuICAgICAgICAuZmluZEJ5SWQoZ2VuLnZhbHVlcy5jb250ZW50LmlkKTtcbn07IH07XG4vKipcbiAqIEdlbmVyaWNMYXlvdXQgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgTGF5b3V0LlxuICovXG52YXIgR2VuZXJpY0xheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2VuZXJpY0xheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZW5lcmljTGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2V0Q29udGVudCA9IGV4cG9ydHMuc2V0Q29udGVudChfdGhpcykoX2dldChfdGhpcykpO1xuICAgICAgICBfdGhpcy5yZW1vdmVDb250ZW50ID0gZXhwb3J0cy5yZW1vdmVDb250ZW50KF90aGlzKShfZ2V0KF90aGlzKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyaWNMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5HZW5lcmljTGF5b3V0ID0gR2VuZXJpY0xheW91dDtcbi8qKlxuICogc2V0Q29udGVudCBoZWxwZXIuXG4gKi9cbmV4cG9ydHMuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgcmV0dXJuIGZuKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbDsgfSlcbiAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBsOyB9KVxuICAgICAgICAuZ2V0KCk7XG59OyB9OyB9O1xuLyoqXG4gKiByZW1vdmVDb250ZW50IGhlbHBlci5cbiAqL1xuZXhwb3J0cy5yZW1vdmVDb250ZW50ID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgd2hpbGUgKGUuZmlyc3RDaGlsZClcbiAgICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGw7IH0pXG4gICAgICAgIC5vckp1c3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbDsgfSlcbiAgICAgICAgLmdldCgpO1xufTsgfTsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXRlbSA9IHJlcXVpcmUoXCIuL3dtbC9saXN0LWxheW91dC1pdGVtXCIpO1xudmFyIGxheW91dCA9IHJlcXVpcmUoXCIuL3dtbC9saXN0LWxheW91dFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLkxJU1RfTEFZT1VUID0gJ3d3LWxpc3QtbGF5b3V0JztcbmV4cG9ydHMuTElTVF9MQVlPVVRfSVRFTSA9ICd3dy1saXN0LWxheW91dF9faXRlbSc7XG4vKipcbiAqIExpc3RMYXlvdXRJdGVtXG4gKi9cbnZhciBMaXN0TGF5b3V0SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdExheW91dEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdExheW91dEl0ZW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGl0ZW0uTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2l0ZW0nLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBleHBvcnRzLkxJU1RfTEFZT1VUX0lURU1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdExheW91dEl0ZW07XG59KF8xLkdlbmVyaWNMYXlvdXQpKTtcbmV4cG9ydHMuTGlzdExheW91dEl0ZW0gPSBMaXN0TGF5b3V0SXRlbTtcbi8qKlxuICogTGlzdExheW91dCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHZlcnRpY2FsIGxpc3Qgb2YgY29udGVudC5cbiAqXG4gKiBDaGlsZHJlbiBtdXN0IGJlIExpc3RHcm91cEl0ZW1zLlxuICovXG52YXIgTGlzdExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdExheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0TGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBsYXlvdXQuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTElTVF9MQVlPVVQsIF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0TGF5b3V0O1xufShfMS5HZW5lcmljTGF5b3V0KSk7XG5leHBvcnRzLkxpc3RMYXlvdXQgPSBMaXN0TGF5b3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oX19fY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX19jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWxheW91dC1pdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC1sYXlvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tYWluLWxheW91dFwiKTtcbnZhciBvcmllbnRhdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvY29udGVudC9vcmllbnRhdGlvblwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLk1BSU5fTEFZT1VUID0gJ3d3LW1haW4tbGF5b3V0Jztcbi8qKlxuICogTWFpbkxheW91dCBwcm92aWRlcyBhIGNvbnRhaW5lciBmb3IgdGhlIG1haW4gY29udGVudCBvZiBhbiBhcHBsaWNhdGlvbi5cbiAqL1xudmFyIE1haW5MYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW5MYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbkxheW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KGV4cG9ydHMuTUFJTl9MQVlPVVQsIG9yaWVudGF0aW9uLlJJR0hUX1BVU0hBQkxFLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW5MYXlvdXQ7XG59KF8xLkdlbmVyaWNMYXlvdXQpKTtcbmV4cG9ydHMuTWFpbkxheW91dCA9IE1haW5MYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4tbGF5b3V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3R5bGUgPSByZXF1aXJlKFwiLi4vLi4vY29udGVudC9zdHlsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBwYW5lbF8xID0gcmVxdWlyZShcIi4vd21sL3BhbmVsXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuLyoqXG4gKiBQYW5lbCBwcm92aWRlcyBhIHJlY3Rhbmd1bGFyIGNvbnRhaW5lciBmb3IgdmlzdWFsbHkgc2VwZXJhdGluZ1xuICogY29udGVudCBieSBjb250ZXh0LlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgdGhlIGNvbnRhaW5pbmcsIHBhcnQgdGhhdCBjYW4gYmUgZnVydGhlclxuICogc3ViZGl2aWRlZCBpbnRvIGEgaGVhZGVyLCBib2R5IGFuZC9vciBmb290ZXIgc2VjdGlvbi5cbiAqL1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgcGFuZWxfMS5NYWluKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByb290IHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIGlkOiAncGFuZWwnLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGNsYXNzIG5hbWUgZm9yIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoXzEuUEFORUwsIF90aGlzLmF0dHJzLnd3ID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc3R5bGUgOiBzdHlsZS5ERUZBVUxULCBfdGhpcy5hdHRycy53dyA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsO1xufShfXzEuR2VuZXJpY0xheW91dCkpO1xuZXhwb3J0cy5QYW5lbCA9IFBhbmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFuZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBwYW5lbF9ib2R5XzEgPSByZXF1aXJlKFwiLi93bWwvcGFuZWwtYm9keVwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgXzIgPSByZXF1aXJlKFwiLlwiKTtcbi8qKlxuICogUGFuZWxCb2R5IHBhcnQgb2YgYSBQYW5lbCBmb3IgY29udGFpbmluZyB0aGUgbWFpbiBjb250ZW50LlxuICovXG52YXIgUGFuZWxCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxCb2R5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBwYW5lbF9ib2R5XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2JvZHknLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGNsYXNzIGZvciB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KF8yLlBBTkVMX0JPRFksIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWxCb2R5O1xufShfMS5HZW5lcmljTGF5b3V0KSk7XG5leHBvcnRzLlBhbmVsQm9keSA9IFBhbmVsQm9keTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhbmVsQm9keS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHBhbmVsX2Zvb3Rlcl8xID0gcmVxdWlyZShcIi4vd21sL3BhbmVsLWZvb3RlclwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgXzIgPSByZXF1aXJlKFwiLlwiKTtcbi8qKlxuICogUGFuZWxGb290ZXIgcGFydCBvZiB0aGUgcGFuZWwgZm9yIHN1bW1hcnkgY29udGVudCBldGMuXG4gKi9cbnZhciBQYW5lbEZvb3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWxGb290ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxGb290ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHBhbmVsX2Zvb3Rlcl8xLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGNsYXNzIG5hbWUgZm9yIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoXzIuUEFORUxfRk9PVEVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsRm9vdGVyO1xufShfMS5HZW5lcmljTGF5b3V0KSk7XG5leHBvcnRzLlBhbmVsRm9vdGVyID0gUGFuZWxGb290ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYW5lbEZvb3Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHBhbmVsX2hlYWRlcl8xID0gcmVxdWlyZShcIi4vd21sL3BhbmVsLWhlYWRlclwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgXzIgPSByZXF1aXJlKFwiLlwiKTtcbnZhciBQYW5lbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWxIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHBhbmVsX2hlYWRlcl8xLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGNsYXNzIG5hbWUgZm9yIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQoXzIuUEFORUxfSEVBREVSLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsSGVhZGVyO1xufShfMS5HZW5lcmljTGF5b3V0KSk7XG5leHBvcnRzLlBhbmVsSGVhZGVyID0gUGFuZWxIZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYW5lbEhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYW5lbF8xID0gcmVxdWlyZShcIi4vUGFuZWxcIik7XG5leHBvcnRzLlBhbmVsID0gUGFuZWxfMS5QYW5lbDtcbnZhciBQYW5lbEhlYWRlcl8xID0gcmVxdWlyZShcIi4vUGFuZWxIZWFkZXJcIik7XG5leHBvcnRzLlBhbmVsSGVhZGVyID0gUGFuZWxIZWFkZXJfMS5QYW5lbEhlYWRlcjtcbnZhciBQYW5lbEJvZHlfMSA9IHJlcXVpcmUoXCIuL1BhbmVsQm9keVwiKTtcbmV4cG9ydHMuUGFuZWxCb2R5ID0gUGFuZWxCb2R5XzEuUGFuZWxCb2R5O1xudmFyIFBhbmVsRm9vdGVyXzEgPSByZXF1aXJlKFwiLi9QYW5lbEZvb3RlclwiKTtcbmV4cG9ydHMuUGFuZWxGb290ZXIgPSBQYW5lbEZvb3Rlcl8xLlBhbmVsRm9vdGVyO1xuLy8vY2xhc3NOYW1lczpiZWdpblxuLyoqXG4gKiBQQU5FTCB3cmFwcGVyIGNsYXNzLlxuICovXG5leHBvcnRzLlBBTkVMID0gJ3d3LXBhbmVsJztcbi8qKlxuICogUEFORUxfSEVBREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuUEFORUxfSEVBREVSID0gJ3d3LXBhbmVsX19oZWFkZXInO1xuLyoqXG4gKiBQQU5FTF9CT0RZIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuUEFORUxfQk9EWSA9ICd3dy1wYW5lbF9fYm9keSc7XG4vKipcbiAqIFBBTkVMX0ZPT1RFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0ZPT1RFUiA9ICd3dy1wYW5lbF9fZm9vdGVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWwtYm9keS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLWZvb3Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLWhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihfX19jb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fX2NvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY29udGVudC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvdGFiLWxheW91dFwiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vLy9jbGFzc05hbWVzOmJlZ2luXG5leHBvcnRzLlRBQl9MQVlPVVQgPSAnd3ctdGFiLWxheW91dCc7XG4vKipcbiAqIFRhYkxheW91dCBwcm92aWRlcyBhIGxheW91dCB3aG9zZSBkaXNwbGF5ZWQgY29udGVudCBjYW4gYmUgY2hhbmdlZCB2aWEgdGFicy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFRhYjEgIHwgIFRhYjIgIHwgVGFiMiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q29udGVudD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKi9cbnZhciBUYWJMYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkxheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlcy5jb250ZW50ID0gdmlld3MuY29udGVudChjKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW1vdmVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudmFsdWVzLmNvbnRlbnQgPSB2aWV3cy5lbXB0eTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IGV4cG9ydHMuVEFCX0xBWU9VVFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhYjogX3RoaXMuYXR0cnMud3cuYWN0aXZlIHx8IE9iamVjdC5rZXlzKF90aGlzLmF0dHJzLnd3LnRhYnMpWzBdLFxuICAgICAgICAgICAgdGFiczogX3RoaXMuYXR0cnMud3cudGFicyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IE1heWJlXzEuTWF5YmVcbiAgICAgICAgICAgICAgICAuZnJvbUFueShfdGhpcy5hdHRycy53dy50YWJzW190aGlzLmF0dHJzLnd3LmFjdGl2ZV0pXG4gICAgICAgICAgICAgICAgLm9yRWxzZShmdW5jdGlvbiAoKSB7IHJldHVybiBNYXliZV8xLk1heWJlLmZyb21BbnkoX3RoaXMuYXR0cnMud3cudGFic1tPYmplY3Qua2V5cyhfdGhpcy5hdHRycy53dy50YWJzKVswXV0pOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRzKSB7IHJldHVybiB0cy5jb250ZW50VGVtcGxhdGU7IH0pXG4gICAgICAgICAgICAgICAgLmdldCgpLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBNYXliZV8xLk1heWJlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tQm9vbGVhbihfdGhpcy52YWx1ZXMudGFiICE9PSBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKCkgeyBfdGhpcy52YWx1ZXMudGFiID0gZS5uYW1lOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2hhaW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF5YmVfMS5NYXliZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZyb21BbnkoX3RoaXMuYXR0cnMud3cudGFic1tlLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy5jb250ZW50ID0gdHMuY29udGVudFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7IF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IGNvbnNvbGUuZXJyb3IoXCJUYWJMYXlvdXQ6IHVua25vd24gdGFiICdcIiArIGUubmFtZSArIFwiJyFcIik7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJMYXlvdXQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWJMYXlvdXQgPSBUYWJMYXlvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIGZyYWdtZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZnJhZ21lbnRcIik7XG47XG52YXIgdGFiX2Jhcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyb2wvdGFiLWJhclwiKTtcbjtcbmV4cG9ydHMuZW1wdHkgPSBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC53aWRnZXQoZnJhZ21lbnRfMS5GcmFnbWVudCwge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtdLCBfX192aWV3KTsgfTsgfTtcbjtcbmV4cG9ydHMuY29udGVudCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoXykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5kb21pZnkoYyk7IH07IH07IH07XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKF9fX2NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX19fY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldCh0YWJfYmFyXzEuVGFiQmFyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMudGFicywgZnVuY3Rpb24gX21hcCh0YWIsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KHRhYl9iYXJfMS5UYWIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnZhbHVlcy50YWIgPT09IG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudmFsdWVzLm9uQ2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbKHRhYi50YWJUZW1wbGF0ZSkgPyBfX193bWwuZG9taWZ5KHRhYi50YWJUZW1wbGF0ZShfX19jb250ZXh0KShfX192aWV3KSkgOiAodGFiLnRleHQpID8gX19fd21sLmRvbWlmeSh0YWIudGV4dCkgOiBfX193bWwuZG9taWZ5KG5hbWUpXSwgX19fdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyksIChfX19jb250ZXh0LnZhbHVlcy5jb250ZW50KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuY29udGVudChfX19jb250ZXh0KShfX192aWV3KSkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiLWxheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB1c2VkXG4gKiB0aHJvdWdoIG91dCB0aGUgd21sLXdpZGdldHMgbW9kdWxlLlxuICovXG4vKipcbiAqIGNvbWJpbmUgdGhlIG1lbWJlcnMgb2YgYW4gYXJyYXkgaW50byBvbmUgc3RyaW5nLlxuICovXG5leHBvcnRzLmNvbWJpbmUgPSBmdW5jdGlvbiAoc3RyLCBqb2luZXIpIHtcbiAgICBpZiAoam9pbmVyID09PSB2b2lkIDApIHsgam9pbmVyID0gJyAnOyB9XG4gICAgcmV0dXJuIHN0ci5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICgocyAhPSBudWxsKSB8fCBzICE9ICcnKTsgfSkuam9pbihqb2luZXIpO1xufTtcbi8qKlxuICogY29uY2F0IGpvaW5zIHZhcmlvdXMgc3RyaW5ncyB0b2dldGhlciB0byBmb3JtIGFuIGh0bWwgY2xhc3MgYXR0cmlidXRlIHZhbHVlLlxuICpcbiAqIFJlbW92ZXMgZW1wdHkgc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAqL1xuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0ciA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cltfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gKChzID09IG51bGwpIHx8IChzID09ICcnKSkgPyBmYWxzZSA6IHRydWU7IH0pLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy50cmltKCk7IH0pLmpvaW4oJyAnKTtcbn07XG4vKipcbiAqIG5vb3BcbiAqL1xuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLyoqXG4gKiByZXBsYWNlQ29udGVudFxuICovXG5leHBvcnRzLnJlcGxhY2VDb250ZW50ID0gZnVuY3Rpb24gKHIsIG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpXG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoci5yZW5kZXIoKSk7XG59O1xuLyoqXG4gKiBkZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIHRoYXQgaXQgaXMgb25seSBjYWxsZWQgb25jZSBhZnRlclxuICogYSBwZXJpb2Qgb2YgdGltZS5cbiAqL1xuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmLCBkZWxheSkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgcmV0dXJuIGRlbGF5ID09PSAwID8gZiA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZihhKTsgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZihhKTsgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVHlwZXMgY29ycmVzcG9uZGluZyB0byB0aGUgV01MIEFTVC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuO1xuLyoqXG4gKiBNb2R1bGUgaXMgd2hhdCBhIHdtbCBmaWxlIGNvbXBpbGVzIHRvLlxuICpcbiAqIEEgbW9kdWxlIGNvbnRhaW5zIGEgbGlzdCBvZiBpbXBvcnRzIGFuZCBleHBvcnRlZCBzeW1ib2xzLlxuICogQWxsIGRlY2xhcmF0aW9ucyBpbiB3bWwgYXJlIGV4cG9ydGVkLiBUaGVyZSBpcyBubyBzdWNoIHRoaW5nXG4gKiBhcyBwcml2YXRlIGhlcmUuXG4gKi9cbnZhciBNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kdWxlKGltcG9ydHMsIGV4cG9ydHMsIG1haW4sIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaW1wb3J0cyA9IGltcG9ydHM7XG4gICAgICAgIHRoaXMuZXhwb3J0cyA9IGV4cG9ydHM7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ21vZHVsZSc7XG4gICAgfVxuICAgIHJldHVybiBNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XG4vKipcbiAqIEltcG9ydFN0YXRlbWVudFxuICovXG52YXIgSW1wb3J0U3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltcG9ydFN0YXRlbWVudChtZW1iZXIsIG1vZHVsZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbXBvcnQtc3RhdGVtZW50JztcbiAgICB9XG4gICAgcmV0dXJuIEltcG9ydFN0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLkltcG9ydFN0YXRlbWVudCA9IEltcG9ydFN0YXRlbWVudDtcbi8qKlxuICogQWxpYXNlZE1lbWJlclxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBhbGlhcyAtIFRoZSBpZGVudGlmaWVyIGludHJvZHVjZWQgdG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ9IG1lbWJlciAtIFRoZSBpZGVudGlmaWVyIHRoYXQgaXMgYWxpYXNlZC5cbiAqL1xudmFyIEFsaWFzZWRNZW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWxpYXNlZE1lbWJlcihtZW1iZXIsIGFsaWFzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlciA9IG1lbWJlcjtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbGlhc2VkLW1lbWJlcic7XG4gICAgfVxuICAgIHJldHVybiBBbGlhc2VkTWVtYmVyO1xufSgpKTtcbmV4cG9ydHMuQWxpYXNlZE1lbWJlciA9IEFsaWFzZWRNZW1iZXI7XG4vKipcbiAqIEFnZ3JlZ2F0ZU1lbWJlclxuICovXG52YXIgQWdncmVnYXRlTWVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFnZ3JlZ2F0ZU1lbWJlcihpZCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtbWVtYmVyJztcbiAgICB9XG4gICAgcmV0dXJuIEFnZ3JlZ2F0ZU1lbWJlcjtcbn0oKSk7XG5leHBvcnRzLkFnZ3JlZ2F0ZU1lbWJlciA9IEFnZ3JlZ2F0ZU1lbWJlcjtcbi8qKlxuICogQ29tcG9zaXRlTWVtYmVyXG4gKiBAcHJvcGVydHkgey4uLklkZW50aWZpZXJ8QWxpYXNlZF9NZW1iZXJ9IG1lbWJlcnNcbiAqL1xudmFyIENvbXBvc2l0ZU1lbWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb3NpdGVNZW1iZXIobWVtYmVycywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29tcG9zaXRlLW1lbWJlcic7XG4gICAgfVxuICAgIHJldHVybiBDb21wb3NpdGVNZW1iZXI7XG59KCkpO1xuZXhwb3J0cy5Db21wb3NpdGVNZW1iZXIgPSBDb21wb3NpdGVNZW1iZXI7XG52YXIgVHlwZWRNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVkTWFpbihpZCwgdHlwZUNsYXNzZXMsIGNvbnRleHQsIHBhcmFtZXRlcnMsIHRhZywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGVDbGFzc2VzID0gdHlwZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlZC1tYWluJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVkTWFpbjtcbn0oKSk7XG5leHBvcnRzLlR5cGVkTWFpbiA9IFR5cGVkTWFpbjtcbnZhciBVbnR5cGVkTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnR5cGVkTWFpbih0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd1bnR5cGVkLW1haW4nO1xuICAgIH1cbiAgICByZXR1cm4gVW50eXBlZE1haW47XG59KCkpO1xuZXhwb3J0cy5VbnR5cGVkTWFpbiA9IFVudHlwZWRNYWluO1xudmFyIEV4cG9ydFN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnRTdGF0ZW1lbnQobWVtYmVycywgbW9kdWxlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZXhwb3J0LXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBFeHBvcnRTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5FeHBvcnRTdGF0ZW1lbnQgPSBFeHBvcnRTdGF0ZW1lbnQ7XG4vKipcbiAqIFZpZXdTdGF0ZW1lbnRcbiAqL1xudmFyIFZpZXdTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld1N0YXRlbWVudChpZCwgdHlwZUNsYXNzZXMsIGNvbnRleHQsIHBhcmFtZXRlcnMsIHRhZywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGVDbGFzc2VzID0gdHlwZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd2aWV3LXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBWaWV3U3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuVmlld1N0YXRlbWVudCA9IFZpZXdTdGF0ZW1lbnQ7XG52YXIgRnVuU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1blN0YXRlbWVudChpZCwgdHlwZUNsYXNzZXMsIGNvbnRleHQsIHBhcmFtZXRlcnMsIGJvZHksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdmdW4tc3RhdGVtZW50JztcbiAgICB9XG4gICAgcmV0dXJuIEZ1blN0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLkZ1blN0YXRlbWVudCA9IEZ1blN0YXRlbWVudDtcbi8qKlxuICogVHlwZUNsYXNzXG4gKi9cbnZhciBUeXBlQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZUNsYXNzKGlkLCBjb25zdHJhaW50LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY29uc3RyYWludCA9IGNvbnN0cmFpbnQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3R5cGUtY2xhc3MnO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZUNsYXNzO1xufSgpKTtcbmV4cG9ydHMuVHlwZUNsYXNzID0gVHlwZUNsYXNzO1xudmFyIFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZShpZCwgdHlwZUNsYXNzZXMsIGxpc3QsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UeXBlID0gVHlwZTtcbnZhciBUeXBlZFBhcmFtZXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlZFBhcmFtZXRlcihpZCwgaGludCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmhpbnQgPSBoaW50O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlZC1wYXJhbWV0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZWRQYXJhbWV0ZXI7XG59KCkpO1xuZXhwb3J0cy5UeXBlZFBhcmFtZXRlciA9IFR5cGVkUGFyYW1ldGVyO1xudmFyIFVudHlwZWRQYXJhbWV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW50eXBlZFBhcmFtZXRlcihpZCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd1bnR5cGVkLXBhcmFtZXRlcic7XG4gICAgfVxuICAgIHJldHVybiBVbnR5cGVkUGFyYW1ldGVyO1xufSgpKTtcbmV4cG9ydHMuVW50eXBlZFBhcmFtZXRlciA9IFVudHlwZWRQYXJhbWV0ZXI7XG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKG9wZW4sIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBjbG9zZSkge1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xudmFyIFdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaWRnZXQob3BlbiwgYXR0cmlidXRlcywgY2hpbGRyZW4sIGNsb3NlKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5jbG9zZSA9IGNsb3NlO1xuICAgICAgICB0aGlzLnR5cGUgPSAnd2lkZ2V0JztcbiAgICB9XG4gICAgcmV0dXJuIFdpZGdldDtcbn0oKSk7XG5leHBvcnRzLldpZGdldCA9IFdpZGdldDtcbnZhciBBdHRyaWJ1dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRlKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2F0dHJpYnV0ZSc7XG4gICAgfVxuICAgIHJldHVybiBBdHRyaWJ1dGU7XG59KCkpO1xuZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG52YXIgSW50ZXJwb2xhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uKGV4cHJlc3Npb24sIGZpbHRlcnMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ludGVycG9sYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4gSW50ZXJwb2xhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0aW9uO1xudmFyIEZvclN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQodmFyaWFibGUsIGluZGV4LCBhbGwsIGxpc3QsIGJvZHksIG90aGVyd2lzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYWxsID0gYWxsO1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZm9yLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XG52YXIgSWZTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWZTdGF0ZW1lbnQoY29uZGl0aW9uLCB0aGVuLCBlbHNlQ2xhdXNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgICAgdGhpcy5lbHNlQ2xhdXNlID0gZWxzZUNsYXVzZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaWYtc3RhdGVtZW50JztcbiAgICB9XG4gICAgcmV0dXJuIElmU3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBJZlN0YXRlbWVudDtcbnZhciBFbHNlQ2xhdXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsc2VDbGF1c2UoY2hpbGRyZW4sIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZWxzZS1jbGF1c2UnO1xuICAgIH1cbiAgICByZXR1cm4gRWxzZUNsYXVzZTtcbn0oKSk7XG5leHBvcnRzLkVsc2VDbGF1c2UgPSBFbHNlQ2xhdXNlO1xudmFyIEVsc2VJZkNsYXVzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbHNlSWZDbGF1c2UoY29uZGl0aW9uLCB0aGVuLCBlbHNlQ2xhdXNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgICAgdGhpcy5lbHNlQ2xhdXNlID0gZWxzZUNsYXVzZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZWxzZS1pZi1jbGF1c2UnO1xuICAgIH1cbiAgICByZXR1cm4gRWxzZUlmQ2xhdXNlO1xufSgpKTtcbmV4cG9ydHMuRWxzZUlmQ2xhdXNlID0gRWxzZUlmQ2xhdXNlO1xudmFyIENoYXJhY3RlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhcmFjdGVycyh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdjaGFyYWN0ZXJzJztcbiAgICB9XG4gICAgcmV0dXJuIENoYXJhY3RlcnM7XG59KCkpO1xuZXhwb3J0cy5DaGFyYWN0ZXJzID0gQ2hhcmFjdGVycztcbnZhciBJZlRoZW5FeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElmVGhlbkV4cHJlc3Npb24oY29uZGl0aW9uLCBpZnRydWUsIGlmZmFsc2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmlmdHJ1ZSA9IGlmdHJ1ZTtcbiAgICAgICAgdGhpcy5pZmZhbHNlID0gaWZmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaWYtdGhlbi1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIElmVGhlbkV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5JZlRoZW5FeHByZXNzaW9uID0gSWZUaGVuRXhwcmVzc2lvbjtcbnZhciBCaW5hcnlFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24obGVmdCwgb3BlcmF0b3IsIHJpZ2h0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gQmluYXJ5RXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xudmFyIFVuYXJ5RXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW5hcnktZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBVbmFyeUV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XG52YXIgVmlld0NvbnN0cnVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29uc3RydWN0aW9uKGNvbnMsIGNvbnRleHQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ucyA9IGNvbnM7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3ZpZXctY29uc3RydWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIFZpZXdDb25zdHJ1Y3Rpb247XG59KCkpO1xuZXhwb3J0cy5WaWV3Q29uc3RydWN0aW9uID0gVmlld0NvbnN0cnVjdGlvbjtcbnZhciBGdW5BcHBsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5BcHBsaWNhdGlvbih0YXJnZXQsIHR5cGVBcmdzLCBhcmdzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50eXBlQXJncyA9IHR5cGVBcmdzO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdmdW4tYXBwbGljYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4gRnVuQXBwbGljYXRpb247XG59KCkpO1xuZXhwb3J0cy5GdW5BcHBsaWNhdGlvbiA9IEZ1bkFwcGxpY2F0aW9uO1xudmFyIENvbnN0cnVjdEV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RydWN0RXhwcmVzc2lvbihjb25zLCBhcmdzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbnMgPSBjb25zO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdjb25zdHJ1Y3QtZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBDb25zdHJ1Y3RFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuQ29uc3RydWN0RXhwcmVzc2lvbiA9IENvbnN0cnVjdEV4cHJlc3Npb247XG52YXIgQ2FsbEV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24odGFyZ2V0LCB0eXBlQXJncywgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudHlwZUFyZ3MgPSB0eXBlQXJncztcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2FsbC1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIENhbGxFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcbi8qKlxuICogTWVtYmVyRXhwcmVzc2lvblxuICovXG52YXIgTWVtYmVyRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW1iZXJFeHByZXNzaW9uKHRhcmdldCwgbWVtYmVyLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIE1lbWJlckV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5NZW1iZXJFeHByZXNzaW9uID0gTWVtYmVyRXhwcmVzc2lvbjtcbnZhciBSZWFkRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWFkRXhwcmVzc2lvbih0YXJnZXQsIHBhdGgsIGhpbnQsIGRlZmF1bHRzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5oaW50ID0gaGludDtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZWFkLWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gUmVhZEV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5SZWFkRXhwcmVzc2lvbiA9IFJlYWRFeHByZXNzaW9uO1xudmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1ldGVycywgYm9keSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuY3Rpb24tZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBGdW5jdGlvbkV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jdGlvbkV4cHJlc3Npb247XG52YXIgTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXN0KG1lbWJlcnMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpc3QnO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdDtcbn0oKSk7XG5leHBvcnRzLkxpc3QgPSBMaXN0O1xudmFyIFJlY29yZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvcmQocHJvcGVydGllcywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVjb3JkJztcbiAgICB9XG4gICAgcmV0dXJuIFJlY29yZDtcbn0oKSk7XG5leHBvcnRzLlJlY29yZCA9IFJlY29yZDtcbnZhciBQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eShrZXksIHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdwcm9wZXJ0eSc7XG4gICAgfVxuICAgIHJldHVybiBQcm9wZXJ0eTtcbn0oKSk7XG5leHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XG52YXIgU3RyaW5nTGl0ZXJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdMaXRlcmFsKHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0cmluZyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmdMaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nTGl0ZXJhbCA9IFN0cmluZ0xpdGVyYWw7XG52YXIgTnVtYmVyTGl0ZXJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJMaXRlcmFsKHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ251bWJlci1saXRlcmFsJztcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlckxpdGVyYWw7XG59KCkpO1xuZXhwb3J0cy5OdW1iZXJMaXRlcmFsID0gTnVtYmVyTGl0ZXJhbDtcbnZhciBCb29sZWFuTGl0ZXJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdib29sZWFuLWxpdGVyYWwnO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbkxpdGVyYWw7XG59KCkpO1xuZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbCA9IEJvb2xlYW5MaXRlcmFsO1xudmFyIENvbnRleHRQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0UHJvcGVydHkobWVtYmVyLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlciA9IG1lbWJlcjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29udGV4dC1wcm9wZXJ0eSc7XG4gICAgfVxuICAgIHJldHVybiBDb250ZXh0UHJvcGVydHk7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0UHJvcGVydHkgPSBDb250ZXh0UHJvcGVydHk7XG52YXIgQ29udGV4dFZhcmlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHRWYXJpYWJsZShsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdjb250ZXh0LXZhcmlhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHRWYXJpYWJsZTtcbn0oKSk7XG5leHBvcnRzLkNvbnRleHRWYXJpYWJsZSA9IENvbnRleHRWYXJpYWJsZTtcbnZhciBVbnF1YWxpZmllZENvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVucXVhbGlmaWVkQ29uc3RydWN0b3IoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW5xdWFsaWZpZWQtY29uc3RydWN0b3InO1xuICAgIH1cbiAgICByZXR1cm4gVW5xdWFsaWZpZWRDb25zdHJ1Y3Rvcjtcbn0oKSk7XG5leHBvcnRzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IgPSBVbnF1YWxpZmllZENvbnN0cnVjdG9yO1xudmFyIFF1YWxpZmllZENvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1YWxpZmllZENvbnN0cnVjdG9yKHF1YWxpZmllciwgbWVtYmVyLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnF1YWxpZmllciA9IHF1YWxpZmllcjtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3F1YWxpZmllZC1jb25zdHJ1Y3Rvcic7XG4gICAgfVxuICAgIHJldHVybiBRdWFsaWZpZWRDb25zdHJ1Y3Rvcjtcbn0oKSk7XG5leHBvcnRzLlF1YWxpZmllZENvbnN0cnVjdG9yID0gUXVhbGlmaWVkQ29uc3RydWN0b3I7XG52YXIgVW5xdWFsaWZpZWRJZGVudGlmaWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVucXVhbGlmaWVkSWRlbnRpZmllcihpZCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd1bnF1YWxpZmllZC1pZGVudGlmaWVyJztcbiAgICB9XG4gICAgcmV0dXJuIFVucXVhbGlmaWVkSWRlbnRpZmllcjtcbn0oKSk7XG5leHBvcnRzLlVucXVhbGlmaWVkSWRlbnRpZmllciA9IFVucXVhbGlmaWVkSWRlbnRpZmllcjtcbi8qKlxuICogUXVhbGlmaWVkSWRlbnRpZmllclxuICovXG52YXIgUXVhbGlmaWVkSWRlbnRpZmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWFsaWZpZWRJZGVudGlmaWVyKHF1YWxpZmllciwgbWVtYmVyLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnF1YWxpZmllciA9IHF1YWxpZmllcjtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3F1YWxpZmllZC1pZGVudGlmaWVyJztcbiAgICB9XG4gICAgcmV0dXJuIFF1YWxpZmllZElkZW50aWZpZXI7XG59KCkpO1xuZXhwb3J0cy5RdWFsaWZpZWRJZGVudGlmaWVyID0gUXVhbGlmaWVkSWRlbnRpZmllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFTVC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9J1BhcnNlci5kLnRzJyAvPlxudmFyIFBhcnNlciA9IHJlcXVpcmUoXCIuL1BhcnNlclwiKTtcbnZhciBub2RlcyA9IHJlcXVpcmUoXCIuL0FTVFwiKTtcbnZhciBhZnBsID0gcmVxdWlyZShcImFmcGxcIik7XG52YXIganNmbXQgPSByZXF1aXJlKFwianMtYmVhdXRpZnlcIik7XG52YXIgVHlwZVNjcmlwdCA9IHJlcXVpcmUoXCIuL1R5cGVTY3JpcHRcIik7XG52YXIgYWZwbF8xID0gcmVxdWlyZShcImFmcGxcIik7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIG1haW46ICdNYWluJyxcbiAgICBtb2R1bGU6ICdAcXVlbmsvd21sJyxcbn07XG4vKipcbiAqIHBhcnNlIGEgc3RyaW5nIGFzIFdNTCByZXR1cm5pbmcgZWl0aGVyIGFuIGVycm9yIG9yIGFuIEFTVC5cbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIGFzdCkge1xuICAgIGlmIChhc3QgPT09IHZvaWQgMCkgeyBhc3QgPSBub2RlczsgfVxuICAgIFBhcnNlci5wYXJzZXIueXkgPSB7IGFzdDogYXN0IH07XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFmcGxfMS5FaXRoZXIucmlnaHQoUGFyc2VyLnBhcnNlci5wYXJzZShzdHIpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGFmcGxfMS5FaXRoZXIubGVmdChlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBwcmV0dHkgdXAgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbiAoZG9pdCkgeyByZXR1cm4gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gZG9pdCA/IGpzZm10KHMsIHt9KSA6IHM7XG59OyB9O1xuLyoqXG4gKiBjb21waWxlIGEgc3RyaW5nIG9mIFdNTCB0dXJuaW5nIGl0IGludG8gdHlwZXNjcmlwdCBjb2RlLlxuICovXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgb3B0cyA9IGFmcGwudXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGV4cG9ydHMucGFyc2Uoc3JjKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBUeXBlU2NyaXB0LmNvZGUobSwgb3B0cyk7IH0pXG4gICAgICAgIC5tYXAoZXhwb3J0cy5wcmV0dHkob3B0aW9ucy5wcmV0dHkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21waWxlci5qcy5tYXAiLCJcbi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC42LjEtMjAzICovXG5cbi8qXG4gKiBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiAgUGFyc2VyOiB7XG4gKiAgICB5eToge30gICAgIFRoZSBzby1jYWxsZWQgXCJzaGFyZWQgc3RhdGVcIiBvciByYXRoZXIgdGhlICpzb3VyY2UqIG9mIGl0O1xuICogICAgICAgICAgICAgICB0aGUgcmVhbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgcGFzc2VkIGFyb3VuZCB0b1xuICogICAgICAgICAgICAgICB0aGUgcnVsZSBhY3Rpb25zLCBldGMuIGlzIGEgZGVyaXZhdGl2ZS9jb3B5IG9mIHRoaXMgb25lLFxuICogICAgICAgICAgICAgICBub3QgYSBkaXJlY3QgcmVmZXJlbmNlIVxuICogIH1cbiAqXG4gKiAgUGFyc2VyLnByb3RvdHlwZToge1xuICogICAgeXk6IHt9LFxuICogICAgRU9GOiAxLFxuICogICAgVEVSUk9SOiAyLFxuICpcbiAqICAgIHRyYWNlOiBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIC4uLiksXG4gKlxuICogICAgSmlzb25QYXJzZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqXG4gKiAgICBxdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlciBjb2RlIGxhdGVyIG9uOiBwdXQgc3VpdGFibGVcbiAqICAgICAgICAgICAgICAgcXVvdGVzIGFyb3VuZCBsaXRlcmFsIElEcyBpbiBhIGRlc2NyaXB0aW9uIHN0cmluZy5cbiAqXG4gKiAgICBvcmlnaW5hbFF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgIFRoZSBiYXNpYyBxdW90ZU5hbWUgaGFuZGxlciBwcm92aWRlZCBieSBKSVNPTi5cbiAqICAgICAgICAgICAgICAgYGNsZWFudXBBZnRlclBhcnNlKClgIHdpbGwgY2xlYW4gdXAgYW5kIHJlc2V0IGBxdW90ZU5hbWUoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIGRlc2NyaWJlU3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpLFxuICogICAgICAgICAgICAgICBSZXR1cm4gYSBtb3JlLW9yLWxlc3MgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGdpdmVuIHN5bWJvbCwgd2hlblxuICogICAgICAgICAgICAgICBhdmFpbGFibGUsIG9yIHRoZSBzeW1ib2wgaXRzZWxmLCBzZXJ2aW5nIGFzIGl0cyBvd24gJ2Rlc2NyaXB0aW9uJyBmb3IgbGFja1xuICogICAgICAgICAgICAgICBvZiBzb21ldGhpbmcgYmV0dGVyIHRvIHNlcnZlIHVwLlxuICpcbiAqICAgICAgICAgICAgICAgUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbiAqXG4gKiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gKiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAqICAgIG5vbnRlcm1pbmFsczoge2Fzc29jaWF0aXZlIGxpc3Q6IHJ1bGUtbmFtZSA9PT4ge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gcnVsZS1hbHR9fSxcbiAqICAgIHRlcm1pbmFsX2Rlc2NyaXB0aW9uc186IChpZiB0aGVyZSBhcmUgYW55KSB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBkZXNjcmlwdGlvbn0sXG4gKiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBhcnNlcl9fcGVyZm9ybUFjdGlvbih5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5bG9jLCB5eXN0YXRlLCB5eXNwLCB5eXZzdGFjaywgeXlsc3RhY2ssIHl5c3RhY2ssIHl5c3N0YWNrKSxcbiAqXG4gKiAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFuZCBgdGhpc2AgaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlL21lYW5pbmc6XG4gKiAgICAgICAgICAgICAgIC0gYHRoaXNgICAgIDogcmVmZXJlbmNlIHRvIHRoZSBgeXl2YWxgIGludGVybmFsIG9iamVjdCwgd2hpY2ggaGFzIG1lbWJlcnMgKGAkYCBhbmQgYF8kYClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdG9yZS9yZWZlcmVuY2UgdGhlIHJ1bGUgdmFsdWUgYCQkYCBhbmQgbG9jYXRpb24gaW5mbyBgQCRgLlxuICpcbiAqICAgICAgICAgICAgICAgICBPbmUgaW1wb3J0YW50IHRoaW5nIHRvIG5vdGUgYWJvdXQgYHRoaXNgIGEuay5hLiBgeXl2YWxgOiBldmVyeSAqcmVkdWNlKiBhY3Rpb24gZ2V0c1xuICogICAgICAgICAgICAgICAgIHRvIHNlZSB0aGUgc2FtZSBvYmplY3QgdmlhIHRoZSBgdGhpc2AgcmVmZXJlbmNlLCBpLmUuIGlmIHlvdSB3aXNoIHRvIGNhcnJ5IGN1c3RvbVxuICogICAgICAgICAgICAgICAgIGRhdGEgZnJvbSBvbmUgcmVkdWNlIGFjdGlvbiB0aHJvdWdoIHRvIHRoZSBuZXh0IHdpdGhpbiBhIHNpbmdsZSBwYXJzZSBydW4sIHRoZW4geW91XG4gKiAgICAgICAgICAgICAgICAgbWF5IGdldCBuYXN0eSBhbmQgdXNlIGB5eXZhbGAgYS5rLmEuIGB0aGlzYCBmb3Igc3RvcmluZyB5b3Ugb3duIHNlbWktcGVybWFuZW50IGRhdGEuXG4gKlxuICogICAgICAgICAgICAgICAgIGB0aGlzLnl5YCBpcyBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGB5eWAgc2hhcmVkIHN0YXRlIG9iamVjdC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgYCVwYXJzZS1wYXJhbWAtc3BlY2lmaWVkIGFkZGl0aW9uYWwgYHBhcnNlKClgIGFyZ3VtZW50cyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBgeXlgXG4gKiAgICAgICAgICAgICAgICAgb2JqZWN0IGF0IGBwYXJzZSgpYCBzdGFydCBhbmQgYXJlIHRoZXJlZm9yZSBhdmFpbGFibGUgdG8gdGhlIGFjdGlvbiBjb2RlIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICBzYW1lIG5hbWVkIGB5eS54eHh4YCBhdHRyaWJ1dGVzICh3aGVyZSBgeHh4eGAgcmVwcmVzZW50cyBhIGlkZW50aWZpZXIgbmFtZSBmcm9tXG4gKiAgICAgICAgICAgICAgICAgdGhlICVwYXJzZS1wYXJhbWAgbGlzdC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5dGV4dGAgIDogcmVmZXJlbmNlIHRvIHRoZSBsZXhlciB2YWx1ZSB3aGljaCBiZWxvbmdzIHRvIHRoZSBsYXN0IGxleGVyIHRva2VuIHVzZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBtYXRjaCB0aGlzIHJ1bGUuIFRoaXMgaXMgKm5vdCogdGhlIGxvb2stYWhlYWQgdG9rZW4sIGJ1dCB0aGUgbGFzdCB0b2tlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQncyBhY3R1YWxseSBwYXJ0IG9mIHRoaXMgcnVsZS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgRm9ybXVsYXRlZCBhbm90aGVyIHdheSwgYHl5dGV4dGAgaXMgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbW1lZGlhdGVseSBwcmVjZWVkaW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGN1cnJlbnQgbG9vay1haGVhZCB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBDYXZlYXRzIGFwcGx5IGZvciBydWxlcyB3aGljaCBkb24ndCByZXF1aXJlIGxvb2stYWhlYWQsIHN1Y2ggYXMgZXBzaWxvbiBydWxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGVuZ2AgIDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsZW5nIHZhbHVlLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlsaW5lbm9gOiBkaXR0byBhcyBgeXl0ZXh0YCwgb25seSBub3cgZm9yIHRoZSBsZXhlci55eWxpbmVubyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bG9jYCAgIDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsbG9jIGxleGVyIHRva2VuIGxvY2F0aW9uIGluZm8uXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGVudHJ5IG1heSBiZSBOVUxML1VOREVGSU5FRCBpbnN0ZWFkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBhbiBlbXB0eSBvYmplY3Qgd2hlbiBubyBzdWl0YWJsZSBsb2NhdGlvbiBpbmZvIGNhbiBiZSBwcm92aWRlZC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3RhdGVgIDogdGhlIGN1cnJlbnQgcGFyc2VyIHN0YXRlIG51bWJlciwgdXNlZCBpbnRlcm5hbGx5IGZvciBkaXNwYXRjaGluZyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGluZyB0aGUgYWN0aW9uIGNvZGUgY2h1bmsgbWF0Y2hpbmcgdGhlIHJ1bGUgY3VycmVudGx5IGJlaW5nIHJlZHVjZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXNwYCAgICA6IHRoZSBjdXJyZW50IHN0YXRlIHN0YWNrIHBvc2l0aW9uIChhLmsuYS4gJ3N0YWNrIHBvaW50ZXInKVxuICpcbiAqICAgICAgICAgICAgICAgICBUaGlzIG9uZSBjb21lcyBpbiBoYW5keSB3aGVuIHlvdSBhcmUgZ29pbmcgdG8gZG8gYWR2YW5jZWQgdGhpbmdzIHRvIHRoZSBwYXJzZXJcbiAqICAgICAgICAgICAgICAgICBzdGFja3MsIGFsbCBvZiB3aGljaCBhcmUgYWNjZXNzaWJsZSBmcm9tIHlvdXIgYWN0aW9uIGNvZGUgKHNlZSB0aGUgbmV4dCBlbnRyaWVzIGJlbG93KS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgQWxzbyBub3RlIHRoYXQgeW91IGNhbiBhY2Nlc3MgdGhpcyBhbmQgb3RoZXIgc3RhY2sgaW5kZXggdmFsdWVzIHVzaW5nIHRoZSBuZXcgZG91YmxlLWhhc2hcbiAqICAgICAgICAgICAgICAgICBzeW50YXgsIGkuZS4gYCMjJCA9PT0gIyMwID09PSB5eXNwYCwgd2hpbGUgYCMjMWAgaXMgdGhlIHN0YWNrIGluZGV4IGZvciBhbGwgdGhpbmdzXG4gKiAgICAgICAgICAgICAgICAgcmVsYXRlZCB0byB0aGUgZmlyc3QgcnVsZSB0ZXJtLCBqdXN0IGxpa2UgeW91IGhhdmUgYCQxYCwgYEAxYCBhbmQgYCMxYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGlzIG1hZGUgYXZhaWxhYmxlIHRvIHdyaXRlIHZlcnkgYWR2YW5jZWQgZ3JhbW1hciBhY3Rpb24gcnVsZXMsIGUuZy4gd2hlbiB5b3Ugd2FudFxuICogICAgICAgICAgICAgICAgIHRvIGludmVzdGlnYXRlIHRoZSBwYXJzZSBzdGF0ZSBzdGFjayBpbiB5b3VyIGFjdGlvbiBjb2RlLCB3aGljaCB3b3VsZCwgZm9yIGV4YW1wbGUsXG4gKiAgICAgICAgICAgICAgICAgYmUgcmVsZXZhbnQgd2hlbiB5b3Ugd2lzaCB0byBpbXBsZW1lbnQgZXJyb3IgZGlhZ25vc3RpY3MgYW5kIHJlcG9ydGluZyBzY2hlbWVzIHNpbWlsYXJcbiAqICAgICAgICAgICAgICAgICB0byB0aGUgd29yayBkZXNjcmliZWQgaGVyZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgKyBQb3R0aWVyLCBGLiwgMjAxNi4gUmVhY2hhYmlsaXR5IGFuZCBlcnJvciBkaWFnbm9zaXMgaW4gTFIoMSkgYXV0b21hdGEuXG4gKiAgICAgICAgICAgICAgICAgICBJbiBKb3VybsOpZXMgRnJhbmNvcGhvbmVzIGRlcyBMYW5ndWFnZXMgQXBwbGljYXRpZnMuXG4gKlxuICogICAgICAgICAgICAgICAgICsgSmVmZmVyeSwgQy5MLiwgMjAwMy4gR2VuZXJhdGluZyBMUiBzeW50YXggZXJyb3IgbWVzc2FnZXMgZnJvbSBleGFtcGxlcy5cbiAqICAgICAgICAgICAgICAgICAgIEFDTSBUcmFuc2FjdGlvbnMgb24gUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzIGFuZCBTeXN0ZW1zIChUT1BMQVMpLCAyNSg1KSwgcHAuNjMx4oCTNjQwLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlydWxlbGVuZ3RoYDogdGhlIGN1cnJlbnQgcnVsZSdzIHRlcm0gY291bnQsIGkuZS4gdGhlIG51bWJlciBvZiBlbnRyaWVzIG9jY3VwaWVkIG9uIHRoZSBzdGFjay5cbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXZzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHZhbHVlIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGUgYCQxYCBldGMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bHN0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgdG9rZW4gbG9jYXRpb24gc3RhY2suIEFsc28gYWNjZXNzZWQgdmlhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGBAMWAgZXRjLiBjb25zdHJ1Y3RzLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXQVJOSU5HOiBzaW5jZSBqaXNvbiAwLjQuMTgtMTg2IHRoaXMgYXJyYXkgTUFZIGNvbnRhaW4gc2xvdHMgd2hpY2ggYXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVU5ERUZJTkVEIHJhdGhlciB0aGFuIGFuIGVtcHR5IChsb2NhdGlvbikgb2JqZWN0LCB3aGVuIHRoZSBsZXhlci9wYXJzZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gY29kZSBkaWQgbm90IHByb3ZpZGUgYSBzdWl0YWJsZSBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGVuIHN1Y2ggYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Qgd2FzIGZpbGxlZCFcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3RhY2tgIDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgdG9rZW4gaWQgc3RhY2suIEFsc28gYWNjZXNzZWQgdmlhIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAjMWAgZXRjLiBjb25zdHJ1Y3RzLlxuICpcbiAqICAgICAgICAgICAgICAgICBOb3RlOiB0aGlzIGlzIGEgYml0IG9mIGEgKip3aGl0ZSBsaWUqKiBhcyB3ZSBjYW4gc3RhdGljYWxseSBkZWNvZGUgYW55IGAjbmAgcmVmZXJlbmNlIHRvXG4gKiAgICAgICAgICAgICAgICAgaXRzIG51bWVyaWMgdG9rZW4gaWQgdmFsdWUsIGhlbmNlIHRoYXQgY29kZSB3b3VsZG4ndCBuZWVkIHRoZSBgeXlzdGFja2AgYnV0ICp5b3UqIG1pZ2h0XG4gKiAgICAgICAgICAgICAgICAgd2FudCBhY2Nlc3MgdGhpcyBhcnJheSBmb3IgeW91ciBvd24gcHVycG9zZXMsIHN1Y2ggYXMgZXJyb3IgYW5hbHlzaXMgYXMgbWVudGlvbmVkIGFib3ZlIVxuICpcbiAqICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBzdGFjayBzdG9yZXMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgKnRva2VucyosIHRoYXQgaXMgdGhlIHNlcXVlbmNlIG9mXG4gKiAgICAgICAgICAgICAgICAgYWxyZWFkeSBwYXJzZWQ9cmVkdWNlZCAqbm9udGVybWluYWxzKiAodG9rZW5zIHJlcHJlc2VudGluZyBydWxlcykgYW5kICp0ZXJtaW5hbHMqXG4gKiAgICAgICAgICAgICAgICAgKGxleGVyIHRva2VucyAqc2hpZnRlZCogb250byB0aGUgc3RhY2sgdW50aWwgdGhlIHJ1bGUgdGhleSBiZWxvbmcgdG8gaXMgZm91bmQgYW5kXG4gKiAgICAgICAgICAgICAgICAgKnJlZHVjZWQqLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzc3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciBzdGF0ZSBzdGFjay4gVGhpcyBvbmUgY2FycmllcyB0aGUgaW50ZXJuYWwgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKnN0YXRlcyogc3VjaCBhcyB0aGUgb25lIGluIGB5eXN0YXRlYCwgd2hpY2ggYXJlIHVzZWQgdG8gcmVwcmVzZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGluIHRoZSAqcGFyc2UgdGFibGUqLiAqVmVyeSogKmludGVybmFsKiBzdHVmZixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGF0IGNhbiBJIHNheT8gSWYgeW91IGFjY2VzcyB0aGlzIG9uZSwgeW91J3JlIGNsZWFybHkgZG9pbmcgd2lja2VkIHRoaW5nc1xuICpcbiAqICAgICAgICAgICAgICAgLSBgLi4uYCAgICAgOiB0aGUgZXh0cmEgYXJndW1lbnRzIHlvdSBzcGVjaWZpZWQgaW4gdGhlIGAlcGFyc2UtcGFyYW1gIHN0YXRlbWVudCBpbiB5b3VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbW1hciBkZWZpbml0aW9uIGZpbGUuXG4gKlxuICogICAgdGFibGU6IFsuLi5dLFxuICogICAgICAgICAgICAgICBTdGF0ZSB0cmFuc2l0aW9uIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgICAgICAgICAgICAgIGluZGV4IGxldmVscyBhcmU6XG4gKiAgICAgICAgICAgICAgIC0gYHN0YXRlYCAgLS0+IGhhc2ggdGFibGVcbiAqICAgICAgICAgICAgICAgLSBgc3ltYm9sYCAtLT4gYWN0aW9uIChudW1iZXIgb3IgYXJyYXkpXG4gKlxuICogICAgICAgICAgICAgICAgIElmIHRoZSBgYWN0aW9uYCBpcyBhbiBhcnJheSwgdGhlc2UgYXJlIHRoZSBlbGVtZW50cycgbWVhbmluZzpcbiAqICAgICAgICAgICAgICAgICAtIGluZGV4IFswXTogMSA9IHNoaWZ0LCAyID0gcmVkdWNlLCAzID0gYWNjZXB0XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMV06IEdPVE8gYHN0YXRlYFxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYSBudW1iZXIsIGl0IGlzIHRoZSBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gKlxuICogICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICB5eUVycm9yOiBmdW5jdGlvbihzdHIsIC4uLiksXG4gKiAgICB5eVJlY292ZXJpbmc6IGZ1bmN0aW9uKCksXG4gKiAgICB5eUVyck9rOiBmdW5jdGlvbigpLFxuICogICAgeXlDbGVhckluOiBmdW5jdGlvbigpLFxuICpcbiAqICAgIGNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvOiBmdW5jdGlvbihlcnJvcl9tZXNzYWdlLCBleGNlcHRpb25fb2JqZWN0LCBleHBlY3RlZF90b2tlbl9zZXQsIGlzX3JlY292ZXJhYmxlKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2VzIGEgbmV3IGVycm9ySW5mbyAnaGFzaCBvYmplY3QnIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBgcGFyc2VFcnJvcigpYC5cbiAqICAgICAgICAgICAgICAgU2VlIGl0J3MgdXNlIGluIHRoaXMgcGFyc2VyIGtlcm5lbCBpbiBtYW55IHBsYWNlczsgZXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICB2YXIgaW5mb09iaiA9IHBhcnNlci5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnZmFpbCEnLCBudWxsLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlKSwgdHJ1ZSk7XG4gKiAgICAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gcGFyc2VyLnBhcnNlRXJyb3IoaW5mb09iai5lcnJTdHIsIGluZm9PYmosIHBhcnNlci5KaXNvblBhcnNlckVycm9yKTtcbiAqXG4gKiAgICBvcmlnaW5hbFBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgYHBhcnNlRXJyb3JgIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcGFyc2VFcnJvcigpYCB0byByZWZlcmVuY2UgdGhpcyBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhdCB0aGUgZW5kIG9mIHRoZSBgcGFyc2UoKWAuXG4gKlxuICogICAgb3B0aW9uczogeyAuLi4gcGFyc2VyICVvcHRpb25zIC4uLiB9LFxuICpcbiAqICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dFssIGFyZ3MuLi5dKSxcbiAqICAgICAgICAgICAgICAgUGFyc2UgdGhlIGdpdmVuIGBpbnB1dGAgYW5kIHJldHVybiB0aGUgcGFyc2VkIHZhbHVlIChvciBgdHJ1ZWAgd2hlbiBub25lIHdhcyBwcm92aWRlZCBieVxuICogICAgICAgICAgICAgICB0aGUgcm9vdCBhY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHBhcnNlciBpcyBhY3RpbmcgYXMgYSAqbWF0Y2hlciopLlxuICogICAgICAgICAgICAgICBZb3UgTUFZIHVzZSB0aGUgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyBhcyBwZXIgYCVwYXJzZS1wYXJhbWAgc3BlYyBvZiB0aGlzIGdyYW1tYXI6XG4gKiAgICAgICAgICAgICAgIHRoZXNlIGV4dHJhIGBhcmdzLi4uYCBhcmUgYWRkZWQgdmVyYmF0aW0gdG8gdGhlIGB5eWAgb2JqZWN0IHJlZmVyZW5jZSBhcyBtZW1iZXIgdmFyaWFibGVzLlxuICpcbiAqICAgICAgICAgICAgICAgV0FSTklORzpcbiAqICAgICAgICAgICAgICAgUGFyc2VyJ3MgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyAodmlhIGAlcGFyc2UtcGFyYW1gKSBNQVkgY29uZmxpY3Qgd2l0aFxuICogICAgICAgICAgICAgICBhbnkgYXR0cmlidXRlcyBhbHJlYWR5IGFkZGVkIHRvIGB5eWAgYnkgdGhlIGppc29uIHJ1bi10aW1lO1xuICogICAgICAgICAgICAgICB3aGVuIHN1Y2ggYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgYW4gZXhjZXB0aW9uIGlzIHRocm93biB0byBwcmV2ZW50IHRoZSBnZW5lcmF0ZWQgcnVuLXRpbWVcbiAqICAgICAgICAgICAgICAgZnJvbSBzaWxlbnRseSBhY2NlcHRpbmcgdGhpcyBjb25mdXNpbmcgYW5kIHBvdGVudGlhbGx5IGhhemFyZG91cyBzaXR1YXRpb24hXG4gKlxuICogICAgICAgICAgICAgICBUaGUgbGV4ZXIgTUFZIGFkZCBpdHMgb3duIHNldCBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgKHZpYSB0aGUgYCVwYXJzZS1wYXJhbWAgbGluZSBpblxuICogICAgICAgICAgICAgICB0aGUgbGV4ZXIgc2VjdGlvbiBvZiB0aGUgZ3JhbW1hciBzcGVjKTogdGhlc2Ugd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgYHl5YCBzaGFyZWQgc3RhdGVcbiAqICAgICAgICAgICAgICAgb2JqZWN0IGFuZCBhbnkgY29sbGlzaW9uIHdpdGggdGhvc2Ugd2lsbCBiZSByZXBvcnRlZCBieSB0aGUgbGV4ZXIgdmlhIGEgdGhyb3duIGV4Y2VwdGlvbi5cbiAqXG4gKiAgICBjbGVhbnVwQWZ0ZXJQYXJzZTogZnVuY3Rpb24ocmVzdWx0VmFsdWUsIGludm9rZV9wb3N0X21ldGhvZHMsIGRvX25vdF9udWtlX2Vycm9yaW5mb3MpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgIGNhbGwsIHVubGVzcyBhbiBleGNlcHRpb24gd2FzIHRocm93blxuICogICAgICAgICAgICAgICBhbmQgYCVvcHRpb25zIG5vLXRyeS1jYXRjaGAgaGFzIGJlZW4gZGVmaW5lZCBmb3IgdGhpcyBncmFtbWFyOiBpbiB0aGF0IGNhc2UgdGhpcyBoZWxwZXIgTUFZXG4gKiAgICAgICAgICAgICAgIGJlIGludm9rZWQgYnkgY2FsbGluZyB1c2VyIGNvZGUgdG8gZW5zdXJlIHRoZSBgcG9zdF9wYXJzZWAgY2FsbGJhY2tzIGFyZSBpbnZva2VkIGFuZFxuICogICAgICAgICAgICAgICB0aGUgaW50ZXJuYWwgcGFyc2VyIGdldHMgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0ZWQgdW5kZXIgdGhlc2UgcGFydGljdWxhciBjaXJjdW1zdGFuY2VzLlxuICpcbiAqICAgIHl5TWVyZ2VMb2NhdGlvbkluZm86IGZ1bmN0aW9uKGZpcnN0X2luZGV4LCBsYXN0X2luZGV4LCBmaXJzdF95eWxsb2MsIGxhc3RfeXlsbG9jLCBkb250X2xvb2tfYmFjayksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBBUEkgY2FuIGJlIGludm9rZWQgdG8gY2FsY3VsYXRlIGEgc3Bhbm5pbmcgYHl5bGxvY2AgbG9jYXRpb24gaW5mbyBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICBOb3RlOiAlZXBzaWxvbiBydWxlcyBNQVkgc3BlY2lmeSBubyBgZmlyc3RfaW5kZXhgIGFuZCBgZmlyc3RfeXlsbG9jYCwgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIHdpbGwgYXR0ZW1wdCB0byBvYnRhaW4gYSBzdWl0YWJsZSBsb2NhdGlvbiBtYXJrZXIgYnkgaW5zcGVjdGluZyB0aGUgbG9jYXRpb24gc3RhY2tcbiAqICAgICAgICAgICAgICAgYmFja3dhcmRzLlxuICpcbiAqICAgICAgICAgICAgICAgRm9yIG1vcmUgaW5mbyBzZWUgdGhlIGRvY3VtZW50YXRpb24gY29tbWVudCBmdXJ0aGVyIGJlbG93LCBpbW1lZGlhdGVseSBhYm92ZSB0aGlzIGZ1bmN0aW9uJ3NcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogICAgbGV4ZXI6IHtcbiAqICAgICAgICB5eTogey4uLn0sICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgYHl5YCBvbmNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQgdmlhIGEgY2FsbCB0byB0aGUgYC5zZXRJbnB1dChpbnB1dCwgeXkpYCBsZXhlciBBUEkuXG4gKiAgICAgICAgRU9GOiAxLFxuICogICAgICAgIEVSUk9SOiAyLFxuICogICAgICAgIEppc29uTGV4ZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQsIFt5eV0pLFxuICogICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICogICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICogICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgcmVqZWN0OiBmdW5jdGlvbigpLFxuICogICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24obiksXG4gKiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24obiksXG4gKiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICogICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4LCAuLi4pLFxuICogICAgICAgIG5leHQ6IGZ1bmN0aW9uKC4uLiksXG4gKiAgICAgICAgbGV4OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICogICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICogICAgICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbigpLFxuICogICAgICAgIGNsZWFudXBBZnRlckxleDogZnVuY3Rpb24oKVxuICpcbiAqICAgICAgICBvcHRpb25zOiB7IC4uLiBsZXhlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQsIC4uLiksXG4gKiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICogICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICogICAgfVxuICogIH1cbiAqXG4gKlxuICogIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAqICAgIGZpcnN0X2xpbmU6IG4sXG4gKiAgICBsYXN0X2xpbmU6IG4sXG4gKiAgICBmaXJzdF9jb2x1bW46IG4sXG4gKiAgICBsYXN0X2NvbHVtbjogbixcbiAqICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXVxuICogICAgICAgICAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCB6ZXJvLWJhc2VkKVxuICogIH1cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZFxuICogcGFyc2VyIGVycm9yczpcbiAqXG4gKiAge1xuICogICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gKiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICogICAgdG9rZW5faWQ6ICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4gbnVtZXJpYyBJRCwgaWYgYW55KVxuICogICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAqICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICogIH1cbiAqXG4gKiBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBhZGRpdGlvbmFsIG1lbWJlcnM6XG4gKlxuICogIHtcbiAqICAgIGV4cGVjdGVkOiAgICAoYXJyYXkgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucztcbiAqICAgICAgICAgICAgICAgICAgbWF5IGJlIFVOREVGSU5FRCB3aGVuIHdlIGNhbm5vdCBlYXNpbHkgcHJvZHVjZSBzdWNoIGEgc2V0KVxuICogICAgc3RhdGU6ICAgICAgIChpbnRlZ2VyIChvciBhcnJheSB3aGVuIHRoZSB0YWJsZSBpbmNsdWRlcyBncmFtbWFyIGNvbGxpc2lvbnMpO1xuICogICAgICAgICAgICAgICAgICByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBwYXJzZXIga2VybmVsLlxuICogICAgICAgICAgICAgICAgICBjYW4sIGZvciBleGFtcGxlLCBiZSB1c2VkIHRvIHBhc3MgdG8gdGhlIGBjb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldCgpYFxuICogICAgICAgICAgICAgICAgICBBUEkgdG8gb2J0YWluIHRoZSBleHBlY3RlZCB0b2tlbiBzZXQpXG4gKiAgICBhY3Rpb246ICAgICAgKGludGVnZXI7IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgaW50ZXJuYWwgYWN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQpXG4gKiAgICBuZXdfc3RhdGU6ICAgKGludGVnZXI7IHJlcHJlc2VudHMgdGhlIG5leHQvcGxhbm5lZCBpbnRlcm5hbCBzdGF0ZSwgb25jZSB0aGUgY3VycmVudFxuICogICAgICAgICAgICAgICAgICBhY3Rpb24gaGFzIGV4ZWN1dGVkKVxuICogICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBNQVkgaGF2ZSBhbiBlcnJvciByZWNvdmVyeSBydWxlXG4gKiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICogICAgc3RhdGVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgc3RhdGUgc3RhY2s7IHRoaXMgY2FuIGJlIHVzZWQsXG4gKiAgICAgICAgICAgICAgICAgIGZvciBpbnN0YW5jZSwgZm9yIGFkdmFuY2VkIGVycm9yIGFuYWx5c2lzIGFuZCByZXBvcnRpbmcpXG4gKiAgICB2YWx1ZV9zdGFjazogKGFycmF5OiB0aGUgY3VycmVudCBwYXJzZXIgTEFMUi9MUiBpbnRlcm5hbCBgJCRgIHZhbHVlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbG9jYXRpb25fc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgbG9jYXRpb24gc3RhY2s7IHRoaXMgY2FuIGJlIHVzZWQsXG4gKiAgICAgICAgICAgICAgICAgIGZvciBpbnN0YW5jZSwgZm9yIGFkdmFuY2VkIGVycm9yIGFuYWx5c2lzIGFuZCByZXBvcnRpbmcpXG4gKiAgICB5eTogICAgICAgICAgKG9iamVjdDogdGhlIGN1cnJlbnQgcGFyc2VyIGludGVybmFsIFwic2hhcmVkIHN0YXRlXCIgYHl5YFxuICogICAgICAgICAgICAgICAgICBhcyBpcyBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcnVsZSBhY3Rpb25zOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UgdXNlZCBieSB0aGUgcGFyc2VyKVxuICogICAgcGFyc2VyOiAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlKVxuICogIH1cbiAqXG4gKiB3aGlsZSBgdGhpc2Agd2lsbCByZWZlcmVuY2UgdGhlIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBsZXhlcjogICAgICAgKHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBsZXhlciBpbnN0YW5jZSB3aGljaCByZXBvcnRlZCB0aGUgZXJyb3IpXG4gKiAgfVxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIHBhcnNlciBkdWUgdG8gYSAqKkphdmFTY3JpcHQgZXhjZXB0aW9uKiogYmVpbmcgZmlyZWRcbiAqIGZyb20gZWl0aGVyIHRoZSBwYXJzZXIgb3IgbGV4ZXIsIGB0aGlzYCB3aWxsIHN0aWxsIHJlZmVyZW5jZSB0aGUgcmVsYXRlZCAqcGFyc2VyKlxuICogaW5zdGFuY2UsIHdoaWxlIHRoZXNlIGFkZGl0aW9uYWwgYGhhc2hgIGZpZWxkcyB3aWxsIGFsc28gYmUgcHJvdmlkZWQ6XG4gKlxuICogIHtcbiAqICAgIGV4Y2VwdGlvbjogICAocmVmZXJlbmNlIHRvIHRoZSBleGNlcHRpb24gdGhyb3duKVxuICogIH1cbiAqXG4gKiBQbGVhc2UgZG8gbm90ZSB0aGF0IGluIHRoZSBsYXR0ZXIgc2l0dWF0aW9uLCB0aGUgYGV4cGVjdGVkYCBmaWVsZCB3aWxsIGJlIG9taXR0ZWQgYXNcbiAqIHRoaXMgdHlwZSBvZiBmYWlsdXJlIGlzIGFzc3VtZWQgbm90IHRvIGJlIGR1ZSB0byAqcGFyc2UgZXJyb3JzKiBidXQgcmF0aGVyIGR1ZSB0byB1c2VyXG4gKiBhY3Rpb24gY29kZSBpbiBlaXRoZXIgcGFyc2VyIG9yIGxleGVyIGZhaWxpbmcgdW5leHBlY3RlZGx5LlxuICpcbiAqIC0tLVxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBwYXJzZXIgb3B0aW9ucyBieSBzZXR0aW5nIC8gbW9kaWZ5aW5nIHRoZSBgLnl5YCBvYmplY3Qgb2YgeW91ciBQYXJzZXIgaW5zdGFuY2UuXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggYXJlIGdsb2JhbCBmb3IgYWxsIHBhcnNlciBpbnN0YW5jZXNcbiAqXG4gKiAgUGFyc2VyLnByZV9wYXJzZTogZnVuY3Rpb24oeXkpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHlvdSBjYW4gc3BlY2lmeSBhIHByZV9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLlxuICogIFBhcnNlci5wb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwb3N0X3BhcnNlKCkgZnVuY3Rpb24gaW4gdGhlIGNodW5rIGZvbGxvd2luZ1xuICogICAgICAgICAgICAgICAgIHRoZSBncmFtbWFyLCBpLmUuIGFmdGVyIHRoZSBsYXN0IGAlJWAuIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSxcbiAqICAgICAgICAgICAgICAgICB0aGUgcGFyc2VyIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCBgcmV0dmFsYC5cbiAqXG4gKiAjIyMgb3B0aW9ucyB3aGljaCBjYW4gYmUgc2V0IHVwIHBlciBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiAgeXk6IHtcbiAqICAgICAgcHJlX3BhcnNlOiAgZnVuY3Rpb24oeXkpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBwYXJzZSBjeWNsZSBzdGFydHMgKGFuZCBiZWZvcmUgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBvZiBgbGV4KClgKSBidXQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICBgcGFyc2VyLnByZV9wYXJzZSgpYCkuXG4gKiAgICAgIHBvc3RfcGFyc2U6IGZ1bmN0aW9uKHl5LCByZXR2YWwsIHBhcnNlSW5mbykgeyByZXR1cm4gcmV0dmFsOyB9XG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgd2hlbiB0aGUgcGFyc2UgdGVybWluYXRlcyBkdWUgdG8gc3VjY2VzcyAoJ2FjY2VwdCcpXG4gKiAgICAgICAgICAgICAgICAgb3IgZmFpbHVyZSAoZXZlbiB3aGVuIGV4Y2VwdGlvbnMgYXJlIHRocm93bikuXG4gKiAgICAgICAgICAgICAgICAgYHJldHZhbGAgY29udGFpbnMgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBwcm9kdWNlZCBieSBgUGFyc2VyLnBhcnNlKClgO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm4gdmFsdWUgYnkgcmV0dXJuaW5nIGFub3RoZXIuXG4gKiAgICAgICAgICAgICAgICAgV2hlbiBpdCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlLCB0aGUgcGFyc2VyIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgLlxuICogICAgICAgICAgICAgICAgIFRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYHBhcnNlci5wb3N0X3BhcnNlKClgLlxuICpcbiAqICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcylcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCBmdW5jdGlvbi5cbiAqICAgICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBxdW90ZU5hbWVgIGZ1bmN0aW9uLlxuICogIH1cbiAqXG4gKiAgcGFyc2VyLmxleGVyLm9wdGlvbnM6IHtcbiAqICAgICAgcHJlX2xleDogIGZ1bmN0aW9uKClcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCBiZWZvcmUgdGhlIGxleGVyIGlzIGludm9rZWQgdG8gcHJvZHVjZSBhbm90aGVyIHRva2VuLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqICAgICAgcG9zdF9sZXg6IGZ1bmN0aW9uKHRva2VuKSB7IHJldHVybiB0b2tlbjsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIGxleGVyIGhhcyBwcm9kdWNlZCBhIHRva2VuIGB0b2tlbmA7XG4gKiAgICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiBjYW4gb3ZlcnJpZGUgdGhlIHJldHVybmVkIHRva2VuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSAodHJ1dGh5KSB2YWx1ZSwgdGhlIGxleGVyIHdpbGwgcmV0dXJuXG4gKiAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbmFsIGB0b2tlbmAuXG4gKiAgICAgICAgICAgICAgICAgYHRoaXNgIHJlZmVycyB0byB0aGUgTGV4ZXIgb2JqZWN0LlxuICpcbiAqICAgICAgcmFuZ2VzOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIuXG4gKiAgICAgIGZsZXg6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZFxuICogICAgICAgICAgICAgICAgIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoLlxuICogICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBpbnZva2VkO1xuICogICAgICAgICAgICAgICAgIHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUuXG4gKiAgICAgIHhyZWdleHA6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciBydWxlIHJlZ2V4ZXMgYXJlIFwiZXh0ZW5kZWQgcmVnZXggZm9ybWF0XCIgcmVxdWlyaW5nIHRoZVxuICogICAgICAgICAgICAgICAgIGBYUmVnRXhwYCBsaWJyYXJ5LiBXaGVuIHRoaXMgYCVvcHRpb25gIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQgYXQgY29tcGlsZSB0aW1lLCBhbGwgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICBydWxlIHJlZ2V4ZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gYXMgc3RhbmRhcmQgSmF2YVNjcmlwdCBSZWdFeHAgZXhwcmVzc2lvbnMuXG4gKiAgfVxuICovXG5cbiAgICAgICAgXG4gICAgXG4gICAgICAgICAgICB2YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcblxuLy8gU2VlIGFsc286XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzODIxMDcvd2hhdHMtYS1nb29kLXdheS10by1leHRlbmQtZXJyb3ItaW4tamF2YXNjcmlwdC8jMzU4ODE1MDhcbi8vIGJ1dCB3ZSBrZWVwIHRoZSBwcm90b3R5cGUuY29uc3RydWN0b3IgYW5kIHByb3RvdHlwZS5uYW1lIGFzc2lnbm1lbnQgbGluZXMgdG9vIGZvciBjb21wYXRpYmlsaXR5XG4vLyB3aXRoIHVzZXJsYW5kIGNvZGUgd2hpY2ggbWlnaHQgYWNjZXNzIHRoZSBkZXJpdmVkIGNsYXNzIGluIGEgJ2NsYXNzaWMnIHdheS5cbmZ1bmN0aW9uIEppc29uUGFyc2VyRXJyb3IobXNnLCBoYXNoKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogJ0ppc29uUGFyc2VyRXJyb3InXG4gICAgfSk7XG5cbiAgICBpZiAobXNnID09IG51bGwpIG1zZyA9ICc/Pz8nO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBtc2dcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzaCA9IGhhc2g7XG5cbiAgICB2YXIgc3RhY2t0cmFjZTtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmV4Y2VwdGlvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBleDIgPSBoYXNoLmV4Y2VwdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXgyLm1lc3NhZ2UgfHwgbXNnO1xuICAgICAgICBzdGFja3RyYWNlID0gZXgyLnN0YWNrO1xuICAgIH1cbiAgICBpZiAoIXN0YWNrdHJhY2UpIHtcbiAgICAgICAgaWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSB7ICAgICAgICAvLyBWOC9DaHJvbWUgZW5naW5lXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrdHJhY2UgPSAobmV3IEVycm9yKG1zZykpLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFja3RyYWNlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdGFja3RyYWNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG59IGVsc2Uge1xuICAgIEppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xufVxuSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKaXNvblBhcnNlckVycm9yO1xuSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdKaXNvblBhcnNlckVycm9yJztcblxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgcHJvZHVjdGlvbnNbXSB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBicChzKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgICAgIHZhciBwID0gcy5wb3A7XG4gICAgICAgICAgICB2YXIgciA9IHMucnVsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBydi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcFtpXSxcbiAgICAgICAgICAgICAgICAgICAgcltpXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgXG5cblxuICAgICAgICAvLyBoZWxwZXI6IHJlY29uc3RydWN0IHRoZSBkZWZhdWx0QWN0aW9uc1tdIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJkYShzKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSB7fTtcbiAgICAgICAgICAgIHZhciBkID0gcy5pZHg7XG4gICAgICAgICAgICB2YXIgZyA9IHMuZ290bztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGRbaV07XG4gICAgICAgICAgICAgICAgcnZbal0gPSBnW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgXG5cblxuICAgICAgICAvLyBoZWxwZXI6IHJlY29uc3RydWN0IHRoZSAnZ290bycgdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYnQocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICB2YXIgZCA9IHMubGVuO1xuICAgICAgICAgICAgdmFyIHkgPSBzLnN5bWJvbDtcbiAgICAgICAgICAgIHZhciB0ID0gcy50eXBlO1xuICAgICAgICAgICAgdmFyIGEgPSBzLnN0YXRlO1xuICAgICAgICAgICAgdmFyIG0gPSBzLm1vZGU7XG4gICAgICAgICAgICB2YXIgZyA9IHMuZ290bztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGRbaV07XG4gICAgICAgICAgICAgICAgdmFyIHEgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeiA9IHkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcVt6XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcVt6XSA9IGEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlID09PSAxOiBhY2NlcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydi5wdXNoKHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgXG5cblxuICAgICAgICAvLyBoZWxwZXI6IHJ1bmxlbmd0aCBlbmNvZGluZyB3aXRoIGluY3JlbWVudCBzdGVwOiBjb2RlLCBsZW5ndGg6IHN0ZXAgKGRlZmF1bHQgc3RlcCA9IDApXG4gICAgICAgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGFuIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIHMoYywgbCwgYSkge1xuICAgICAgICAgICAgYSA9IGEgfHwgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGMgKz0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlbHBlcjogZHVwbGljYXRlIHNlcXVlbmNlIGZyb20gKnJlbGF0aXZlKiBvZmZzZXQgYW5kIGxlbmd0aC5cbiAgICAgICAgLy8gYHRoaXNgIHJlZmVyZW5jZXMgYW4gYXJyYXlcbiAgICAgICAgZnVuY3Rpb24gYyhpLCBsKSB7XG4gICAgICAgICAgICBpID0gdGhpcy5sZW5ndGggLSBpO1xuICAgICAgICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXI6IHVucGFjayBhbiBhcnJheSB1c2luZyBoZWxwZXJzIGFuZCBkYXRhLCBhbGwgcGFzc2VkIGluIGFuIGFycmF5IGFyZ3VtZW50ICdhJy5cbiAgICAgICAgZnVuY3Rpb24gdShhKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGFbaV07XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBlbnRyeSBhIGhlbHBlciBmdW5jdGlvbj9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBlLmFwcGx5KHJ2LCBhW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydi5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG52YXIgcGFyc2VyID0ge1xuICAgIC8vIENvZGUgR2VuZXJhdG9yIEluZm9ybWF0aW9uIFJlcG9ydFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gT3B0aW9uczpcbiAgICAvL1xuICAgIC8vICAgZGVmYXVsdCBhY3Rpb24gbW9kZTogLi4uLi4uLi4uLi4uLiBjbGFzc2ljLG1lcmdlXG4gICAgLy8gICBubyB0cnkuLmNhdGNoOiAuLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBubyBkZWZhdWx0IHJlc29sdmUgb24gY29uZmxpY3Q6ICAgIGZhbHNlXG4gICAgLy8gICBvbi1kZW1hbmQgbG9vay1haGVhZDogLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBlcnJvciByZWNvdmVyeSB0b2tlbiBza2lwIG1heGltdW06IDNcbiAgICAvLyAgIHl5ZXJyb3IgaW4gcGFyc2UgYWN0aW9ucyBpczogLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgeXllcnJvciBpbiBsZXhlciBhY3Rpb25zIGFuZCBvdGhlciBub24tZmF0YWwgbGV4ZXIgYXJlOlxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBOT1QgcmVjb3ZlcmFibGUsXG4gICAgLy8gICBkZWJ1ZyBncmFtbWFyL291dHB1dDogLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgcGFydGlhbCBMUiBjb25mbGljdCB1cGdyYWRlOiAgIHRydWVcbiAgICAvLyAgIHJ1ZGltZW50YXJ5IHRva2VuLXN0YWNrIHN1cHBvcnQ6ICAgZmFsc2VcbiAgICAvLyAgIHBhcnNlciB0YWJsZSBjb21wcmVzc2lvbiBtb2RlOiAuLi4gMlxuICAgIC8vICAgZXhwb3J0IGRlYnVnIHRhYmxlczogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXhwb3J0ICphbGwqIHRhYmxlczogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbW9kdWxlIHR5cGU6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBjb21tb25qc1xuICAgIC8vICAgcGFyc2VyIGVuZ2luZSB0eXBlOiAuLi4uLi4uLi4uLi4uLiBsYWxyXG4gICAgLy8gICBvdXRwdXQgbWFpbigpIGluIHRoZSBtb2R1bGU6IC4uLi4uIHRydWVcbiAgICAvLyAgIGhhcyB1c2VyLXNwZWNpZmllZCBtYWluKCk6IC4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGhhcyB1c2VyLXNwZWNpZmllZCByZXF1aXJlKCkvaW1wb3J0IG1vZHVsZXMgZm9yIG1haW4oKTogXG4gICAgLy8gICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBudW1iZXIgb2YgZXhwZWN0ZWQgY29uZmxpY3RzOiAuLi4uIDBcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gUGFyc2VyIEFuYWx5c2lzIGZsYWdzOlxuICAgIC8vXG4gICAgLy8gICBubyBzaWduaWZpY2FudCBhY3Rpb25zIChwYXJzZXIgaXMgYSBsYW5ndWFnZSBtYXRjaGVyIG9ubHkpOlxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxlbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxsb2M6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBQYXJzZUVycm9yIEFQSTogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUVSUk9SOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWVJFQ09WRVJJTkc6IC4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUVSUk9LOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUNMRUFSSU46IC4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdHJhY2tzIHJ1bGUgdmFsdWVzOiAuLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICBhc3NpZ25zIHJ1bGUgdmFsdWVzOiAuLi4uLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIHVzZXMgbG9jYXRpb24gdHJhY2tpbmc6IC4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgYXNzaWducyBsb2NhdGlvbjogLi4uLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIHl5c3RhY2s6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5c3N0YWNrOiAuLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5c3A6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIHVzZXMgeXlydWxlbGVuZ3RoOiAuLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlNZXJnZUxvY2F0aW9uSW5mbyBBUEk6IC4uLi4gdHJ1ZVxuICAgIC8vICAgaGFzIGVycm9yIHJlY292ZXJ5OiAuLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIGVycm9yIHJlcG9ydGluZzogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tIEVORCBPRiBSRVBPUlQgLS0tLS0tLS0tLS1cblxudHJhY2U6IGZ1bmN0aW9uIG5vX29wX3RyYWNlKCkge30sXG5KaXNvblBhcnNlckVycm9yOiBKaXNvblBhcnNlckVycm9yLFxueXk6IHt9LFxub3B0aW9uczoge1xuICB0eXBlOiBcImxhbHJcIixcbiAgaGFzUGFydGlhbExyVXBncmFkZU9uQ29uZmxpY3Q6IHRydWUsXG4gIGVycm9yUmVjb3ZlcnlUb2tlbkRpc2NhcmRDb3VudDogMyxcbiAgZWJuZjogdHJ1ZVxufSxcbnN5bWJvbHNfOiB7XG4gIFwiIVwiOiAxNixcbiAgXCIhPVwiOiA2MSxcbiAgXCIkYWNjZXB0XCI6IDAsXG4gIFwiJGVuZFwiOiAxLFxuICBcIiV9XCI6IDMwLFxuICBcIiYmXCI6IDYyLFxuICBcIihcIjogNyxcbiAgXCIpXCI6IDgsXG4gIFwiKlwiOiAzLFxuICBcIitcIjogMjEsXG4gIFwiLFwiOiA2LFxuICBcIi1cIjogMjMsXG4gIFwiLT5cIjogNTcsXG4gIFwiLlwiOiAxNyxcbiAgXCIvXCI6IDIyLFxuICBcIi8+XCI6IDM4LFxuICBcIjpcIjogMTIsXG4gIFwiO1wiOiAyMCxcbiAgXCI8XCI6IDEzLFxuICBcIjwvXCI6IDM3LFxuICBcIjw9XCI6IDU5LFxuICBcIj1cIjogOSxcbiAgXCI9PVwiOiA2MCxcbiAgXCI9PlwiOiA1MCxcbiAgXCI+XCI6IDE0LFxuICBcIj49XCI6IDU4LFxuICBcIj9cIjogMTgsXG4gIFwiQFwiOiAxOSxcbiAgXCJBU1wiOiAyNyxcbiAgXCJDSEFSQUNURVJTXCI6IDQ3LFxuICBcIkNPTlNUUlVDVE9SXCI6IDU2LFxuICBcIkVMU0VcIjogNDQsXG4gIFwiRU5ERk9SXCI6IDQzLFxuICBcIkVOREZVTlwiOiAzNixcbiAgXCJFTkRJRlwiOiA0NixcbiAgXCJFTkRNQUlOXCI6IDMxLFxuICBcIkVORFZJRVdcIjogMzQsXG4gIFwiRU9GXCI6IDEsXG4gIFwiRVhQT1JUXCI6IDMyLFxuICBcIkZBTFNFXCI6IDU0LFxuICBcIkZPUlwiOiA0MSxcbiAgXCJGUk9NXCI6IDI2LFxuICBcIkZVTlwiOiAzNSxcbiAgXCJJREVOVElGSUVSXCI6IDU1LFxuICBcIklGXCI6IDQ1LFxuICBcIklNUE9SVFwiOiAyNSxcbiAgXCJJTlwiOiA0MixcbiAgXCJJTlNUQU5DRU9GXCI6IDY0LFxuICBcIk1BSU5cIjogMjksXG4gIFwiTlVNQkVSX0xJVEVSQUxcIjogNTIsXG4gIFwiU1RSSU5HX0xJVEVSQUxcIjogNTEsXG4gIFwiVEhFTlwiOiA0OCxcbiAgXCJUUlVFXCI6IDUzLFxuICBcIlZJRVdcIjogMzMsXG4gIFwiW1wiOiAxMCxcbiAgXCJcXFxcXFxcXFwiOiA0OSxcbiAgXCJdXCI6IDExLFxuICBcIl5cIjogMjQsXG4gIFwiYWdncmVnYXRlX21lbWJlclwiOiA3MCxcbiAgXCJhbGlhc2VkX21lbWJlclwiOiA2OSxcbiAgXCJhcmd1bWVudF9saXN0XCI6IDEwNyxcbiAgXCJhcmd1bWVudHNcIjogMTA2LFxuICBcImF0dHJpYnV0ZVwiOiA5NixcbiAgXCJhdHRyaWJ1dGVfdmFsdWVcIjogOTcsXG4gIFwiYXR0cmlidXRlX3ZhbHVlX2dyb3VwXCI6IDE1OSxcbiAgXCJhdHRyaWJ1dGVzXCI6IDk1LFxuICBcImJpbmFyeV9leHByZXNzaW9uXCI6IDExMCxcbiAgXCJiaW5hcnlfb3BlcmF0b3JcIjogMTQxLFxuICBcImJpbmFyeV9vcGVyYXRvcl9ncm91cFwiOiAxNjUsXG4gIFwiYm9vbGVhbl9saXRlcmFsXCI6IDEzMixcbiAgXCJjYWxsX2V4cHJlc3Npb25cIjogMTIwLFxuICBcImNoYXJhY3RlcnNcIjogMTA1LFxuICBcImNoaWxkXCI6IDkxLFxuICBcImNoaWxkX2dyb3VwXCI6IDE1NCxcbiAgXCJjaGlsZHJlblwiOiA5MCxcbiAgXCJjb21wb3NpdGVfbWVtYmVyXCI6IDcxLFxuICBcImNvbnNcIjogMTM1LFxuICBcImNvbnN0cnVjdF9leHByZXNzaW9uXCI6IDExOSxcbiAgXCJjb250ZXh0X3Byb3BlcnR5XCI6IDEzMyxcbiAgXCJjb250ZXh0X3R5cGVcIjogODEsXG4gIFwiY29udGV4dF92YXJpYWJsZVwiOiAxMzQsXG4gIFwiY29udHJvbFwiOiAxMDEsXG4gIFwiY29udHJvbF9ncm91cFwiOiAxNjAsXG4gIFwiY3VycmllZF9wYXJhbWV0ZXJzXCI6IDg2LFxuICBcImN1cnJpZWRfcGFyYW1ldGVyc19ncm91cFwiOiAxNTMsXG4gIFwiZWxzZV9jbGF1c2VcIjogMTA0LFxuICBcImVuZF9tYWluXCI6IDc1LFxuICBcImVycm9yXCI6IDIsXG4gIFwiZXhwb3J0XCI6IDc3LFxuICBcImV4cG9ydF9zdGF0ZW1lbnRcIjogNzgsXG4gIFwiZXhwb3J0c1wiOiA3NixcbiAgXCJleHByZXNzaW9uXCI6IDEwOCxcbiAgXCJmaWx0ZXJcIjogMTAwLFxuICBcImZpbHRlcnNcIjogOTksXG4gIFwiZm9yX3N0YXRlbWVudFwiOiAxMDIsXG4gIFwiZnVuX2FwcGxpY2F0aW9uXCI6IDExNCxcbiAgXCJmdW5fc3RhdGVtZW50XCI6IDgwLFxuICBcImZ1bl90YXJnZXRcIjogMTE1LFxuICBcImZ1bmN0aW9uX2V4cHJlc3Npb25cIjogMTI0LFxuICBcImlkZW50aWZpZXJcIjogMTM4LFxuICBcImlmX2V4cHJlc3Npb25cIjogMTA5LFxuICBcImlmX3N0YXRlbWVudFwiOiAxMDMsXG4gIFwiaW1wb3J0X21lbWJlclwiOiA2OCxcbiAgXCJpbXBvcnRfc3RhdGVtZW50XCI6IDY3LFxuICBcImltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uXCI6IDE0MixcbiAgXCJpbXBvcnRzXCI6IDY2LFxuICBcImludGVycG9sYXRpb25cIjogOTgsXG4gIFwibGlzdFwiOiAxMjksXG4gIFwibGl0ZXJhbFwiOiAxMjUsXG4gIFwibGl0ZXJhbF9ncm91cFwiOiAxNjMsXG4gIFwibWFpblwiOiA3NCxcbiAgXCJtYWluX29wdGlvblwiOiAxNDYsXG4gIFwibWFpbl9vcHRpb24yXCI6IDE0NyxcbiAgXCJtYWluX29wdGlvbjNcIjogMTQ4LFxuICBcIm1haW5fb3B0aW9uNFwiOiAxNDksXG4gIFwibWVtYmVyXCI6IDczLFxuICBcIm1lbWJlcl9leHByZXNzaW9uXCI6IDEyMSxcbiAgXCJtZW1iZXJfZ3JvdXBcIjogMTQ1LFxuICBcIm1lbWJlcl9saXN0XCI6IDcyLFxuICBcIm1lbWJlcl9saXN0X2dyb3VwXCI6IDE0MyxcbiAgXCJtZW1iZXJfbGlzdF9ncm91cDJcIjogMTQ0LFxuICBcIm1vZHVsZVwiOiA2NSxcbiAgXCJub2RlXCI6IDkzLFxuICBcIm5vZGVfb3B0aW9uXCI6IDE1NSxcbiAgXCJub2RlX29wdGlvbjJcIjogMTU2LFxuICBcIm51bWJlcl9saXRlcmFsXCI6IDEzMSxcbiAgXCJwYXJhbWV0ZXJcIjogODksXG4gIFwicGFyYW1ldGVyX2xpc3RcIjogODgsXG4gIFwicGFyYW1ldGVyc1wiOiA4NyxcbiAgXCJwYXJ0aWFsX2FwcGxpY2F0aW9uXCI6IDExOCxcbiAgXCJwcm9wZXJ0aWVzXCI6IDEyNyxcbiAgXCJwcm9wZXJ0eVwiOiAxMjgsXG4gIFwicHJvcGVydHlfZ3JvdXBcIjogMTY0LFxuICBcInF1YWxpZmllZF9jb25zdHJ1Y3RvclwiOiAxMzYsXG4gIFwicXVhbGlmaWVkX2lkZW50aWZpZXJcIjogMTM5LFxuICBcInJlYWRfZXhwcmVzc2lvblwiOiAxMjIsXG4gIFwicmVhZGFibGVfZXhwcmVzc2lvblwiOiAxMjMsXG4gIFwicmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cFwiOiAxNjIsXG4gIFwicmVjb3JkXCI6IDEyNixcbiAgXCJzaW1wbGVfZXhwcmVzc2lvblwiOiAxMTIsXG4gIFwic2ltcGxlX2V4cHJlc3Npb25fZ3JvdXBcIjogMTYxLFxuICBcInN0cmluZ19saXRlcmFsXCI6IDEzMCxcbiAgXCJ0YWdcIjogOTIsXG4gIFwidHlwZVwiOiA4NSxcbiAgXCJ0eXBlX2FyZ19saXN0XCI6IDExNyxcbiAgXCJ0eXBlX2FyZ3VtZW50c1wiOiAxMTYsXG4gIFwidHlwZV9jbGFzc1wiOiA4NCxcbiAgXCJ0eXBlX2NsYXNzX2xpc3RcIjogODMsXG4gIFwidHlwZV9jbGFzc2VzXCI6IDgyLFxuICBcInR5cGVfb3B0aW9uXCI6IDE1MixcbiAgXCJ1bmFyeV9leHByZXNzaW9uXCI6IDExMSxcbiAgXCJ1bnF1YWxpZmllZF9jb25zdHJ1Y3RvclwiOiAxMzcsXG4gIFwidW5xdWFsaWZpZWRfaWRlbnRpZmllclwiOiAxNDAsXG4gIFwidmlld19jb25zdHJ1Y3Rpb25cIjogMTEzLFxuICBcInZpZXdfc3RhdGVtZW50XCI6IDc5LFxuICBcInZpZXdfc3RhdGVtZW50X29wdGlvblwiOiAxNTAsXG4gIFwidmlld19zdGF0ZW1lbnRfb3B0aW9uMlwiOiAxNTEsXG4gIFwid2lkZ2V0XCI6IDk0LFxuICBcIndpZGdldF9vcHRpb25cIjogMTU3LFxuICBcIndpZGdldF9vcHRpb24yXCI6IDE1OCxcbiAgXCJ7XCI6IDQsXG4gIFwieyVcIjogMjgsXG4gIFwie3tcIjogMzksXG4gIFwifFwiOiAxNSxcbiAgXCJ8fFwiOiA2MyxcbiAgXCJ9XCI6IDUsXG4gIFwifX1cIjogNDBcbn0sXG50ZXJtaW5hbHNfOiB7XG4gIDE6IFwiRU9GXCIsXG4gIDI6IFwiZXJyb3JcIixcbiAgMzogXCIqXCIsXG4gIDQ6IFwie1wiLFxuICA1OiBcIn1cIixcbiAgNjogXCIsXCIsXG4gIDc6IFwiKFwiLFxuICA4OiBcIilcIixcbiAgOTogXCI9XCIsXG4gIDEwOiBcIltcIixcbiAgMTE6IFwiXVwiLFxuICAxMjogXCI6XCIsXG4gIDEzOiBcIjxcIixcbiAgMTQ6IFwiPlwiLFxuICAxNTogXCJ8XCIsXG4gIDE2OiBcIiFcIixcbiAgMTc6IFwiLlwiLFxuICAxODogXCI/XCIsXG4gIDE5OiBcIkBcIixcbiAgMjA6IFwiO1wiLFxuICAyMTogXCIrXCIsXG4gIDIyOiBcIi9cIixcbiAgMjM6IFwiLVwiLFxuICAyNDogXCJeXCIsXG4gIDI1OiBcIklNUE9SVFwiLFxuICAyNjogXCJGUk9NXCIsXG4gIDI3OiBcIkFTXCIsXG4gIDI4OiBcInslXCIsXG4gIDI5OiBcIk1BSU5cIixcbiAgMzA6IFwiJX1cIixcbiAgMzE6IFwiRU5ETUFJTlwiLFxuICAzMjogXCJFWFBPUlRcIixcbiAgMzM6IFwiVklFV1wiLFxuICAzNDogXCJFTkRWSUVXXCIsXG4gIDM1OiBcIkZVTlwiLFxuICAzNjogXCJFTkRGVU5cIixcbiAgMzc6IFwiPC9cIixcbiAgMzg6IFwiLz5cIixcbiAgMzk6IFwie3tcIixcbiAgNDA6IFwifX1cIixcbiAgNDE6IFwiRk9SXCIsXG4gIDQyOiBcIklOXCIsXG4gIDQzOiBcIkVOREZPUlwiLFxuICA0NDogXCJFTFNFXCIsXG4gIDQ1OiBcIklGXCIsXG4gIDQ2OiBcIkVORElGXCIsXG4gIDQ3OiBcIkNIQVJBQ1RFUlNcIixcbiAgNDg6IFwiVEhFTlwiLFxuICA0OTogXCJcXFxcXFxcXFwiLFxuICA1MDogXCI9PlwiLFxuICA1MTogXCJTVFJJTkdfTElURVJBTFwiLFxuICA1MjogXCJOVU1CRVJfTElURVJBTFwiLFxuICA1MzogXCJUUlVFXCIsXG4gIDU0OiBcIkZBTFNFXCIsXG4gIDU1OiBcIklERU5USUZJRVJcIixcbiAgNTY6IFwiQ09OU1RSVUNUT1JcIixcbiAgNTc6IFwiLT5cIixcbiAgNTg6IFwiPj1cIixcbiAgNTk6IFwiPD1cIixcbiAgNjA6IFwiPT1cIixcbiAgNjE6IFwiIT1cIixcbiAgNjI6IFwiJiZcIixcbiAgNjM6IFwifHxcIixcbiAgNjQ6IFwiSU5TVEFOQ0VPRlwiXG59LFxuVEVSUk9SOiAyLFxuRU9GOiAxLFxuXG4vLyBpbnRlcm5hbHM6IGRlZmluZWQgaGVyZSBzbyB0aGUgb2JqZWN0ICpzdHJ1Y3R1cmUqIGRvZXNuJ3QgZ2V0IG1vZGlmaWVkIGJ5IHBhcnNlKCkgZXQgYWwsXG4vLyB0aHVzIGhlbHBpbmcgSklUIGNvbXBpbGVycyBsaWtlIENocm9tZSBWOC5cbm9yaWdpbmFsUXVvdGVOYW1lOiBudWxsLFxub3JpZ2luYWxQYXJzZUVycm9yOiBudWxsLFxuY2xlYW51cEFmdGVyUGFyc2U6IG51bGwsXG5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogbnVsbCxcbnl5TWVyZ2VMb2NhdGlvbkluZm86IG51bGwsXG5cbl9fcmVlbnRyYW50X2NhbGxfZGVwdGg6IDAsIC8vIElOVEVSTkFMIFVTRSBPTkxZXG5fX2Vycm9yX2luZm9zOiBbXSwgLy8gSU5URVJOQUwgVVNFIE9OTFk6IHRoZSBzZXQgb2YgcGFyc2VFcnJvckluZm8gb2JqZWN0cyBjcmVhdGVkIHNpbmNlIHRoZSBsYXN0IGNsZWFudXBcbl9fZXJyb3JfcmVjb3ZlcnlfaW5mb3M6IFtdLCAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuXG4vLyBBUElzIHdoaWNoIHdpbGwgYmUgc2V0IHVwIGRlcGVuZGluZyBvbiB1c2VyIGFjdGlvbiBjb2RlIGFuYWx5c2lzOlxuLy95eVJlY292ZXJpbmc6IDAsXG4vL3l5RXJyT2s6IDAsXG4vL3l5Q2xlYXJJbjogMCxcblxuLy8gSGVscGVyIEFQSXNcbi8vIC0tLS0tLS0tLS0tXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2VyIGNvZGUgbGF0ZXIgb246IHB1dCBzdWl0YWJsZSBxdW90ZXMgYXJvdW5kXG4vLyBsaXRlcmFsIElEcyBpbiBhIGRlc2NyaXB0aW9uIHN0cmluZy5cbnF1b3RlTmFtZTogZnVuY3Rpb24gcGFyc2VyX3F1b3RlTmFtZShpZF9zdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIGlkX3N0ciArICdcIic7XG59LFxuXG4vLyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGdpdmVuIHN5bWJvbCAodGVybWluYWwgb3Igbm9uLXRlcm1pbmFsKSBhcyBhIHN0cmluZywgd2hlbiBhdmFpbGFibGUuXG4vL1xuLy8gUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbmdldFN5bWJvbE5hbWU6IGZ1bmN0aW9uIHBhcnNlcl9nZXRTeW1ib2xOYW1lKHN5bWJvbCkge1xuICAgIGlmICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF07XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLi4uIHRoaXMgbWlnaHQgcmVmZXIgdG8gYSBSVUxFIHRva2VuIGkuZS4gYSBub24tdGVybWluYWw6IHNlZSBpZiB3ZSBjYW4gZGlnIHRoYXQgb25lIHVwLlxuICAgIC8vXG4gICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIG1heSBiZSB3aGVyZSBhIHJ1bGUncyBhY3Rpb24gY29kZSBjb250YWlucyBhIGNhbGwgbGlrZSB0aGlzOlxuICAgIC8vXG4gICAgLy8gICAgICBwYXJzZXIuZ2V0U3ltYm9sTmFtZSgjJClcbiAgICAvL1xuICAgIC8vIHRvIG9idGFpbiBhIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGN1cnJlbnQgZ3JhbW1hciBydWxlLlxuICAgIHZhciBzID0gdGhpcy5zeW1ib2xzXztcbiAgICBmb3IgKHZhciBrZXkgaW4gcykge1xuICAgICAgICBpZiAoc1trZXldID09PSBzeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59LFxuXG4vLyBSZXR1cm4gYSBtb3JlLW9yLWxlc3MgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGdpdmVuIHN5bWJvbCwgd2hlbiBhdmFpbGFibGUsXG4vLyBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbi8vXG4vLyBSZXR1cm4gTlVMTCB3aGVuIHRoZSBzeW1ib2wgaXMgdW5rbm93biB0byB0aGUgcGFyc2VyLlxuZGVzY3JpYmVTeW1ib2w6IGZ1bmN0aW9uIHBhcnNlcl9kZXNjcmliZVN5bWJvbChzeW1ib2wpIHtcbiAgICBpZiAoc3ltYm9sICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc18gJiYgdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybWluYWxfZGVzY3JpcHRpb25zX1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAoc3ltYm9sID09PSB0aGlzLkVPRikge1xuICAgICAgICByZXR1cm4gJ2VuZCBvZiBpbnB1dCc7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgIGlmIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdW90ZU5hbWUoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0sXG5cbi8vIFByb2R1Y2UgYSAobW9yZSBvciBsZXNzKSBodW1hbi1yZWFkYWJsZSBsaXN0IG9mIGV4cGVjdGVkIHRva2VucyBhdCB0aGUgcG9pbnQgb2YgZmFpbHVyZS5cbi8vXG4vLyBUaGUgcHJvZHVjZWQgbGlzdCBtYXkgY29udGFpbiB0b2tlbiBvciB0b2tlbiBzZXQgZGVzY3JpcHRpb25zIGluc3RlYWQgb2YgdGhlIHRva2Vuc1xuLy8gdGhlbXNlbHZlcyB0byBoZWxwIHR1cm5pbmcgdGhpcyBvdXRwdXQgaW50byBzb21ldGhpbmcgdGhhdCBlYXNpZXIgdG8gcmVhZCBieSBodW1hbnNcbi8vIHVubGVzcyBgZG9fbm90X2Rlc2NyaWJlYCBwYXJhbWV0ZXIgaXMgc2V0LCBpbiB3aGljaCBjYXNlIGEgbGlzdCBvZiB0aGUgcmF3LCAqbnVtZXJpYyosXG4vLyBleHBlY3RlZCB0ZXJtaW5hbHMgYW5kIG5vbnRlcm1pbmFscyBpcyBwcm9kdWNlZC5cbi8vXG4vLyBUaGUgcmV0dXJuZWQgbGlzdCAoYXJyYXkpIHdpbGwgbm90IGNvbnRhaW4gYW55IGR1cGxpY2F0ZSBlbnRyaWVzLlxuY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQ6IGZ1bmN0aW9uIHBhcnNlcl9jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSwgZG9fbm90X2Rlc2NyaWJlKSB7XG4gICAgdmFyIFRFUlJPUiA9IHRoaXMuVEVSUk9SO1xuICAgIHZhciB0b2tlbnNldCA9IFtdO1xuICAgIHZhciBjaGVjayA9IHt9O1xuICAgIC8vIEhhcyB0aGlzIChlcnJvcj8pIHN0YXRlIGJlZW4gb3V0Zml0dGVkIHdpdGggYSBjdXN0b20gZXhwZWN0YXRpb25zIGRlc2NyaXB0aW9uIHRleHQgZm9yIGh1bWFuIGNvbnN1bXB0aW9uP1xuICAgIC8vIElmIHNvLCB1c2UgdGhhdCBvbmUgaW5zdGVhZCBvZiB0aGUgbGVzcyBwYWxhdGFibGUgdG9rZW4gc2V0LlxuICAgIGlmICghZG9fbm90X2Rlc2NyaWJlICYmIHRoaXMuc3RhdGVfZGVzY3JpcHRpb25zXyAmJiB0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc19bc3RhdGVdKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfW3N0YXRlXV07XG4gICAgfVxuICAgIGZvciAodmFyIHAgaW4gdGhpcy50YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgcCA9ICtwO1xuICAgICAgICBpZiAocCAhPT0gVEVSUk9SKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGRvX25vdF9kZXNjcmliZSA/IHAgOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHApO1xuICAgICAgICAgICAgaWYgKGQgJiYgIWNoZWNrW2RdKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zZXQucHVzaChkKTtcbiAgICAgICAgICAgICAgICBjaGVja1tkXSA9IHRydWU7IC8vIE1hcmsgdGhpcyB0b2tlbiBkZXNjcmlwdGlvbiBhcyBhbHJlYWR5IG1lbnRpb25lZCB0byBwcmV2ZW50IG91dHB1dHRpbmcgZHVwbGljYXRlIGVudHJpZXMuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vuc2V0O1xufSxcbnByb2R1Y3Rpb25zXzogYnAoe1xuICBwb3A6IHUoW1xuICBzLFxuICBbNjUsIDddLFxuICA2NixcbiAgNjYsXG4gIDY3LFxuICBzLFxuICBbNjgsIDNdLFxuICBzLFxuICBbNjksIDQsIDFdLFxuICA3MixcbiAgNzMsXG4gIDc0LFxuICA3NCxcbiAgNzUsXG4gIDc2LFxuICA3NixcbiAgcyxcbiAgWzc3LCAzXSxcbiAgNzgsXG4gIDc5LFxuICBzLFxuICBbODAsIDE2XSxcbiAgODEsXG4gIDgyLFxuICA4MyxcbiAgODMsXG4gIHMsXG4gIFs4NCwgNF0sXG4gIHMsXG4gIFs4NSwgM10sXG4gIHMsXG4gIFs4NiwgNF0sXG4gIDg3LFxuICA4NyxcbiAgODgsXG4gIDg4LFxuICA4OSxcbiAgODksXG4gIDkwLFxuICA5MCxcbiAgOTEsXG4gIDkyLFxuICA5MixcbiAgcyxcbiAgWzkzLCA0XSxcbiAgcyxcbiAgWzk0LCA0XSxcbiAgOTUsXG4gIDk1LFxuICBzLFxuICBbOTYsIDRdLFxuICA5NyxcbiAgOTgsXG4gIDk4LFxuICA5OSxcbiAgcyxcbiAgWzk5LCA0LCAxXSxcbiAgcyxcbiAgWzEwMiwgNV0sXG4gIDEwMyxcbiAgMTA0LFxuICAxMDQsXG4gIDEwNSxcbiAgMTA2LFxuICAxMDYsXG4gIDEwNyxcbiAgMTA3LFxuICBzLFxuICBbMTA4LCA3XSxcbiAgMTA5LFxuICBzLFxuICBbMTEwLCA0XSxcbiAgMTExLFxuICBzLFxuICBbMTExLCA0LCAxXSxcbiAgMTE0LFxuICAxMTQsXG4gIHMsXG4gIFsxMTUsIDNdLFxuICAxMTYsXG4gIDExNyxcbiAgMTE3LFxuICBzLFxuICBbMTE4LCAzXSxcbiAgMTE5LFxuICBzLFxuICBbMTIwLCA4XSxcbiAgcyxcbiAgWzEyMSwgMTBdLFxuICBzLFxuICBbMTIyLCAxMF0sXG4gIDEyMyxcbiAgMTIzLFxuICAxMjQsXG4gIDEyNCxcbiAgMTI1LFxuICAxMjYsXG4gIDEyNixcbiAgMTI3LFxuICAxMjcsXG4gIDEyOCxcbiAgMTI5LFxuICBzLFxuICBbMTI5LCA0LCAxXSxcbiAgcyxcbiAgWzEzMiwgNCwgMV0sXG4gIDEzNSxcbiAgMTM2LFxuICAxMzYsXG4gIDEzNyxcbiAgMTM4LFxuICAxMzgsXG4gIDEzOSxcbiAgcyxcbiAgWzEzOSwgNCwgMV0sXG4gIDE0MixcbiAgMTQzLFxuICAxNDMsXG4gIDE0NCxcbiAgMTQ0LFxuICAxNDUsXG4gIDE0NSxcbiAgMTQ2LFxuICAxNDYsXG4gIDE0NyxcbiAgMTQ3LFxuICAxNDgsXG4gIDE0OCxcbiAgMTQ5LFxuICAxNDksXG4gIDE1MCxcbiAgMTUwLFxuICAxNTEsXG4gIDE1MSxcbiAgMTUyLFxuICAxNTIsXG4gIDE1MyxcbiAgMTUzLFxuICBzLFxuICBbMTU0LCA1XSxcbiAgMTU1LFxuICAxNTUsXG4gIDE1NixcbiAgMTU2LFxuICAxNTcsXG4gIDE1NyxcbiAgMTU4LFxuICAxNTgsXG4gIDE1OSxcbiAgMTU5LFxuICAxNjAsXG4gIDE2MCxcbiAgcyxcbiAgWzE2MSwgMTBdLFxuICBzLFxuICBbMTYyLCA0XSxcbiAgcyxcbiAgWzE2MywgNV0sXG4gIDE2NCxcbiAgMTY0LFxuICBzLFxuICBbMTY1LCAxNF1cbl0pLFxuICBydWxlOiB1KFtcbiAgNCxcbiAgMyxcbiAgMyxcbiAgMixcbiAgMyxcbiAgMixcbiAgMixcbiAgMSxcbiAgMixcbiAgNSxcbiAgcyxcbiAgWzEsIDNdLFxuICBzLFxuICBbMywgM10sXG4gIDEsXG4gIDMsXG4gIDEsXG4gIDExLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIHMsXG4gIFsxLCAzXSxcbiAgNixcbiAgMTMsXG4gIDExLFxuICAxMCxcbiAgMTAsXG4gIDksXG4gIDEwLFxuICA5LFxuICA5LFxuICA4LFxuICA5LFxuICA4LFxuICA4LFxuICA3LFxuICA4LFxuICA3LFxuICA3LFxuICA2LFxuICBjLFxuICBbMzEsIDVdLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIDQsXG4gIGMsXG4gIFs1LCAzXSxcbiAgYyxcbiAgWzU0LCAzXSxcbiAgYyxcbiAgWzYsIDRdLFxuICAxLFxuICBjLFxuICBbNDQsIDVdLFxuICA4LFxuICA3LFxuICA0LFxuICAzLFxuICBjLFxuICBbNCwgNF0sXG4gIGMsXG4gIFs3MiwgM10sXG4gIGMsXG4gIFsxOSwgNF0sXG4gIDMsXG4gIDQsXG4gIDEsXG4gIGMsXG4gIFs4NCwgM10sXG4gIDEwLFxuICAxMixcbiAgMTQsXG4gIDE0LFxuICAxNixcbiAgMTgsXG4gIDYsXG4gIDcsXG4gIDcsXG4gIDEsXG4gIGMsXG4gIFs0MiwgNF0sXG4gIHMsXG4gIFsxLCA2XSxcbiAgMyxcbiAgNixcbiAgMyxcbiAgNSxcbiAgNSxcbiAgNyxcbiAgMixcbiAgNCxcbiAgMSxcbiAgNCxcbiAgNSxcbiAgYyxcbiAgWzQ2LCAzXSxcbiAgYyxcbiAgWzY0LCA0XSxcbiAgYyxcbiAgWzEyOCwgM10sXG4gIDQsXG4gIGMsXG4gIFsxMzEsIDNdLFxuICBjLFxuICBbMTM1LCA0XSxcbiAgYyxcbiAgWzE5LCAzXSxcbiAgcyxcbiAgWzMsIDddLFxuICA1LFxuICAzLFxuICA2LFxuICA4LFxuICA2LFxuICA4LFxuICBjLFxuICBbNCwgNF0sXG4gIDEwLFxuICA4LFxuICBjLFxuICBbNzgsIDNdLFxuICBjLFxuICBbMTYwLCAzXSxcbiAgYyxcbiAgWzExNCwgNV0sXG4gIGMsXG4gIFs2OSwgNV0sXG4gIGMsXG4gIFsxMTIsIDRdLFxuICBjLFxuICBbMTAxLCA0XSxcbiAgYyxcbiAgWzUsIDVdLFxuICAwLFxuICBzLFxuICBbMSwgN10sXG4gIDAsXG4gIGMsXG4gIFsxMCwgM10sXG4gIGMsXG4gIFs0LCAxMF0sXG4gIGMsXG4gIFsyMSwgMTVdLFxuICBzLFxuICBbMSwgMzldXG5dKVxufSksXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX1BlcmZvcm1BY3Rpb24oeXlsb2MsIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCB5eXNwLCB5eXZzdGFjaywgeXlsc3RhY2spIHtcblxuICAgICAgICAgIC8qIHRoaXMgPT0geXl2YWwgKi9cblxuICAgICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgaXRzZWxmIGNhbiBnbyBhbmQgcmVtb3ZlIHRoZXNlIHN0YXRlbWVudHMgd2hlbiBgeXlgIHR1cm5zIG91dCB0byBiZSB1bnVzZWQgaW4gYW55IGFjdGlvbiBjb2RlIVxuICAgICAgICAgIHZhciB5eSA9IHRoaXMueXk7XG4gICAgICAgICAgdmFyIHl5cGFyc2VyID0geXkucGFyc2VyO1xuICAgICAgICAgIHZhciB5eWxleGVyID0geXkubGV4ZXI7XG5cbiAgICAgICAgICBcblxuICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgJGFjY2VwdCA6IG1vZHVsZSAkZW5kICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3AgLSAxXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSlcbiAgICBicmVhaztcblxuY2FzZSAxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBleHBvcnRzIG1haW4gRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgZXhwb3J0cyBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgbnVsbCwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBpbXBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIG51bGwsIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBleHBvcnRzIG1haW4gRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogZXhwb3J0cyBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydHMgOiBpbXBvcnRfc3RhdGVtZW50ICovXG5jYXNlIDg5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZmlsdGVycyA6IGZpbHRlciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gIFt5eXZzdGFja1t5eXNwXV07XG4gICAgYnJlYWs7XG5cbmNhc2UgOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydHMgOiBpbXBvcnRzIGltcG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnRzIDogZXhwb3J0cyBleHBvcnQgKi9cbmNhc2UgNjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZHJlbiA6IGNoaWxkcmVuIGNoaWxkICovXG5jYXNlIDgxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlcyA6IGF0dHJpYnV0ZXMgYXR0cmlidXRlICovXG5jYXNlIDkwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZmlsdGVycyA6IGZpbHRlcnMgZmlsdGVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV0uY29uY2F0KHl5dnN0YWNrW3l5c3BdKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnQgOiBJTVBPUlQgaW1wb3J0X21lbWJlciBGUk9NIHN0cmluZ19saXRlcmFsIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSW1wb3J0U3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9tZW1iZXIgOiBhZ2dyZWdhdGVfbWVtYmVyICovXG5jYXNlIDEyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGFsaWFzZWRfbWVtYmVyICovXG5jYXNlIDEzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGNvbXBvc2l0ZV9tZW1iZXIgKi9cbmNhc2UgMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXIgOiBtZW1iZXJfZ3JvdXAgKi9cbmNhc2UgMjU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiBleHBvcnRfc3RhdGVtZW50ICovXG5jYXNlIDI2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwb3J0IDogdmlld19zdGF0ZW1lbnQgKi9cbmNhc2UgMTY4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbCA6IGxpdGVyYWxfZ3JvdXAgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3BdO1xuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSlcbiAgICBicmVhaztcblxuY2FzZSAxNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFsaWFzZWRfbWVtYmVyIDogbWVtYmVyIEFTIG1lbWJlciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkFsaWFzZWRNZW1iZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhZ2dyZWdhdGVfbWVtYmVyIDogXCIqXCIgQVMgbWVtYmVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQWdncmVnYXRlTWVtYmVyKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbXBvc2l0ZV9tZW1iZXIgOiBcIntcIiBtZW1iZXJfbGlzdCBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbXBvc2l0ZU1lbWJlcih5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3QgOiBtZW1iZXJfbGlzdF9ncm91cCAqL1xuY2FzZSAyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydHMgOiBleHBvcnQgKi9cbmNhc2UgNDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzX2xpc3QgOiB0eXBlX2NsYXNzICovXG5jYXNlIDU3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3VycmllZF9wYXJhbWV0ZXJzIDogcGFyYW1ldGVyICovXG5jYXNlIDYzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyX2xpc3QgOiBwYXJhbWV0ZXIgKi9cbmNhc2UgNjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZHJlbiA6IGNoaWxkICovXG5jYXNlIDgwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlcyA6IGF0dHJpYnV0ZSAqL1xuY2FzZSAxMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudF9saXN0IDogZXhwcmVzc2lvbiAqL1xuY2FzZSAxMzA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2FyZ19saXN0IDogdHlwZSAqL1xuY2FzZSAxNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0aWVzIDogcHJvcGVydHkgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IFt5eXZzdGFja1t5eXNwXV07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdCA6IG1lbWJlcl9saXN0IFwiLFwiIG1lbWJlcl9saXN0X2dyb3VwMiAqL1xuY2FzZSA0OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3NfbGlzdCA6IHR5cGVfY2xhc3NfbGlzdCBcIixcIiB0eXBlX2NsYXNzICovXG5jYXNlIDU4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3VycmllZF9wYXJhbWV0ZXJzIDogY3VycmllZF9wYXJhbWV0ZXJzIGN1cnJpZWRfcGFyYW1ldGVyc19ncm91cCBwYXJhbWV0ZXIgKi9cbmNhc2UgNjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJfbGlzdCA6IHBhcmFtZXRlcl9saXN0IFwiLFwiIHBhcmFtZXRlciAqL1xuY2FzZSAxMDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudF9saXN0IDogYXJndW1lbnRfbGlzdCBcIixcIiBleHByZXNzaW9uICovXG5jYXNlIDEzMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJnX2xpc3QgOiB0eXBlX2FyZ19saXN0IFwiLFwiIHR5cGUgKi9cbmNhc2UgMTcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydGllcyA6IHByb3BlcnRpZXMgXCIsXCIgcHJvcGVydHkgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXS5jb25jYXQoeXl2c3RhY2tbeXlzcF0pO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbiA6IFwieyVcIiBNQUlOIG1haW5fb3B0aW9uIG1haW5fb3B0aW9uMiBcIihcIiB0eXBlIFwiKVwiIG1haW5fb3B0aW9uMyBcIiV9XCIgdGFnIG1haW5fb3B0aW9uNCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTAsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlZE1haW4oeXl2c3RhY2tbeXlzcCAtIDhdLCB5eXZzdGFja1t5eXNwIC0gN118fFtdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluIDogdGFnICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW50eXBlZE1haW4oeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZW5kX21haW4gOiBcInslXCIgRU5ETUFJTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXTtcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pXG4gICAgYnJlYWs7XG5cbmNhc2UgMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiBmdW5fc3RhdGVtZW50ICovXG5jYXNlIDY5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGQgOiBjaGlsZF9ncm91cCAqL1xuY2FzZSA3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHRhZyA6IG5vZGUgKi9cbmNhc2UgNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0YWcgOiB3aWRnZXQgKi9cbmNhc2UgODY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWUgOiBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgKi9cbmNhc2UgOTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250cm9sIDogY29udHJvbF9ncm91cCAqL1xuY2FzZSAxMDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogaWZfZXhwcmVzc2lvbiAqL1xuY2FzZSAxMDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogYmluYXJ5X2V4cHJlc3Npb24gKi9cbmNhc2UgMTEwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uICovXG5jYXNlIDExMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiByZWFkX2V4cHJlc3Npb24gKi9cbmNhc2UgMTEyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IGZ1bmN0aW9uX2V4cHJlc3Npb24gKi9cbmNhc2UgMTIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb24gOiBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogaWRlbnRpZmllciAqL1xuY2FzZSAxMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogY29udGV4dF9wcm9wZXJ0eSAqL1xuY2FzZSAxNjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uIDogcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb25zIDogcXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnMgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAxODc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZGVudGlmaWVyIDogcXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTg4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaWRlbnRpZmllciA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTkyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yIDogYmluYXJ5X29wZXJhdG9yX2dyb3VwICovXG5jYXNlIDE5NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uIDogXCI7XCIgKi9cbmNhc2UgMTk1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBtZW1iZXIgKi9cbmNhc2UgMTk2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBhbGlhc2VkX21lbWJlciAqL1xuY2FzZSAxOTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cDIgOiBtZW1iZXIgKi9cbmNhc2UgMTk4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAyIDogYWxpYXNlZF9tZW1iZXIgKi9cbmNhc2UgMTk5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2dyb3VwIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAyMDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZ3JvdXAgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAyMDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbiA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDIwNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uMiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjMgOiBwYXJhbWV0ZXJzICovXG5jYXNlIDIwODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uNCA6IGVuZF9tYWluICovXG5jYXNlIDIxMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfc3RhdGVtZW50X29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24yIDogcGFyYW1ldGVycyAqL1xuY2FzZSAyMTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjdXJyaWVkX3BhcmFtZXRlcnNfZ3JvdXAgOiBcIi0+XCIgKi9cbmNhc2UgMjE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3VycmllZF9wYXJhbWV0ZXJzX2dyb3VwIDogXCIsXCIgKi9cbmNhc2UgMjE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiB0YWcgKi9cbmNhc2UgMjE4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiBpbnRlcnBvbGF0aW9uICovXG5jYXNlIDIxOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogY29udHJvbCAqL1xuY2FzZSAyMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGNoYXJhY3RlcnMgKi9cbmNhc2UgMjIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiBpZGVudGlmaWVyICovXG5jYXNlIDIyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGVfb3B0aW9uIDogY2hpbGRyZW4gKi9cbmNhc2UgMjI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZV9vcHRpb24yIDogY2hpbGRyZW4gKi9cbmNhc2UgMjI3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0X29wdGlvbiA6IGNoaWxkcmVuICovXG5jYXNlIDIyOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldF9vcHRpb24yIDogY2hpbGRyZW4gKi9cbmNhc2UgMjMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlX3ZhbHVlX2dyb3VwIDogaW50ZXJwb2xhdGlvbiAqL1xuY2FzZSAyMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgOiBsaXRlcmFsICovXG5jYXNlIDIzMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRyb2xfZ3JvdXAgOiBmb3Jfc3RhdGVtZW50ICovXG5jYXNlIDIzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRyb2xfZ3JvdXAgOiBpZl9zdGF0ZW1lbnQgKi9cbmNhc2UgMjM0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiB2aWV3X2NvbnN0cnVjdGlvbiAqL1xuY2FzZSAyMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGZ1bl9hcHBsaWNhdGlvbiAqL1xuY2FzZSAyMzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnN0cnVjdF9leHByZXNzaW9uICovXG5jYXNlIDIzNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY2FsbF9leHByZXNzaW9uICovXG5jYXNlIDIzODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogbWVtYmVyX2V4cHJlc3Npb24gKi9cbmNhc2UgMjM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBsaXRlcmFsICovXG5jYXNlIDI0MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29udGV4dF9wcm9wZXJ0eSAqL1xuY2FzZSAyNDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnMgKi9cbmNhc2UgMjQyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBpZGVudGlmaWVyICovXG5jYXNlIDI0MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29udGV4dF92YXJpYWJsZSAqL1xuY2FzZSAyNDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwIDogc3RyaW5nX2xpdGVyYWwgKi9cbmNhc2UgMjQ1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IG1lbWJlcl9leHByZXNzaW9uICovXG5jYXNlIDI0NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb250ZXh0X3Byb3BlcnR5ICovXG5jYXNlIDI0NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjYWxsX2V4cHJlc3Npb24gKi9cbmNhc2UgMjQ4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IHJlY29yZCAqL1xuY2FzZSAyNDk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogbGlzdCAqL1xuY2FzZSAyNTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogc3RyaW5nX2xpdGVyYWwgKi9cbmNhc2UgMjUxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IG51bWJlcl9saXRlcmFsICovXG5jYXNlIDI1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBib29sZWFuX2xpdGVyYWwgKi9cbmNhc2UgMjUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydHlfZ3JvdXAgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDI1NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnR5X2dyb3VwIDogc3RyaW5nX2xpdGVyYWwgKi9cbmNhc2UgMjU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI+XCIgKi9cbmNhc2UgMjU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI+PVwiICovXG5jYXNlIDI1NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPFwiICovXG5jYXNlIDI1ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPD1cIiAqL1xuY2FzZSAyNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj09XCIgKi9cbmNhc2UgMjYwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCIhPVwiICovXG5jYXNlIDI2MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiK1wiICovXG5jYXNlIDI2MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiL1wiICovXG5jYXNlIDI2MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiLVwiICovXG5jYXNlIDI2NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPVwiICovXG5jYXNlIDI2NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiJiZcIiAqL1xuY2FzZSAyNjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcInx8XCIgKi9cbmNhc2UgMjY3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCJeXCIgKi9cbmNhc2UgMjY4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogSU5TVEFOQ0VPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcF07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnRfc3RhdGVtZW50IDogXCJ7JVwiIEVYUE9SVCBjb21wb3NpdGVfbWVtYmVyIEZST00gc3RyaW5nX2xpdGVyYWwgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRXhwb3J0U3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAyOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfc3RhdGVtZW50IDogXCJ7JVwiIFZJRVcgdW5xdWFsaWZpZWRfY29uc3RydWN0b3Igdmlld19zdGF0ZW1lbnRfb3B0aW9uIFwiKFwiIHR5cGUgXCIpXCIgdmlld19zdGF0ZW1lbnRfb3B0aW9uMiBcIiV9XCIgdGFnIFwieyVcIiBFTkRWSUVXIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5WaWV3U3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAxMF0sIHl5dnN0YWNrW3l5c3AgLSA5XXx8W10sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIGNvbnRleHRfdHlwZSBjdXJyaWVkX3BhcmFtZXRlcnMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gOF0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBjb250ZXh0X3R5cGUgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY3VycmllZF9wYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA2XSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCBudWxsLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIGN1cnJpZWRfcGFyYW1ldGVycyBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDksIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDddLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGNvbnRleHRfdHlwZSBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDgsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDZdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDVdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY3VycmllZF9wYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sW10sbnVsbCx5eXZzdGFja1t5eXNwIC0gNV0seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLFtdLG51bGwsW10seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIGN1cnJpZWRfcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDgsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIGN1cnJpZWRfcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gNF0sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgbnVsbCwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGNvbnRleHRfdHlwZSBjdXJyaWVkX3BhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBjb250ZXh0X3R5cGUgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGN1cnJpZWRfcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDRdLFtdLG51bGwseXl2c3RhY2tbeXlzcCAtIDNdLHl5dnN0YWNrW3l5c3AgLSAxXSx0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSxbXSxudWxsLFtdLHl5dnN0YWNrW3l5c3AgLSAxXSx0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfdHlwZSA6IFwiKFwiIHR5cGUgXCIpXCIgKi9cbmNhc2UgNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzZXMgOiBcIltcIiB0eXBlX2NsYXNzX2xpc3QgXCJdXCIgKi9cbmNhc2UgNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjdXJyaWVkX3BhcmFtZXRlcnMgOiBcIihcIiBjdXJyaWVkX3BhcmFtZXRlcnMgXCIpXCIgKi9cbmNhc2UgNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJzIDogXCIoXCIgcGFyYW1ldGVyX2xpc3QgXCIpXCIgKi9cbmNhc2UgMTA0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXJndW1lbnRzIDogXCIoXCIgYXJndW1lbnRfbGlzdCBcIilcIiAqL1xuY2FzZSAxMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuY2FzZSAxMjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuY2FzZSAxMjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2FyZ3VtZW50cyA6IFwiW1wiIHR5cGVfYXJnX2xpc3QgXCJdXCIgKi9cbmNhc2UgMTY1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXTtcbiAgICBicmVhaztcblxuY2FzZSA1MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3MgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDUyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzcyA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZUNsYXNzKHl5dnN0YWNrW3l5c3BdLCBudWxsLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3MgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiOlwiIHR5cGUgKi9cbmNhc2UgNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfY29uc3RydWN0b3IgXCI6XCIgdHlwZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGVDbGFzcyh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGUgOiBjb25zIHR5cGVfb3B0aW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZSh5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdfHxbXSwgZmFsc2UsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZSA6IGNvbnMgdHlwZV9jbGFzc2VzIFwiW1wiIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZSh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgdHJ1ZSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlIDogY29ucyBcIltcIiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGUoeXl2c3RhY2tbeXlzcCAtIDJdLCBbXSwgdHJ1ZSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjdXJyaWVkX3BhcmFtZXRlcnMgOiBcIihcIiBcIilcIiAqL1xuY2FzZSA2MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHBhcmFtZXRlcnMgOiBcIihcIiBcIilcIiAqL1xuY2FzZSAxMDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudHMgOiBcIihcIiBcIilcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gW107XG4gICAgYnJlYWs7XG5cbmNhc2UgNjU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXIgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiOlwiIHR5cGUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlZFBhcmFtZXRlcih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA2NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHBhcmFtZXRlciA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbnR5cGVkUGFyYW1ldGVyKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIGF0dHJpYnV0ZXMgXCI+XCIgbm9kZV9vcHRpb24gXCI8L1wiIGlkZW50aWZpZXIgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Ob2RlKHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM118fFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDczOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZSA6IFwiPFwiIGlkZW50aWZpZXIgXCI+XCIgbm9kZV9vcHRpb24yIFwiPC9cIiBpZGVudGlmaWVyIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM118fFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZSA6IFwiPFwiIGlkZW50aWZpZXIgYXR0cmlidXRlcyBcIi8+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Ob2RlKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIFwiLz5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk5vZGUoeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIGF0dHJpYnV0ZXMgXCI+XCIgd2lkZ2V0X29wdGlvbiBcIjwvXCIgY29ucyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LldpZGdldCh5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldCA6IFwiPFwiIGNvbnMgXCI+XCIgd2lkZ2V0X29wdGlvbjIgXCI8L1wiIGNvbnMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5XaWRnZXQoeXl2c3RhY2tbeXlzcCAtIDVdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldCA6IFwiPFwiIGNvbnMgYXR0cmlidXRlcyBcIi8+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5XaWRnZXQoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0IDogXCI8XCIgY29ucyBcIi8+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5XaWRnZXQoeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGUgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiOlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI9XCIgYXR0cmlidXRlX3ZhbHVlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQXR0cmlidXRlKHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGUgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiPVwiIGF0dHJpYnV0ZV92YWx1ZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuQXR0cmlidXRlKG5ldyB5eS5hc3QuVW5xdWFsaWZpZWRJZGVudGlmaWVyKCdodG1sJywgdGhpcy5fJCksXG4gICAgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGUgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiOlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5BdHRyaWJ1dGUoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgbmV3IHl5LmFzdC5Cb29sZWFuTGl0ZXJhbCh0cnVlLCB0aGlzLl8kKSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGUgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQXR0cmlidXRlKFxuICAgIG5ldyB5eS5hc3QuVW5xdWFsaWZpZWRJZGVudGlmaWVyKCdodG1sJywgdGhpcy5fJCksXG4gICAgeXl2c3RhY2tbeXlzcF0sIG5ldyB5eS5hc3QuQm9vbGVhbkxpdGVyYWwodHJ1ZSwgdGhpcy5fJCksIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDg3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW50ZXJwb2xhdGlvbiA6IFwie3tcIiBleHByZXNzaW9uIFwifX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkludGVycG9sYXRpb24oeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbnRlcnBvbGF0aW9uIDogXCJ7e1wiIGV4cHJlc3Npb24gZmlsdGVycyBcIn19XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JbnRlcnBvbGF0aW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZpbHRlciA6IFwifFwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3BdXG4gICAgYnJlYWs7XG5cbmNhc2UgOTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDksIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDddLCBudWxsLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDExXSwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVMU0UgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTFdLCBudWxsLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVMU0UgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTNdLCB5eXZzdGFja1t5eXNwIC0gMTFdLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDE1XSwgeXl2c3RhY2tbeXlzcCAtIDEzXSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDExXSwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaWZfc3RhdGVtZW50IDogXCJ7JVwiIElGIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIGVsc2VfY2xhdXNlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSWZTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBlbHNlX2NsYXVzZSA6IFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ESUYgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRWxzZUNsYXVzZSh5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEwMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGVsc2VfY2xhdXNlIDogXCJ7JVwiIEVMU0UgSUYgZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gZWxzZV9jbGF1c2UgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5FbHNlSWZDbGF1c2UoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGFyYWN0ZXJzIDogQ0hBUkFDVEVSUyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNoYXJhY3RlcnMoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEwOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiB1bmFyeV9leHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPXl5dnN0YWNrW3l5c3BdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGlmX2V4cHJlc3Npb24gOiBJRiBleHByZXNzaW9uIFRIRU4gZXhwcmVzc2lvbiBFTFNFIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JZlRoZW5FeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X2V4cHJlc3Npb24gOiBzaW1wbGVfZXhwcmVzc2lvbiBiaW5hcnlfb3BlcmF0b3Igc2ltcGxlX2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X2V4cHJlc3Npb24gOiBzaW1wbGVfZXhwcmVzc2lvbiBiaW5hcnlfb3BlcmF0b3IgXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJpbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIGJpbmFyeV9vcGVyYXRvciBzaW1wbGVfZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJpbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgYmluYXJ5X29wZXJhdG9yIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVuYXJ5X2V4cHJlc3Npb24gOiBcIiFcIiBzaW1wbGVfZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVuYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB1bmFyeV9leHByZXNzaW9uIDogXCIhXCIgXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVuYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19jb25zdHJ1Y3Rpb24gOiBcIjxcIiBjb25zIGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlZpZXdDb25zdHJ1Y3Rpb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9hcHBsaWNhdGlvbiA6IFwiPFwiIGZ1bl90YXJnZXQgdHlwZV9hcmd1bWVudHMgcGFydGlhbF9hcHBsaWNhdGlvbiBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV18fFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IHBhcnRpYWxfYXBwbGljYXRpb24gXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5BcHBsaWNhdGlvbih5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0gfHxbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX2FwcGxpY2F0aW9uIDogXCI8XCIgZnVuX3RhcmdldCBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJ0aWFsX2FwcGxpY2F0aW9uIDogXCIoXCIgXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gW25ldyB5eS5hc3QuVW5xdWFsaWZpZWRJZGVudGlmaWVyKCd1bmRlZmluZWQnLCB0aGlzLl8kKV07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTMzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFydGlhbF9hcHBsaWNhdGlvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IFt5eXZzdGFja1t5eXNwIC0gMV1dO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHBhcnRpYWxfYXBwbGljYXRpb24gOiBwYXJ0aWFsX2FwcGxpY2F0aW9uIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAzXS5jb25jYXQoeXl2c3RhY2tbeXlzcCAtIDFdKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb25zdHJ1Y3RfZXhwcmVzc2lvbiA6IGNvbnMgYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29uc3RydWN0RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuY2FzZSAxMzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuY2FzZSAxNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiB0eXBlX2FyZ3VtZW50cyBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DYWxsRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgYXJndW1lbnRzICovXG5jYXNlIDEzOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgYXJndW1lbnRzICovXG5jYXNlIDE0MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTQzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DYWxsRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTQ0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBxdWFsaWZpZWRfaWRlbnRpZmllciBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE0NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogcXVhbGlmaWVkX2NvbnN0cnVjdG9yIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQ2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjb250ZXh0X3ZhcmlhYmxlIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQ3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQ4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBsaXN0IFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiByZWNvcmQgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHN0cmluZ19saXRlcmFsIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTUxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjYWxsX2V4cHJlc3Npb24gXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5NZW1iZXJFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTWVtYmVyRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3ZhcmlhYmxlIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWFkRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5jYXNlIDE1NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiP1wiIGV4cHJlc3Npb24gXCJdXCIgKi9cbmNhc2UgMTU5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogY29udGV4dF9wcm9wZXJ0eSBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuY2FzZSAxNjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTYyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIltcIiBleHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTYzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIltcIiBleHByZXNzaW9uIEFTIHR5cGUgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWFkRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBudWxsLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5jdGlvbl9leHByZXNzaW9uIDogXCJcXFxcXCIgcGFyYW1ldGVyX2xpc3QgXCI9PlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5jdGlvbkV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTY3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuY3Rpb25fZXhwcmVzc2lvbiA6IFwiPT5cIiBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuY3Rpb25FeHByZXNzaW9uKFtdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTY5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVjb3JkIDogXCJ7XCIgXCJ9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWNvcmQoW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlY29yZCA6IFwie1wiIHByb3BlcnRpZXMgXCJ9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWNvcmQoeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0eSA6IHByb3BlcnR5X2dyb3VwIFwiOlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Qcm9wZXJ0eSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXN0IDogXCJbXCIgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5MaXN0KFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXN0IDogXCJbXCIgYXJndW1lbnRfbGlzdCBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lkxpc3QoeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzdHJpbmdfbGl0ZXJhbCA6IFNUUklOR19MSVRFUkFMICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuU3RyaW5nTGl0ZXJhbCh5eXZzdGFja1t5eXNwXS5zbGljZSgxLCB5eXZzdGFja1t5eXNwXS5sZW5ndGggLSAxLCB0aGlzLl8kKSk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTc3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbnVtYmVyX2xpdGVyYWwgOiBOVU1CRVJfTElURVJBTCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk51bWJlckxpdGVyYWwoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJvb2xlYW5fbGl0ZXJhbCA6IFRSVUUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Cb29sZWFuTGl0ZXJhbCh0cnVlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBib29sZWFuX2xpdGVyYWwgOiBGQUxTRSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKGZhbHNlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxODA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3Byb3BlcnR5IDogXCJAXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbnRleHRQcm9wZXJ0eSh5eXZzdGFja1t5eXNwXSwgdGhpcy5fJClcbiAgICBicmVhaztcblxuY2FzZSAxODE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3ZhcmlhYmxlIDogXCJAXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Db250ZXh0VmFyaWFibGUodGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTg0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcXVhbGlmaWVkX2NvbnN0cnVjdG9yIDogSURFTlRJRklFUiBcIi5cIiBDT05TVFJVQ1RPUiAqL1xuY2FzZSAxODU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfY29uc3RydWN0b3IgOiBDT05TVFJVQ1RPUiBcIi5cIiBDT05TVFJVQ1RPUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlF1YWxpZmllZENvbnN0cnVjdG9yKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yIDogQ09OU1RSVUNUT1IgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbnF1YWxpZmllZENvbnN0cnVjdG9yKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxODk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfaWRlbnRpZmllciA6IElERU5USUZJRVIgXCIuXCIgSURFTlRJRklFUiAqL1xuY2FzZSAxOTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfaWRlbnRpZmllciA6IENPTlNUUlVDVE9SIFwiLlwiIElERU5USUZJRVIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5RdWFsaWZpZWRJZGVudGlmaWVyKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE5MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgOiBJREVOVElGSUVSICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW5xdWFsaWZpZWRJZGVudGlmaWVyKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxOTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfc3RhdGVtZW50X29wdGlvbiA6ICVlcHNpbG9uICovXG5jYXNlIDIwMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjAzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24yIDogJWVwc2lsb24gKi9cbmNhc2UgMjA1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24zIDogJWVwc2lsb24gKi9cbmNhc2UgMjA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb240IDogJWVwc2lsb24gKi9cbmNhc2UgMjA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnRfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5jYXNlIDIxMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZV9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjI4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0X29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHRydWUpO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB1bmRlZmluZWQ7XG4gICAgYnJlYWs7XG5cbn1cbn0sXG50YWJsZTogYnQoe1xuICBsZW46IHUoW1xuICAxNSxcbiAgMSxcbiAgMTQsXG4gIDExLFxuICAxLFxuICAwLFxuICAwLFxuICA0LFxuICAwLFxuICAxMixcbiAgcyxcbiAgWzAsIDVdLFxuICA4LFxuICBjLFxuICBbMTMsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIDAsXG4gIDUsXG4gIHMsXG4gIFsyLCAzXSxcbiAgYyxcbiAgWzgsIDRdLFxuICAxLFxuICAxLFxuICA5LFxuICBzLFxuICBbMCwgNV0sXG4gIDYsXG4gIDYsXG4gIHMsXG4gIFswLCA0XSxcbiAgMjksXG4gIDI5LFxuICBjLFxuICBbMjAsIDRdLFxuICA0LFxuICAwLFxuICAxLFxuICA0LFxuICAxMCxcbiAgMixcbiAgNixcbiAgNixcbiAgMixcbiAgMCxcbiAgMyxcbiAgMCxcbiAgNSxcbiAgMjMsXG4gIGMsXG4gIFs0NCwgM10sXG4gIGMsXG4gIFs1LCAzXSxcbiAgMixcbiAgMixcbiAgYyxcbiAgWzU1LCAzXSxcbiAgNixcbiAgYyxcbiAgWzUxLCAzXSxcbiAgOCxcbiAgNyxcbiAgNSxcbiAgMjEsXG4gIDIwLFxuICAxMSxcbiAgMCxcbiAgOCxcbiAgYyxcbiAgWzQ4LCA1XSxcbiAgOCxcbiAgYyxcbiAgWzMwLCAzXSxcbiAgMSxcbiAgMjEsXG4gIHMsXG4gIFswLCA3XSxcbiAgNDMsXG4gIHMsXG4gIFswLCA0XSxcbiAgMTAsXG4gIDEsXG4gIDIsXG4gIDIsXG4gIDE3LFxuICAyMyxcbiAgYyxcbiAgWzIxLCA3XSxcbiAgYyxcbiAgWzY2LCA0XSxcbiAgMyxcbiAgMSxcbiAgNixcbiAgYyxcbiAgWzUwLCA0XSxcbiAgYyxcbiAgWzMsIDNdLFxuICA2LFxuICAyMSxcbiAgMjAsXG4gIDMsXG4gIDAsXG4gIDAsXG4gIDIwLFxuICAxLFxuICAxLFxuICBjLFxuICBbMTQxLCAzXSxcbiAgNSxcbiAgMTIsXG4gIGMsXG4gIFs2NCwgNF0sXG4gIDMsXG4gIGMsXG4gIFs0MCwgM10sXG4gIDUsXG4gIGMsXG4gIFsxMTEsIDNdLFxuICAwLFxuICAwLFxuICAyNixcbiAgYyxcbiAgWzYzLCAzXSxcbiAgNDMsXG4gIDMzLFxuICAwLFxuICAyOCxcbiAgMjYsXG4gIDI5LFxuICAyOSxcbiAgNCxcbiAgYyxcbiAgWzcyLCA0XSxcbiAgMjUsXG4gIDAsXG4gIDI2LFxuICAyNyxcbiAgMjgsXG4gIDI3LFxuICBzLFxuICBbMjUsIDNdLFxuICAxMixcbiAgMCxcbiAgNDUsXG4gIDgsXG4gIHMsXG4gIFswLCA1XSxcbiAgMSxcbiAgMSxcbiAgMyxcbiAgNDMsXG4gIGMsXG4gIFs0MiwgNF0sXG4gIGMsXG4gIFsxMiwgNV0sXG4gIDIxLFxuICA1LFxuICAxLFxuICAxLFxuICAwLFxuICA1LFxuICBjLFxuICBbMTgwLCAzXSxcbiAgMSxcbiAgYyxcbiAgWzg4LCAzXSxcbiAgMjEsXG4gIDIwLFxuICAyMCxcbiAgMSxcbiAgYyxcbiAgWzQsIDRdLFxuICAyMCxcbiAgMSxcbiAgYyxcbiAgWzgxLCAzXSxcbiAgYyxcbiAgWzEzMSwgNF0sXG4gIDcsXG4gIGMsXG4gIFsyOSwgNF0sXG4gIGMsXG4gIFsxMywgNF0sXG4gIGMsXG4gIFs4MiwgM10sXG4gIHMsXG4gIFswLCAxNF0sXG4gIGMsXG4gIFsyNSwgM10sXG4gIDQzLFxuICAxNSxcbiAgMTUsXG4gIDE0LFxuICAxMSxcbiAgMjQsXG4gIDIsXG4gIDAsXG4gIDQ1LFxuICAyMCxcbiAgMixcbiAgMjQsXG4gIGMsXG4gIFsyMTMsIDNdLFxuICBjLFxuICBbNCwgNF0sXG4gIDIsXG4gIDAsXG4gIGMsXG4gIFszLCAzXSxcbiAgYyxcbiAgWzcsIDNdLFxuICBzLFxuICBbMiwgNF0sXG4gIDUsXG4gIGMsXG4gIFsxMzcsIDNdLFxuICBjLFxuICBbMTgsIDddLFxuICBjLFxuICBbMjY3LCAzXSxcbiAgMixcbiAgMSxcbiAgMTcsXG4gIDUsXG4gIGMsXG4gIFsxNzUsIDNdLFxuICBjLFxuICBbMjc1LCAzXSxcbiAgYyxcbiAgWzk3LCA2XSxcbiAgMyxcbiAgYyxcbiAgWzE5MSwgM10sXG4gIDMsXG4gIGMsXG4gIFsxODMsIDRdLFxuICAxLFxuICBjLFxuICBbMzI1LCA1XSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgMzEsXG4gIDQzLFxuICAxLFxuICA3LFxuICAxLFxuICAyLFxuICBjLFxuICBbMjUyLCAzXSxcbiAgYyxcbiAgWzMwNCwgNF0sXG4gIHMsXG4gIFsxLCAzXSxcbiAgYyxcbiAgWzQ1LCAzXSxcbiAgYyxcbiAgWzcsIDRdLFxuICBjLFxuICBbMzEsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIDQzLFxuICBjLFxuICBbMTQ1LCA1XSxcbiAgYyxcbiAgWzExLCAzXSxcbiAgYyxcbiAgWzEwMiwgM10sXG4gIDQ0LFxuICBjLFxuICBbMTI0LCAzXSxcbiAgMCxcbiAgNixcbiAgNDMsXG4gIDQzLFxuICAzLFxuICAyMSxcbiAgYyxcbiAgWzI2LCAzXSxcbiAgYyxcbiAgWzE2MSwgNV0sXG4gIGMsXG4gIFs3NiwgN10sXG4gIGMsXG4gIFs3OSwgNV0sXG4gIGMsXG4gIFszNiwgM10sXG4gIDMzLFxuICA0NSxcbiAgYyxcbiAgWzM1NywgNF0sXG4gIDE1LFxuICA2LFxuICAwLFxuICA2LFxuICBjLFxuICBbMzYyLCAzXSxcbiAgYyxcbiAgWzQwMCwgNV0sXG4gIGMsXG4gIFs4OCwgNF0sXG4gIGMsXG4gIFsxMDQsIDVdLFxuICAxLFxuICAyLFxuICAyMSxcbiAgYyxcbiAgWzI5NSwgM10sXG4gIDIsXG4gIDQsXG4gIGMsXG4gIFsxMjIsIDhdLFxuICAxNSxcbiAgMCxcbiAgNDMsXG4gIDEsXG4gIDIyLFxuICBjLFxuICBbMTcwLCA1XSxcbiAgNixcbiAgcyxcbiAgWzIsIDNdLFxuICBjLFxuICBbMTgsIDNdLFxuICAyMSxcbiAgYyxcbiAgWzEwNiwgM10sXG4gIDMsXG4gIGMsXG4gIFs0NDAsIDNdLFxuICBjLFxuICBbNzMsIDVdLFxuICBjLFxuICBbNTksIDNdLFxuICA0MyxcbiAgYyxcbiAgWzU4LCAzXSxcbiAgYyxcbiAgWzQsIDRdLFxuICBjLFxuICBbMzY2LCAzXSxcbiAgYyxcbiAgWzIwNCwgM10sXG4gIGMsXG4gIFsyMywgM10sXG4gIDE1LFxuICBjLFxuICBbMTUwLCA0XSxcbiAgMSxcbiAgNCxcbiAgMjEsXG4gIDQzLFxuICAyMSxcbiAgNDMsXG4gIDEsXG4gIDEsXG4gIGMsXG4gIFs0MjYsIDVdLFxuICBjLFxuICBbMjIsIDNdLFxuICBjLFxuICBbMzA4LCA1XSxcbiAgYyxcbiAgWzYyLCA0XSxcbiAgNCxcbiAgMjEsXG4gIGMsXG4gIFsxNTAsIDNdLFxuICBjLFxuICBbNDQsIDNdLFxuICBjLFxuICBbMzI5LCAzXSxcbiAgMyxcbiAgYyxcbiAgWzE0LCAzXSxcbiAgYyxcbiAgWzIwLCAzXSxcbiAgYyxcbiAgWzEzLCAzXSxcbiAgYyxcbiAgWzE1NiwgM10sXG4gIDIxLFxuICAxLFxuICAyMCxcbiAgMCxcbiAgMyxcbiAgMSxcbiAgMFxuXSksXG4gIHN5bWJvbDogdShbXG4gIDEzLFxuICAyNSxcbiAgMjgsXG4gIDY1LFxuICA2NixcbiAgNjcsXG4gIDc0LFxuICBzLFxuICBbNzYsIDUsIDFdLFxuICA5MixcbiAgOTMsXG4gIDk0LFxuICAxLFxuICAxLFxuICBjLFxuICBbMTcsIDNdLFxuICBjLFxuICBbMTUsIDExXSxcbiAgMTMsXG4gIDI4LFxuICA3NCxcbiAgYyxcbiAgWzExLCA4XSxcbiAgMjksXG4gIDMyLFxuICAzMyxcbiAgMzUsXG4gIDMsXG4gIDQsXG4gIDU1LFxuICA1NixcbiAgcyxcbiAgWzY4LCA0LCAxXSxcbiAgNzMsXG4gIDEzNyxcbiAgMTQwLFxuICAxNDUsXG4gIDU1LFxuICA1NixcbiAgcyxcbiAgWzEzNSwgNiwgMV0sXG4gIGMsXG4gIFszNiwgMTJdLFxuICAxLFxuICA3LFxuICAxMCxcbiAgNTYsXG4gIDEzNyxcbiAgMTQ2LFxuICA0LFxuICA3MSxcbiAgNTYsXG4gIDEzNyxcbiAgNTUsXG4gIDE0MCxcbiAgMjYsXG4gIDI3LFxuICAyNyxcbiAgNTUsXG4gIDU2LFxuICA2OSxcbiAgNzIsXG4gIGMsXG4gIFs0MywgM10sXG4gIDE0MyxcbiAgMTQ1LFxuICAxNCxcbiAgMzgsXG4gIDU1LFxuICA5NSxcbiAgOTYsXG4gIDE0MCxcbiAgYyxcbiAgWzYsIDZdLFxuICBzLFxuICBbNSwgNywgMV0sXG4gIDEzLFxuICAxNCxcbiAgMTUsXG4gIDE3LFxuICBzLFxuICBbMjEsIDQsIDFdLFxuICAyNyxcbiAgMzAsXG4gIDM4LFxuICA0MCxcbiAgNDQsXG4gIDQ4LFxuICA1NSxcbiAgcyxcbiAgWzU4LCA3LCAxXSxcbiAgYyxcbiAgWzI5LCAyOV0sXG4gIGMsXG4gIFs5NCwgM10sXG4gIDgyLFxuICAxNDcsXG4gIDI2LFxuICBjLFxuICBbNSwgM10sXG4gIDE1MCxcbiAgNyxcbiAgOSxcbiAgMTAsXG4gIDMwLFxuICA1NSxcbiAgODEsXG4gIDgyLFxuICA4NixcbiAgODksXG4gIDE0MCxcbiAgNTEsXG4gIDEzMCxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTQyLCA2XSxcbiAgYyxcbiAgWzYsIDRdLFxuICA1LFxuICA2LFxuICA1LFxuICA2LFxuICAyNyxcbiAgYyxcbiAgWzEwMywgM10sXG4gIDk2LFxuICAxNDAsXG4gIDEzLFxuICAyOCxcbiAgMzcsXG4gIDM5LFxuICA0NyxcbiAgNTUsXG4gIDU2LFxuICBzLFxuICBbOTAsIDUsIDFdLFxuICA5OCxcbiAgMTAxLFxuICAxMDIsXG4gIDEwMyxcbiAgMTA1LFxuICBjLFxuICBbMTcwLCAzXSxcbiAgMTU0LFxuICAxNTYsXG4gIDE2MCxcbiAgOSxcbiAgMTIsXG4gIGMsXG4gIFszMCwgM10sXG4gIGMsXG4gIFszMywgMjZdLFxuICAxNTgsXG4gIDE2MCxcbiAgNTUsXG4gIDU2LFxuICA1NSxcbiAgNTYsXG4gIDcsXG4gIDU1LFxuICA1NixcbiAgODMsXG4gIDg0LFxuICAxMzcsXG4gIGMsXG4gIFs5MSwgM10sXG4gIDcsXG4gIDcsXG4gIDksXG4gIGMsXG4gIFsxMDMsIDNdLFxuICBjLFxuICBbMTAyLCAzXSxcbiAgYyxcbiAgWzgsIDRdLFxuICBjLFxuICBbNywgM10sXG4gIDYsXG4gIDksXG4gIDMwLFxuICA1NyxcbiAgMTUzLFxuICAxMyxcbiAgMjgsXG4gIGMsXG4gIFs1NiwgMThdLFxuICAxNjAsXG4gIGMsXG4gIFsyMSwgNl0sXG4gIGMsXG4gIFsyMCwgMTRdLFxuICA3LFxuICA4LFxuICA1NSxcbiAgNTYsXG4gIDg1LFxuICA4NixcbiAgODksXG4gIGMsXG4gIFsyOTQsIDNdLFxuICAxNDAsXG4gIDYsXG4gIDgsXG4gIDksXG4gIDEyLFxuICAzMCxcbiAgNDIsXG4gIDUwLFxuICA1NyxcbiAgMSxcbiAgMTMsXG4gIDIwLFxuICAyNSxcbiAgMjgsXG4gIDE0MixcbiAgYyxcbiAgWzI3OSwgM10sXG4gIGMsXG4gIFsxNzMsIDNdLFxuICAxNDQsXG4gIDE0NSxcbiAgYyxcbiAgWzEzMSwgMjFdLFxuICAxNTUsXG4gIDE2MCxcbiAgMzcsXG4gIGMsXG4gIFsyNCwgN10sXG4gIGMsXG4gIFs3OCwgMTRdLFxuICBzLFxuICBbNCwgNiwgM10sXG4gIDQ1LFxuICBzLFxuICBbNDksIDgsIDFdLFxuICBzLFxuICBbMTA4LCA3LCAxXSxcbiAgcyxcbiAgWzExOSwgNCwgMV0sXG4gIDEyNCxcbiAgMTI1LFxuICAxMjYsXG4gIHMsXG4gIFsxMjksIDEyLCAxXSxcbiAgMTYxLFxuICAxNjMsXG4gIDEzLFxuICAxNCxcbiAgMTcsXG4gIDI4LFxuICAzMCxcbiAgYyxcbiAgWzY3LCA1XSxcbiAgMTcsXG4gIDQxLFxuICA0NSxcbiAgNTUsXG4gIDE0MCxcbiAgNCxcbiAgMTAsXG4gIDM5LFxuICBjLFxuICBbNTIsIDRdLFxuICA5NyxcbiAgOTgsXG4gIGMsXG4gIFs0MCwgNl0sXG4gIDE1OSxcbiAgMTYzLFxuICBjLFxuICBbMTIwLCAyMV0sXG4gIDE1NyxcbiAgYyxcbiAgWzEyMCwgMjNdLFxuICBjLFxuICBbMTk2LCAzXSxcbiAgYyxcbiAgWzg4LCAzXSxcbiAgNixcbiAgMTEsXG4gIDYsXG4gIDExLFxuICAxMixcbiAgYyxcbiAgWzMsIDNdLFxuICAzMCxcbiAgYyxcbiAgWzE1LCA2XSxcbiAgYyxcbiAgWzI3MiwgNTNdLFxuICBjLFxuICBbMzE4LCA0OV0sXG4gIGMsXG4gIFs5OCwgM10sXG4gIGMsXG4gIFs0NywgNDFdLFxuICA1NSxcbiAgYyxcbiAgWzQ0LCA4XSxcbiAgYyxcbiAgWzIzLCAxNF0sXG4gIDMwLFxuICA4LFxuICA2LFxuICA4LFxuICA1NyxcbiAgMTUzLFxuICBjLFxuICBbMzgzLCAzXSxcbiAgMTAsXG4gIDExLFxuICAxOCxcbiAgYyxcbiAgWzM4NSwgNF0sXG4gIDgyLFxuICAxNTIsXG4gIDYsXG4gIDgsXG4gIDEyLFxuICAxNyxcbiAgNTcsXG4gIGMsXG4gIFsxNywgNV0sXG4gIDE0LFxuICAxNyxcbiAgYyxcbiAgWzE5LCA1XSxcbiAgYyxcbiAgWzIxMCwgNl0sXG4gIGMsXG4gIFs1NjgsIDNdLFxuICBjLFxuICBbMjU2LCAyNF0sXG4gIGMsXG4gIFs3LCAzXSxcbiAgMTUsXG4gIDQwLFxuICA5OSxcbiAgMTAwLFxuICA1LFxuICBjLFxuICBbNTMsIDNdLFxuICBjLFxuICBbNjY1LCA0XSxcbiAgYyxcbiAgWzY2NCwgNl0sXG4gIGMsXG4gIFs2NjMsIDNdLFxuICBjLFxuICBbNjYyLCA3XSxcbiAgMTQxLFxuICAxNjUsXG4gIGMsXG4gIFs0MTEsIDQzXSxcbiAgYyxcbiAgWzQzLCA0N10sXG4gIDE5LFxuICBjLFxuICBbMzksIDZdLFxuICBjLFxuICBbMzUsIDZdLFxuICBjLFxuICBbMzMsIDE2XSxcbiAgYyxcbiAgWzgxMiwgMTBdLFxuICBjLFxuICBbMTQ3LCAxNl0sXG4gIDEwNixcbiAgMTE2LFxuICBjLFxuICBbMTczLCA0XSxcbiAgYyxcbiAgWzgzOSwgMTJdLFxuICBjLFxuICBbMjgsIDEwXSxcbiAgYyxcbiAgWzg2NiwgMTddLFxuICBjLFxuICBbNTUsIDE0XSxcbiAgYyxcbiAgWzI5LCAyN10sXG4gIDU1LFxuICA4OCxcbiAgODksXG4gIDE0MCxcbiAgYyxcbiAgWzE5MiwgNDNdLFxuICBjLFxuICBbMzA0LCA4XSxcbiAgYyxcbiAgWzEzMCwgMjJdLFxuICBjLFxuICBbMTgzLCAyMV0sXG4gIGMsXG4gIFsxMjcsIDI3XSxcbiAgYyxcbiAgWzIwOSwgMTldLFxuICBjLFxuICBbMTA0NywgOF0sXG4gIGMsXG4gIFsxMTA2LCAxOF0sXG4gIGMsXG4gIFs1NSwgMTRdLFxuICBjLFxuICBbMjUsIDcxXSxcbiAgNyxcbiAgMTksXG4gIDU1LFxuICA1NixcbiAgMTE1LFxuICAxMzMsXG4gIGMsXG4gIFsyMjIsIDZdLFxuICBjLFxuICBbMjYzLCAzXSxcbiAgMTEsXG4gIGMsXG4gIFsyNjQsIDEyXSxcbiAgcyxcbiAgWzEwNywgOCwgMV0sXG4gIGMsXG4gIFsyNjUsIDIyXSxcbiAgNTEsXG4gIDU1LFxuICAxMjcsXG4gIDEyOCxcbiAgMTMwLFxuICAxNDAsXG4gIDE2NCxcbiAgcyxcbiAgWzU1LCAzXSxcbiAgYyxcbiAgWzMyMSwgNDVdLFxuICA5LFxuICBjLFxuICBbMTE5MiwgM10sXG4gIGMsXG4gIFs2NjAsIDI0XSxcbiAgYyxcbiAgWzM2LCAzXSxcbiAgOCxcbiAgMTcsXG4gIDU1LFxuICA1NixcbiAgYyxcbiAgWzExOTAsIDNdLFxuICBjLFxuICBbNzAzLCA2XSxcbiAgYyxcbiAgWzYsIDZdLFxuICA4LFxuICBjLFxuICBbODY3LCA0Nl0sXG4gIGMsXG4gIFs0MSwgNDddLFxuICBjLFxuICBbODU4LCAxNV0sXG4gIGMsXG4gIFs2MiwgNjhdLFxuICBjLFxuICBbMjEsIDE1XSxcbiAgMzYsXG4gIDQxLFxuICA0NSxcbiAgYyxcbiAgWzkzOSwgMTBdLFxuICAxMSxcbiAgYyxcbiAgWzE0MTQsIDZdLFxuICA1NixcbiAgYyxcbiAgWzE0MjUsIDNdLFxuICBjLFxuICBbMzAsIDNdLFxuICAxNCxcbiAgMTUsXG4gIDQwLFxuICAxMDAsXG4gIGMsXG4gIFs4MjksIDc2XSxcbiAgOCxcbiAgNDgsXG4gIGMsXG4gIFs3MTUsIDQ1XSxcbiAgNyxcbiAgOCxcbiAgMTAsXG4gIDExLFxuICAxNSxcbiAgMTcsXG4gIGMsXG4gIFs1MjcsIDVdLFxuICBjLFxuICBbODA2LCA2XSxcbiAgYyxcbiAgWzE1LCAxOF0sXG4gIGMsXG4gIFsxNCwgOV0sXG4gIDgsXG4gIGMsXG4gIFsyNywgOF0sXG4gIGMsXG4gIFs5OCwgM10sXG4gIDE5LFxuICA1MSxcbiAgYyxcbiAgWzQxMCwgM10sXG4gIDExNyxcbiAgMTIwLFxuICAxMjEsXG4gIDEyMyxcbiAgYyxcbiAgWzgyLCAzXSxcbiAgYyxcbiAgWzgwLCA4XSxcbiAgMTYyLFxuICA3LFxuICAxMDYsXG4gIDQsXG4gIGMsXG4gIFs1MCwgM10sXG4gIGMsXG4gIFs1NzYsIDQxXSxcbiAgYyxcbiAgWzcxLCA3XSxcbiAgYyxcbiAgWzY5LCA4XSxcbiAgMTM2LFxuICBjLFxuICBbNjcsIDRdLFxuICBjLFxuICBbMTQ5NCwgM10sXG4gIGMsXG4gIFs5MywgMjNdLFxuICA1NSxcbiAgMTQwLFxuICBjLFxuICBbOTUsIDRdLFxuICBjLFxuICBbMjgsIDI2XSxcbiAgNixcbiAgNTAsXG4gIDU1LFxuICAxNDAsXG4gIDU1LFxuICAxNDAsXG4gIGMsXG4gIFs0LCA4XSxcbiAgNyxcbiAgMTA2LFxuICA3LFxuICAxMCxcbiAgMTQsXG4gIDExNixcbiAgMTE4LFxuICBjLFxuICBbMjY4LCA0M10sXG4gIDU1LFxuICAxNDAsXG4gIDYsXG4gIDExLFxuICA1LFxuICA2LFxuICAxMixcbiAgNixcbiAgNDIsXG4gIDMwLFxuICBjLFxuICBbMTYyNCwgMTddLFxuICBjLFxuICBbNjYzLCA1XSxcbiAgMTQsXG4gIDcsXG4gIDMwLFxuICA4NyxcbiAgMTQ4LFxuICBjLFxuICBbNCwgM10sXG4gIDE1MSxcbiAgYyxcbiAgWzU0NCwgODZdLFxuICBjLFxuICBbMjQsIDI0XSxcbiAgYyxcbiAgWzMsIDNdLFxuICAzMCxcbiAgMTEsXG4gIDE0LFxuICBjLFxuICBbNDY4LCA0N10sXG4gIGMsXG4gIFsxMjU5LCAyNV0sXG4gIGMsXG4gIFsxNDkyLCA0NV0sXG4gIGMsXG4gIFsyMDIzLCA0XSxcbiAgMTE3LFxuICBjLFxuICBbMTMsIDNdLFxuICAyNyxcbiAgNixcbiAgMTEsXG4gIGMsXG4gIFs1NCwgNDNdLFxuICAxNyxcbiAgMjcsXG4gIDcsXG4gIDEwLFxuICAxNyxcbiAgMjcsXG4gIDEwNixcbiAgMTE2LFxuICBjLFxuICBbNiwgNl0sXG4gIDE3LFxuICAyNyxcbiAgcyxcbiAgWzE3LCAzXSxcbiAgNyxcbiAgMTAsXG4gIDEwNixcbiAgMTE2LFxuICA2LFxuICA4LFxuICBjLFxuICBbMTAsIDNdLFxuICAyNyxcbiAgMjcsXG4gIGMsXG4gIFs0MDEsIDQ0XSxcbiAgODksXG4gIDE0MCxcbiAgMTQsXG4gIDcsXG4gIDExOCxcbiAgNyxcbiAgYyxcbiAgWzI1MiwgM10sXG4gIGMsXG4gIFs1OTYsIDE0XSxcbiAgYyxcbiAgWzE3OSwgMjldLFxuICBjLFxuICBbOTYsIDQzXSxcbiAgNTEsXG4gIDU1LFxuICBjLFxuICBbMTIxMywgNF0sXG4gIGMsXG4gIFsxNzY0LCA4Nl0sXG4gIGMsXG4gIFsxOTc0LCA5XSxcbiAgYyxcbiAgWzU1MSwgMTVdLFxuICAxNCxcbiAgMzAsXG4gIDgsXG4gIGMsXG4gIFsxNjQ2LCA0XSxcbiAgYyxcbiAgWzUxOCwgMjVdLFxuICBjLFxuICBbNDk0LCA0XSxcbiAgYyxcbiAgWzQsIDRdLFxuICAzMCxcbiAgYyxcbiAgWzIwMSwgNV0sXG4gIGMsXG4gIFsxMDAxLCAyOV0sXG4gIGMsXG4gIFsxNDIsIDE1XSxcbiAgODUsXG4gIGMsXG4gIFsxNDMsIDddLFxuICAxMTcsXG4gIGMsXG4gIFs3MzMsIDIzXSxcbiAgNyxcbiAgMTA2LFxuICA0NCxcbiAgYyxcbiAgWzk5MSwgMTVdLFxuICBjLFxuICBbMTM3NywgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzIzMTUsIDddLFxuICBjLFxuICBbNjI5LCA0NF0sXG4gIDgsXG4gIDMwLFxuICA2LFxuICA0MixcbiAgYyxcbiAgWzIxMiwgMTRdLFxuICAxMDQsXG4gIGMsXG4gIFs3NzIsIDddLFxuICBjLFxuICBbMTUsIDNdLFxuICA2LFxuICA4LFxuICBjLFxuICBbNiwgNF0sXG4gIGMsXG4gIFsyMTUsIDVdLFxuICAzMCxcbiAgYyxcbiAgWzEzMiwgMTVdLFxuICBjLFxuICBbOTksIDQzXSxcbiAgMjcsXG4gIDYsXG4gIGMsXG4gIFsyODQ1LCAzXSxcbiAgYyxcbiAgWzcyNywgM10sXG4gIGMsXG4gIFs3MjUsIDVdLFxuICBjLFxuICBbNzIxLCA3XSxcbiAgODIsXG4gIDEwNixcbiAgMTUyLFxuICBjLFxuICBbNjYsIDQzXSxcbiAgMTEsXG4gIDE4LFxuICBjLFxuICBbNjYwLCA2XSxcbiAgMTEsXG4gIDE4LFxuICAxMSxcbiAgMTgsXG4gIDExLFxuICAxOCxcbiAgOCxcbiAgYyxcbiAgWzQxNywgMjFdLFxuICBjLFxuICBbNDg0LCA0Nl0sXG4gIDQxLFxuICA0NCxcbiAgNDUsXG4gIDEsXG4gIDI4LFxuICA3NSxcbiAgMTQ5LFxuICAyOCxcbiAgYyxcbiAgWzQ3MCwgM10sXG4gIGMsXG4gIFszMDgsIDVdLFxuICBjLFxuICBbMjM1MywgOTBdLFxuICBjLFxuICBbNDMsIDgyXSxcbiAgYyxcbiAgWzY0MywgMjFdLFxuICA0MixcbiAgMzAsXG4gIDQ1LFxuICAzMSxcbiAgMzQsXG4gIGMsXG4gIFs0MjAsIDE1XSxcbiAgYyxcbiAgWzMwMSwgM10sXG4gIHMsXG4gIFsxMSwgM10sXG4gIDQxLFxuICA0MyxcbiAgNDQsXG4gIGMsXG4gIFsxMTg4LCA3XSxcbiAgYyxcbiAgWzMwNiwgNThdLFxuICBjLFxuICBbNjQsIDY0XSxcbiAgMzAsXG4gIDMwLFxuICBjLFxuICBbNDUsIDQ1XSxcbiAgYyxcbiAgWzE0MDgsIDQyXSxcbiAgMTEsXG4gIGMsXG4gIFsxNTQsIDIxXSxcbiAgYyxcbiAgWzI0MywgMjVdLFxuICA0MSxcbiAgNDUsXG4gIDQ2LFxuICBjLFxuICBbMTU0MSwgNDFdLFxuICBjLFxuICBbMTM1LCAzN10sXG4gIGMsXG4gIFs4MTMsIDddLFxuICA0MSxcbiAgNDMsXG4gIGMsXG4gIFsxMTIsIDIzXSxcbiAgYyxcbiAgWzEzNywgM10sXG4gIGMsXG4gIFs3MSwgMjJdLFxuICAzMCxcbiAgYyxcbiAgWzUxLCAyNF0sXG4gIGMsXG4gIFs0NywgMjFdLFxuICBjLFxuICBbNDUsIDNdLFxuICAzMFxuXSksXG4gIHR5cGU6IHUoW1xuICBzLFxuICBbMiwgM10sXG4gIHMsXG4gIFswLCAxMl0sXG4gIDEsXG4gIHMsXG4gIFsyLCA0XSxcbiAgcyxcbiAgWzAsIDEwXSxcbiAgYyxcbiAgWzEzLCAxMV0sXG4gIHMsXG4gIFsyLCA5XSxcbiAgYyxcbiAgWzE3LCAxMF0sXG4gIGMsXG4gIFszNiwgMjJdLFxuICBjLFxuICBbNywgM10sXG4gIDAsXG4gIDIsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzQ1LCAxMV0sXG4gIGMsXG4gIFsxMCwgNl0sXG4gIGMsXG4gIFs2LCA5XSxcbiAgcyxcbiAgWzIsIDU4XSxcbiAgYyxcbiAgWzY5LCA3XSxcbiAgYyxcbiAgWzkyLCAxMF0sXG4gIGMsXG4gIFsxMDQsIDRdLFxuICBjLFxuICBbMTQyLCAxMF0sXG4gIGMsXG4gIFszOSwgMTNdLFxuICBjLFxuICBbMjAzLCAxNF0sXG4gIGMsXG4gIFsxOTgsIDE0XSxcbiAgYyxcbiAgWzMzLCAzMl0sXG4gIGMsXG4gIFs5MSwgOF0sXG4gIGMsXG4gIFsxMSwgOF0sXG4gIGMsXG4gIFsxODcsIDEwXSxcbiAgYyxcbiAgWzM0LCA3XSxcbiAgYyxcbiAgWzU1LCAyMV0sXG4gIGMsXG4gIFsyMCwgMThdLFxuICBjLFxuICBbMzE3LCAxNl0sXG4gIGMsXG4gIFs2NiwgN10sXG4gIGMsXG4gIFsxMDgsIDE3XSxcbiAgYyxcbiAgWzE2NCwgMjJdLFxuICBjLFxuICBbMjIsIDIwXSxcbiAgYyxcbiAgWzUzLCAyM10sXG4gIGMsXG4gIFs0MywgMjZdLFxuICBjLFxuICBbMTAzLCAxOF0sXG4gIGMsXG4gIFsxMjAsIDQ3XSxcbiAgYyxcbiAgWzgzLCAxNV0sXG4gIGMsXG4gIFsyNzIsIDYyXSxcbiAgYyxcbiAgWzQ2LCA0NF0sXG4gIGMsXG4gIFsyNiwgMjNdLFxuICBjLFxuICBbNDcsIDIyXSxcbiAgYyxcbiAgWzExNiwgMjZdLFxuICBjLFxuICBbMjU4LCA5XSxcbiAgYyxcbiAgWzUwNCwgMTJdLFxuICBjLFxuICBbMzMyLCAxNl0sXG4gIGMsXG4gIFszNDcsIDI1XSxcbiAgYyxcbiAgWzEzNSwgN10sXG4gIGMsXG4gIFs2OTYsIDI2XSxcbiAgYyxcbiAgWzQxMSwgNTldLFxuICBjLFxuICBbNDMsIDQwXSxcbiAgYyxcbiAgWzc2LCAzN10sXG4gIGMsXG4gIFsxNDcsIDI4XSxcbiAgYyxcbiAgWzg2MSwgNDNdLFxuICBjLFxuICBbMjksIDI3XSxcbiAgYyxcbiAgWzY0NiwgNjBdLFxuICBjLFxuICBbMTI4LCAzN10sXG4gIGMsXG4gIFsxMDQ0LCA1NV0sXG4gIHMsXG4gIFsyLCAxMDZdLFxuICBjLFxuICBbMjIwLCAyNF0sXG4gIHMsXG4gIFswLCAyOV0sXG4gIGMsXG4gIFsxMTk1LCA5XSxcbiAgYyxcbiAgWzU1NiwgNTldLFxuICBjLFxuICBbNjYwLCAyMV0sXG4gIGMsXG4gIFs2NjcsIDldLFxuICBjLFxuICBbOTM0LCAxM10sXG4gIGMsXG4gIFs5MTMsIDQ2XSxcbiAgYyxcbiAgWzQxLCA1N10sXG4gIGMsXG4gIFsxOTMsIDIyXSxcbiAgYyxcbiAgWzYyLCA2MV0sXG4gIGMsXG4gIFs5MjEsIDI1XSxcbiAgYyxcbiAgWzMxNywgN10sXG4gIGMsXG4gIFs4MjksIDkzXSxcbiAgYyxcbiAgWzcxNSwgNDFdLFxuICBjLFxuICBbMTUsIDI5XSxcbiAgYyxcbiAgWzc1OSwgMjBdLFxuICBjLFxuICBbNzksIDE4XSxcbiAgYyxcbiAgWzU3NiwgNDldLFxuICBjLFxuICBbMzYsIDE3XSxcbiAgYyxcbiAgWzE0OTQsIDE5XSxcbiAgYyxcbiAgWzI2LCAxMF0sXG4gIGMsXG4gIFsyOCwgMzJdLFxuICBjLFxuICBbMTk1MywgOF0sXG4gIGMsXG4gIFsxNiwgOV0sXG4gIGMsXG4gIFszNDYsIDQ1XSxcbiAgYyxcbiAgWzQ1LCAyNl0sXG4gIGMsXG4gIFsyMDIxLCAxMF0sXG4gIGMsXG4gIFs4NCwgMTBdLFxuICBjLFxuICBbNTQ0LCA4Nl0sXG4gIGMsXG4gIFsxMTMwLCAzOV0sXG4gIGMsXG4gIFsxMTgzLCA1NV0sXG4gIGMsXG4gIFsxNDQ5LCA1MF0sXG4gIGMsXG4gIFs4MiwgMjNdLFxuICBjLFxuICBbMTI4LCAzNF0sXG4gIGMsXG4gIFs3MzYsIDhdLFxuICBjLFxuICBbMTQxMCwgMzFdLFxuICBjLFxuICBbNDAxLCAzMF0sXG4gIGMsXG4gIFszNjcsIDRdLFxuICBjLFxuICBbMjUzLCA2Ml0sXG4gIGMsXG4gIFs0NCwgMzBdLFxuICBjLFxuICBbMjE3NSwgNjFdLFxuICBjLFxuICBbMTg4LCAzNF0sXG4gIGMsXG4gIFs1NTEsIDIzXSxcbiAgYyxcbiAgWzEwNjIsIDQxXSxcbiAgYyxcbiAgWzEwMDEsIDQ1XSxcbiAgcyxcbiAgWzAsIDMwXSxcbiAgYyxcbiAgWzgyOSwgMTFdLFxuICBjLFxuICBbNDAyLCAxMV0sXG4gIGMsXG4gIFsyNjIsIDEzXSxcbiAgYyxcbiAgWzEzLCAxMl0sXG4gIGMsXG4gIFsxMDk3LCA1OV0sXG4gIGMsXG4gIFsyNjUsIDE4XSxcbiAgYyxcbiAgWzI4NDcsIDI2XSxcbiAgYyxcbiAgWzE5MTEsIDY1XSxcbiAgYyxcbiAgWzQ0OCwgNTJdLFxuICBjLFxuICBbMTI1NSwgMTddLFxuICBjLFxuICBbNDg0LCA2NF0sXG4gIGMsXG4gIFsyOTk4LCAxMV0sXG4gIGMsXG4gIFsyMzUzLCA5N10sXG4gIGMsXG4gIFs0MywgODFdLFxuICBjLFxuICBbMzU2LCAzM10sXG4gIGMsXG4gIFs4NTIsIDMzXSxcbiAgYyxcbiAgWzExNSwgNjNdLFxuICBjLFxuICBbNTE1LCA2MV0sXG4gIGMsXG4gIFs0NSwgMzZdLFxuICBjLFxuICBbMTQwOCwgNDNdLFxuICBjLFxuICBbNzI1LCA0MV0sXG4gIGMsXG4gIFsyNCwgMjldLFxuICBjLFxuICBbMTM1LCA1N10sXG4gIGMsXG4gIFs4OCwgMzFdLFxuICBjLFxuICBbNDMyLCAzMF0sXG4gIGMsXG4gIFsxODg0LCAzNV0sXG4gIGMsXG4gIFsyMSwgNV1cbl0pLFxuICBzdGF0ZTogdShbXG4gIDEsXG4gIDIsXG4gIDUsXG4gIDQsXG4gIDMsXG4gIDYsXG4gIDEwLFxuICAxMSxcbiAgMTIsXG4gIDgsXG4gIDEzLFxuICAxNCxcbiAgMTksXG4gIDE3LFxuICAxNixcbiAgYyxcbiAgWzEwLCA3XSxcbiAgMjAsXG4gIDIyLFxuICBjLFxuICBbOCwgNl0sXG4gIDI4LFxuICAzMCxcbiAgMjksXG4gIDMxLFxuICAzMyxcbiAgMzcsXG4gIDM2LFxuICAzNSxcbiAgNDEsXG4gIDQ0LFxuICA0NSxcbiAgNDAsXG4gIDQyLFxuICA0MyxcbiAgNDgsXG4gIGMsXG4gIFsyMiwgN10sXG4gIDUzLFxuICA1MixcbiAgNTQsXG4gIDU1LFxuICA1NixcbiAgNjMsXG4gIDYwLFxuICA2MixcbiAgMzcsXG4gIDM2LFxuICA2MSxcbiAgMzUsXG4gIDY0LFxuICA2NyxcbiAgNjgsXG4gIDY5LFxuICA2NyxcbiAgNjgsXG4gIDc2LFxuICA3NSxcbiAgODAsXG4gIDc5LFxuICA4MixcbiAgODEsXG4gIDgzLFxuICA4NyxcbiAgODgsXG4gIDg5LFxuICA5MSxcbiAgYyxcbiAgWzQ2LCAzXSxcbiAgOTIsXG4gIGMsXG4gIFs0LCAzXSxcbiAgOTcsXG4gIDY4LFxuICA5OSxcbiAgMTAwLFxuICAxMDIsXG4gIDEzLFxuICAxNCxcbiAgMTAzLFxuICAxMDQsXG4gIDExMCxcbiAgMTExLFxuICAxMDUsXG4gIDEwNixcbiAgNDIsXG4gIDQzLFxuICAxMDEsXG4gIDk4LFxuICAxMDgsXG4gIDk3LFxuICA2OCxcbiAgMTIwLFxuICBjLFxuICBbMTgsIDEzXSxcbiAgMTE5LFxuICAxMDgsXG4gIDEyNixcbiAgMTI3LFxuICAxMjksXG4gIDEyOCxcbiAgMTMwLFxuICAxMzIsXG4gIDEzMyxcbiAgODcsXG4gIDg4LFxuICAxMzYsXG4gIDg3LFxuICA4OCxcbiAgMTQyLFxuICAxNDUsXG4gIGMsXG4gIFsyOSwgMTNdLFxuICAxMDgsXG4gIDE0NixcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDE0NyxcbiAgMTQ4LFxuICA4NyxcbiAgMTUwLFxuICA0NCxcbiAgNDUsXG4gIDg4LFxuICAxNTQsXG4gIDE1OCxcbiAgMTU3LFxuICAzNyxcbiAgMzYsXG4gIDE1NixcbiAgMzUsXG4gIDE2MCxcbiAgYyxcbiAgWzQzLCAxM10sXG4gIDE1OSxcbiAgMTA4LFxuICAxNjIsXG4gIGMsXG4gIFs0NCwgMTNdLFxuICBzLFxuICBbMTYzLCA1LCAxXSxcbiAgcyxcbiAgWzE4MCwgNCwgMV0sXG4gIDE3NyxcbiAgMTY4LFxuICAxNjksXG4gIDE4NCxcbiAgMTkwLFxuICAxODksXG4gIDE5MSxcbiAgMTk2LFxuICAxOTcsXG4gIDE3NixcbiAgMTc1LFxuICAxODUsXG4gIDE4OCxcbiAgNDUsXG4gIDE3NCxcbiAgMTg2LFxuICA0MyxcbiAgMTczLFxuICAxOTMsXG4gIDIwNSxcbiAgMjA2LFxuICBzLFxuICBbMjA4LCA1LCAxXSxcbiAgMTk2LFxuICAxOTcsXG4gIDIwNyxcbiAgMTkzLFxuICAyMTQsXG4gIGMsXG4gIFs2OSwgMTNdLFxuICAyMTMsXG4gIGMsXG4gIFs2OSwgMTVdLFxuICAyMTYsXG4gIGMsXG4gIFsxMTEsIDNdLFxuICAyMjMsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjI0LFxuICBjLFxuICBbMTU0LCAzXSxcbiAgMjI5LFxuICBjLFxuICBbMTU0LCAxNF0sXG4gIDIzMCxcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDE0MixcbiAgMjMzLFxuICBjLFxuICBbMzAsIDE0XSxcbiAgMjM0LFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMTQ4LFxuICA4NyxcbiAgODgsXG4gIDIzNSxcbiAgYyxcbiAgWzMyLCAxNF0sXG4gIDIzNixcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDIzNyxcbiAgODgsXG4gIGMsXG4gIFsxMTksIDE0XSxcbiAgMTQyLFxuICAyNDMsXG4gIDI0MixcbiAgMjQ3LFxuICBjLFxuICBbMTE4LCAzXSxcbiAgYyxcbiAgWzIxLCAxNF0sXG4gIDI0OSxcbiAgNDIsXG4gIDQzLFxuICAyNTEsXG4gIDI1MixcbiAgMjU0LFxuICAyNTUsXG4gIDI3MCxcbiAgYyxcbiAgWzIxNiwgMjddLFxuICAyNzEsXG4gIGMsXG4gIFsyOCwgMjddLFxuICAyNzIsXG4gIGMsXG4gIFsyNCwgNF0sXG4gIDI3NCxcbiAgYyxcbiAgWzIyLCA2XSxcbiAgMjc1LFxuICAyNzcsXG4gIGMsXG4gIFsyMiwgM10sXG4gIDI3NixcbiAgYyxcbiAgWzIyLCA0XSxcbiAgMjgwLFxuICAyNzksXG4gIDI4NyxcbiAgMjg2LFxuICAyOTEsXG4gIDI5MCxcbiAgMjkyLFxuICAyOTMsXG4gIDg4LFxuICAyOTQsXG4gIGMsXG4gIFs1OSwgMjddLFxuICAyOTYsXG4gIDI5OCxcbiAgMzA0LFxuICAzMDYsXG4gIDMwMyxcbiAgNDQsXG4gIDQ1LFxuICAzMDUsXG4gIDQyLFxuICA0MyxcbiAgMzEwLFxuICAzMTEsXG4gIGMsXG4gIFszOSwgMjddLFxuICAzMTMsXG4gIDMxNCxcbiAgMzE3LFxuICAzMTYsXG4gIDMxNSxcbiAgMzE4LFxuICA4OCxcbiAgMzE5LFxuICBjLFxuICBbMzUsIDI3XSxcbiAgYyxcbiAgWzIxMCwgMTRdLFxuICAzMjIsXG4gIDQ0LFxuICA0NSxcbiAgMzI0LFxuICAxMjksXG4gIDEyOCxcbiAgMzI1LFxuICBjLFxuICBbMjM0LCAzXSxcbiAgMzI2LFxuICBjLFxuICBbNCwgM10sXG4gIDE0MixcbiAgMzMwLFxuICBjLFxuICBbMjkxLCAxNF0sXG4gIDMzMSxcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDMzMixcbiAgYyxcbiAgWzI5LCAxNF0sXG4gIDMzMyxcbiAgYyxcbiAgWzE0LCAxM10sXG4gIGMsXG4gIFs4NywgMTRdLFxuICAzMzYsXG4gIGMsXG4gIFs0MywgMTRdLFxuICAzMzcsXG4gIGMsXG4gIFs0MywgMjddLFxuICBjLFxuICBbMTQsIDE0XSxcbiAgYyxcbiAgWzY0OSwgNF0sXG4gIDM0NSxcbiAgNDIsXG4gIDQzLFxuICAzNDgsXG4gIDM0OSxcbiAgYyxcbiAgWzE5NCwgMjddLFxuICAzNTAsXG4gIGMsXG4gIFszMjcsIDIxXSxcbiAgMzU0LFxuICBjLFxuICBbNTAsIDI3XSxcbiAgMjkxLFxuICAyOTAsXG4gIDI4NyxcbiAgMjg2LFxuICAyODAsXG4gIDI3OSxcbiAgMzYwLFxuICAzNTcsXG4gIDM2NCxcbiAgMzYyLFxuICAzNTYsXG4gIDM2NyxcbiAgMzY2LFxuICAzNjEsXG4gIDM2MyxcbiAgMzY1LFxuICAxNTAsXG4gIDE4OCxcbiAgNDUsXG4gIDM2OCxcbiAgMTg2LFxuICA0MyxcbiAgMzU4LFxuICAzNjksXG4gIDM3MSxcbiAgYyxcbiAgWzMzMiwgMjhdLFxuICAzNjQsXG4gIDM2MixcbiAgMzcyLFxuICBjLFxuICBbNDUsIDVdLFxuICAzNzMsXG4gIGMsXG4gIFs0MywgNF0sXG4gIDM3NSxcbiAgYyxcbiAgWzYxLCA0XSxcbiAgMzc2LFxuICBjLFxuICBbNjEsIDEyXSxcbiAgMzc3LFxuICAzNzgsXG4gIGMsXG4gIFsxOSwgNF0sXG4gIDM3OSxcbiAgYyxcbiAgWzE5LCAxMl0sXG4gIDM4MCxcbiAgMzgxLFxuICBzLFxuICBbMzg0LCA5LCAxXSxcbiAgMzk1LFxuICBjLFxuICBbODksIDI3XSxcbiAgMjk4LFxuICA0MDQsXG4gIGMsXG4gIFs3NjMsIDldLFxuICA0MDUsXG4gIDQ0LFxuICA0NSxcbiAgNDA4LFxuICA0MDcsXG4gIDQxMSxcbiAgNDEwLFxuICA0MTIsXG4gIGMsXG4gIFszMDMsIDE0XSxcbiAgNDEzLFxuICBjLFxuICBbMzAzLCA0MV0sXG4gIGMsXG4gIFsxNCwgMTRdLFxuICA0MjYsXG4gIGMsXG4gIFsxMTcsIDI3XSxcbiAgNDMxLFxuICA0MzAsXG4gIDQyNyxcbiAgMjU1LFxuICA0MzIsXG4gIGMsXG4gIFszMiwgMjddLFxuICAzNjAsXG4gIDM1NyxcbiAgYyxcbiAgWzUxMiwgM10sXG4gIDQzNyxcbiAgYyxcbiAgWzMyNCwgMzNdLFxuICA0NDIsXG4gIGMsXG4gIFszNCwgMjddLFxuICA0NDMsXG4gIDg4LFxuICA0NDUsXG4gIDQ0OSxcbiAgYyxcbiAgWzMxLCAyN10sXG4gIDQ1MSxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDQ1MixcbiAgYyxcbiAgWzY5NSwgM10sXG4gIDQ1MyxcbiAgYyxcbiAgWzMyLCAyN10sXG4gIDQ1NCxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDQ1NSxcbiAgODgsXG4gIDQ1NixcbiAgYyxcbiAgWzMxOSwgMTRdLFxuICA0NjAsXG4gIDI5MyxcbiAgYyxcbiAgWzk3MiwgMTVdLFxuICA0NzEsXG4gIGMsXG4gIFs1NjEsIDIxXSxcbiAgMzYwLFxuICA0NzMsXG4gIGMsXG4gIFs4NSwgNl0sXG4gIDM1NyxcbiAgYyxcbiAgWzg2LCAxM10sXG4gIDQ3NCxcbiAgYyxcbiAgWzg2LCA3XSxcbiAgNDc1LFxuICA0NzYsXG4gIDQzMSxcbiAgNDMwLFxuICA0NzgsXG4gIGMsXG4gIFsyNzUsIDNdLFxuICA0NzksXG4gIGMsXG4gIFs0LCAzXSxcbiAgNDgxLFxuICBjLFxuICBbNCwgM10sXG4gIDQ4MixcbiAgYyxcbiAgWzQsIDNdLFxuICA0ODMsXG4gIGMsXG4gIFs0LCAzXSxcbiAgNDg1LFxuICBjLFxuICBbODU5LCAzNV0sXG4gIDQ5MCxcbiAgYyxcbiAgWzExOSwgNl0sXG4gIDQ5MixcbiAgMTMsXG4gIDE0LFxuICA0OTQsXG4gIDEzLFxuICAxNCxcbiAgNDMxLFxuICA0MzAsXG4gIDQ5OSxcbiAgYyxcbiAgWzUxLCAyN10sXG4gIDI0MyxcbiAgMjk2LFxuICAyNDIsXG4gIDUwMSxcbiAgYyxcbiAgWzQzOCwgMjldLFxuICA1MTEsXG4gIGMsXG4gIFsyMjAsIDE0XSxcbiAgNTEyLFxuICBjLFxuICBbNDUsIDI3XSxcbiAgNTEzLFxuICA4OCxcbiAgNTE2LFxuICA1MTUsXG4gIDUyMSxcbiAgYyxcbiAgWzE2MywgM10sXG4gIDUyMixcbiAgYyxcbiAgWzM2LCAyN10sXG4gIDUyMyxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUyNCxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUyNSxcbiAgYyxcbiAgWzExMDYsIDQxXSxcbiAgNDMxLFxuICA0MzAsXG4gIDU0MSxcbiAgYyxcbiAgWzE3OSwgMTRdLFxuICA1NDIsXG4gIGMsXG4gIFs1OSwgMjddLFxuICA1NDMsXG4gIGMsXG4gIFs0MywgMTRdLFxuICA1NDQsXG4gIGMsXG4gIFs0MywgMjddLFxuICA1NDcsXG4gIGMsXG4gIFsxMzAsIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDU1NSxcbiAgYyxcbiAgWzk5LCAxNF0sXG4gIDU1OCxcbiAgYyxcbiAgWzE1LCAxNF0sXG4gIDU2MCxcbiAgYyxcbiAgWzE1LCAxNF0sXG4gIGMsXG4gIFs4NzYsIDM2XSxcbiAgNTY2LFxuICBjLFxuICBbMTUsIDZdLFxuICA1NjgsXG4gIGMsXG4gIFs1OCwgMjhdLFxuICA1NzYsXG4gIGMsXG4gIFsyOSwgMjhdXG5dKSxcbiAgbW9kZTogdShbXG4gIHMsXG4gIFsxLCAyNl0sXG4gIDIsXG4gIDIsXG4gIGMsXG4gIFsxNywgMTddLFxuICBzLFxuICBbMiwgOF0sXG4gIGMsXG4gIFsxMSwgMTFdLFxuICBzLFxuICBbMiwgMThdLFxuICBjLFxuICBbMjksIDE5XSxcbiAgMSxcbiAgYyxcbiAgWzc1LCAzXSxcbiAgYyxcbiAgWzc4LCAxNF0sXG4gIGMsXG4gIFs5MywgOF0sXG4gIGMsXG4gIFs3LCA4XSxcbiAgYyxcbiAgWzE2LCA3XSxcbiAgYyxcbiAgWzExNSwgMTZdLFxuICBjLFxuICBbMTU4LCAyOF0sXG4gIGMsXG4gIFsxMDUsIDhdLFxuICBjLFxuICBbNzYsIDddLFxuICBjLFxuICBbNTksIDhdLFxuICBjLFxuICBbNjcsIDIwXSxcbiAgYyxcbiAgWzE0OSwgMTBdLFxuICBjLFxuICBbMjMsIDE0XSxcbiAgYyxcbiAgWzUxLCAxNl0sXG4gIGMsXG4gIFs3NywgOV0sXG4gIHMsXG4gIFsxLCA2M10sXG4gIGMsXG4gIFsyNjIsIDEzXSxcbiAgYyxcbiAgWzEyMywgOV0sXG4gIGMsXG4gIFsxMjksIDddLFxuICBjLFxuICBbMTc1LCAxNF0sXG4gIGMsXG4gIFs0NCwgNl0sXG4gIGMsXG4gIFsxNiwgN10sXG4gIGMsXG4gIFsxNjMsIDE4XSxcbiAgYyxcbiAgWzEwOSwgMzddLFxuICBjLFxuICBbMjI0LCAxMV0sXG4gIGMsXG4gIFszOTgsIDIyXSxcbiAgYyxcbiAgWzQwMywgMjFdLFxuICBjLFxuICBbMjcsIDUwXSxcbiAgYyxcbiAgWzIzMSwgMTldLFxuICBjLFxuICBbNDk4LCAyNl0sXG4gIHMsXG4gIFsyLCAzMV0sXG4gIGMsXG4gIFszMywgMzNdLFxuICBjLFxuICBbMzYsIDIxXSxcbiAgYyxcbiAgWzIzMSwgMzBdLFxuICBjLFxuICBbMjUsIDYyXSxcbiAgYyxcbiAgWzQ3OSwgNDZdLFxuICBjLFxuICBbNjg0LCA0NF0sXG4gIGMsXG4gIFs3MjIsIDQ5XSxcbiAgYyxcbiAgWzYzLCA1NF0sXG4gIGMsXG4gIFsxNDYsIDNdLFxuICBjLFxuICBbNjIyLCAxMl0sXG4gIGMsXG4gIFsxMywgMTZdLFxuICBjLFxuICBbMjUxLCAxNl0sXG4gIHMsXG4gIFsxLCA5N10sXG4gIGMsXG4gIFs3MjgsIDVdLFxuICBjLFxuICBbMjcyLCA2MF0sXG4gIGMsXG4gIFs3OTIsIDddLFxuICBjLFxuICBbMTA1MSwgN10sXG4gIGMsXG4gIFsxODAsIDQ4XSxcbiAgYyxcbiAgWzQyMCwgOF0sXG4gIGMsXG4gIFsxMzUsIDYzXSxcbiAgYyxcbiAgWzI5NSwgOThdLFxuICBjLFxuICBbNDI4LCAxMl0sXG4gIGMsXG4gIFs2MSwgNzddLFxuICBjLFxuICBbNTA0LCAxNl0sXG4gIGMsXG4gIFs5NiwgMjNdLFxuICBjLFxuICBbMTE3LCAzM10sXG4gIGMsXG4gIFszMjAsIDc5XSxcbiAgYyxcbiAgWzI0MSwgNjFdLFxuICBzLFxuICBbMSwgMTI2XVxuXSksXG4gIGdvdG86IHUoW1xuICAxNSxcbiAgOSxcbiAgNyxcbiAgMTgsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjEsXG4gIDE1LFxuICA3LFxuICBzLFxuICBbMjMsIDUsIDFdLFxuICAzMixcbiAgMzQsXG4gIDM4LFxuICAzOSxcbiAgNDYsXG4gIDQ3LFxuICA0OSxcbiAgMTUsXG4gIDcsXG4gIDUwLFxuICA1MSxcbiAgMjAxLFxuICAyMDEsXG4gIDM5LFxuICAzNCxcbiAgMzksXG4gIDM4LFxuICA1NyxcbiAgNTgsXG4gIDU5LFxuICAzOCxcbiAgMzksXG4gIDY1LFxuICA2NixcbiAgMzgsXG4gIDcwLFxuICA3MSxcbiAgMzgsXG4gIHMsXG4gIFsxOTEsIDEwXSxcbiAgNzIsXG4gIHMsXG4gIFsxOTEsIDE4XSxcbiAgcyxcbiAgWzE4NiwgMTBdLFxuICA3MyxcbiAgcyxcbiAgWzE4NiwgMThdLFxuICA3NCxcbiAgMjAzLFxuICA3NyxcbiAgNzgsXG4gIDIwOSxcbiAgNzcsXG4gIDg2LFxuICA4NSxcbiAgNzcsXG4gIDg0LFxuICAzOCxcbiAgOTAsXG4gIDM4LFxuICAzOSxcbiAgMzgsXG4gIDM5LFxuICA5MyxcbiAgOTQsXG4gIDE5NSxcbiAgMTk1LFxuICA1OSxcbiAgOTUsXG4gIDk2LFxuICAzOCxcbiAgMTUsXG4gIDExNCxcbiAgMjI0LFxuICAxMDcsXG4gIDEwOSxcbiAgMTEyLFxuICAxMTMsXG4gIDExNixcbiAgMTE1LFxuICBzLFxuICBbODUsIDNdLFxuICAxMTcsXG4gIDExOCxcbiAgYyxcbiAgWzE1LCAzXSxcbiAgMjI4LFxuICBjLFxuICBbMTUsIDRdLFxuICBzLFxuICBbMTIxLCA1LCAxXSxcbiAgMzgsXG4gIDM5LFxuICA5MCxcbiAgMTMxLFxuICA4NixcbiAgMTM1LFxuICAxMzQsXG4gIDM4LFxuICAxMzksXG4gIDEzOCxcbiAgMTM3LFxuICAzOCxcbiAgMTQ0LFxuICAxNDEsXG4gIDE0MCxcbiAgMTQzLFxuICAxNSxcbiAgMTE0LFxuICBjLFxuICBbMjcsIDRdLFxuICBjLFxuICBbNiwgNl0sXG4gIDEzOSxcbiAgMTQ5LFxuICAxNTEsXG4gIDE1MixcbiAgcyxcbiAgWzY2LCAzXSxcbiAgMTUzLFxuICBzLFxuICBbNjYsIDRdLFxuICAxOTMsXG4gIDE5MyxcbiAgMTU1LFxuICAxOTMsXG4gIDE5MyxcbiAgMzgsXG4gIDM5LFxuICAxNSxcbiAgMTE0LFxuICAyMjIsXG4gIGMsXG4gIFsyNiwgNF0sXG4gIDE2MSxcbiAgMTUsXG4gIDExNCxcbiAgMjI1LFxuICBjLFxuICBbOCwgNF0sXG4gIDE5NSxcbiAgMTcwLFxuICAxOTQsXG4gIDE5MixcbiAgMTcyLFxuICAxODcsXG4gIDE3MSxcbiAgMTc4LFxuICAxNzksXG4gIDkwLFxuICAxOTgsXG4gIDE5OSxcbiAgMjAwLFxuICA0NixcbiAgNDcsXG4gIDE5MSxcbiAgMTkxLFxuICAyMDEsXG4gIHMsXG4gIFsxOTEsIDddLFxuICAyMDIsXG4gIDIwMyxcbiAgMjA0LFxuICAzOCxcbiAgMTk1LFxuICAxOTQsXG4gIDEwNyxcbiAgYyxcbiAgWzIzLCA0XSxcbiAgMTUsXG4gIDExNCxcbiAgMjI2LFxuICBjLFxuICBbNDMsIDRdLFxuICAyMTUsXG4gIDE1LFxuICAxMTQsXG4gIDIyOSxcbiAgYyxcbiAgWzgsIDRdLFxuICAyMTcsXG4gIDE1MixcbiAgMjE5LFxuICAyMTgsXG4gIDUwLFxuICA1MCxcbiAgMjIwLFxuICA1MixcbiAgNTIsXG4gIDIyMSxcbiAgMjIyLFxuICAyMTcsXG4gIDE1MixcbiAgMTM5LFxuICAyMjYsXG4gIDIyNSxcbiAgMzgsXG4gIDE0NCxcbiAgMjI4LFxuICAyMjcsXG4gIGMsXG4gIFsxMTgsIDEzXSxcbiAgMTQ0LFxuICAyMzIsXG4gIDIzMSxcbiAgYyxcbiAgWzEzNCwgMTVdLFxuICBjLFxuICBbMTc3LCAzXSxcbiAgYyxcbiAgWzE1LCAxMF0sXG4gIDM4LFxuICAxNSxcbiAgMjM4LFxuICBjLFxuICBbNywgNF0sXG4gIDIzOSxcbiAgMjQwLFxuICAxNDQsXG4gIDI0MSxcbiAgMTQzLFxuICBzLFxuICBbMjEzLCAzXSxcbiAgMjQ0LFxuICBzLFxuICBbMjEzLCA2XSxcbiAgcyxcbiAgWzE5MSwgM10sXG4gIDI0NSxcbiAgYyxcbiAgWzI4NCwgN10sXG4gIDI0NixcbiAgcyxcbiAgWzE4NiwgNV0sXG4gIDIxNyxcbiAgMTUyLFxuICAxOTcsXG4gIDE5NyxcbiAgNTksXG4gIDI0OCxcbiAgMTUsXG4gIDExNCxcbiAgMjIzLFxuICBjLFxuICBbNDUsIDRdLFxuICAxMTIsXG4gIDExMyxcbiAgMjUzLFxuICAyNTAsXG4gIHMsXG4gIFsxMTAsIDNdLFxuICAyNjUsXG4gIDExMCxcbiAgMjU4LFxuICAyNTYsXG4gIDExMCxcbiAgMjYyLFxuICAyNjMsXG4gIDI2NCxcbiAgMjY4LFxuICBzLFxuICBbMTEwLCA1XSxcbiAgMjU3LFxuICAyNTksXG4gIDI2MCxcbiAgMjYxLFxuICAyNjYsXG4gIDI2NyxcbiAgMjY5LFxuICBjLFxuICBbMTk1LCAxNV0sXG4gIGMsXG4gIFsxNSwgMTZdLFxuICAyNzMsXG4gIDE5NCxcbiAgMTkyLFxuICAxODcsXG4gIGMsXG4gIFsxMSwgNl0sXG4gIDI0MixcbiAgMjQyLFxuICAyODEsXG4gIDI0MixcbiAgMjQyLFxuICAyNzgsXG4gIHMsXG4gIFsyNDIsIDIwXSxcbiAgcyxcbiAgWzI0MywgNF0sXG4gIDI4MixcbiAgcyxcbiAgWzI0MywgNF0sXG4gIDI4MyxcbiAgcyxcbiAgWzI0MywgMTZdLFxuICAyNDAsXG4gIDI0MCxcbiAgMjgxLFxuICAyNDAsXG4gIDI0MCxcbiAgMjg0LFxuICBzLFxuICBbMjQwLCA0XSxcbiAgMjg1LFxuICBzLFxuICBbMjQwLCAxNl0sXG4gIDIzOCxcbiAgMjM4LFxuICAyODEsXG4gIDIzOCxcbiAgMjM4LFxuICAyODgsXG4gIHMsXG4gIFsyMzgsIDRdLFxuICAyODksXG4gIHMsXG4gIFsyMzgsIDE2XSxcbiAgMzgsXG4gIGMsXG4gIFsxMzMsIDE1XSxcbiAgcyxcbiAgWzIzNywgOF0sXG4gIDI5NSxcbiAgcyxcbiAgWzIzNywgMTZdLFxuICAyNDEsXG4gIDI0MSxcbiAgMjgxLFxuICBzLFxuICBbMjQxLCAyMl0sXG4gIHMsXG4gIFsxODcsIDEwXSxcbiAgMjk3LFxuICBzLFxuICBbMTg3LCAxNl0sXG4gIHMsXG4gIFsxODEsIDE5XSxcbiAgMzgsXG4gIHMsXG4gIFsxODEsIDddLFxuICBzLFxuICBbMTgyLCAxMF0sXG4gIDI5OSxcbiAgcyxcbiAgWzE4MiwgMTZdLFxuICBzLFxuICBbMjQ5LCA4XSxcbiAgMzAwLFxuICBzLFxuICBbMjQ5LCAxNl0sXG4gIHMsXG4gIFsyNDgsIDhdLFxuICAzMDEsXG4gIHMsXG4gIFsyNDgsIDE2XSxcbiAgcyxcbiAgWzI1MCwgOF0sXG4gIDMwMixcbiAgcyxcbiAgWzI1MCwgMTZdLFxuICAzMDcsXG4gIDMwOCxcbiAgYyxcbiAgWzM1OCwgNV0sXG4gIDMwOSxcbiAgYyxcbiAgWzIyNiwgMTJdLFxuICAzMTIsXG4gIDkwLFxuICAzOCxcbiAgMTIxLFxuICAxMjMsXG4gIGMsXG4gIFsyNDcsIDE2XSxcbiAgMzIwLFxuICBzLFxuICBbODQsIDNdLFxuICAzMjEsXG4gIDE1LFxuICAxMTQsXG4gIDIyNyxcbiAgYyxcbiAgWzU2NiwgNl0sXG4gIDMyMyxcbiAgMjQ1LFxuICAzOCxcbiAgMzksXG4gIDIxNyxcbiAgMTUyLFxuICAyMTcsXG4gIDE1MixcbiAgMzI3LFxuICAxNDQsXG4gIDMyOSxcbiAgMzI4LFxuICBjLFxuICBbNTQ0LCAxM10sXG4gIGMsXG4gIFs2LCAxM10sXG4gIDMzNCxcbiAgYyxcbiAgWzYsIDRdLFxuICAzMzUsXG4gIGMsXG4gIFsxOSwgMTNdLFxuICAzMzgsXG4gIGMsXG4gIFs2LCA0XSxcbiAgMzM5LFxuICAxNSxcbiAgMzQwLFxuICBjLFxuICBbNywgNF0sXG4gIDM0MSxcbiAgMzQyLFxuICAyMDMsXG4gIDIwNCxcbiAgcyxcbiAgWzIxNCwgM10sXG4gIDM0MyxcbiAgcyxcbiAgWzIxNCwgNl0sXG4gIDM0NCxcbiAgMzgsXG4gIDM5LFxuICAxMjIsXG4gIDEyNCxcbiAgMTEyLFxuICAxMTMsXG4gIDM0NixcbiAgMjUzLFxuICAzNDcsXG4gIGMsXG4gIFs1MDIsIDE2XSxcbiAgMzUxLFxuICBjLFxuICBbNTAyLCA5XSxcbiAgMzUyLFxuICAzNTMsXG4gIGMsXG4gIFsyOCwgMTVdLFxuICBjLFxuICBbNDQwLCA0XSxcbiAgMzU1LFxuICBjLFxuICBbNDM3LCA4XSxcbiAgYyxcbiAgWzQ4MCwgNF0sXG4gIDM1NSxcbiAgYyxcbiAgWzQ3NywgOF0sXG4gIGMsXG4gIFs1NDUsIDRdLFxuICAzNTUsXG4gIGMsXG4gIFs1MzEsIDExXSxcbiAgYyxcbiAgWzUyNywgN10sXG4gIDE5NSxcbiAgMzU5LFxuICAxOTQsXG4gIDE4NyxcbiAgOTAsXG4gIDQ2LFxuICA0NyxcbiAgMjgxLFxuICAxOTUsXG4gIDE3MCxcbiAgMzcwLFxuICBjLFxuICBbMTAxLCAxNF0sXG4gIGMsXG4gIFsyNCwgNV0sXG4gIDM3NCxcbiAgMzgsXG4gIGMsXG4gIFszMiwgN10sXG4gIDM4LFxuICAyODEsXG4gIGMsXG4gIFs5LCA5XSxcbiAgMzgzLFxuICAzODIsXG4gIHMsXG4gIFszOCwgNl0sXG4gIDI4MSxcbiAgMzk0LFxuICAzNTUsXG4gIDM5MyxcbiAgYyxcbiAgWzEyNiwgMTVdLFxuICAzOCxcbiAgMzk3LFxuICAzOTYsXG4gIDM5OCxcbiAgMzk5LFxuICA0MDAsXG4gIDQwMixcbiAgNDAxLFxuICA0MDMsXG4gIGMsXG4gIFs4NjEsIDddLFxuICAyMTcsXG4gIDE1MixcbiAgNDA2LFxuICA0MDksXG4gIDIwNSxcbiAgNDA5LFxuICAyMTEsXG4gIGMsXG4gIFsyNDEsIDEzXSxcbiAgNDE0LFxuICBjLFxuICBbNiwgNF0sXG4gIDQxNSxcbiAgMTUsXG4gIDQxNixcbiAgYyxcbiAgWzcsIDRdLFxuICA0MTcsXG4gIDQxOCxcbiAgMjAzLFxuICAyMDQsXG4gIDE1LFxuICA0MTksXG4gIGMsXG4gIFsxMCwgNF0sXG4gIDQyMCxcbiAgNDIxLFxuICAyMDMsXG4gIDIwNCxcbiAgNDIyLFxuICAyMDMsXG4gIDIwNCxcbiAgNDIzLFxuICA0MjQsXG4gIDQyNSxcbiAgYyxcbiAgWzgzLCAxNV0sXG4gIDExMyxcbiAgMTEzLFxuICAyODEsXG4gIDExMyxcbiAgMjY1LFxuICA0MjgsXG4gIDExMyxcbiAgMjU4LFxuICAyNTYsXG4gIDExMyxcbiAgNDI5LFxuICBjLFxuICBbNzk2LCA0XSxcbiAgcyxcbiAgWzExMywgNV0sXG4gIGMsXG4gIFs3OTYsIDIyXSxcbiAgNDMzLFxuICAyMTcsXG4gIDE1MixcbiAgNDM0LFxuICA0MzYsXG4gIDQzNSxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDMwMixcbiAgMjQ0LFxuICAyODEsXG4gIDM1NSxcbiAgMjg5LFxuICAyNDUsXG4gIDI4MSxcbiAgMzU1LFxuICAyODUsXG4gIDI0NixcbiAgMjk1LFxuICAyNDcsXG4gIDI4MyxcbiAgMzAwLFxuICAzMDEsXG4gIDI4MSxcbiAgMzU1LFxuICAzOTcsXG4gIDQzOCxcbiAgNDM5LFxuICAyOTksXG4gIDczLFxuICA0NDAsXG4gIDQ0MSxcbiAgYyxcbiAgWzE4NSwgMTZdLFxuICA0NDQsXG4gIDM5NCxcbiAgNDQ3LFxuICA0NDYsXG4gIDE5NSxcbiAgMTcwLFxuICA0NDgsXG4gIGMsXG4gIFsyMSwgMTNdLFxuICA0NTAsXG4gIGMsXG4gIFszNywgMTVdLFxuICA5MCxcbiAgYyxcbiAgWzUxNSwgMTZdLFxuICBjLFxuICBbNjksIDE2XSxcbiAgYyxcbiAgWzIyNiwgNl0sXG4gIDQ1NyxcbiAgNDU4LFxuICA0NTksXG4gIDM4LFxuICA0NjEsXG4gIDE1LFxuICA0NjIsXG4gIGMsXG4gIFsxMSwgNF0sXG4gIDQ2MyxcbiAgNDY0LFxuICAyMDMsXG4gIDIwNCxcbiAgNDY1LFxuICAyMDMsXG4gIDIwNCxcbiAgNDY2LFxuICA0NjcsXG4gIDIwMyxcbiAgMjA0LFxuICA0NjgsXG4gIDQ2OSxcbiAgNDcwLFxuICAxOTUsXG4gIDQ3MixcbiAgYyxcbiAgWzQ0MCwgOV0sXG4gIGMsXG4gIFs1OCwgMTZdLFxuICAyODEsXG4gIDQ3NyxcbiAgMTIwLFxuICAxMjAsXG4gIDI4MSxcbiAgMTIwLFxuICAzNTUsXG4gIDEyMCxcbiAgMTIwLFxuICA0MjksXG4gIHMsXG4gIFsxMjAsIDVdLFxuICBjLFxuICBbNTg2LCA0XSxcbiAgNDgwLFxuICBjLFxuICBbNSwgNF0sXG4gIDIxNyxcbiAgMTUyLFxuICA0NDcsXG4gIDQ4NCxcbiAgYyxcbiAgWzQ0LCAxNV0sXG4gIDQ4NixcbiAgNDg3LFxuICA0ODksXG4gIDQ4OCxcbiAgMTUsXG4gIDQ5MSxcbiAgYyxcbiAgWzMzMSwgNV0sXG4gIDM4MyxcbiAgNDkzLFxuICAxNSxcbiAgNDk1LFxuICAyMDMsXG4gIDIwNCxcbiAgNDk2LFxuICA0OTcsXG4gIDQ5OCxcbiAgMTE2LFxuICAxMTYsXG4gIDI4MSxcbiAgMTE2LFxuICAzNTUsXG4gIDExNixcbiAgMTE2LFxuICA0MjksXG4gIHMsXG4gIFsxMTYsIDVdLFxuICBjLFxuICBbNDgsIDE1XSxcbiAgNTAwLFxuICAyMTMsXG4gIDI4MSxcbiAgMjQxLFxuICAyNDQsXG4gIDIxMyxcbiAgcyxcbiAgWzI0MSwgMTRdLFxuICBjLFxuICBbMzUsIDE1XSxcbiAgNTAyLFxuICA1MDMsXG4gIDI4MSxcbiAgMzU1LFxuICA0MjksXG4gIDE2NSxcbiAgcyxcbiAgWzUwNCwgNywgMV0sXG4gIGMsXG4gIFsxOTcsIDZdLFxuICBjLFxuICBbMTYxLCAxNl0sXG4gIDIwMyxcbiAgNTE0LFxuICAyMDQsXG4gIDIwNyxcbiAgcyxcbiAgWzUxNywgNCwgMV0sXG4gIDIxNyxcbiAgMTUyLFxuICBjLFxuICBbMTE3MCwgMzFdLFxuICBjLFxuICBbMTUsIDI5XSxcbiAgMTUsXG4gIDUyNixcbiAgYyxcbiAgWzkyLCA0XSxcbiAgcyxcbiAgWzUyNywgNiwgMV0sXG4gIDExOCxcbiAgMTE4LFxuICAyODEsXG4gIDExOCxcbiAgMzU1LFxuICAxMTgsXG4gIDExOCxcbiAgNDI5LFxuICBzLFxuICBbMTE4LCA1XSxcbiAgNTM0LFxuICA1MzMsXG4gIHMsXG4gIFs1MzUsIDQsIDFdLFxuICAyMDMsXG4gIDUzOSxcbiAgNTQwLFxuICAyMDQsXG4gIGMsXG4gIFsxMjcsIDIxXSxcbiAgYyxcbiAgWzIxLCAyMV0sXG4gIDU0NSxcbiAgNTQ2LFxuICBjLFxuICBbMTcsIDE1XSxcbiAgNTQ4LFxuICA1NDksXG4gIDE1LFxuICA1NTAsXG4gIGMsXG4gIFs0MCwgNF0sXG4gIDU1MSxcbiAgMTUsXG4gIDU1MixcbiAgYyxcbiAgWzcsIDRdLFxuICA1NTMsXG4gIDU1NCxcbiAgYyxcbiAgWzU1LCA2XSxcbiAgMjAzLFxuICA1NTYsXG4gIDU1NyxcbiAgYyxcbiAgWzg2LCA3XSxcbiAgMjAzLFxuICAyMDQsXG4gIDU1OSxcbiAgYyxcbiAgWzY0NSwgN10sXG4gIDU2MSxcbiAgYyxcbiAgWzYsIDRdLFxuICA1NjIsXG4gIDU2MyxcbiAgMTUsXG4gIDU2NCxcbiAgYyxcbiAgWzgsIDRdLFxuICA1NjUsXG4gIGMsXG4gIFszMzUsIDZdLFxuICAyMDMsXG4gIDU2NyxcbiAgYyxcbiAgWzM5LCA4XSxcbiAgNTY5LFxuICA1NzAsXG4gIDIwNCxcbiAgNTcxLFxuICAxNSxcbiAgNTcyLFxuICBjLFxuICBbMTEsIDRdLFxuICA1NzMsXG4gIDU3NCxcbiAgMjAzLFxuICA1NzUsXG4gIGMsXG4gIFsyMiwgN10sXG4gIDU3NyxcbiAgMTUsXG4gIDU3OCxcbiAgYyxcbiAgWzI5LCA1XSxcbiAgNTc5LFxuICAyMDQsXG4gIDU4MFxuXSlcbn0pLFxuZGVmYXVsdEFjdGlvbnM6IGJkYSh7XG4gIGlkeDogdShbXG4gIDUsXG4gIDYsXG4gIDgsXG4gIHMsXG4gIFsxMCwgNSwgMV0sXG4gIDE4LFxuICAxOSxcbiAgMjEsXG4gIDIyLFxuICAyMyxcbiAgMjksXG4gIDMwLFxuICAzMSxcbiAgcyxcbiAgWzM1LCA1LCAxXSxcbiAgcyxcbiAgWzQyLCA0LCAxXSxcbiAgNDksXG4gIDUwLFxuICA1MSxcbiAgNTMsXG4gIDYxLFxuICA2MyxcbiAgNjYsXG4gIDY3LFxuICA3MSxcbiAgNzQsXG4gIDc2LFxuICA4MCxcbiAgODcsXG4gIHMsXG4gIFs5MCwgNCwgMV0sXG4gIDk2LFxuICA5NyxcbiAgcyxcbiAgWzEwMCwgNywgMV0sXG4gIHMsXG4gIFsxMDgsIDQsIDFdLFxuICAxMTgsXG4gIHMsXG4gIFsxMjEsIDQsIDFdLFxuICAxMjcsXG4gIDE0MyxcbiAgMTQ0LFxuICAxNDksXG4gIDE1NCxcbiAgMTU1LFxuICAxNTYsXG4gIDE1OCxcbiAgMTYyLFxuICAxNjQsXG4gIDE2NSxcbiAgMTY2LFxuICAxNjgsXG4gIDE2OSxcbiAgMTczLFxuICAxODAsXG4gIDE4MSxcbiAgMTgyLFxuICAxODQsXG4gIDE5MyxcbiAgcyxcbiAgWzE5NiwgNSwgMV0sXG4gIHMsXG4gIFsyMDYsIDcsIDFdLFxuICAyMTgsXG4gIDIyMixcbiAgMjM3LFxuICBzLFxuICBbMjM5LCA0LCAxXSxcbiAgMjQ3LFxuICAyNTAsXG4gIDI1MixcbiAgcyxcbiAgWzI1NSwgMTUsIDFdLFxuICAyNzIsXG4gIDI4MCxcbiAgMjg3LFxuICAyOTEsXG4gIDI5MyxcbiAgMjk0LFxuICAyOTYsXG4gIDI5OCxcbiAgMzA1LFxuICAzMDYsXG4gIDMwOSxcbiAgMzExLFxuICAzMTIsXG4gIDMxNCxcbiAgMzE2LFxuICAzMTcsXG4gIDMyNCxcbiAgMzI1LFxuICAzMjYsXG4gIDMzNSxcbiAgMzM5LFxuICAzNDEsXG4gIDM0NCxcbiAgcyxcbiAgWzM0NiwgNSwgMV0sXG4gIDM1OCxcbiAgMzYwLFxuICAzNjksXG4gIDM3MCxcbiAgMzc1LFxuICAzNzcsXG4gIDM3OCxcbiAgMzgwLFxuICAzODEsXG4gIHMsXG4gIFszODQsIDYsIDFdLFxuICAzOTMsXG4gIDM5NixcbiAgMzk4LFxuICA0MDQsXG4gIDQwNixcbiAgNDA4LFxuICA0MTEsXG4gIDQxNSxcbiAgNDE3LFxuICA0MjAsXG4gIDQyMyxcbiAgNDI0LFxuICA0MjUsXG4gIDQzMSxcbiAgNDM1LFxuICA0MzgsXG4gIDQ0MixcbiAgNDQzLFxuICBzLFxuICBbNDQ0LCA0LCAyXSxcbiAgNDUxLFxuICA0NTIsXG4gIDQ1MyxcbiAgNDU3LFxuICA0NTksXG4gIDQ2MyxcbiAgNDY2LFxuICA0NjgsXG4gIDQ2OSxcbiAgNDcxLFxuICA0NzUsXG4gIDQ3NixcbiAgNDc5LFxuICA0ODQsXG4gIDQ4NixcbiAgNDkwLFxuICA0OTMsXG4gIDQ5NixcbiAgNDk3LFxuICA0OTgsXG4gIDUwMSxcbiAgcyxcbiAgWzUwMiwgNSwgMl0sXG4gIDUxNSxcbiAgNTE2LFxuICA1MTksXG4gIHMsXG4gIFs1MzQsIDUsIDFdLFxuICA1NDUsXG4gIDU0NixcbiAgNTQ4LFxuICA1NTQsXG4gIDU2MixcbiAgNTY1LFxuICA1NjYsXG4gIDU3MSxcbiAgNTczLFxuICA1NzcsXG4gIDU4MFxuXSksXG4gIGdvdG86IHUoW1xuICA4LFxuICAyMyxcbiAgMjEsXG4gIDI1LFxuICAyNixcbiAgMjcsXG4gIDcwLFxuICA3MSxcbiAgNCxcbiAgOSxcbiAgNixcbiAgMjQsXG4gIDcsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE5LFxuICAxOTksXG4gIDIwMCxcbiAgMTkxLFxuICAxODYsXG4gIDE4NyxcbiAgMTg4LFxuICAxODIsXG4gIDE4MyxcbiAgMixcbiAgMyxcbiAgNSxcbiAgMjAyLFxuICAxNyxcbiAgMTk2LFxuICA3NSxcbiAgODAsXG4gIDc5LFxuICAxLFxuICAyMDQsXG4gIDIxMCxcbiAgNTcsXG4gIDE3NixcbiAgMTUsXG4gIDE0LFxuICAxNixcbiAgNzQsXG4gIDgxLFxuICA2NyxcbiAgNjksXG4gIHMsXG4gIFsyMTcsIDUsIDFdLFxuICA5MixcbiAgMTAyLFxuICAyMzIsXG4gIDIzMyxcbiAgNzgsXG4gIDE4OSxcbiAgMTg0LFxuICAxOTAsXG4gIDE4NSxcbiAgNDgsXG4gIDIxNSxcbiAgMjE2LFxuICA2MCxcbiAgMTAsXG4gIDE5NCxcbiAgMTgsXG4gIDE5OCxcbiAgNjgsXG4gIDEwNyxcbiAgMTA4LFxuICAxMDksXG4gIDExMSxcbiAgMTEyLFxuICAxMjEsXG4gIDIzNCxcbiAgMjM1LFxuICAyMzYsXG4gIDIzOSxcbiAgMTY4LFxuICAyNTEsXG4gIDI1MixcbiAgMTc3LFxuICAxNzgsXG4gIDE3OSxcbiAgODMsXG4gIDg2LFxuICAyMzAsXG4gIDIzMSxcbiAgMjQ4LFxuICAyNDksXG4gIDI1MCxcbiAgNDcsXG4gIDI4LFxuICA1OCxcbiAgNDUsXG4gIDQ2LFxuICA1OSxcbiAgNTQsXG4gIDY1LFxuICA4NyxcbiAgODksXG4gIDE5MixcbiAgcyxcbiAgWzI1NSwgMTQsIDFdLFxuICAxMTksXG4gIDEzNyxcbiAgMTM5LFxuICAxNDEsXG4gIDYzLFxuICAxNjcsXG4gIDEzNSxcbiAgMTgwLFxuICAxMjYsXG4gIDEyNyxcbiAgMTc0LFxuICAxMDUsXG4gIDE2OSxcbiAgMTcxLFxuICAyNTMsXG4gIDI1NCxcbiAgNDksXG4gIDUxLFxuICA1MyxcbiAgNDEsXG4gIDQzLFxuICA0NCxcbiAgNTYsXG4gIDczLFxuICA4OCxcbiAgOTAsXG4gIDkxLFxuICAxMTUsXG4gIDE2NCxcbiAgMTMwLFxuICAxMzYsXG4gIDEwMyxcbiAgMTQ2LFxuICAxNDcsXG4gIDEzOCxcbiAgMTUzLFxuICAxNDAsXG4gIDE1MSxcbiAgMTQ0LFxuICAxNDUsXG4gIDE0OCxcbiAgMTQ5LFxuICAxNTAsXG4gIDEyNSxcbiAgMTc1LFxuICAxNzAsXG4gIDgyLFxuICA3NyxcbiAgMjA2LFxuICAyMTIsXG4gIDM5LFxuICA0MCxcbiAgNDIsXG4gIDM3LFxuICA1NSxcbiAgNzIsXG4gIDE0MyxcbiAgMTI5LFxuICAxMDQsXG4gIDE2NixcbiAgNjQsXG4gIDEyMixcbiAgMTI0LFxuICAxMzIsXG4gIDEyOCxcbiAgMTA2LFxuICAxNzIsXG4gIDE3MyxcbiAgNzYsXG4gIDYxLFxuICAzOCxcbiAgMzMsXG4gIDM1LFxuICAzNixcbiAgMTE3LFxuICAxNTIsXG4gIDE0MixcbiAgMTMxLFxuICAxMjMsXG4gIDEzMyxcbiAgOTksXG4gIDYyLFxuICAzMSxcbiAgMzIsXG4gIDM0LFxuICAxMTQsXG4gIHMsXG4gIFsxNTQsIDQsIDJdLFxuICAxMzQsXG4gIDIwLFxuICAyMDgsXG4gIDMwLFxuICAxNjMsXG4gIHMsXG4gIFsxNTUsIDQsIDJdLFxuICAyMixcbiAgMjksXG4gIDkzLFxuICAxNjIsXG4gIDk0LFxuICAxMDAsXG4gIDEwMSxcbiAgOTYsXG4gIDk1LFxuICA5NyxcbiAgOThcbl0pXG59KSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlICYmIHR5cGVvZiB0aGlzLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICAgICAgaGFzaC5kZXN0cm95KCk7IC8vIGRlc3Ryb3kuLi4gd2VsbCwgKmFsbW9zdCohXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFFeGNlcHRpb25DbGFzcykge1xuICAgICAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uUGFyc2VyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaCk7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgICAvLyB0b2tlbiBzdGFjazogc3RvcmVzIHRva2VuIHdoaWNoIGxlYWRzIHRvIHN0YXRlIGF0IHRoZSBzYW1lIGluZGV4IChjb2x1bW4gc3RvcmFnZSlcbiAgICB2YXIgc3N0YWNrID0gbmV3IEFycmF5KDEyOCk7ICAgICAgICAvLyBzdGF0ZSBzdGFjazogc3RvcmVzIHN0YXRlcyAoY29sdW1uIHN0b3JhZ2UpXG5cbiAgICB2YXIgdnN0YWNrID0gbmV3IEFycmF5KDEyOCk7ICAgICAgICAvLyBzZW1hbnRpYyB2YWx1ZSBzdGFja1xuICAgIHZhciBsc3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIGxvY2F0aW9uIHN0YWNrXG4gICAgdmFyIHRhYmxlID0gdGhpcy50YWJsZTtcbiAgICB2YXIgc3AgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc3RhY2sgcG9pbnRlcic6IGluZGV4IGludG8gdGhlIHN0YWNrc1xuICAgIHZhciB5eWxvYztcblxuICAgIHZhciB5eWxpbmVubztcblxuXG4gICAgdmFyIHN5bWJvbCA9IDA7XG5cblxuXG4gICAgdmFyIFRFUlJPUiA9IHRoaXMuVEVSUk9SO1xuICAgIHZhciBFT0YgPSB0aGlzLkVPRjtcbiAgICB2YXIgRVJST1JfUkVDT1ZFUllfVE9LRU5fRElTQ0FSRF9DT1VOVCA9ICh0aGlzLm9wdGlvbnMuZXJyb3JSZWNvdmVyeVRva2VuRGlzY2FyZENvdW50IHwgMCkgfHwgMztcbiAgICB2YXIgTk9fQUNUSU9OID0gWzAsIDU4MSAvKiA9PT0gdGFibGUubGVuZ3RoIDo6IGVuc3VyZXMgdGhhdCBhbnlvbmUgdXNpbmcgdGhpcyBuZXcgc3RhdGUgd2lsbCBmYWlsIGRyYW1hdGljYWxseSEgKi9dO1xuXG4gICAgdmFyIGxleGVyO1xuICAgIGlmICh0aGlzLl9fbGV4ZXJfXykge1xuICAgICAgICBsZXhlciA9IHRoaXMuX19sZXhlcl9fO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxleGVyID0gdGhpcy5fX2xleGVyX18gPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIH1cblxuICAgIHZhciBzaGFyZWRTdGF0ZV95eSA9IHtcbiAgICAgICAgcGFyc2VFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBxdW90ZU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgbGV4ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyc2VyOiB1bmRlZmluZWQsXG4gICAgICAgIHByZV9wYXJzZTogdW5kZWZpbmVkLFxuICAgICAgICBwb3N0X3BhcnNlOiB1bmRlZmluZWQsXG4gICAgICAgIHByZV9sZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zdF9sZXg6IHVuZGVmaW5lZCAgICAgIC8vIFdBUk5JTkc6IG11c3QgYmUgd3JpdHRlbiB0aGlzIHdheSBmb3IgdGhlIGNvZGUgZXhwYW5kZXJzIHRvIHdvcmsgY29ycmVjdGx5IGluIGJvdGggRVM1IGFuZCBFUzYgbW9kZXMhXG4gICAgfTtcblxuICAgIHZhciBBU1NFUlQ7XG4gICAgaWYgKHR5cGVvZiBhc3NlcnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQVNTRVJUID0gZnVuY3Rpb24gSmlzb25Bc3NlcnQoY29uZCwgbXNnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydGlvbiBmYWlsZWQ6ICcgKyAobXNnIHx8ICcqKionKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgQVNTRVJUID0gYXNzZXJ0O1xuICAgIH1cblxuICAgIHRoaXMueXlHZXRTaGFyZWRTdGF0ZSA9IGZ1bmN0aW9uIHl5R2V0U2hhcmVkU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzaGFyZWRTdGF0ZV95eTtcbiAgICB9O1xuXG5cbiAgICAvLyBzaGFsbG93IGNsb25lIG9iamVjdHMsIHN0cmFpZ2h0IGNvcHkgb2Ygc2ltcGxlIGBzcmNgIHZhbHVlc1xuICAgIC8vIGUuZy4gYGxleGVyLnl5dGV4dGAgTUFZIGJlIGEgY29tcGxleCB2YWx1ZSBvYmplY3QsXG4gICAgLy8gcmF0aGVyIHRoYW4gYSBzaW1wbGUgc3RyaW5nL3ZhbHVlLlxuICAgIGZ1bmN0aW9uIHNoYWxsb3dfY29weShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICBkc3Rba10gPSBzcmNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaGFsbG93X2NvcHlfbm9jbG9iYmVyKGRzdCwgc3JjKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRzdFtrXSA9PT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgaykpIHtcbiAgICAgICAgICAgICAgICBkc3Rba10gPSBzcmNba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29weV95eWxsb2MobG9jKSB7XG4gICAgICAgIHZhciBydiA9IHNoYWxsb3dfY29weShsb2MpO1xuICAgICAgICBpZiAocnYgJiYgcnYucmFuZ2UpIHtcbiAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cblxuICAgIC8vIGNvcHkgc3RhdGVcbiAgICBzaGFsbG93X2NvcHlfbm9jbG9iYmVyKHNoYXJlZFN0YXRlX3l5LCB0aGlzLnl5KTtcblxuICAgIHNoYXJlZFN0YXRlX3l5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGVfeXkucGFyc2VyID0gdGhpcztcblxuXG5cblxuXG5cbiAgICAvLyBEb2VzIHRoZSBzaGFyZWQgc3RhdGUgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHBhcnNlRXJyb3JgIHRoYXQgYWxyZWFkeSBjb21lcyB3aXRoIHRoaXMgaW5zdGFuY2U/XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZV95eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IGZ1bmN0aW9uIHBhcnNlRXJyb3JBbHQoc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykge1xuICAgICAgICAgICAgaWYgKCFFeGNlcHRpb25DbGFzcykge1xuICAgICAgICAgICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvblBhcnNlckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5LnBhcnNlRXJyb3IuY2FsbCh0aGlzLCBzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0aGlzLm9yaWdpbmFsUGFyc2VFcnJvcjtcbiAgICB9XG5cbiAgICAvLyBEb2VzIHRoZSBzaGFyZWQgc3RhdGUgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHF1b3RlTmFtZWAgdGhhdCBhbHJlYWR5IGNvbWVzIHdpdGggdGhpcyBpbnN0YW5jZT9cbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlX3l5LnF1b3RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnF1b3RlTmFtZSA9IGZ1bmN0aW9uIHF1b3RlTmFtZUFsdChpZF9zdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWRTdGF0ZV95eS5xdW90ZU5hbWUuY2FsbCh0aGlzLCBpZF9zdHIpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gdGhpcy5vcmlnaW5hbFF1b3RlTmFtZTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdXAgdGhlIGNsZWFudXAgZnVuY3Rpb247IG1ha2UgaXQgYW4gQVBJIHNvIHRoYXQgZXh0ZXJuYWwgY29kZSBjYW4gcmUtdXNlIHRoaXMgb25lIGluIGNhc2Ugb2ZcbiAgICAvLyBjYWxhbWl0aWVzIG9yIHdoZW4gdGhlIGAlb3B0aW9ucyBuby10cnktY2F0Y2hgIG9wdGlvbiBoYXMgYmVlbiBzcGVjaWZpZWQgZm9yIHRoZSBncmFtbWFyLCBpbiB3aGljaFxuICAgIC8vIGNhc2UgdGhpcyBwYXJzZSgpIEFQSSBtZXRob2QgZG9lc24ndCBjb21lIHdpdGggYSBgZmluYWxseSB7IC4uLiB9YCBibG9jayBhbnkgbW9yZSFcbiAgICAvL1xuICAgIC8vIE5PVEU6IGFzIHRoaXMgQVBJIHVzZXMgcGFyc2UoKSBhcyBhIGNsb3N1cmUsIGl0IE1VU1QgYmUgc2V0IGFnYWluIG9uIGV2ZXJ5IHBhcnNlKCkgaW52b2NhdGlvbixcbiAgICAvLyAgICAgICBvciBlbHNlIHlvdXIgYHNoYXJlZFN0YXRlYCwgZXRjLiByZWZlcmVuY2VzIHdpbGwgYmUgKndyb25nKiFcbiAgICB0aGlzLmNsZWFudXBBZnRlclBhcnNlID0gZnVuY3Rpb24gcGFyc2VyX2NsZWFudXBBZnRlclBhcnNlKHJlc3VsdFZhbHVlLCBpbnZva2VfcG9zdF9tZXRob2RzLCBkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAgIHZhciBydjtcblxuICAgICAgICBpZiAoaW52b2tlX3Bvc3RfbWV0aG9kcykge1xuICAgICAgICAgICAgdmFyIGhhc2g7XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eS5wb3N0X3BhcnNlIHx8IHRoaXMucG9zdF9wYXJzZSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlcnJvciBoYXNoIGluZm8gaW5zdGFuY2U6IHdlIHJlLXVzZSB0aGlzIEFQSSBpbiBhICoqbm9uLWVycm9yIHNpdHVhdGlvbioqXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhpcyBvbmUgZGVsaXZlcnMgYWxsIHBhcnNlciBpbnRlcm5hbHMgcmVhZHkgZm9yIGFjY2VzcyBieSB1c2VybGFuZCBjb2RlLlxuICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKG51bGwgLyogbm8gZXJyb3IhICovLCBudWxsIC8qIG5vIGV4Y2VwdGlvbiEgKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnBvc3RfcGFyc2UpIHtcbiAgICAgICAgICAgICAgICBydiA9IHNoYXJlZFN0YXRlX3l5LnBvc3RfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSwgcmVzdWx0VmFsdWUsIGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICd1bmRlZmluZWQnKSByZXN1bHRWYWx1ZSA9IHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zdF9wYXJzZSkge1xuICAgICAgICAgICAgICAgIHJ2ID0gdGhpcy5wb3N0X3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXksIHJlc3VsdFZhbHVlLCBoYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAndW5kZWZpbmVkJykgcmVzdWx0VmFsdWUgPSBydjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2xlYW51cDpcbiAgICAgICAgICAgIGlmIChoYXNoICYmIGhhc2guZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGhhc2guZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aCA+IDEpIHJldHVybiByZXN1bHRWYWx1ZTsgICAgICAgIC8vIGRvIG5vdCAoeWV0KSBraWxsIHRoZSBzaGFyZWRTdGF0ZSB3aGVuIHRoaXMgaXMgYSByZWVudHJhbnQgcnVuLlxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBsaW5nZXJpbmcgbGV4ZXIgc3RydWN0dXJlcyBhcyB3ZWxsOlxuICAgICAgICBpZiAobGV4ZXIuY2xlYW51cEFmdGVyTGV4KSB7XG4gICAgICAgICAgICBsZXhlci5jbGVhbnVwQWZ0ZXJMZXgoZG9fbm90X251a2VfZXJyb3JpbmZvcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IGxpbmdlcmluZyBjaXJjdWxhciByZWZlcmVuY2VzIGZyb20gY2F1c2luZyBtZW1vcnkgbGVha3M6XG4gICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGVfeXkubGV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5wYXJzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobGV4ZXIueXkgPT09IHNoYXJlZFN0YXRlX3l5KSB7XG4gICAgICAgICAgICAgICAgbGV4ZXIueXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhcmVkU3RhdGVfeXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMub3JpZ2luYWxQYXJzZUVycm9yO1xuICAgICAgICB0aGlzLnF1b3RlTmFtZSA9IHRoaXMub3JpZ2luYWxRdW90ZU5hbWU7XG5cbiAgICAgICAgLy8gbnVrZSB0aGUgdnN0YWNrW10gYXJyYXkgYXQgbGVhc3QgYXMgdGhhdCBvbmUgd2lsbCBzdGlsbCByZWZlcmVuY2Ugb2Jzb2xldGVkIHVzZXIgdmFsdWVzLlxuICAgICAgICAvLyBUbyBiZSBzYWZlLCB3ZSBudWtlIHRoZSBvdGhlciBpbnRlcm5hbCBzdGFjayBjb2x1bW5zIGFzIHdlbGwuLi5cbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDsgICAgICAgICAgICAgICAvLyBmYXN0ZXN0IHdheSB0byBudWtlIGFuIGFycmF5IHdpdGhvdXQgb3Zlcmx5IGJvdGhlcmluZyB0aGUgR0NcbiAgICAgICAgc3N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGxzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgc3AgPSAwO1xuXG4gICAgICAgIC8vIG51a2UgdGhlIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZXMgY3JlYXRlZCBkdXJpbmcgdGhpcyBydW4uXG4gICAgICAgIC8vIFVzZXJsYW5kIGNvZGUgbXVzdCBDT1BZIGFueSBkYXRhL3JlZmVyZW5jZXNcbiAgICAgICAgLy8gaW4gdGhlIGVycm9yIGhhc2ggaW5zdGFuY2UocykgaXQgaXMgbW9yZSBwZXJtYW5lbnRseSBpbnRlcmVzdGVkIGluLlxuICAgICAgICBpZiAoIWRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9fZXJyb3JfaW5mb3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIHR5cGVvZiBlbC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoID0gMDtcblxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIG1lcmdlIHl5bGxvYyBpbmZvIGludG8gYSBuZXcgeXlsbG9jIGluc3RhbmNlLlxuICAgIC8vXG4gICAgLy8gYGZpcnN0X2luZGV4YCBhbmQgYGxhc3RfaW5kZXhgIE1BWSBiZSBVTkRFRklORUQvTlVMTCBvciB0aGVzZSBhcmUgaW5kZXhlcyBpbnRvIHRoZSBgbHN0YWNrW11gIGxvY2F0aW9uIHN0YWNrIGFycmF5LlxuICAgIC8vXG4gICAgLy8gYGZpcnN0X3l5bGxvY2AgYW5kIGBsYXN0X3l5bGxvY2AgTUFZIGJlIFVOREVGSU5FRC9OVUxMIG9yIGV4cGxpY2l0IChjdXN0b20gb3IgcmVndWxhcikgYHl5bGxvY2AgaW5zdGFuY2VzLCBpbiB3aGljaFxuICAgIC8vIGNhc2UgdGhlc2Ugb3ZlcnJpZGUgdGhlIGNvcnJlc3BvbmRpbmcgZmlyc3QvbGFzdCBpbmRleGVzLlxuICAgIC8vXG4gICAgLy8gYGRvbnRfbG9va19iYWNrYCBpcyBhbiBvcHRpb25hbCBmbGFnIChkZWZhdWx0OiBGQUxTRSksIHdoaWNoIGluc3RydWN0cyB0aGlzIG1lcmdlIG9wZXJhdGlvbiBOT1QgdG8gc2VhcmNoXG4gICAgLy8gdGhyb3VnaCB0aGUgcGFyc2UgbG9jYXRpb24gc3RhY2sgZm9yIGEgbG9jYXRpb24sIHdoaWNoIHdvdWxkIG90aGVyd2lzZSBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgbmV3IChlcHNpbG9uISlcbiAgICAvLyB5eWxsb2MgaW5mby5cbiAgICAvL1xuICAgIC8vIE5vdGU6IGVwc2lsb24gcnVsZSdzIHl5bGxvYyBzaXR1YXRpb24gaXMgZGV0ZWN0ZWQgYnkgcGFzc2luZyBib3RoIGBmaXJzdF9pbmRleGAgYW5kIGBmaXJzdF95eWxsb2NgIGFzIFVOREVGSU5FRC9OVUxMLlxuICAgIHRoaXMueXlNZXJnZUxvY2F0aW9uSW5mbyA9IGZ1bmN0aW9uIHBhcnNlcl95eU1lcmdlTG9jYXRpb25JbmZvKGZpcnN0X2luZGV4LCBsYXN0X2luZGV4LCBmaXJzdF95eWxsb2MsIGxhc3RfeXlsbG9jLCBkb250X2xvb2tfYmFjaykge1xuICAgICAgICB2YXIgaTEgPSBmaXJzdF9pbmRleCB8IDAsXG4gICAgICAgICAgICBpMiA9IGxhc3RfaW5kZXggfCAwO1xuICAgICAgICB2YXIgbDEgPSBmaXJzdF95eWxsb2MsXG4gICAgICAgICAgICBsMiA9IGxhc3RfeXlsbG9jO1xuICAgICAgICB2YXIgcnY7XG5cbiAgICAgICAgLy8gcnVsZXM6XG4gICAgICAgIC8vIC0gZmlyc3QvbGFzdCB5eWxsb2MgZW50cmllcyBvdmVycmlkZSBmaXJzdC9sYXN0IGluZGV4ZXNcblxuICAgICAgICBpZiAoIWwxKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpMTsgaSA8PSBpMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGwxID0gbHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsMikge1xuICAgICAgICAgICAgaWYgKGxhc3RfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpMjsgaSA+PSBpMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGwyID0gbHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLSBkZXRlY3QgaWYgYW4gZXBzaWxvbiBydWxlIGlzIGJlaW5nIHByb2Nlc3NlZCBhbmQgYWN0IGFjY29yZGluZ2x5OlxuICAgICAgICBpZiAoIWwxICYmIGZpcnN0X2luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGVwc2lsb24gcnVsZSBzcGFuIG1lcmdlci4gV2l0aCBvcHRpb25hbCBsb29rLWFoZWFkIGluIGwyLlxuICAgICAgICAgICAgaWYgKCFkb250X2xvb2tfYmFjaykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAoaTEgfHwgc3ApIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbDEgPSBsc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWwxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsMikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIHN0aWxsIGRvbid0IGhhdmUgYW55IHZhbGlkIHl5bGxvYyBpbmZvLCB3ZSdyZSBsb29raW5nIGF0IGFuIGVwc2lsb24gcnVsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IGxvb2stYWhlYWQgYW5kIG5vIHByZWNlZGluZyB0ZXJtcyBhbmQvb3IgYGRvbnRfbG9va19iYWNrYCBzZXQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYSBkbyBub3RoaW5nIGJ1dCByZXR1cm4gTlVMTC9VTkRFRklORUQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdy1jb3B5IEwyOiBhZnRlciBhbGwsIHdlIE1BWSBiZSBsb29raW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHVuY29udmVudGlvbmFsIHl5bGxvYyBpbmZvIG9iamVjdHMuLi5cbiAgICAgICAgICAgICAgICAgICAgcnYgPSBzaGFsbG93X2NvcHkobDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNoYWxsb3cgY29weSB0aGUgeXlsbG9jIHJhbmdlcyBpbmZvIHRvIHByZXZlbnQgdXMgZnJvbSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cycgZW50cmllczpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2hhbGxvdy1jb3B5IEwxLCB0aGVuIGFkanVzdCBmaXJzdCBjb2wvcm93IDEgY29sdW1uIHBhc3QgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICBydiA9IHNoYWxsb3dfY29weShsMSk7XG4gICAgICAgICAgICAgICAgcnYuZmlyc3RfbGluZSA9IHJ2Lmxhc3RfbGluZTtcbiAgICAgICAgICAgICAgICBydi5maXJzdF9jb2x1bW4gPSBydi5sYXN0X2NvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAocnYucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHRoZSB5eWxsb2MgcmFuZ2VzIGluZm8gdG8gcHJldmVudCB1cyBmcm9tIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzJyBlbnRyaWVzOlxuICAgICAgICAgICAgICAgICAgICBydi5yYW5nZSA9IHJ2LnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBydi5yYW5nZVswXSA9IHJ2LnJhbmdlWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93LW1peGluIEwyLCB0aGVuIGFkanVzdCBsYXN0IGNvbC9yb3cgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIocnYsIGwyKTtcbiAgICAgICAgICAgICAgICAgICAgcnYubGFzdF9saW5lID0gbDIubGFzdF9saW5lO1xuICAgICAgICAgICAgICAgICAgICBydi5sYXN0X2NvbHVtbiA9IGwyLmxhc3RfY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYucmFuZ2UgJiYgbDIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlWzFdID0gbDIucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsMSkge1xuICAgICAgICAgICAgbDEgPSBsMjtcbiAgICAgICAgICAgIGwyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWwxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhbGxvdy1jb3B5IEwxfEwyLCBiZWZvcmUgd2UgdHJ5IHRvIGFkanVzdCB0aGUgeXlsbG9jIHZhbHVlczogYWZ0ZXIgYWxsLCB3ZSBNQVkgYmUgbG9va2luZ1xuICAgICAgICAvLyBhdCB1bmNvbnZlbnRpb25hbCB5eWxsb2MgaW5mbyBvYmplY3RzLi4uXG4gICAgICAgIHJ2ID0gc2hhbGxvd19jb3B5KGwxKTtcblxuICAgICAgICAvLyBmaXJzdF9saW5lOiAuLi4sXG4gICAgICAgIC8vIGZpcnN0X2NvbHVtbjogLi4uLFxuICAgICAgICAvLyBsYXN0X2xpbmU6IC4uLixcbiAgICAgICAgLy8gbGFzdF9jb2x1bW46IC4uLixcbiAgICAgICAgaWYgKHJ2LnJhbmdlKSB7XG4gICAgICAgICAgICAvLyBzaGFsbG93IGNvcHkgdGhlIHl5bGxvYyByYW5nZXMgaW5mbyB0byBwcmV2ZW50IHVzIGZyb20gbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMnIGVudHJpZXM6XG4gICAgICAgICAgICBydi5yYW5nZSA9IHJ2LnJhbmdlLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwyKSB7XG4gICAgICAgICAgICBzaGFsbG93X2NvcHlfbm9jbG9iYmVyKHJ2LCBsMik7XG4gICAgICAgICAgICBydi5sYXN0X2xpbmUgPSBsMi5sYXN0X2xpbmU7XG4gICAgICAgICAgICBydi5sYXN0X2NvbHVtbiA9IGwyLmxhc3RfY29sdW1uO1xuICAgICAgICAgICAgaWYgKHJ2LnJhbmdlICYmIGwyLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcnYucmFuZ2VbMV0gPSBsMi5yYW5nZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydjtcbiAgICB9O1xuXG4gICAgLy8gTk9URTogYXMgdGhpcyBBUEkgdXNlcyBwYXJzZSgpIGFzIGEgY2xvc3VyZSwgaXQgTVVTVCBiZSBzZXQgYWdhaW4gb24gZXZlcnkgcGFyc2UoKSBpbnZvY2F0aW9uLFxuICAgIC8vICAgICAgIG9yIGVsc2UgeW91ciBgbGV4ZXJgLCBgc2hhcmVkU3RhdGVgLCBldGMuIHJlZmVyZW5jZXMgd2lsbCBiZSAqd3JvbmcqIVxuICAgIHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8gPSBmdW5jdGlvbiBwYXJzZXJfY29uc3RydWN0UGFyc2VFcnJvckluZm8obXNnLCBleCwgZXhwZWN0ZWQsIHJlY292ZXJhYmxlKSB7XG4gICAgICAgIHZhciBwZWkgPSB7XG4gICAgICAgICAgICBlcnJTdHI6IG1zZyxcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogZXgsXG4gICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgIHZhbHVlOiBsZXhlci55eXRleHQsXG4gICAgICAgICAgICB0b2tlbjogdGhpcy5kZXNjcmliZVN5bWJvbChzeW1ib2wpIHx8IHN5bWJvbCxcbiAgICAgICAgICAgIHRva2VuX2lkOiBzeW1ib2wsXG4gICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgIGxvYzogY29weV95eWxsb2MobGV4ZXIueXlsbG9jKSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgIHJlY292ZXJhYmxlOiByZWNvdmVyYWJsZSxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbmV3X3N0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgIHN5bWJvbF9zdGFjazogc3RhY2ssXG4gICAgICAgICAgICBzdGF0ZV9zdGFjazogc3N0YWNrLFxuICAgICAgICAgICAgdmFsdWVfc3RhY2s6IHZzdGFjayxcbiAgICAgICAgICAgIGxvY2F0aW9uX3N0YWNrOiBsc3RhY2ssXG4gICAgICAgICAgICBzdGFja19wb2ludGVyOiBzcCxcbiAgICAgICAgICAgIHl5OiBzaGFyZWRTdGF0ZV95eSxcbiAgICAgICAgICAgIGxleGVyOiBsZXhlcixcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcblxuICAgICAgICAgICAgLy8gYW5kIG1ha2Ugc3VyZSB0aGUgZXJyb3IgaW5mbyBkb2Vzbid0IHN0YXkgZHVlIHRvIHBvdGVudGlhbFxuICAgICAgICAgICAgLy8gcmVmIGN5Y2xlIHZpYSB1c2VybGFuZCBjb2RlIG1hbmlwdWxhdGlvbnMuXG4gICAgICAgICAgICAvLyBUaGVzZSB3b3VsZCBvdGhlcndpc2UgYWxsIGJlIG1lbW9yeSBsZWFrIG9wcG9ydHVuaXRpZXMhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9ubHkgYXJyYXkgYW5kIG9iamVjdCByZWZlcmVuY2VzIGFyZSBudWtlZCBhcyB0aG9zZVxuICAgICAgICAgICAgLy8gY29uc3RpdHV0ZSB0aGUgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGNhbiBwcm9kdWNlIGEgY3ljbGljIHJlZi5cbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBtZW1iZXJzIGlzIGtlcHQgaW50YWN0IGFzIHRoZXkgYXJlIGhhcm1sZXNzLlxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJ1Y3RQYXJzZUVycm9ySW5mbygpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY3ljbGljIHJlZmVyZW5jZXMgYWRkZWQgdG8gZXJyb3IgaW5mbzpcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnl5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLmxleGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnZhbHVlX3N0YWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICAgICAgICB2YXIgcmVjID0gISF0aGlzLnJlY292ZXJhYmxlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJhYmxlID0gcmVjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB0cmFjayB0aGlzIGluc3RhbmNlIHNvIHdlIGNhbiBgZGVzdHJveSgpYCBpdCBvbmNlIHdlIGRlZW0gaXQgc3VwZXJmbHVvdXMgYW5kIHJlYWR5IGZvciBnYXJiYWdlIGNvbGxlY3Rpb24hXG4gICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5wdXNoKHBlaSk7XG4gICAgICAgIHJldHVybiBwZWk7XG4gICAgfTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIGZ1bmN0aW9uIGdldE5vblRlcm1pbmFsRnJvbUNvZGUoc3ltYm9sKSB7XG4gICAgICAgIHZhciB0b2tlbk5hbWUgPSBzZWxmLmdldFN5bWJvbE5hbWUoc3ltYm9sKTtcbiAgICAgICAgaWYgKCF0b2tlbk5hbWUpIHtcbiAgICAgICAgICAgIHRva2VuTmFtZSA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5OYW1lO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXhlci5sZXgoKTtcbiAgICAgICAgLy8gaWYgdG9rZW4gaXNuJ3QgaXRzIG51bWVyaWMgdmFsdWUsIGNvbnZlcnRcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4gfHwgRU9GO1xuICAgIH1cblxuXG4gICAgdmFyIHN0YXRlLCBhY3Rpb24sIHIsIHQ7XG4gICAgdmFyIHl5dmFsID0ge1xuICAgICAgICAkOiB0cnVlLFxuICAgICAgICBfJDogdW5kZWZpbmVkLFxuICAgICAgICB5eTogc2hhcmVkU3RhdGVfeXlcbiAgICB9O1xuICAgIHZhciBwO1xuICAgIHZhciB5eXJ1bGVsZW47XG4gICAgdmFyIHRoaXNfcHJvZHVjdGlvbjtcbiAgICB2YXIgbmV3U3RhdGU7XG4gICAgdmFyIHJldHZhbCA9IGZhbHNlO1xuXG5cbiAgICB0cnkge1xuICAgICAgICB0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGgrKztcblxuICAgICAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGVfeXkpO1xuXG4gICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICBsc3RhY2tbc3BdID0geXlsb2M7XG4gICAgICAgIHZzdGFja1tzcF0gPSBudWxsO1xuICAgICAgICBzc3RhY2tbc3BdID0gMDtcbiAgICAgICAgc3RhY2tbc3BdID0gMDtcbiAgICAgICAgKytzcDtcblxuXG5cblxuXG4gICAgICAgIGlmICh0aGlzLnByZV9wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5wcmVfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnByZV9wYXJzZSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGVfeXkucHJlX3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3U3RhdGUgPSBzc3RhY2tbc3AgLSAxXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gcmV0cmlldmUgc3RhdGUgbnVtYmVyIGZyb20gdG9wIG9mIHN0YWNrXG4gICAgICAgICAgICBzdGF0ZSA9IG5ld1N0YXRlOyAgICAgICAgICAgICAgIC8vIHNzdGFja1tzcCAtIDFdO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVmYXVsdCBhY3Rpb25zIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gMjtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2luZ2xlIGA9PWAgY29uZGl0aW9uIGJlbG93IGNvdmVycyBib3RoIHRoZXNlIGA9PT1gIGNvbXBhcmlzb25zIGluIGEgc2luZ2xlXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PT0gJ3VuZGVmaW5lZCcpIC4uLlxuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWFkIGFjdGlvbiBmb3IgY3VycmVudCBzdGF0ZSBhbmQgZmlyc3QgaW5wdXRcbiAgICAgICAgICAgICAgICB0ID0gKHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXSkgfHwgTk9fQUNUSU9OO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdFsxXTtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSB0WzBdO1xuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcGFyc2UgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyU3RyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyU3ltYm9sRGVzY3IgPSAodGhpcy5kZXNjcmliZVN5bWJvbChzeW1ib2wpIHx8IHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRoaXMuY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxleGVyLnl5bGluZW5vID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArIChsZXhlci55eWxpbmVubyArIDEpICsgJzogJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvcjogJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxleGVyLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKDc5IC0gMTAsIDEwKSArICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IHVuZXhwZWN0ZWQgJyArIGVyclN5bWJvbERlc2NyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdVbmV4cGVjdGVkICcgKyBlcnJTeW1ib2xEZXNjcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBmcm9tIHRoZSBlcnJvciFcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oZXJyU3RyLCBudWxsLCBleHBlY3RlZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBtaXNjLiBwYXJzZSBmYWlsdXJlczpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wsIG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciBjYXNlIG9mIGJldHRlciBzYWZlIHRoYW4gc29ycnk6IGluIGNhc2Ugc3RhdGUgdHJhbnNpdGlvbnMgY29tZSBvdXQgb2YgYW5vdGhlciBlcnJvciByZWNvdmVyeSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gb3IgYSBidWdneSBMVVQgKExvb2tVcCBUYWJsZSk6XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNpbmcgaGFsdGVkLiBObyB2aWFibGUgZXJyb3IgcmVjb3ZlcnkgYXBwcm9hY2ggYXZhaWxhYmxlIGR1ZSB0byBpbnRlcm5hbCBzeXN0ZW0gZmFpbHVyZS4nLCBudWxsLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBzaGlmdDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzdGFja1tzcF0gPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgdnN0YWNrW3NwXSA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICBsc3RhY2tbc3BdID0gY29weV95eWxsb2MobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgICBzc3RhY2tbc3BdID0gbmV3U3RhdGU7IC8vIHB1c2ggc3RhdGVcblxuICAgICAgICAgICAgICAgICsrc3A7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBpY2sgdXAgdGhlIGxleGVyIGRldGFpbHMgZm9yIHRoZSBjdXJyZW50IHN5bWJvbCBhcyB0aGF0IG9uZSBpcyBub3QgJ2xvb2stYWhlYWQnIGFueSBtb3JlOlxuXG5cblxuICAgICAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICBcblxuXG5cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyByZWR1Y2U6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpc19wcm9kdWN0aW9uID0gdGhpcy5wcm9kdWN0aW9uc19bbmV3U3RhdGUgLSAxXTsgIC8vIGB0aGlzLnByb2R1Y3Rpb25zX1tdYCBpcyB6ZXJvLWJhc2VkIGluZGV4ZWQgd2hpbGUgc3RhdGVzIHN0YXJ0IGZyb20gMSB1cHdhcmRzLi4uXG4gICAgICAgICAgICAgICAgeXlydWxlbGVuID0gdGhpc19wcm9kdWN0aW9uWzFdO1xuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHl5dmFsLCB5eWxvYywgbmV3U3RhdGUsIHNwIC0gMSwgdnN0YWNrLCBsc3RhY2spO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3Agb2ZmIHN0YWNrXG4gICAgICAgICAgICAgICAgc3AgLT0geXlydWxlbGVuO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgb3ZlcndyaXRlIHRoZSBgc3ltYm9sYCB2YXJpYWJsZTogdXNlIGEgbG9jYWwgdmFyIHRvIHNwZWVkIHRoaW5ncyB1cDpcbiAgICAgICAgICAgICAgICB2YXIgbnRzeW1ib2wgPSB0aGlzX3Byb2R1Y3Rpb25bMF07ICAgIC8vIHB1c2ggbm9udGVybWluYWwgKHJlZHVjZSlcbiAgICAgICAgICAgICAgICBzdGFja1tzcF0gPSBudHN5bWJvbDtcbiAgICAgICAgICAgICAgICB2c3RhY2tbc3BdID0geXl2YWwuJDtcbiAgICAgICAgICAgICAgICBsc3RhY2tbc3BdID0geXl2YWwuXyQ7XG4gICAgICAgICAgICAgICAgLy8gZ290byBuZXcgc3RhdGUgPSB0YWJsZVtTVEFURV1bTk9OVEVSTUlOQUxdXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzc3RhY2tbc3AgLSAxXV1bbnRzeW1ib2xdO1xuICAgICAgICAgICAgICAgIHNzdGFja1tzcF0gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICArK3NwO1xuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBhY2NlcHQ6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGAkYWNjZXB0YCBydWxlJ3MgYCQkYCByZXN1bHQsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IEpJU09OIGFsd2F5cyBhZGRzIHRoaXMgdG9wLW1vc3QgYCRhY2NlcHRgIHJ1bGUgKHdpdGggaW1wbGljaXQsXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCwgYWN0aW9uKTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAkYWNjZXB0OiA8c3RhcnRTeW1ib2w+ICRlbmRcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICV7ICQkID0gJDE7IEAkID0gQDE7ICV9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyB3aGljaCwgY29tYmluZWQgd2l0aCB0aGUgcGFyc2Uga2VybmVsJ3MgYCRhY2NlcHRgIHN0YXRlIGJlaGF2aW91ciBjb2RlZCBiZWxvdyxcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHByb2R1Y2UgdGhlIGAkJGAgdmFsdWUgb3V0cHV0IG9mIHRoZSA8c3RhcnRTeW1ib2w+IHJ1bGUgYXMgdGhlIHBhcnNlIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAvLyBJRkYgdGhhdCByZXN1bHQgaXMgKm5vdCogYHVuZGVmaW5lZGAuIChTZWUgYWxzbyB0aGUgcGFyc2VyIGtlcm5lbCBjb2RlLilcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIGNvZGU6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICV7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgQCQgPSBAMTsgICAgICAgICAgICAvLyBpZiBsb2NhdGlvbiB0cmFja2luZyBzdXBwb3J0IGlzIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkMSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgcGFyc2UgcmVzdWx0IGlmIHRoZSBydWxlIGFjdGlvbnMgZG9uJ3QgcHJvZHVjZSBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJX1cbiAgICAgICAgICAgICAgICBzcC0tO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdnN0YWNrW3NwXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdnN0YWNrW3NwXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYnJlYWsgb3V0IG9mIGxvb3A6IHdlIGFjY2VwdCBvciBmYWlsIHdpdGggZXJyb3JcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgLy8gcmVwb3J0IGV4Y2VwdGlvbnMgdGhyb3VnaCB0aGUgcGFyc2VFcnJvciBjYWxsYmFjayB0b28sIGJ1dCBrZWVwIHRoZSBleGNlcHRpb24gaW50YWN0XG4gICAgICAgIC8vIGlmIGl0IGlzIGEga25vd24gcGFyc2VyIG9yIGxleGVyIGVycm9yIHdoaWNoIGhhcyBiZWVuIHRocm93biBieSBwYXJzZUVycm9yKCkgYWxyZWFkeTpcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgdGhpcy5KaXNvblBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXhlciAmJiB0eXBlb2YgbGV4ZXIuSmlzb25MZXhlckVycm9yID09PSAnZnVuY3Rpb24nICYmIGV4IGluc3RhbmNlb2YgbGV4ZXIuSmlzb25MZXhlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdQYXJzaW5nIGFib3J0ZWQgZHVlIHRvIGV4Y2VwdGlvbi4nLCBleCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmV0dmFsID0gdGhpcy5jbGVhbnVwQWZ0ZXJQYXJzZShyZXR2YWwsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGgtLTtcbiAgICB9ICAgLy8gL2ZpbmFsbHlcblxuICAgIHJldHVybiByZXR2YWw7XG59XG59O1xucGFyc2VyLm9yaWdpbmFsUGFyc2VFcnJvciA9IHBhcnNlci5wYXJzZUVycm9yO1xucGFyc2VyLm9yaWdpbmFsUXVvdGVOYW1lID0gcGFyc2VyLnF1b3RlTmFtZTtcblxuXG4vKiBsZXhlciBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuNi4xLTIwMyAqL1xuXG4vKlxuICogUmV0dXJucyBhIExleGVyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiAgTGV4ZXI6IHtcbiAqICAgIHl5OiB7fSAgICAgVGhlIHNvLWNhbGxlZCBcInNoYXJlZCBzdGF0ZVwiIG9yIHJhdGhlciB0aGUgKnNvdXJjZSogb2YgaXQ7XG4gKiAgICAgICAgICAgICAgIHRoZSByZWFsIFwic2hhcmVkIHN0YXRlXCIgYHl5YCBwYXNzZWQgYXJvdW5kIHRvXG4gKiAgICAgICAgICAgICAgIHRoZSBydWxlIGFjdGlvbnMsIGV0Yy4gaXMgYSBkaXJlY3QgcmVmZXJlbmNlIVxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBcInNoYXJlZCBjb250ZXh0XCIgb2JqZWN0IHdhcyBwYXNzZWQgdG8gdGhlIGxleGVyIGJ5IHdheSBvZiBcbiAqICAgICAgICAgICAgICAgdGhlIGBsZXhlci5zZXRJbnB1dChzdHIsIHl5KWAgQVBJIGJlZm9yZSB5b3UgbWF5IHVzZSBpdC5cbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgXCJzaGFyZWQgY29udGV4dFwiIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIGxleGVyIGFjdGlvbiBjb2RlIGluIGBwZXJmb3JtQWN0aW9uKClgXG4gKiAgICAgICAgICAgICAgIHNvIHVzZXJsYW5kIGNvZGUgaW4gdGhlIGxleGVyIGFjdGlvbnMgbWF5IGNvbW11bmljYXRlIHdpdGggdGhlIG91dHNpZGUgd29ybGQgXG4gKiAgICAgICAgICAgICAgIGFuZC9vciBvdGhlciBsZXhlciBydWxlcycgYWN0aW9ucyBpbiBtb3JlIG9yIGxlc3MgY29tcGxleCB3YXlzLlxuICpcbiAqICB9XG4gKlxuICogIExleGVyLnByb3RvdHlwZToge1xuICogICAgRU9GOiAxLFxuICogICAgRVJST1I6IDIsXG4gKlxuICogICAgeXk6ICAgICAgICBUaGUgb3ZlcmFsbCBcInNoYXJlZCBjb250ZXh0XCIgb2JqZWN0IHJlZmVyZW5jZS5cbiAqXG4gKiAgICBKaXNvbkxleGVyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKlxuICogICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpLFxuICpcbiAqICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYW5kIGB0aGlzYCBoYXZlIHRoZSBmb2xsb3dpbmcgdmFsdWUvbWVhbmluZzpcbiAqICAgICAgICAgICAgICAgLSBgdGhpc2AgICAgOiByZWZlcmVuY2UgdG8gdGhlIGBsZXhlcmAgaW5zdGFuY2UuIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHl5X2AgaXMgYW4gYWxpYXMgZm9yIGB0aGlzYCBsZXhlciBpbnN0YW5jZSByZWZlcmVuY2UgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlgICAgICAgOiBhIHJlZmVyZW5jZSB0byB0aGUgYHl5YCBcInNoYXJlZCBzdGF0ZVwiIG9iamVjdCB3aGljaCB3YXMgcGFzc2VkIHRvIHRoZSBsZXhlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHdheSBvZiB0aGUgYGxleGVyLnNldElucHV0KHN0ciwgeXkpYCBBUEkgYmVmb3JlLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBleHRyYSBhcmd1bWVudHMgeW91IHNwZWNpZmllZCBpbiB0aGUgYCVwYXJzZS1wYXJhbWAgc3RhdGVtZW50IGluIHlvdXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKnBhcnNlcioqIGdyYW1tYXIgZGVmaW5pdGlvbiBmaWxlIGFyZSBwYXNzZWQgdG8gdGhlIGxleGVyIHZpYSB0aGlzIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSBhcyBtZW1iZXIgdmFyaWFibGVzLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlydWxlbnVtYmVyYCAgIDogaW5kZXggb2YgdGhlIG1hdGNoZWQgbGV4ZXIgcnVsZSAocmVnZXgpLCB1c2VkIGludGVybmFsbHkuXG4gKlxuICogICAgICAgICAgICAgICAtIGBZWV9TVEFSVGA6IHRoZSBjdXJyZW50IGxleGVyIFwic3RhcnQgY29uZGl0aW9uXCIgc3RhdGUuXG4gKlxuICogICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKlxuICogICAgY29uc3RydWN0TGV4RXJyb3JJbmZvOiBmdW5jdGlvbihlcnJvcl9tZXNzYWdlLCBpc19yZWNvdmVyYWJsZSksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgUHJvZHVjZXMgYSBuZXcgZXJyb3JJbmZvICdoYXNoIG9iamVjdCcgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIGBwYXJzZUVycm9yKClgLlxuICogICAgICAgICAgICAgICBTZWUgaXQncyB1c2UgaW4gdGhpcyBsZXhlciBrZXJuZWwgaW4gbWFueSBwbGFjZXM7IGV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgdmFyIGluZm9PYmogPSBsZXhlci5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnZmFpbCEnLCB0cnVlKTtcbiAqICAgICAgICAgICAgICAgICAgIHZhciByZXRWYWwgPSBsZXhlci5wYXJzZUVycm9yKGluZm9PYmouZXJyU3RyLCBpbmZvT2JqLCBsZXhlci5KaXNvbkxleGVyRXJyb3IpO1xuICpcbiAqICAgIG9wdGlvbnM6IHsgLi4uIGxleGVyICVvcHRpb25zIC4uLiB9LFxuICpcbiAqICAgIGxleDogZnVuY3Rpb24oKSxcbiAqICAgICAgICAgICAgICAgUHJvZHVjZSBvbmUgdG9rZW4gb2YgbGV4ZWQgaW5wdXQsIHdoaWNoIHdhcyBwYXNzZWQgaW4gZWFybGllciB2aWEgdGhlIGBsZXhlci5zZXRJbnB1dCgpYCBBUEkuXG4gKiAgICAgICAgICAgICAgIFlvdSBNQVkgdXNlIHRoZSBhZGRpdGlvbmFsIGBhcmdzLi4uYCBwYXJhbWV0ZXJzIGFzIHBlciBgJXBhcnNlLXBhcmFtYCBzcGVjIG9mIHRoZSAqKmxleGVyKiogZ3JhbW1hcjpcbiAqICAgICAgICAgICAgICAgdGhlc2UgZXh0cmEgYGFyZ3MuLi5gIGFyZSBhZGRlZCB2ZXJiYXRpbSB0byB0aGUgYHl5YCBvYmplY3QgcmVmZXJlbmNlIGFzIG1lbWJlciB2YXJpYWJsZXMuXG4gKlxuICogICAgICAgICAgICAgICBXQVJOSU5HOlxuICogICAgICAgICAgICAgICBMZXhlcidzIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgKHZpYSBsZXhlcidzIGAlcGFyc2UtcGFyYW1gKSBNQVkgY29uZmxpY3Qgd2l0aFxuICogICAgICAgICAgICAgICBhbnkgYXR0cmlidXRlcyBhbHJlYWR5IGFkZGVkIHRvIGB5eWAgYnkgdGhlICoqcGFyc2VyKiogb3IgdGhlIGppc29uIHJ1bi10aW1lOyBcbiAqICAgICAgICAgICAgICAgd2hlbiBzdWNoIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gdG8gcHJldmVudCB0aGUgZ2VuZXJhdGVkIHJ1bi10aW1lIFxuICogICAgICAgICAgICAgICBmcm9tIHNpbGVudGx5IGFjY2VwdGluZyB0aGlzIGNvbmZ1c2luZyBhbmQgcG90ZW50aWFsbHkgaGF6YXJkb3VzIHNpdHVhdGlvbiEgXG4gKlxuICogICAgY2xlYW51cEFmdGVyTGV4OiBmdW5jdGlvbihkb19ub3RfbnVrZV9lcnJvcmluZm9zKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uLlxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGlzIGludm9rZWQgd2hlbiB0aGUgKipwYXJzZSBwcm9jZXNzKiogaGFzIGNvbXBsZXRlZDogaXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XG4gKiAgICAgICAgICAgICAgIG9mIHRoZSAqKnBhcnNlcioqIChvciB0aGUgY2FsbGluZyB1c2VybGFuZCBjb2RlKSB0byBpbnZva2UgdGhpcyBtZXRob2Qgb25jZSBjbGVhbnVwIGlzIGRlc2lyZWQuIFxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgbWF5IGJlIGludm9rZWQgYnkgdXNlciBjb2RlIHRvIGVuc3VyZSB0aGUgaW50ZXJuYWwgbGV4ZXIgZ2V0cyBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqXG4gKiAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQsIFt5eV0pLFxuICpcbiAqXG4gKiAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gKlxuICpcbiAqICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHJlamVjdDogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgbGVzczogZnVuY3Rpb24obiksXG4gKlxuICpcbiAqICAgIHBhc3RJbnB1dDogZnVuY3Rpb24obiksXG4gKlxuICpcbiAqICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICpcbiAqXG4gKiAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAqXG4gKlxuICogICAgbmV4dDogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKlxuICpcbiAqICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqXG4gKlxuICogICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCksXG4gKlxuICpcbiAqICAgIHJ1bGVzOiBbLi4uXSxcbiAqXG4gKlxuICogICAgY29uZGl0aW9uczoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IHNldH0sXG4gKiAgfVxuICpcbiAqXG4gKiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoYHl5bGxvY2ApOiB7XG4gKiAgICBmaXJzdF9saW5lOiBuLFxuICogICAgbGFzdF9saW5lOiBuLFxuICogICAgZmlyc3RfY29sdW1uOiBuLFxuICogICAgbGFzdF9jb2x1bW46IG4sXG4gKiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl1cbiAqICAgICAgICAgICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgemVyby1iYXNlZClcbiAqICB9XG4gKlxuICogLS0tXG4gKlxuICogVGhlIGBwYXJzZUVycm9yYCBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBlcnJvcnM6XG4gKlxuICogIHtcbiAqICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICogICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAqICAgIHRva2VuX2lkOiAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuIG51bWVyaWMgSUQsIGlmIGFueSlcbiAqICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gKiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAqICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgTUFZIGhhdmUgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZVxuICogICAgICAgICAgICAgICAgICBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAqICAgIHl5OiAgICAgICAgICAob2JqZWN0OiB0aGUgY3VycmVudCBwYXJzZXIgaW50ZXJuYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgXG4gKiAgICAgICAgICAgICAgICAgIGFzIGlzIGFsc28gYXZhaWxhYmxlIGluIHRoZSBydWxlIGFjdGlvbnM7IHRoaXMgY2FuIGJlIHVzZWQsXG4gKiAgICAgICAgICAgICAgICAgIGZvciBpbnN0YW5jZSwgZm9yIGFkdmFuY2VkIGVycm9yIGFuYWx5c2lzIGFuZCByZXBvcnRpbmcpXG4gKiAgICBsZXhlcjogICAgICAgKHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBsZXhlciBpbnN0YW5jZSB1c2VkIGJ5IHRoZSBwYXJzZXIpXG4gKiAgfVxuICpcbiAqIHdoaWxlIGB0aGlzYCB3aWxsIHJlZmVyZW5jZSB0aGUgY3VycmVudCBsZXhlciBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBsZXhlciwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbFxuICogYXR0ZW1wdCB0byBpbnZva2UgYHl5LnBhcnNlci5wYXJzZUVycm9yKClgOyB3aGVuIHRoaXMgY2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkXG4gKiBpdCB3aWxsIHRyeSB0byBpbnZva2UgYHl5LnBhcnNlRXJyb3IoKWAgaW5zdGVhZC4gV2hlbiB0aGF0IGNhbGxiYWNrIGlzIGFsc28gbm90XG4gKiBwcm92aWRlZCwgYSBgSmlzb25MZXhlckVycm9yYCBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gY29udGFpbmluZyB0aGUgZXJyb3JcbiAqIG1lc3NhZ2UgYW5kIGBoYXNoYCwgYXMgY29uc3RydWN0ZWQgYnkgdGhlIGBjb25zdHJ1Y3RMZXhFcnJvckluZm8oKWAgQVBJLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgbGV4ZXIncyBgSmlzb25MZXhlckVycm9yYCBlcnJvciBjbGFzcyBpcyBwYXNzZWQgdmlhIHRoZVxuICogYEV4Y2VwdGlvbkNsYXNzYCBhcmd1bWVudCwgd2hpY2ggaXMgaW52b2tlZCB0byBjb25zdHJ1Y3QgdGhlIGV4Y2VwdGlvblxuICogaW5zdGFuY2UgdG8gYmUgdGhyb3duLCBzbyB0ZWNobmljYWxseSBgcGFyc2VFcnJvcmAgd2lsbCB0aHJvdyB0aGUgb2JqZWN0XG4gKiBwcm9kdWNlZCBieSB0aGUgYG5ldyBFeGNlcHRpb25DbGFzcyhzdHIsIGhhc2gpYCBKYXZhU2NyaXB0IGV4cHJlc3Npb24uXG4gKlxuICogLS0tXG4gKlxuICogWW91IGNhbiBzcGVjaWZ5IGxleGVyIG9wdGlvbnMgYnkgc2V0dGluZyAvIG1vZGlmeWluZyB0aGUgYC5vcHRpb25zYCBvYmplY3Qgb2YgeW91ciBMZXhlciBpbnN0YW5jZS5cbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGF2YWlsYWJsZTpcbiAqXG4gKiAoT3B0aW9ucyBhcmUgcGVybWFuZW50LilcbiAqICBcbiAqICB5eToge1xuICogICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBvdmVycmlkZXMgdGhlIGRlZmF1bHQgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uLlxuICogIH1cbiAqXG4gKiAgbGV4ZXIub3B0aW9uczoge1xuICogICAgICBwcmVfbGV4OiAgZnVuY3Rpb24oKVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIGJlZm9yZSB0aGUgbGV4ZXIgaXMgaW52b2tlZCB0byBwcm9kdWNlIGFub3RoZXIgdG9rZW4uXG4gKiAgICAgICAgICAgICAgICAgYHRoaXNgIHJlZmVycyB0byB0aGUgTGV4ZXIgb2JqZWN0LlxuICogICAgICBwb3N0X2xleDogZnVuY3Rpb24odG9rZW4pIHsgcmV0dXJuIHRva2VuOyB9XG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgd2hlbiB0aGUgbGV4ZXIgaGFzIHByb2R1Y2VkIGEgdG9rZW4gYHRva2VuYDtcbiAqICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIGNhbiBvdmVycmlkZSB0aGUgcmV0dXJuZWQgdG9rZW4gdmFsdWUgYnkgcmV0dXJuaW5nIGFub3RoZXIuXG4gKiAgICAgICAgICAgICAgICAgV2hlbiBpdCBkb2VzIG5vdCByZXR1cm4gYW55ICh0cnV0aHkpIHZhbHVlLCB0aGUgbGV4ZXIgd2lsbCByZXR1cm5cbiAqICAgICAgICAgICAgICAgICB0aGUgb3JpZ2luYWwgYHRva2VuYC5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKlxuICogV0FSTklORzogdGhlIG5leHQgc2V0IG9mIG9wdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSBjaGFuZ2VkLiBUaGV5IGVjaG8gdGhlIGFiaWxpdGllcyBvZlxuICogdGhlIGxleGVyIGFzIHBlciB3aGVuIGl0IHdhcyBjb21waWxlZCFcbiAqXG4gKiAgICAgIHJhbmdlczogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyLlxuICogICAgICBmbGV4OiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWRcbiAqICAgICAgICAgICAgICAgICBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaC5cbiAqICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgaW52b2tlZDtcbiAqICAgICAgICAgICAgICAgICB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlLlxuICogICAgICB4cmVnZXhwOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcnVsZSByZWdleGVzIGFyZSBcImV4dGVuZGVkIHJlZ2V4IGZvcm1hdFwiIHJlcXVpcmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICBgWFJlZ0V4cGAgbGlicmFyeS4gV2hlbiB0aGlzICVvcHRpb24gaGFzIG5vdCBiZWVuIHNwZWNpZmllZCBhdCBjb21waWxlIHRpbWUsIGFsbCBsZXhlclxuICogICAgICAgICAgICAgICAgIHJ1bGUgcmVnZXhlcyBoYXZlIGJlZW4gd3JpdHRlbiBhcyBzdGFuZGFyZCBKYXZhU2NyaXB0IFJlZ0V4cCBleHByZXNzaW9ucy5cbiAqICB9XG4gKi9cblxuXG52YXIgbGV4ZXIgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFNlZSBhbHNvOlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzODIxMDcvd2hhdHMtYS1nb29kLXdheS10by1leHRlbmQtZXJyb3ItaW4tamF2YXNjcmlwdC8jMzU4ODE1MDhcbiAgICogYnV0IHdlIGtlZXAgdGhlIHByb3RvdHlwZS5jb25zdHJ1Y3RvciBhbmQgcHJvdG90eXBlLm5hbWUgYXNzaWdubWVudCBsaW5lcyB0b28gZm9yIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCB1c2VybGFuZCBjb2RlIHdoaWNoIG1pZ2h0IGFjY2VzcyB0aGUgZGVyaXZlZCBjbGFzcyBpbiBhICdjbGFzc2ljJyB3YXkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBub2NvbGxhcHNlXG4gICAqL1xuICBmdW5jdGlvbiBKaXNvbkxleGVyRXJyb3IobXNnLCBoYXNoKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogJ0ppc29uTGV4ZXJFcnJvcidcbiAgICB9KTtcblxuICAgIGlmIChtc2cgPT0gbnVsbClcbiAgICAgIG1zZyA9ICc/Pz8nO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBtc2dcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgdmFyIHN0YWNrdHJhY2U7XG5cbiAgICBpZiAoaGFzaCAmJiBoYXNoLmV4Y2VwdGlvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB2YXIgZXgyID0gaGFzaC5leGNlcHRpb247XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBleDIubWVzc2FnZSB8fCBtc2c7XG4gICAgICBzdGFja3RyYWNlID0gZXgyLnN0YWNrO1xuICAgIH1cblxuICAgIGlmICghc3RhY2t0cmFjZSkge1xuICAgICAgaWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSB7XG4gICAgICAgIC8vIFY4XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2t0cmFjZSA9IG5ldyBFcnJvcihtc2cpLnN0YWNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFja3RyYWNlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc3RhY2t0cmFjZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoSmlzb25MZXhlckVycm9yLnByb3RvdHlwZSwgRXJyb3IucHJvdG90eXBlKTtcbiAgfSBlbHNlIHtcbiAgICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICB9XG5cbiAgSmlzb25MZXhlckVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEppc29uTGV4ZXJFcnJvcjtcbiAgSmlzb25MZXhlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ppc29uTGV4ZXJFcnJvcic7XG5cbiAgdmFyIGxleGVyID0ge1xuICAgIFxuLy8gQ29kZSBHZW5lcmF0b3IgSW5mb3JtYXRpb24gUmVwb3J0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBPcHRpb25zOlxuLy9cbi8vICAgYmFja3RyYWNraW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICBsb2NhdGlvbi5yYW5nZXM6IC4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIGxvY2F0aW9uIGxpbmUrY29sdW1uIHRyYWNraW5nOiAuLi4gdHJ1ZVxuLy9cbi8vXG4vLyBGb3J3YXJkZWQgUGFyc2VyIEFuYWx5c2lzIGZsYWdzOlxuLy9cbi8vICAgdXNlcyB5eWxlbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5bGluZW5vOiAuLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eWxsb2M6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIGxleGVyIHZhbHVlczogLi4uLi4uLi4uLi4uLi4uIHRydWUgLyB0cnVlXG4vLyAgIGxvY2F0aW9uIHRyYWNraW5nOiAuLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuLy8gICBsb2NhdGlvbiBhc3NpZ25tZW50OiAuLi4uLi4uLi4uLi4uIHRydWVcbi8vXG4vL1xuLy8gTGV4ZXIgQW5hbHlzaXMgZmxhZ3M6XG4vL1xuLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5bGluZW5vOiAuLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5dGV4dDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIFBhcnNlRXJyb3IgQVBJOiAuLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5ZXJyb3I6IC4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGxvY2F0aW9uIHRyYWNraW5nICYgZWRpdGluZzogID8/P1xuLy8gICB1c2VzIG1vcmUoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHVucHV0KCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHJlamVjdCgpIEFQSTogLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGxlc3MoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGRpc3BsYXkgQVBJcyBwYXN0SW5wdXQoKSwgdXBjb21pbmdJbnB1dCgpLCBzaG93UG9zaXRpb24oKTpcbi8vICAgICAgICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBkZXNjcmliZVlZTExPQygpIEFQSTogLi4uLi4uLiA/Pz9cbi8vXG4vLyAtLS0tLS0tLS0gRU5EIE9GIFJFUE9SVCAtLS0tLS0tLS0tLVxuXG5FT0Y6IDEsXG4gICAgRVJST1I6IDIsXG5cbiAgICAvLyBKaXNvbkxleGVyRXJyb3I6IEppc29uTGV4ZXJFcnJvciwgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdG9yXG5cbiAgICAvLyBvcHRpb25zOiB7fSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdG9yXG5cbiAgICAvLyB5eTogLi4uLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgc2V0SW5wdXQoKVxuXG4gICAgX19jdXJyZW50UnVsZVNldF9fOiBudWxsLCAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IGludGVybmFsIHJ1bGUgc2V0IGNhY2hlIGZvciB0aGUgY3VycmVudCBsZXhlciBzdGF0ZSAgXG5cbiAgICBfX2Vycm9yX2luZm9zOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBsZXhFcnJvckluZm8gb2JqZWN0cyBjcmVhdGVkIHNpbmNlIHRoZSBsYXN0IGNsZWFudXAgIFxuICAgIF9fZGVjb21wcmVzc2VkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiBtYXJrIHdoZXRoZXIgdGhlIGxleGVyIGluc3RhbmNlIGhhcyBiZWVuICd1bmZvbGRlZCcgY29tcGxldGVseSBhbmQgaXMgbm93IHJlYWR5IGZvciB1c2UgIFxuICAgIGRvbmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfYmFja3RyYWNrOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX2lucHV0OiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9tb3JlOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfc2lnbmFsZWRfZXJyb3JfdG9rZW46IGZhbHNlLCAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgY29uZGl0aW9uU3RhY2s6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk7IG1hbmFnZWQgdmlhIGBwdXNoU3RhdGUoKWAsIGBwb3BTdGF0ZSgpYCwgYHRvcFN0YXRlKClgIGFuZCBgc3RhdGVTdGFja1NpemUoKWAgIFxuICAgIG1hdGNoOiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyIGZvciB0aGUgbGV4ZXIgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uLiBgbWF0Y2hgIGlzIGlkZW50aWNhbCB0byBgeXl0ZXh0YCBleGNlcHQgdGhhdCB0aGlzIG9uZSBzdGlsbCBjb250YWlucyB0aGUgbWF0Y2hlZCBpbnB1dCBzdHJpbmcgYWZ0ZXIgYGxleGVyLnBlcmZvcm1BY3Rpb24oKWAgaGFzIGJlZW4gaW52b2tlZCwgd2hlcmUgdXNlcmxhbmQgY29kZSBNQVkgaGF2ZSBjaGFuZ2VkL3JlcGxhY2VkIHRoZSBgeXl0ZXh0YCB2YWx1ZSBlbnRpcmVseSEgIFxuICAgIG1hdGNoZWQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGVudGlyZSBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciAgXG4gICAgbWF0Y2hlczogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgUkUgbWF0Y2ggcmVzdWx0IGZvciBsYXN0IChzdWNjZXNzZnVsKSBtYXRjaCBhdHRlbXB0ICBcbiAgICB5eXRleHQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyIGZvciB0aGUgbGV4ZXIgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uOyB0aGlzIHZhbHVlIGlzIHRyYW5zZmVycmVkIHRvIHRoZSBwYXJzZXIgYXMgdGhlICd0b2tlbiB2YWx1ZScgd2hlbiB0aGUgcGFyc2VyIGNvbnN1bWVzIHRoZSBsZXhlciB0b2tlbiBwcm9kdWNlZCB0aHJvdWdoIGEgY2FsbCB0byB0aGUgYGxleCgpYCBBUEkuICBcbiAgICBvZmZzZXQ6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyB0aGUgJ2N1cnNvciBwb3NpdGlvbicgaW4gdGhlIGlucHV0IHN0cmluZywgaS5lLiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgbWF0Y2hlZCBzbyBmYXIgIFxuICAgIHl5bGVuZzogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogbGVuZ3RoIG9mIG1hdGNoZWQgaW5wdXQgZm9yIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gKGB5eXRleHRgKSAgXG4gICAgeXlsaW5lbm86IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiAnbGluZSBudW1iZXInIGF0IHdoaWNoIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gaXMgbG9jYXRlZCAgXG4gICAgeXlsbG9jOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgbG9jYXRpb24gaW5mbyAobGluZXMgKyBjb2x1bW5zKSBmb3IgdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiAgXG5cbiAgICAvKipcbiAgICAgKiBJTlRFUk5BTCBVU0U6IGNvbnN0cnVjdCBhIHN1aXRhYmxlIGVycm9yIGluZm8gaGFzaCBvYmplY3QgaW5zdGFuY2UgZm9yIGBwYXJzZUVycm9yYC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdExleEVycm9ySW5mbzogZnVuY3Rpb24gbGV4ZXJfY29uc3RydWN0TGV4RXJyb3JJbmZvKG1zZywgcmVjb3ZlcmFibGUpIHtcbiAgICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICAgIHZhciBwZWkgPSB7XG4gICAgICAgIGVyclN0cjogbXNnLFxuICAgICAgICByZWNvdmVyYWJsZTogISFyZWNvdmVyYWJsZSxcbiAgICAgICAgdGV4dDogdGhpcy5tYXRjaCwgICAgICAgICAgIC8vIFRoaXMgb25lIE1BWSBiZSBlbXB0eTsgdXNlcmxhbmQgY29kZSBzaG91bGQgdXNlIHRoZSBgdXBjb21pbmdJbnB1dGAgQVBJIHRvIG9idGFpbiBtb3JlIHRleHQgd2hpY2ggZm9sbG93cyB0aGUgJ2xleGVyIGN1cnNvciBwb3NpdGlvbicuLi4gIFxuICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgbGluZTogdGhpcy55eWxpbmVubyxcbiAgICAgICAgbG9jOiB0aGlzLnl5bGxvYyxcbiAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgIGxleGVyOiB0aGlzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbmQgbWFrZSBzdXJlIHRoZSBlcnJvciBpbmZvIGRvZXNuJ3Qgc3RheSBkdWUgdG8gcG90ZW50aWFsXG4gICAgICAgICAqIHJlZiBjeWNsZSB2aWEgdXNlcmxhbmQgY29kZSBtYW5pcHVsYXRpb25zLlxuICAgICAgICAgKiBUaGVzZSB3b3VsZCBvdGhlcndpc2UgYWxsIGJlIG1lbW9yeSBsZWFrIG9wcG9ydHVuaXRpZXMhXG4gICAgICAgICAqIFxuICAgICAgICAgKiBOb3RlIHRoYXQgb25seSBhcnJheSBhbmQgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIG51a2VkIGFzIHRob3NlXG4gICAgICAgICAqIGNvbnN0aXR1dGUgdGhlIHNldCBvZiBlbGVtZW50cyB3aGljaCBjYW4gcHJvZHVjZSBhIGN5Y2xpYyByZWYuXG4gICAgICAgICAqIFRoZSByZXN0IG9mIHRoZSBtZW1iZXJzIGlzIGtlcHQgaW50YWN0IGFzIHRoZXkgYXJlIGhhcm1sZXNzLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdGhpcyB7TGV4RXJyb3JJbmZvfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJ1Y3RMZXhFcnJvckluZm8oKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGN5Y2xpYyByZWZlcmVuY2VzIGFkZGVkIHRvIGVycm9yIGluZm86XG4gICAgICAgICAgLy8gaW5mby55eSA9IG51bGw7XG4gICAgICAgICAgLy8gaW5mby5sZXhlciA9IG51bGw7XG4gICAgICAgICAgLy8gLi4uXG4gICAgICAgICAgdmFyIHJlYyA9ICEhdGhpcy5yZWNvdmVyYWJsZTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlY292ZXJhYmxlID0gcmVjO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyB0cmFjayB0aGlzIGluc3RhbmNlIHNvIHdlIGNhbiBgZGVzdHJveSgpYCBpdCBvbmNlIHdlIGRlZW0gaXQgc3VwZXJmbHVvdXMgYW5kIHJlYWR5IGZvciBnYXJiYWdlIGNvbGxlY3Rpb24hXG4gICAgICB0aGlzLl9fZXJyb3JfaW5mb3MucHVzaChwZWkpO1xuXG4gICAgICByZXR1cm4gcGVpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGVyIHdoaWNoIGlzIGludm9rZWQgd2hlbiBhIGxleGVyIGVycm9yIG9jY3Vycy5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIGxleGVyX3BhcnNlRXJyb3Ioc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykge1xuICAgICAgaWYgKCFFeGNlcHRpb25DbGFzcykge1xuICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25MZXhlckVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55eSkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIgJiYgdHlwZW9mIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHx8IHRoaXMuRVJST1I7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnl5LnBhcnNlRXJyb3IuY2FsbCh0aGlzLCBzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb25DbGFzcyhzdHIsIGhhc2gpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZXRob2Qgd2hpY2ggaW1wbGVtZW50cyBgeXllcnJvcihzdHIsIC4uLmFyZ3MpYCBmdW5jdGlvbmFsaXR5IGZvciB1c2UgaW5zaWRlIGxleGVyIGFjdGlvbnMuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB5eWVycm9yOiBmdW5jdGlvbiB5eUVycm9yKHN0ciAvKiwgLi4uYXJncyAqLykge1xuICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICdMZXhpY2FsIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiAnICsgc3RyLFxuICAgICAgICB0aGlzLm9wdGlvbnMubGV4ZXJFcnJvcnNBcmVSZWNvdmVyYWJsZVxuICAgICAgKTtcblxuICAgICAgLy8gQWRkIGFueSBleHRyYSBhcmdzIHRvIHRoZSBoYXNoIHVuZGVyIHRoZSBuYW1lIGBleHRyYV9lcnJvcl9hdHRyaWJ1dGVzYDpcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHAuZXh0cmFfZXJyb3JfYXR0cmlidXRlcyA9IGFyZ3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5hbCBjbGVhbnVwIGZ1bmN0aW9uIGZvciB3aGVuIHdlIGhhdmUgY29tcGxldGVkIGxleGluZyB0aGUgaW5wdXQ7XG4gICAgICogbWFrZSBpdCBhbiBBUEkgc28gdGhhdCBleHRlcm5hbCBjb2RlIGNhbiB1c2UgdGhpcyBvbmUgb25jZSB1c2VybGFuZFxuICAgICAqIGNvZGUgaGFzIGRlY2lkZWQgaXQncyB0aW1lIHRvIGRlc3Ryb3kgYW55IGxpbmdlcmluZyBsZXhlciBlcnJvclxuICAgICAqIGhhc2ggb2JqZWN0IGluc3RhbmNlcyBhbmQgdGhlIGxpa2U6IHRoaXMgZnVuY3Rpb24gaGVscHMgdG8gY2xlYW5cbiAgICAgKiB1cCB0aGVzZSBjb25zdHJ1Y3RzLCB3aGljaCAqbWF5KiBjYXJyeSBjeWNsaWMgcmVmZXJlbmNlcyB3aGljaCB3b3VsZFxuICAgICAqIG90aGVyd2lzZSBwcmV2ZW50IHRoZSBpbnN0YW5jZXMgZnJvbSBiZWluZyBwcm9wZXJseSBhbmQgdGltZWx5XG4gICAgICogZ2FyYmFnZS1jb2xsZWN0ZWQsIGkuZS4gdGhpcyBmdW5jdGlvbiBoZWxwcyBwcmV2ZW50IG1lbW9yeSBsZWFrcyFcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNsZWFudXBBZnRlckxleDogZnVuY3Rpb24gbGV4ZXJfY2xlYW51cEFmdGVyTGV4KGRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgIC8vIHByZXZlbnQgbGluZ2VyaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgZnJvbSBjYXVzaW5nIG1lbW9yeSBsZWFrczpcbiAgICAgIHRoaXMuc2V0SW5wdXQoJycsIHt9KTtcblxuICAgICAgLy8gbnVrZSB0aGUgZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlcyBjcmVhdGVkIGR1cmluZyB0aGlzIHJ1bi5cbiAgICAgIC8vIFVzZXJsYW5kIGNvZGUgbXVzdCBDT1BZIGFueSBkYXRhL3JlZmVyZW5jZXNcbiAgICAgIC8vIGluIHRoZSBlcnJvciBoYXNoIGluc3RhbmNlKHMpIGl0IGlzIG1vcmUgcGVybWFuZW50bHkgaW50ZXJlc3RlZCBpbi5cbiAgICAgIGlmICghZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fX2Vycm9yX2luZm9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGVsID0gdGhpcy5fX2Vycm9yX2luZm9zW2ldO1xuXG4gICAgICAgICAgaWYgKGVsICYmIHR5cGVvZiBlbC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlbC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjbGVhciB0aGUgbGV4ZXIgdG9rZW4gY29udGV4dDsgaW50ZW5kZWQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gbGV4ZXJfY2xlYXIoKSB7XG4gICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgdGhpcy55eWxlbmcgPSAwO1xuICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuXG4gICAgICAvLyAtIERPIE5PVCByZXNldCBgdGhpcy5tYXRjaGVkYFxuICAgICAgdGhpcy5tYXRjaGVzID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgdmFyIGNvbCA9ICh0aGlzLnl5bGxvYyA/IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uIDogMCk7XG5cbiAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgZmlyc3RfY29sdW1uOiBjb2wsXG4gICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgIGxhc3RfY29sdW1uOiBjb2wsXG4gICAgICAgIHJhbmdlOiBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHNldElucHV0OiBmdW5jdGlvbiBsZXhlcl9zZXRJbnB1dChpbnB1dCwgeXkpIHtcbiAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuXG4gICAgICAvLyBhbHNvIGNoZWNrIGlmIHdlJ3ZlIGZ1bGx5IGluaXRpYWxpemVkIHRoZSBsZXhlciBpbnN0YW5jZSxcbiAgICAgIC8vIGluY2x1ZGluZyBleHBhbnNpb24gd29yayB0byBiZSBkb25lIHRvIGdvIGZyb20gYSBsb2FkZWRcbiAgICAgIC8vIGxleGVyIHRvIGEgdXNhYmxlIGxleGVyOlxuICAgICAgaWYgKCF0aGlzLl9fZGVjb21wcmVzc2VkKSB7XG4gICAgICAgIC8vIHN0ZXAgMTogZGVjb21wcmVzcyB0aGUgcmVnZXggbGlzdDpcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcnVsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnVsZV9yZSA9IHJ1bGVzW2ldO1xuXG4gICAgICAgICAgLy8gY29tcHJlc3Npb246IGlzIHRoZSBSRSBhbiB4cmVmIHRvIGFub3RoZXIgUkUgc2xvdCBpbiB0aGUgcnVsZXNbXSB0YWJsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVfcmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBydWxlc1tpXSA9IHJ1bGVzW3J1bGVfcmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0ZXAgMjogdW5mb2xkIHRoZSBjb25kaXRpb25zW10gc2V0IHRvIG1ha2UgdGhlc2UgcmVhZHkgZm9yIHVzZTpcbiAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSB0aGlzLmNvbmRpdGlvbnM7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgdmFyIHNwZWMgPSBjb25kaXRpb25zW2tdO1xuICAgICAgICAgIHZhciBydWxlX2lkcyA9IHNwZWMucnVsZXM7XG4gICAgICAgICAgdmFyIGxlbiA9IHJ1bGVfaWRzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgcnVsZV9yZWdleGVzID0gbmV3IEFycmF5KGxlbiArIDEpOyAgICAgICAgICAgICAvLyBzbG90IDAgaXMgdW51c2VkOyB3ZSB1c2UgYSAxLWJhc2VkIGluZGV4IGFwcHJvYWNoIGhlcmUgdG8ga2VlcCB0aGUgaG90dGVzdCBjb2RlIGluIGBsZXhlcl9uZXh0KClgIGZhc3QgYW5kIHNpbXBsZSEgXG4gICAgICAgICAgdmFyIHJ1bGVfbmV3X2lkcyA9IG5ldyBBcnJheShsZW4gKyAxKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBydWxlX2lkc1tpXTtcbiAgICAgICAgICAgIHZhciBydWxlX3JlID0gcnVsZXNbaWR4XTtcbiAgICAgICAgICAgIHJ1bGVfcmVnZXhlc1tpICsgMV0gPSBydWxlX3JlO1xuICAgICAgICAgICAgcnVsZV9uZXdfaWRzW2kgKyAxXSA9IGlkeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGVjLnJ1bGVzID0gcnVsZV9uZXdfaWRzO1xuICAgICAgICAgIHNwZWMuX19ydWxlX3JlZ2V4ZXMgPSBydWxlX3JlZ2V4ZXM7XG4gICAgICAgICAgc3BlYy5fX3J1bGVfY291bnQgPSBsZW47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZGVjb21wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dCB8fCAnJztcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuID0gZmFsc2U7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMueXlsaW5lbm8gPSAwO1xuICAgICAgdGhpcy5tYXRjaGVkID0gJyc7XG4gICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG5cbiAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgbGFzdF9jb2x1bW46IDAsXG4gICAgICAgIHJhbmdlOiBbMCwgMF1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlZGl0IHRoZSByZW1haW5pbmcgaW5wdXQgdmlhIHVzZXItc3BlY2lmaWVkIGNhbGxiYWNrLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yd2FyZC1hZGp1c3QgdGhlIGlucHV0LXRvLXBhcnNlLCBcbiAgICAgKiBlLmcuIGluc2VydGluZyBtYWNybyBleHBhbnNpb25zIGFuZCBhbGlrZSBpbiB0aGVcbiAgICAgKiBpbnB1dCB3aGljaCBoYXMgeWV0IHRvIGJlIGxleGVkLlxuICAgICAqIFRoZSBiZWhhdmlvdXIgb2YgdGhpcyBBUEkgY29udHJhc3RzIHRoZSBgdW5wdXQoKWAgZXQgYWxcbiAgICAgKiBBUElzIGFzIHRob3NlIGFjdCBvbiB0aGUgKmNvbnN1bWVkKiBpbnB1dCwgd2hpbGUgdGhpc1xuICAgICAqIG9uZSBhbGxvd3Mgb25lIHRvIG1hbmlwdWxhdGUgdGhlIGZ1dHVyZSwgd2l0aG91dCBpbXBhY3RpbmdcbiAgICAgKiB0aGUgY3VycmVudCBgeXlsb2NgIGN1cnNvciBsb2NhdGlvbiBvciBhbnkgaGlzdG9yeS4gXG4gICAgICogXG4gICAgICogVXNlIHRoaXMgQVBJIHRvIGhlbHAgaW1wbGVtZW50IEMtcHJlcHJvY2Vzc29yLWxpa2VcbiAgICAgKiBgI2luY2x1ZGVgIHN0YXRlbWVudHMsIGV0Yy5cbiAgICAgKiBcbiAgICAgKiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgbXVzdCBiZSBzeW5jaHJvbm91cyBhbmQgaXNcbiAgICAgKiBleHBlY3RlZCB0byByZXR1cm4gdGhlIGVkaXRlZCBpbnB1dCAoc3RyaW5nKS5cbiAgICAgKlxuICAgICAqIFRoZSBgY3BzQXJnYCBhcmd1bWVudCB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gICAgICogYXMtaXMuXG4gICAgICpcbiAgICAgKiBgY2FsbGJhY2tgIGludGVyZmFjZTogXG4gICAgICogYGZ1bmN0aW9uIGNhbGxiYWNrKGlucHV0LCBjcHNBcmcpYFxuICAgICAqIFxuICAgICAqIC0gYGlucHV0YCB3aWxsIGNhcnJ5IHRoZSByZW1haW5pbmctaW5wdXQtdG8tbGV4IHN0cmluZ1xuICAgICAqICAgZnJvbSB0aGUgbGV4ZXIuXG4gICAgICogLSBgY3BzQXJnYCBpcyBgY3BzQXJnYCBwYXNzZWQgaW50byB0aGlzIEFQSS5cbiAgICAgKiBcbiAgICAgKiBUaGUgYHRoaXNgIHJlZmVyZW5jZSBmb3IgdGhlIGNhbGxiYWNrIHdpbGwgYmUgc2V0IHRvXG4gICAgICogcmVmZXJlbmNlIHRoaXMgbGV4ZXIgaW5zdGFuY2Ugc28gdGhhdCB1c2VybGFuZCBjb2RlXG4gICAgICogaW4gdGhlIGNhbGxiYWNrIGNhbiBlYXNpbHkgYW5kIHF1aWNrbHkgYWNjZXNzIGFueSBsZXhlclxuICAgICAqIEFQSS4gXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgbm9uLXN0cmluZy10eXBlIGZhbHNleSB2YWx1ZSxcbiAgICAgKiB3ZSBhc3N1bWUgdGhlIGNhbGxiYWNrIGRpZCBub3QgZWRpdCB0aGUgaW5wdXQgYW5kIHdlXG4gICAgICogd2lsbCB1c2luZyB0aGUgaW5wdXQgYXMtaXMuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgbm9uLXN0cmluZy10eXBlIHZhbHVlLCBpdFxuICAgICAqIGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBmb3IgbGV4aW5nIHZpYSB0aGUgYFwiXCIgKyByZXR2YWxgXG4gICAgICogb3BlcmF0aW9uLiAoU2VlIGFsc28gd2h5OiBodHRwOi8vMmFsaXR5LmNvbS8yMDEyLzAzL2NvbnZlcnRpbmctdG8tc3RyaW5nLmh0bWwgXG4gICAgICogLS0gdGhhdCB3YXkgYW55IHJldHVybmVkIG9iamVjdCdzIGB0b1ZhbHVlKClgIGFuZCBgdG9TdHJpbmcoKWBcbiAgICAgKiBtZXRob2RzIHdpbGwgYmUgaW52b2tlZCBpbiBhIHByb3Blci9kZXNpcmFibGUgb3JkZXIuKVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgZWRpdFJlbWFpbmluZ0lucHV0OiBmdW5jdGlvbiBsZXhlcl9lZGl0UmVtYWluaW5nSW5wdXQoY2FsbGJhY2ssIGNwc0FyZykge1xuICAgICAgdmFyIHJ2ID0gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9pbnB1dCwgY3BzQXJnKTtcblxuICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHJ2KSB7XG4gICAgICAgICAgdGhpcy5faW5wdXQgPSAnJyArIHJ2O1xuICAgICAgICB9IFxuICAgICAgICAvLyBlbHNlOiBrZWVwIGB0aGlzLl9pbnB1dGAgYXMgaXMuICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gcnY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgaW5wdXQ6IGZ1bmN0aW9uIGxleGVyX2lucHV0KCkge1xuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAvL3RoaXMuZG9uZSA9IHRydWU7ICAgIC0tIGRvbid0IHNldCBgZG9uZWAgYXMgd2Ugd2FudCB0aGUgbGV4KCkvbmV4dCgpIEFQSSB0byBiZSBhYmxlIHRvIHByb2R1Y2Ugb25lIGN1c3RvbSBFT0YgdG9rZW4gbWF0Y2ggYWZ0ZXIgdGhpcyBhbnlob3cuIChsZXhlciBjYW4gbWF0Y2ggc3BlY2lhbCA8PEVPRj4+IHRva2VucyBhbmQgcGVyZm9ybSB1c2VyIGFjdGlvbiBjb2RlIGZvciBhIDw8RU9GPj4gbWF0Y2gsIGJ1dCBvbmx5IGRvZXMgc28gKm9uY2UqKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcblxuICAgICAgLy8gQ291bnQgdGhlIGxpbmVudW1iZXIgdXAgd2hlbiB3ZSBoaXQgdGhlIExGIChvciBhIHN0YW5kLWFsb25lIENSKS5cbiAgICAgIC8vIE9uIENSTEYsIHRoZSBsaW5lbnVtYmVyIGlzIGluY3JlbWVudGVkIHdoZW4geW91IGZldGNoIHRoZSBDUiBvciB0aGUgQ1JMRiBjb21ib1xuICAgICAgLy8gYW5kIHdlIGFkdmFuY2UgaW1tZWRpYXRlbHkgcGFzdCB0aGUgTEYgYXMgd2VsbCwgcmV0dXJuaW5nIGJvdGggdG9nZXRoZXIgYXMgaWZcbiAgICAgIC8vIGl0IHdhcyBhbGwgYSBzaW5nbGUgJ2NoYXJhY3Rlcicgb25seS5cbiAgICAgIHZhciBzbGljZV9sZW4gPSAxO1xuXG4gICAgICB2YXIgbGluZXMgPSBmYWxzZTtcblxuICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICBsaW5lcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICBsaW5lcyA9IHRydWU7XG4gICAgICAgIHZhciBjaDIgPSB0aGlzLl9pbnB1dFsxXTtcblxuICAgICAgICBpZiAoY2gyID09PSAnXFxuJykge1xuICAgICAgICAgIHNsaWNlX2xlbisrO1xuICAgICAgICAgIGNoICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDI7XG4gICAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHRoaXMubWF0Y2ggKz0gY2gyO1xuICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDI7XG4gICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgIH1cblxuICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2Uoc2xpY2VfbGVuKTtcbiAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5zaGlmdHMgb25lIGNoYXIgKG9yIGFuIGVudGlyZSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB1bnB1dDogZnVuY3Rpb24gbGV4ZXJfdW5wdXQoY2gpIHtcbiAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gbGVuKTtcbiAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIGxlbik7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gdGhpcy55eWxpbmVubyArIDE7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLm1hdGNoO1xuICAgICAgICB2YXIgcHJlX2xpbmVzID0gcHJlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgaWYgKHByZV9saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBwcmUgPSB0aGlzLm1hdGNoZWQ7XG4gICAgICAgICAgcHJlX2xpbmVzID0gcHJlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IHByZV9saW5lc1twcmVfbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gLT0gbGVuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSA9IHRoaXMueXlsbG9jLnJhbmdlWzBdICsgdGhpcy55eWxlbmc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWNoZSBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZCBpdCBvbiBuZXh0IGFjdGlvblxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbW9yZTogZnVuY3Rpb24gbGV4ZXJfbW9yZSgpIHtcbiAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpZ25hbCB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGVcbiAgICAgKiBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICByZWplY3Q6IGZ1bmN0aW9uIGxleGVyX3JlamVjdCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIHRoZSBgcGFyc2VFcnJvcigpYCBjYWxsIHJldHVybnMsIHdlIE1VU1QgZW5zdXJlIHRoYXQgdGhlIGVycm9yIGlzIHJlZ2lzdGVyZWQuXG4gICAgICAgIC8vIFdlIGFjY29tcGxpc2ggdGhpcyBieSBzaWduYWxpbmcgYW4gJ2Vycm9yJyB0b2tlbiB0byBiZSBwcm9kdWNlZCBmb3IgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gYC5sZXgoKWAgcnVuLlxuICAgICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zX3N0ciA9ICcnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwb3Nfc3RyID0gdGhpcy5zaG93UG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmIChwb3Nfc3RyICYmIHBvc19zdHJbMF0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBwb3Nfc3RyID0gJ1xcbicgKyBwb3Nfc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6IFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS4nICsgcG9zX3N0cixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBsZXNzOiBmdW5jdGlvbiBsZXhlcl9sZXNzKG4pIHtcbiAgICAgIHJldHVybiB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gKHBhcnQgb2YgdGhlKSBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yXG4gICAgICogbWVzc2FnZXMuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyBsZW5ndGggdG8gYG1heFNpemVgIChkZWZhdWx0OiAyMCkuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyB0byB0aGUgYG1heExpbmVzYCBudW1iZXIgb2YgbGluZXMgb2ZcbiAgICAgKiBpbnB1dCAoZGVmYXVsdDogMSkuXG4gICAgICogXG4gICAgICogTmVnYXRpdmUgbGltaXQgdmFsdWVzIGVxdWFsICp1bmxpbWl0ZWQqLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcGFzdElucHV0OiBmdW5jdGlvbiBsZXhlcl9wYXN0SW5wdXQobWF4U2l6ZSwgbWF4TGluZXMpIHtcbiAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cmluZygwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuXG4gICAgICBpZiAobWF4U2l6ZSA8IDApXG4gICAgICAgIG1heFNpemUgPSBwYXN0Lmxlbmd0aDtcbiAgICAgIGVsc2UgaWYgKCFtYXhTaXplKVxuICAgICAgICBtYXhTaXplID0gMjA7XG5cbiAgICAgIGlmIChtYXhMaW5lcyA8IDApXG4gICAgICAgIG1heExpbmVzID0gcGFzdC5sZW5ndGg7ICAgICAgICAgIC8vIGNhbid0IGV2ZXIgaGF2ZSBtb3JlIGlucHV0IGxpbmVzIHRoYW4gdGhpcyEgXG4gICAgICBlbHNlIGlmICghbWF4TGluZXMpXG4gICAgICAgIG1heExpbmVzID0gMTtcblxuICAgICAgLy8gYHN1YnN0cmAgYW50aWNpcGF0aW9uOiB0cmVhdCBcXHJcXG4gYXMgYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCB0YWtlIGEgbGl0dGxlXG4gICAgICAvLyBtb3JlIHRoYW4gbmVjZXNzYXJ5IHNvIHRoYXQgd2UgY2FuIHN0aWxsIHByb3Blcmx5IGNoZWNrIGFnYWluc3QgbWF4U2l6ZVxuICAgICAgLy8gYWZ0ZXIgd2UndmUgdHJhbnNmb3JtZWQgYW5kIGxpbWl0ZWQgdGhlIG5ld0xpbmVzIGluIGhlcmU6XG4gICAgICBwYXN0ID0gcGFzdC5zdWJzdHIoLW1heFNpemUgKiAyIC0gMik7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYSBzaWduaWZpY2FudGx5IHJlZHVjZWQgc3RyaW5nIHRvIHByb2Nlc3MsIHRyYW5zZm9ybSB0aGUgbmV3bGluZXNcbiAgICAgIC8vIGFuZCBjaG9wIHRoZW0sIHRoZW4gbGltaXQgdGhlbTpcbiAgICAgIHZhciBhID0gcGFzdC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGEgPSBhLnNsaWNlKC1tYXhMaW5lcyk7XG4gICAgICBwYXN0ID0gYS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gV2hlbiwgYWZ0ZXIgbGltaXRpbmcgdG8gbWF4TGluZXMsIHdlIHN0aWxsIGhhdmUgdG9vIG11Y2ggdG8gcmV0dXJuLFxuICAgICAgLy8gZG8gYWRkIGFuIGVsbGlwc2lzIHByZWZpeC4uLlxuICAgICAgaWYgKHBhc3QubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBwYXN0ID0gJy4uLicgKyBwYXN0LnN1YnN0cigtbWF4U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gKHBhcnQgb2YgdGhlKSB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyBsZW5ndGggdG8gYG1heFNpemVgIChkZWZhdWx0OiAyMCkuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyB0byB0aGUgYG1heExpbmVzYCBudW1iZXIgb2YgbGluZXMgb2YgaW5wdXQgKGRlZmF1bHQ6IDEpLlxuICAgICAqIFxuICAgICAqIE5lZ2F0aXZlIGxpbWl0IHZhbHVlcyBlcXVhbCAqdW5saW1pdGVkKi5cbiAgICAgKlxuICAgICAqID4gIyMjIE5PVEUgIyMjXG4gICAgICogPlxuICAgICAqID4gKlwidXBjb21pbmcgaW5wdXRcIiogaXMgZGVmaW5lZCBhcyB0aGUgd2hvbGUgb2YgdGhlIGJvdGhcbiAgICAgKiA+IHRoZSAqY3VycmVudGx5IGxleGVkKiBpbnB1dCwgdG9nZXRoZXIgd2l0aCBhbnkgcmVtYWluaW5nIGlucHV0XG4gICAgICogPiBmb2xsb3dpbmcgdGhhdC4gKlwiY3VycmVudGx5IGxleGVkXCIqIGlucHV0IGlzIHRoZSBpbnB1dCBcbiAgICAgKiA+IGFscmVhZHkgcmVjb2duaXplZCBieSB0aGUgbGV4ZXIgYnV0IG5vdCB5ZXQgcmV0dXJuZWQgd2l0aFxuICAgICAqID4gdGhlIGxleGVyIHRva2VuLiBUaGlzIGhhcHBlbnMgd2hlbiB5b3UgYXJlIGludm9raW5nIHRoaXMgQVBJXG4gICAgICogPiBmcm9tIGluc2lkZSBhbnkgbGV4ZXIgcnVsZSBhY3Rpb24gY29kZSBibG9jay4gXG4gICAgICogPlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24gbGV4ZXJfdXBjb21pbmdJbnB1dChtYXhTaXplLCBtYXhMaW5lcykge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuXG4gICAgICBpZiAobWF4U2l6ZSA8IDApXG4gICAgICAgIG1heFNpemUgPSBuZXh0Lmxlbmd0aCArIHRoaXMuX2lucHV0Lmxlbmd0aDtcbiAgICAgIGVsc2UgaWYgKCFtYXhTaXplKVxuICAgICAgICBtYXhTaXplID0gMjA7XG5cbiAgICAgIGlmIChtYXhMaW5lcyA8IDApXG4gICAgICAgIG1heExpbmVzID0gbWF4U2l6ZTsgICAgICAgICAgLy8gY2FuJ3QgZXZlciBoYXZlIG1vcmUgaW5wdXQgbGluZXMgdGhhbiB0aGlzISBcbiAgICAgIGVsc2UgaWYgKCFtYXhMaW5lcylcbiAgICAgICAgbWF4TGluZXMgPSAxO1xuXG4gICAgICAvLyBgc3Vic3RyaW5nYCBhbnRpY2lwYXRpb246IHRyZWF0IFxcclxcbiBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRha2UgYSBsaXR0bGVcbiAgICAgIC8vIG1vcmUgdGhhbiBuZWNlc3Nhcnkgc28gdGhhdCB3ZSBjYW4gc3RpbGwgcHJvcGVybHkgY2hlY2sgYWdhaW5zdCBtYXhTaXplXG4gICAgICAvLyBhZnRlciB3ZSd2ZSB0cmFuc2Zvcm1lZCBhbmQgbGltaXRlZCB0aGUgbmV3TGluZXMgaW4gaGVyZTpcbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IG1heFNpemUgKiAyICsgMikge1xuICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cmluZygwLCBtYXhTaXplICogMiArIDIpOyAgIC8vIHN1YnN0cmluZyBpcyBmYXN0ZXIgb24gQ2hyb21lL1Y4IFxuICAgICAgfVxuXG4gICAgICAvLyBub3cgdGhhdCB3ZSBoYXZlIGEgc2lnbmlmaWNhbnRseSByZWR1Y2VkIHN0cmluZyB0byBwcm9jZXNzLCB0cmFuc2Zvcm0gdGhlIG5ld2xpbmVzXG4gICAgICAvLyBhbmQgY2hvcCB0aGVtLCB0aGVuIGxpbWl0IHRoZW06XG4gICAgICB2YXIgYSA9IG5leHQucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICBhID0gYS5zbGljZSgwLCBtYXhMaW5lcyk7XG4gICAgICBuZXh0ID0gYS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gV2hlbiwgYWZ0ZXIgbGltaXRpbmcgdG8gbWF4TGluZXMsIHdlIHN0aWxsIGhhdmUgdG9vIG11Y2ggdG8gcmV0dXJuLFxuICAgICAgLy8gZG8gYWRkIGFuIGVsbGlwc2lzIHBvc3RmaXguLi5cbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQuc3Vic3RyaW5nKDAsIG1heFNpemUpICsgJy4uLic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgd2hpY2ggZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGVcbiAgICAgKiBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uIGxleGVyX3Nob3dQb3NpdGlvbihtYXhQcmVmaXgsIG1heFBvc3RmaXgpIHtcbiAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dChtYXhQcmVmaXgpLnJlcGxhY2UoL1xccy9nLCAnICcpO1xuICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oJy0nKTtcbiAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQobWF4UG9zdGZpeCkucmVwbGFjZSgvXFxzL2csICcgJykgKyAnXFxuJyArIGMgKyAnXic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHN0cmluZyB3aGljaCBkaXNwbGF5cyB0aGUgbGluZXMgJiBjb2x1bW5zIG9mIGlucHV0IHdoaWNoIGFyZSByZWZlcmVuY2VkIFxuICAgICAqIGJ5IHRoZSBnaXZlbiBsb2NhdGlvbiBpbmZvIHJhbmdlLCBwbHVzIGEgZmV3IGxpbmVzIG9mIGNvbnRleHQuXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiBwcmV0dHktcHJpbnRzIHRoZSBpbmRpY2F0ZWQgc2VjdGlvbiBvZiB0aGUgaW5wdXQsIHdpdGggbGluZSBudW1iZXJzIFxuICAgICAqIGFuZCBldmVyeXRoaW5nIVxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSB1c2VmdWwgdG8gcHJvdmlkZSBoaWdobHkgcmVhZGFibGUgZXJyb3IgcmVwb3J0cywgd2hpbGVcbiAgICAgKiB0aGUgbG9jYXRpb24gcmFuZ2UgbWF5IGJlIHNwZWNpZmllZCBpbiB2YXJpb3VzIGZsZXhpYmxlIHdheXM6XG4gICAgICogXG4gICAgICogLSBgbG9jYCBpcyB0aGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hpY2ggcmVmZXJlbmNlcyB0aGUgYXJlYSB3aGljaCBzaG91bGQgYmVcbiAgICAgKiAgIGRpc3BsYXllZCBhbmQgJ21hcmtlZCB1cCc6IHRoZXNlIGxpbmVzICYgY29sdW1ucyBvZiB0ZXh0IGFyZSBtYXJrZWQgdXAgYnkgYF5gXG4gICAgICogICBjaGFyYWN0ZXJzIGJlbG93IGVhY2ggY2hhcmFjdGVyIGluIHRoZSBlbnRpcmUgaW5wdXQgcmFuZ2UuXG4gICAgICogXG4gICAgICogLSBgY29udGV4dF9sb2NgIGlzIHRoZSAqb3B0aW9uYWwqIGxvY2F0aW9uIGluZm8gb2JqZWN0IHdoaWNoIGluc3RydWN0cyB0aGlzXG4gICAgICogICBwcmV0dHktcHJpbnRlciBob3cgbXVjaCAqbGVhZGluZyogY29udGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGFsb25nc2lkZVxuICAgICAqICAgdGhlIGFyZWEgcmVmZXJlbmNlZCBieSBgbG9jYC4gVGhpcyBjYW4gaGVscCBwcm92aWRlIGNvbnRleHQgZm9yIHRoZSBkaXNwbGF5ZWRcbiAgICAgKiAgIGVycm9yLCBldGMuXG4gICAgICogXG4gICAgICogICBXaGVuIHRoaXMgbG9jYXRpb24gaW5mbyBpcyBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBjb250ZXh0IG9mIDMgbGluZXMgaXNcbiAgICAgKiAgIHVzZWQuXG4gICAgICogXG4gICAgICogLSBgY29udGV4dF9sb2MyYCBpcyBhbm90aGVyICpvcHRpb25hbCogbG9jYXRpb24gaW5mbyBvYmplY3QsIHdoaWNoIHNlcnZlc1xuICAgICAqICAgYSBzaW1pbGFyIHB1cnBvc2UgdG8gYGNvbnRleHRfbG9jYDogaXQgc3BlY2lmaWVzIHRoZSBhbW91bnQgb2YgKnRyYWlsaW5nKlxuICAgICAqICAgY29udGV4dCBsaW5lcyB0byBkaXNwbGF5IGluIHRoZSBwcmV0dHktcHJpbnQgb3V0cHV0LlxuICAgICAqIFxuICAgICAqICAgV2hlbiB0aGlzIGxvY2F0aW9uIGluZm8gaXMgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgY29udGV4dCBvZiAxIGxpbmUgb25seSBpc1xuICAgICAqICAgdXNlZC5cbiAgICAgKiBcbiAgICAgKiBTcGVjaWFsIE5vdGVzOlxuICAgICAqIFxuICAgICAqIC0gd2hlbiB0aGUgYGxvY2AtaW5kaWNhdGVkIHJhbmdlIGlzIHZlcnkgbGFyZ2UgKGFib3V0IDUgbGluZXMgb3IgbW9yZSksIHRoZW5cbiAgICAgKiAgIG9ubHkgdGhlIGZpcnN0IGFuZCBsYXN0IGZldyBsaW5lcyBvZiB0aGlzIGJsb2NrIGFyZSBwcmludGVkIHdoaWxlIGFcbiAgICAgKiAgIGAuLi5jb250aW51ZWQuLi5gIG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkIGJldHdlZW4gdGhlbS5cbiAgICAgKiBcbiAgICAgKiAgIFRoaXMgc2VydmVzIHRoZSBwdXJwb3NlIG9mIG5vdCBwcmludGluZyBhIGh1Z2UgYW1vdW50IG9mIHRleHQgd2hlbiB0aGUgYGxvY2BcbiAgICAgKiAgIHJhbmdlIGhhcHBlbnMgdG8gYmUgaHVnZTogdGhpcyB3YXkgYSBtYW5hZ2VhYmxlICYgcmVhZGFibGUgb3V0cHV0IHJlc3VsdHNcbiAgICAgKiAgIGZvciBhcmJpdHJhcnkgbGFyZ2UgcmFuZ2VzLlxuICAgICAqIFxuICAgICAqIC0gdGhpcyBmdW5jdGlvbiBjYW4gZGlzcGxheSBsaW5lcyBvZiBpbnB1dCB3aGljaCB3aGF2ZSBub3QgeWV0IGJlZW4gbGV4ZWQuXG4gICAgICogICBgcHJldHR5UHJpbnRSYW5nZSgpYCBjYW4gYWNjZXNzIHRoZSBlbnRpcmUgaW5wdXQhXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwcmV0dHlQcmludFJhbmdlOiBmdW5jdGlvbiBsZXhlcl9wcmV0dHlQcmludFJhbmdlKGxvYywgY29udGV4dF9sb2MsIGNvbnRleHRfbG9jMikge1xuICAgICAgdmFyIGVycm9yX3NpemUgPSBsb2MubGFzdF9saW5lIC0gbG9jLmZpcnN0X2xpbmU7XG4gICAgICBjb25zdCBDT05URVhUID0gMztcbiAgICAgIGNvbnN0IENPTlRFWFRfVEFJTCA9IDE7XG4gICAgICBjb25zdCBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCA9IDI7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLm1hdGNoZWQgKyB0aGlzLl9pbnB1dDtcbiAgICAgIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgLy92YXIgc2hvd19jb250ZXh0ID0gKGVycm9yX3NpemUgPCA1IHx8IGNvbnRleHRfbG9jKTtcbiAgICAgIHZhciBsMCA9IE1hdGgubWF4KDEsIChjb250ZXh0X2xvYyA/IGNvbnRleHRfbG9jLmZpcnN0X2xpbmUgOiBsb2MuZmlyc3RfbGluZSAtIENPTlRFWFQpKTtcblxuICAgICAgdmFyIGwxID0gTWF0aC5tYXgoMSwgKGNvbnRleHRfbG9jMiA/IGNvbnRleHRfbG9jMi5sYXN0X2xpbmUgOiBsb2MubGFzdF9saW5lICsgQ09OVEVYVF9UQUlMKSk7XG4gICAgICB2YXIgbGluZW5vX2Rpc3BsYXlfd2lkdGggPSAxICsgTWF0aC5sb2cxMChsMSB8IDEpIHwgMDtcbiAgICAgIHZhciB3c19wcmVmaXggPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGgpLmpvaW4oJyAnKTtcbiAgICAgIHZhciBub25lbXB0eV9saW5lX2luZGV4ZXMgPSBbXTtcblxuICAgICAgdmFyIHJ2ID0gbGluZXMuc2xpY2UobDAgLSAxLCBsMSArIDEpLm1hcChmdW5jdGlvbiBpbmplY3RMaW5lTnVtYmVyKGxpbmUsIGluZGV4KSB7XG4gICAgICAgIHZhciBsbm8gPSBpbmRleCArIGwwO1xuICAgICAgICB2YXIgbG5vX3BmeCA9ICh3c19wcmVmaXggKyBsbm8pLnN1YnN0cigtbGluZW5vX2Rpc3BsYXlfd2lkdGgpO1xuICAgICAgICB2YXIgcnYgPSBsbm9fcGZ4ICsgJzogJyArIGxpbmU7XG4gICAgICAgIHZhciBlcnJwZnggPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCdeJyk7XG5cbiAgICAgICAgaWYgKGxubyA9PT0gbG9jLmZpcnN0X2xpbmUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jLmZpcnN0X2NvbHVtbiArIDI7XG5cbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICAgKChsbm8gPT09IGxvYy5sYXN0X2xpbmUgPyBsb2MubGFzdF9jb2x1bW4gOiBsaW5lLmxlbmd0aCkpIC0gbG9jLmZpcnN0X2NvbHVtbiArIDFcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdmFyIGxlYWQgPSBuZXcgQXJyYXkob2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIG1hcmsgPSBuZXcgQXJyYXkobGVuKS5qb2luKCdeJyk7XG4gICAgICAgICAgcnYgKz0gJ1xcbicgKyBlcnJwZnggKyBsZWFkICsgbWFyaztcblxuICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub25lbXB0eV9saW5lX2luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxubyA9PT0gbG9jLmxhc3RfbGluZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAyICsgMTtcbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMiwgbG9jLmxhc3RfY29sdW1uICsgMSk7XG4gICAgICAgICAgdmFyIGxlYWQgPSBuZXcgQXJyYXkob2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIG1hcmsgPSBuZXcgQXJyYXkobGVuKS5qb2luKCdeJyk7XG4gICAgICAgICAgcnYgKz0gJ1xcbicgKyBlcnJwZnggKyBsZWFkICsgbWFyaztcblxuICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub25lbXB0eV9saW5lX2luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxubyA+IGxvYy5maXJzdF9saW5lICYmIGxubyA8IGxvYy5sYXN0X2xpbmUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMiArIDE7XG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KDIsIGxpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgdmFyIGxlYWQgPSBuZXcgQXJyYXkob2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIG1hcmsgPSBuZXcgQXJyYXkobGVuKS5qb2luKCdeJyk7XG4gICAgICAgICAgcnYgKz0gJ1xcbicgKyBlcnJwZnggKyBsZWFkICsgbWFyaztcblxuICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub25lbXB0eV9saW5lX2luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnYgPSBydi5yZXBsYWNlKC9cXHQvZywgJyAnKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgcHJpbnQgYW4gb3Zlcmx5IGxhcmdlIGFtb3VudCBvZiBlcnJvciBhcmVhOiBsaW1pdCBpdCBcbiAgICAgIC8vIHRvIHRoZSB0b3AgYW5kIGJvdHRvbSBsaW5lIGNvdW50OlxuICAgICAgaWYgKG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5sZW5ndGggPiAyICogTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQpIHtcbiAgICAgICAgdmFyIGNsaXBfc3RhcnQgPSBub25lbXB0eV9saW5lX2luZGV4ZXNbTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQgLSAxXSArIDE7XG4gICAgICAgIHZhciBjbGlwX2VuZCA9IG5vbmVtcHR5X2xpbmVfaW5kZXhlc1tub25lbXB0eV9saW5lX2luZGV4ZXMubGVuZ3RoIC0gTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlRdIC0gMTtcblxuICAgICAgICBjb25zb2xlLmxvZygnY2xpcCBvZmY6ICcsIHtcbiAgICAgICAgICBzdGFydDogY2xpcF9zdGFydCxcbiAgICAgICAgICBlbmQ6IGNsaXBfZW5kLFxuICAgICAgICAgIGxlbjogY2xpcF9lbmQgLSBjbGlwX3N0YXJ0ICsgMSxcbiAgICAgICAgICBhcnI6IG5vbmVtcHR5X2xpbmVfaW5kZXhlcyxcbiAgICAgICAgICBydlxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW50ZXJtZWRpYXRlX2xpbmUgPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCcgJykgKyAnICAoLi4uY29udGludWVkLi4uKSc7XG4gICAgICAgIGludGVybWVkaWF0ZV9saW5lICs9ICdcXG4nICsgbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignLScpICsgJyAgKC0tLS0tLS0tLS0tLS0tLSknO1xuICAgICAgICBydi5zcGxpY2UoY2xpcF9zdGFydCwgY2xpcF9lbmQgLSBjbGlwX3N0YXJ0ICsgMSwgaW50ZXJtZWRpYXRlX2xpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnYuam9pbignXFxuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBmdW5jdGlvbiwgdXNlZCB0byBwcm9kdWNlIGEgaHVtYW4gcmVhZGFibGUgZGVzY3JpcHRpb24gYXMgYSBzdHJpbmcsIGdpdmVuXG4gICAgICogdGhlIGlucHV0IGB5eWxsb2NgIGxvY2F0aW9uIG9iamVjdC5cbiAgICAgKiBcbiAgICAgKiBTZXQgYGRpc3BsYXlfcmFuZ2VfdG9vYCB0byBUUlVFIHRvIGluY2x1ZGUgdGhlIHN0cmluZyBjaGFyYWN0ZXIgaW5kZXggcG9zaXRpb24ocylcbiAgICAgKiBpbiB0aGUgZGVzY3JpcHRpb24gaWYgdGhlIGB5eWxsb2MucmFuZ2VgIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGRlc2NyaWJlWVlMTE9DOiBmdW5jdGlvbiBsZXhlcl9kZXNjcmliZV95eWxsb2MoeXlsbG9jLCBkaXNwbGF5X3JhbmdlX3Rvbykge1xuICAgICAgdmFyIGwxID0geXlsbG9jLmZpcnN0X2xpbmU7XG4gICAgICB2YXIgbDIgPSB5eWxsb2MubGFzdF9saW5lO1xuICAgICAgdmFyIGMxID0geXlsbG9jLmZpcnN0X2NvbHVtbjtcbiAgICAgIHZhciBjMiA9IHl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgICAgIHZhciBkbCA9IGwyIC0gbDE7XG4gICAgICB2YXIgZGMgPSBjMiAtIGMxO1xuICAgICAgdmFyIHJ2O1xuXG4gICAgICBpZiAoZGwgPT09IDApIHtcbiAgICAgICAgcnYgPSAnbGluZSAnICsgbDEgKyAnLCAnO1xuXG4gICAgICAgIGlmIChkYyA8PSAxKSB7XG4gICAgICAgICAgcnYgKz0gJ2NvbHVtbiAnICsgYzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnYgKz0gJ2NvbHVtbnMgJyArIGMxICsgJyAuLiAnICsgYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2ID0gJ2xpbmVzICcgKyBsMSArICcoY29sdW1uICcgKyBjMSArICcpIC4uICcgKyBsMiArICcoY29sdW1uICcgKyBjMiArICcpJztcbiAgICAgIH1cblxuICAgICAgaWYgKHl5bGxvYy5yYW5nZSAmJiBkaXNwbGF5X3JhbmdlX3Rvbykge1xuICAgICAgICB2YXIgcjEgPSB5eWxsb2MucmFuZ2VbMF07XG4gICAgICAgIHZhciByMiA9IHl5bGxvYy5yYW5nZVsxXSAtIDE7XG5cbiAgICAgICAgaWYgKHIyIDw9IHIxKSB7XG4gICAgICAgICAgcnYgKz0gJyB7U3RyaW5nIE9mZnNldDogJyArIHIxICsgJ30nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ICs9ICcge1N0cmluZyBPZmZzZXQgcmFuZ2U6ICcgKyByMSArICcgLi4gJyArIHIyICsgJ30nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuLlxuICAgICAqIFxuICAgICAqIGBtYXRjaGAgaXMgc3VwcG9zZWQgdG8gYmUgYW4gYXJyYXkgY29taW5nIG91dCBvZiBhIHJlZ2V4IG1hdGNoLCBpLmUuIGBtYXRjaFswXWBcbiAgICAgKiBjb250YWlucyB0aGUgYWN0dWFsbHkgbWF0Y2hlZCB0ZXh0IHN0cmluZy5cbiAgICAgKiBcbiAgICAgKiBBbHNvIG1vdmUgdGhlIGlucHV0IGN1cnNvciBmb3J3YXJkIGFuZCB1cGRhdGUgdGhlIG1hdGNoIGNvbGxlY3RvcnM6XG4gICAgICogXG4gICAgICogLSBgeXl0ZXh0YFxuICAgICAqIC0gYHl5bGVuZ2BcbiAgICAgKiAtIGBtYXRjaGBcbiAgICAgKiAtIGBtYXRjaGVzYFxuICAgICAqIC0gYHl5bGxvY2BcbiAgICAgKiAtIGBvZmZzZXRgXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbiBsZXhlcl90ZXN0X21hdGNoKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgIHZhciB0b2tlbiwgbGluZXMsIGJhY2t1cCwgbWF0Y2hfc3RyLCBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuXG4gICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIHJhbmdlOiB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG5cbiAgICAgICAgICAvL19zaWduYWxlZF9lcnJvcl90b2tlbjogdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4sXG4gICAgICAgICAgeXk6IHRoaXMueXksXG5cbiAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2hfc3RyID0gbWF0Y2hbMF07XG4gICAgICBtYXRjaF9zdHJfbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcblxuICAgICAgLy8gaWYgKG1hdGNoX3N0ci5pbmRleE9mKCdcXG4nKSAhPT0gLTEgfHwgbWF0Y2hfc3RyLmluZGV4T2YoJ1xccicpICE9PSAtMSkge1xuICAgICAgbGluZXMgPSBtYXRjaF9zdHIuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vICsgMTtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArPSBtYXRjaF9zdHJfbGVuO1xuICAgICAgfVxuXG4gICAgICAvLyB9XG4gICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaF9zdHI7XG5cbiAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hfc3RyO1xuICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoX3N0cjtcbiAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSArPSBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICAvLyBwcmV2aW91cyBsZXggcnVsZXMgTUFZIGhhdmUgaW52b2tlZCB0aGUgYG1vcmUoKWAgQVBJIHJhdGhlciB0aGFuIHByb2R1Y2luZyBhIHRva2VuOlxuICAgICAgLy8gdGhvc2UgcnVsZXMgd2lsbCBhbHJlYWR5IGhhdmUgbW92ZWQgdGhpcyBgb2Zmc2V0YCBmb3J3YXJkIG1hdGNoaW5nIHRoZWlyIG1hdGNoIGxlbmd0aHMsXG4gICAgICAvLyBoZW5jZSB3ZSBtdXN0IG9ubHkgYWRkIG91ciBvd24gbWF0Y2ggbGVuZ3RoIG5vdzpcbiAgICAgIHRoaXMub2Zmc2V0ICs9IG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaF9zdHJfbGVuKTtcblxuICAgICAgLy8gY2FsbGluZyB0aGlzIG1ldGhvZDpcbiAgICAgIC8vXG4gICAgICAvLyAgIGZ1bmN0aW9uIGxleGVyX19wZXJmb3JtQWN0aW9uKHl5LCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSB7Li4ufVxuICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy55eSxcbiAgICAgICAgaW5kZXhlZF9ydWxlLFxuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0gLyogPSBZWV9TVEFSVCAqL1xuICAgICAgKTtcblxuICAgICAgLy8gb3RoZXJ3aXNlLCB3aGVuIHRoZSBhY3Rpb24gY29kZXMgYXJlIGFsbCBzaW1wbGUgcmV0dXJuIHRva2VuIHN0YXRlbWVudHM6XG4gICAgICAvL3Rva2VuID0gdGhpcy5zaW1wbGVDYXNlQWN0aW9uQ2x1c3RlcnNbaW5kZXhlZF9ydWxlXTtcblxuICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTsgIC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC4gXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuKSB7XG4gICAgICAgIC8vIHByb2R1Y2Ugb25lICdlcnJvcicgdG9rZW4gYXMgYC5wYXJzZUVycm9yKClgIGluIGByZWplY3QoKWBcbiAgICAgICAgLy8gZGlkIG5vdCBndWFyYW50ZWUgYSBmYWlsdXJlIHNpZ25hbCBieSB0aHJvd2luZyBhbiBleGNlcHRpb24hXG4gICAgICAgIHRva2VuID0gdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW47XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBsZXhlcl9uZXh0KCkge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4O1xuXG4gICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BlYyA9IHRoaXMuX19jdXJyZW50UnVsZVNldF9fO1xuXG4gICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBydWxlc2V0IGNhY2hlIGFzIHdlIGFwcGFyZW50bHkgZW5jb3VudGVyZWQgYSBzdGF0ZSBjaGFuZ2Ugb3IganVzdCBzdGFydGVkIGxleGluZy5cbiAgICAgICAgLy8gVGhlIGNhY2hlIGlzIHNldCB1cCBmb3IgZmFzdCBsb29rdXAgLS0gd2UgYXNzdW1lIGEgbGV4ZXIgd2lsbCBzd2l0Y2ggc3RhdGVzIG11Y2ggbGVzcyBvZnRlbiB0aGFuIGl0IHdpbGxcbiAgICAgICAgLy8gaW52b2tlIHRoZSBgbGV4KClgIHRva2VuLXByb2R1Y2luZyBBUEkgYW5kIHJlbGF0ZWQgQVBJcywgaGVuY2UgY2FjaGluZyB0aGUgc2V0IGZvciBkaXJlY3QgYWNjZXNzIGhlbHBzXG4gICAgICAgIC8vIHNwZWVkIHVwIHRob3NlIGFjdGl2aXRpZXMgYSB0aW55IGJpdC5cbiAgICAgICAgc3BlYyA9IHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhICpzYW5lKiBjb25kaXRpb24gaGFzIGJlZW4gcHVzaGVkIGJlZm9yZTogdGhpcyBtYWtlcyB0aGUgbGV4ZXIgcm9idXN0IGFnYWluc3RcbiAgICAgICAgLy8gdXNlci1wcm9ncmFtbWVyIGJ1Z3Mgc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vemFhY2gvamlzb24tbGV4L2lzc3Vlcy8xOVxuICAgICAgICBpZiAoIXNwZWMgfHwgIXNwZWMucnVsZXMpIHtcbiAgICAgICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb3Nfc3RyID0gJyc7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwb3Nfc3RyID0gdGhpcy5zaG93UG9zaXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKHBvc19zdHIgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgcG9zX3N0ciA9ICdcXG4nICsgcG9zX3N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAgICAgJ0ludGVybmFsIGxleGVyIGVuZ2luZSBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogVGhlIGxleCBncmFtbWFyIHByb2dyYW1tZXIgcHVzaGVkIGEgbm9uLWV4aXN0aW5nIGNvbmRpdGlvbiBuYW1lIFwiJyArIHRoaXMudG9wU3RhdGUoKSArICdcIjsgdGhpcyBpcyBhIGZhdGFsIGVycm9yIGFuZCBzaG91bGQgYmUgcmVwb3J0ZWQgdG8gdGhlIGFwcGxpY2F0aW9uIHByb2dyYW1tZXIgdGVhbSEnICsgcG9zX3N0cixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIHByb2R1Y2Ugb25lICdlcnJvcicgdG9rZW4gdW50aWwgdGhpcyBzaXR1YXRpb24gaGFzIGJlZW4gcmVzb2x2ZWQsIG1vc3QgcHJvYmFibHkgYnkgcGFyc2UgdGVybWluYXRpb24hXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJ1bGVfaWRzID0gc3BlYy5ydWxlcztcbiAgICAgIHZhciByZWdleGVzID0gc3BlYy5fX3J1bGVfcmVnZXhlcztcbiAgICAgIHZhciBsZW4gPSBzcGVjLl9fcnVsZV9jb3VudDtcblxuICAgICAgLy8gTm90ZTogdGhlIGFycmF5cyBhcmUgMS1iYXNlZCwgd2hpbGUgYGxlbmAgaXRzZWxmIGlzIGEgdmFsaWQgaW5kZXgsXG4gICAgICAvLyBoZW5jZSB0aGUgbm9uLXN0YW5kYXJkIGxlc3Mtb3ItZXF1YWwgY2hlY2sgaW4gdGhlIG5leHQgbG9vcCBjb25kaXRpb24hXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaChyZWdleGVzW2ldKTtcblxuICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlX2lkc1tpXSk7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlOyAgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC4gXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZV9pZHNbaW5kZXhdKTtcblxuICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zX3N0ciA9ICcnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwb3Nfc3RyID0gdGhpcy5zaG93UG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmIChwb3Nfc3RyICYmIHBvc19zdHJbMF0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBwb3Nfc3RyID0gJ1xcbicgKyBwb3Nfc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6IFVucmVjb2duaXplZCB0ZXh0LicgKyBwb3Nfc3RyLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5sZXhlckVycm9yc0FyZVJlY292ZXJhYmxlXG4gICAgICAgICk7XG5cbiAgICAgICAgdG9rZW4gPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdGhpcy5FUlJPUikge1xuICAgICAgICAgIC8vIHdlIGNhbiB0cnkgdG8gcmVjb3ZlciBmcm9tIGEgbGV4ZXIgZXJyb3IgdGhhdCBgcGFyc2VFcnJvcigpYCBkaWQgbm90ICdyZWNvdmVyJyBmb3IgdXNcbiAgICAgICAgICAvLyBieSBtb3ZpbmcgZm9yd2FyZCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZTpcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBsZXg6IGZ1bmN0aW9uIGxleGVyX2xleCgpIHtcbiAgICAgIHZhciByO1xuXG4gICAgICAvLyBhbGxvdyB0aGUgUFJFL1BPU1QgaGFuZGxlcnMgc2V0L21vZGlmeSB0aGUgcmV0dXJuIHRva2VuIGZvciBtYXhpbXVtIGZsZXhpYmlsaXR5IG9mIHRoZSBnZW5lcmF0ZWQgbGV4ZXI6XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wcmVfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHIgPSB0aGlzLm9wdGlvbnMucHJlX2xleC5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIXIpIHtcbiAgICAgICAgciA9IHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wb3N0X2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoYWxzbyBhY2NvdW50IGZvciBhIHVzZXJkZWYgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZToga2VlcCB0aGUgdG9rZW4gYXMgaXMpXG4gICAgICAgIHIgPSB0aGlzLm9wdGlvbnMucG9zdF9sZXguY2FsbCh0aGlzLCByKSB8fCByO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmFja3dhcmRzIGNvbXBhdGlibGUgYWxpYXMgZm9yIGBwdXNoU3RhdGUoKWA7XG4gICAgICogdGhlIGxhdHRlciBpcyBzeW1tZXRyaWNhbCB3aXRoIGBwb3BTdGF0ZSgpYCBhbmQgd2UgYWR2aXNlIHRvIHVzZVxuICAgICAqIHRob3NlIEFQSXMgaW4gYW55IG1vZGVybiBsZXhlciBjb2RlLCByYXRoZXIgdGhhbiBgYmVnaW4oKWAuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBiZWdpbjogZnVuY3Rpb24gbGV4ZXJfYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhdGUoY29uZGl0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXJcbiAgICAgKiBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBsZXhlcl9wdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvblxuICAgICAqIHN0YWNrXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwb3BTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfcG9wU3RhdGUoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleFxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSxcbiAgICAgKiBpZiBhdmFpbGFibGVcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHRvcFN0YXRlOiBmdW5jdGlvbiBsZXhlcl90b3BTdGF0ZShuKSB7XG4gICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcblxuICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnSU5JVElBTCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIChpbnRlcm5hbCkgZGV0ZXJtaW5lIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZVxuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbiBsZXhlcl9fY3VycmVudFJ1bGVzKCkge1xuICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zWydJTklUSUFMJ107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24gbGV4ZXJfc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGZsZXg6IHRydWUsXG4gICAgICB0cmFja1Bvc2l0aW9uOiB0cnVlLFxuICAgICAgcGFyc2VBY3Rpb25zVXNlWVlNRVJHRUxPQ0FUSU9OSU5GTzogdHJ1ZVxuICAgIH0sXG5cbiAgICBKaXNvbkxleGVyRXJyb3I6IEppc29uTGV4ZXJFcnJvcixcblxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGxleGVyX19wZXJmb3JtQWN0aW9uKHl5LCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSB7XG4gICAgICB2YXIgeXlfID0gdGhpcztcbiAgICAgIHZhciBZWVNUQVRFID0gWVlfU1RBUlQ7XG5cbiAgICAgIHN3aXRjaCAoeXlydWxlbnVtYmVyKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxccysgKi9cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyUgKi9cbiAgICAgICAgdGhpcy5iZWdpbignQ09OVFJPTCcpO1xuXG4gICAgICAgIHJldHVybiAyODtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPCEtLSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT01NRU5UJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA3OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ1RBRycpO1xuXG4gICAgICAgIHJldHVybiAxMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE3OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxcLz4gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAzODtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTk6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPiAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDSElMRFJFTicpO1xuXG4gICAgICAgIHJldHVybiAxNDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjA6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDIzOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI0OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7JSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT05UUk9MJyk7XG5cbiAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwhLS0gKi9cbiAgICAgICAgdGhpcy5iZWdpbignQ09NTUVOVCcpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjY6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8XFwvICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ1RBRycpO1xuXG4gICAgICAgIHJldHVybiAzNztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ1RBRycpO1xuXG4gICAgICAgIHJldHVybiAxMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgID0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTlRST0xfQ0hJTEQnKTtcbiAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYxOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAlXFx9ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY0OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ1RBRycpO1xuXG4gICAgICAgIHJldHVybiAxMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjU6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxce1xceyAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdFWFBSRVNTSU9OJyk7XG5cbiAgICAgICAgcmV0dXJuIDM5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2NjpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgJVxcfSAqL1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4NDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx9XFx9ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gNDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDg3OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTU1FTlQgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAoLnxcXHJ8XFxuKSo/LS0+ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDExNjpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgLiAqL1xuICAgICAgICBjb25zb2xlLmxvZygnJywgeXlfLnl5dGV4dCk7XG5cbiAgICAgICAgLyogYGZsZXhgIGxleGluZyBtb2RlOiB0aGUgbGFzdCByZXNvcnQgcnVsZSEgKi9cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyc1t5eXJ1bGVudW1iZXJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaW1wbGVDYXNlQWN0aW9uQ2x1c3RlcnM6IHtcbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpbXBvcnQgKi9cbiAgICAgIDE6IDI1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZnJvbSAqL1xuICAgICAgMjogMjYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB1c2luZyAqL1xuICAgICAgMzogJ1VTSU5HJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGFzICovXG4gICAgICA0OiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDk6IDU2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICAxMDogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHsgKi9cbiAgICAgIDExOiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx9ICovXG4gICAgICAxMjogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdHJ1ZSAqL1xuICAgICAgMTM6IDUzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmYWxzZSAqL1xuICAgICAgMTQ6IDU0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICAxNTogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgMTY6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8gKi9cbiAgICAgIDE4OiAnTk9TRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgMjE6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgMjI6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICAyODogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDI5OiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFteLzw+eyV9XSsgKi9cbiAgICAgIDMwOiA0NyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIG1haW4gKi9cbiAgICAgIDMxOiAyOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZG1haW4gKi9cbiAgICAgIDMyOiAzMSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIG1hY3JvICovXG4gICAgICAzMzogJ01BQ1JPJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZG1hY3JvICovXG4gICAgICAzNDogJ0VORE1BQ1JPJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZvciAqL1xuICAgICAgMzU6IDQxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kZm9yICovXG4gICAgICAzNjogNDMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpZiAqL1xuICAgICAgMzc6IDQ1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kaWYgKi9cbiAgICAgIDM4OiA0NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVsc2UgKi9cbiAgICAgIDM5OiA0NCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVsc2VpZiAqL1xuICAgICAgNDA6ICdFTFNFSUYnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgaW4gKi9cbiAgICAgIDQxOiA0MixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGNhc2UgKi9cbiAgICAgIDQyOiAnQ0FTRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRjYXNlICovXG4gICAgICA0MzogJ0VORENBU0UnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZXhwb3J0ICovXG4gICAgICA0NDogMzIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmcm9tICovXG4gICAgICA0NTogMjYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB2aWV3ICovXG4gICAgICA0NjogMzMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB1c2luZyAqL1xuICAgICAgNDc6ICdVU0lORycsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmR2aWV3ICovXG4gICAgICA0ODogMzQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpbnN0YW5jZW9mICovXG4gICAgICA0OTogNjQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB0aGlzICovXG4gICAgICA1MDogJ1RISVMnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZnVuICovXG4gICAgICA1MTogMzUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRmdW4gKi9cbiAgICAgIDUyOiAzNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGFzICovXG4gICAgICA1MzogMjcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA6OiAqL1xuICAgICAgNTQ6ICc6OicsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBAICovXG4gICAgICA1NTogMTksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXChcXCkgKi9cbiAgICAgIDU2OiAnKCknLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLT4gKi9cbiAgICAgIDU3OiA1NyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDU5OiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgNjA6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICA2MjogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgNjM6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICA2NzogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDY4OiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgNjk6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDcwOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx8ICovXG4gICAgICA3MTogMTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PiAqL1xuICAgICAgNzI6IDUwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLT4gKi9cbiAgICAgIDczOiA1NyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDc0OiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGluc3RhbmNlb2YgKi9cbiAgICAgIDc1OiA2NCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRydWUgKi9cbiAgICAgIDc2OiA1MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZhbHNlICovXG4gICAgICA3NzogNTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpZiAqL1xuICAgICAgNzg6IDQ1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdGhlbiAqL1xuICAgICAgNzk6IDQ4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZSAqL1xuICAgICAgODA6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDgxOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDgyOiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgODM6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICA4NTogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgODY6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7TnVtYmVyTGl0ZXJhbH0gKi9cbiAgICAgIDg4OiA1MixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtTdHJpbmdMaXRlcmFsfSAqL1xuICAgICAgODk6IDUxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPiAqL1xuICAgICAgOTA6IDE0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgOTE6IDEzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwoICovXG4gICAgICA5MjogNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKSAqL1xuICAgICAgOTM6IDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFsgKi9cbiAgICAgIDk0OiAxMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcXSAqL1xuICAgICAgOTU6IDExLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOyAqL1xuICAgICAgOTY6IDIwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOiAqL1xuICAgICAgOTc6IDEyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgOTg6IDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PSAqL1xuICAgICAgOTk6IDYwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgIT0gKi9cbiAgICAgIDEwMDogNjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA+PSAqL1xuICAgICAgMTAxOiA1OCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIDw9ICovXG4gICAgICAxMDI6IDU5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwrICovXG4gICAgICAxMDM6IDIxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLSAqL1xuICAgICAgMTA0OiAyMyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKiAqL1xuICAgICAgMTA1OiAzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwvICovXG4gICAgICAxMDY6IDIyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFxcXCAqL1xuICAgICAgMTA3OiA0OSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICYmICovXG4gICAgICAxMDg6IDYyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx8XFx8ICovXG4gICAgICAxMDk6IDYzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFxeICovXG4gICAgICAxMTA6IDI0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgISAqL1xuICAgICAgMTExOiAxNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICwgKi9cbiAgICAgIDExMjogNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcPyAqL1xuICAgICAgMTEzOiAxOCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcLiAqL1xuICAgICAgMTE0OiAxNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICQgKi9cbiAgICAgIDExNTogMVxuICAgIH0sXG5cbiAgICBydWxlczogW1xuICAgICAgLyogICAwOiAqLyAgL14oPzpcXHMrKS8sXG4gICAgICAvKiAgIDE6ICovICAvXig/OmltcG9ydCkvLFxuICAgICAgLyogICAyOiAqLyAgL14oPzpmcm9tKS8sXG4gICAgICAvKiAgIDM6ICovICAvXig/OnVzaW5nKS8sXG4gICAgICAvKiAgIDQ6ICovICAvXig/OmFzKS8sXG4gICAgICAvKiAgIDU6ICovICAvXig/OlxceyUpLyxcbiAgICAgIC8qICAgNjogKi8gIC9eKD86PCEtLSkvLFxuICAgICAgLyogICA3OiAqLyAgL14oPzo8KS8sXG4gICAgICAvKiAgIDg6ICovICAvXig/Olxce1xceykvLFxuICAgICAgLyogICA5OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDEwOiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTE6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDEyOiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICAxMzogKi8gIC9eKD86dHJ1ZSkvLFxuICAgICAgLyogIDE0OiAqLyAgL14oPzpmYWxzZSkvLFxuICAgICAgLyogIDE1OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDE2OiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTc6ICovICAvXig/OlxcLz4pLyxcbiAgICAgIC8qICAxODogKi8gIC9eKD86XFwvKS8sXG4gICAgICAvKiAgMTk6ICovICAvXig/Oj4pLyxcbiAgICAgIC8qICAyMDogKi8gIC9eKD86XFx7XFx7KS8sXG4gICAgICAvKiAgMjE6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDIyOiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICAyMzogKi8gIC9eKD86XFx7XFx7KS8sXG4gICAgICAvKiAgMjQ6ICovICAvXig/OlxceyUpLyxcbiAgICAgIC8qICAyNTogKi8gIC9eKD86PCEtLSkvLFxuICAgICAgLyogIDI2OiAqLyAgL14oPzo8XFwvKS8sXG4gICAgICAvKiAgMjc6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICAyODogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgMjk6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDMwOiAqLyAgL14oPzpbXlxcLzw+eyV9XSspLyxcbiAgICAgIC8qICAzMTogKi8gIC9eKD86bWFpbikvLFxuICAgICAgLyogIDMyOiAqLyAgL14oPzplbmRtYWluKS8sXG4gICAgICAvKiAgMzM6ICovICAvXig/Om1hY3JvKS8sXG4gICAgICAvKiAgMzQ6ICovICAvXig/OmVuZG1hY3JvKS8sXG4gICAgICAvKiAgMzU6ICovICAvXig/OmZvcikvLFxuICAgICAgLyogIDM2OiAqLyAgL14oPzplbmRmb3IpLyxcbiAgICAgIC8qICAzNzogKi8gIC9eKD86aWYpLyxcbiAgICAgIC8qICAzODogKi8gIC9eKD86ZW5kaWYpLyxcbiAgICAgIC8qICAzOTogKi8gIC9eKD86ZWxzZSkvLFxuICAgICAgLyogIDQwOiAqLyAgL14oPzplbHNlaWYpLyxcbiAgICAgIC8qICA0MTogKi8gIC9eKD86aW4pLyxcbiAgICAgIC8qICA0MjogKi8gIC9eKD86Y2FzZSkvLFxuICAgICAgLyogIDQzOiAqLyAgL14oPzplbmRjYXNlKS8sXG4gICAgICAvKiAgNDQ6ICovICAvXig/OmV4cG9ydCkvLFxuICAgICAgLyogIDQ1OiAqLyAgL14oPzpmcm9tKS8sXG4gICAgICAvKiAgNDY6ICovICAvXig/OnZpZXcpLyxcbiAgICAgIC8qICA0NzogKi8gIC9eKD86dXNpbmcpLyxcbiAgICAgIC8qICA0ODogKi8gIC9eKD86ZW5kdmlldykvLFxuICAgICAgLyogIDQ5OiAqLyAgL14oPzppbnN0YW5jZW9mKS8sXG4gICAgICAvKiAgNTA6ICovICAvXig/OnRoaXMpLyxcbiAgICAgIC8qICA1MTogKi8gIC9eKD86ZnVuKS8sXG4gICAgICAvKiAgNTI6ICovICAvXig/OmVuZGZ1bikvLFxuICAgICAgLyogIDUzOiAqLyAgL14oPzphcykvLFxuICAgICAgLyogIDU0OiAqLyAgL14oPzo6OikvLFxuICAgICAgLyogIDU1OiAqLyAgL14oPzpAKS8sXG4gICAgICAvKiAgNTY6ICovICAvXig/OlxcKFxcKSkvLFxuICAgICAgLyogIDU3OiAqLyAgL14oPzotPikvLFxuICAgICAgLyogIDU4OiAqLyAgL14oPzo9KS8sXG4gICAgICAvKiAgNTk6ICovICAvXig/OihbQS1aXVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgNjA6ICovICAvXig/OihbJF9hLXpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA2MTogKi8gIC9eKD86JVxcfSkvLFxuICAgICAgLyogIDYyOiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICA2MzogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgNjQ6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICA2NTogKi8gIC9eKD86XFx7XFx7KS8sXG4gICAgICAvKiAgNjY6ICovICAvXig/OiVcXH0pLyxcbiAgICAgIC8qICA2NzogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA2ODogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDY5OiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICA3MDogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgNzE6ICovICAvXig/OlxcfCkvLFxuICAgICAgLyogIDcyOiAqLyAgL14oPzo9PikvLFxuICAgICAgLyogIDczOiAqLyAgL14oPzotPikvLFxuICAgICAgLyogIDc0OiAqLyAgL14oPzpAKS8sXG4gICAgICAvKiAgNzU6ICovICAvXig/Omluc3RhbmNlb2YpLyxcbiAgICAgIC8qICA3NjogKi8gIC9eKD86dHJ1ZSkvLFxuICAgICAgLyogIDc3OiAqLyAgL14oPzpmYWxzZSkvLFxuICAgICAgLyogIDc4OiAqLyAgL14oPzppZikvLFxuICAgICAgLyogIDc5OiAqLyAgL14oPzp0aGVuKS8sXG4gICAgICAvKiAgODA6ICovICAvXig/OmVsc2UpLyxcbiAgICAgIC8qICA4MTogKi8gIC9eKD86YXMpLyxcbiAgICAgIC8qICA4MjogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA4MzogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDg0OiAqLyAgL14oPzpcXH1cXH0pLyxcbiAgICAgIC8qICA4NTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgODY6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDg3OiAqLyAgL14oPzooLnxcXHJ8XFxuKSo/LS0+KS8sXG4gICAgICAvKiAgODg6ICovICAvXig/OigoPzooWy1dPyg/OlstXT8oWzBdfCgoPzpbMS05XSkoPzpcXGQrKSopKSlcXC4oPzpcXGQrKSooPzooPzpbRWVdKSg/OlsrLV0/XFxkKykpPyl8KFxcLig/OlxcZCspKD86KD86W0VlXSkoPzpbKy1dP1xcZCspKT8pfCgoPzpbLV0/KFswXXwoKD86WzEtOV0pKD86XFxkKykqKSkpKD86KD86W0VlXSkoPzpbKy1dP1xcZCspKT8pKXwoPzpbMF1bWHhdKD86W1xcZEEtRmEtZl0pKyl8KD86WzBdKD86WzAtN10pKykpKS8sXG4gICAgICAvKiAgODk6ICovICAvXig/OigoXCIoPzooW15cXG5cXHJcIlxcXFxdKyl8KFxcXFwoPzooPzooPzpbXCInXFxcXGJmbnJ0dl0pfCg/OlteXFxkXCInXFxcXGJmbnJ0LXZ4XSkpfCg/Oig/OlsxLTddWzAtN117MCwyfXxbMC03XXsyLDN9KSl8KD86W3hdKD86W1xcZEEtRmEtZl0pezJ9KXwoPzpbdV0oPzpbXFxkQS1GYS1mXSl7NH0pKSl8KD86XFxcXChcXHJcXG58XFxyfFxcbikpKSpcIil8KCcoPzooW15cXG5cXHInXFxcXF0rKXwoXFxcXCg/Oig/Oig/OltcIidcXFxcYmZucnR2XSl8KD86W15cXGRcIidcXFxcYmZucnQtdnhdKSl8KD86KD86WzEtN11bMC03XXswLDJ9fFswLTddezIsM30pKXwoPzpbeF0oPzpbXFxkQS1GYS1mXSl7Mn0pfCg/Olt1XSg/OltcXGRBLUZhLWZdKXs0fSkpKXwoPzpcXFxcKFxcclxcbnxcXHJ8XFxuKSkpKicpfChgKD86KFteXFxuXFxyXFxcXGBdKyl8KFxcXFwoPzooPzooPzpbXCInXFxcXGJmbnJ0dl0pfCg/OlteXFxkXCInXFxcXGJmbnJ0LXZ4XSkpfCg/Oig/OlsxLTddWzAtN117MCwyfXxbMC03XXsyLDN9KSl8KD86W3hdKD86W1xcZEEtRmEtZl0pezJ9KXwoPzpbdV0oPzpbXFxkQS1GYS1mXSl7NH0pKSl8KD86XFxcXChcXHJcXG58XFxyfFxcbikpKSpgKSkpLyxcbiAgICAgIC8qICA5MDogKi8gIC9eKD86PikvLFxuICAgICAgLyogIDkxOiAqLyAgL14oPzo8KS8sXG4gICAgICAvKiAgOTI6ICovICAvXig/OlxcKCkvLFxuICAgICAgLyogIDkzOiAqLyAgL14oPzpcXCkpLyxcbiAgICAgIC8qICA5NDogKi8gIC9eKD86XFxbKS8sXG4gICAgICAvKiAgOTU6ICovICAvXig/OlxcXSkvLFxuICAgICAgLyogIDk2OiAqLyAgL14oPzo7KS8sXG4gICAgICAvKiAgOTc6ICovICAvXig/OjopLyxcbiAgICAgIC8qICA5ODogKi8gIC9eKD86PSkvLFxuICAgICAgLyogIDk5OiAqLyAgL14oPzo9PSkvLFxuICAgICAgLyogMTAwOiAqLyAgL14oPzohPSkvLFxuICAgICAgLyogMTAxOiAqLyAgL14oPzo+PSkvLFxuICAgICAgLyogMTAyOiAqLyAgL14oPzo8PSkvLFxuICAgICAgLyogMTAzOiAqLyAgL14oPzpcXCspLyxcbiAgICAgIC8qIDEwNDogKi8gIC9eKD86LSkvLFxuICAgICAgLyogMTA1OiAqLyAgL14oPzpcXCopLyxcbiAgICAgIC8qIDEwNjogKi8gIC9eKD86XFwvKS8sXG4gICAgICAvKiAxMDc6ICovICAvXig/OlxcXFwpLyxcbiAgICAgIC8qIDEwODogKi8gIC9eKD86JiYpLyxcbiAgICAgIC8qIDEwOTogKi8gIC9eKD86XFx8XFx8KS8sXG4gICAgICAvKiAxMTA6ICovICAvXig/OlxcXikvLFxuICAgICAgLyogMTExOiAqLyAgL14oPzohKS8sXG4gICAgICAvKiAxMTI6ICovICAvXig/OiwpLyxcbiAgICAgIC8qIDExMzogKi8gIC9eKD86XFw/KS8sXG4gICAgICAvKiAxMTQ6ICovICAvXig/OlxcLikvLFxuICAgICAgLyogMTE1OiAqLyAgL14oPzokKS8sXG4gICAgICAvKiAxMTY6ICovICAvXig/Oi4pL1xuICAgIF0sXG5cbiAgICBjb25kaXRpb25zOiB7XG4gICAgICAnQ0hJTERSRU4nOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAyMyxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICAyNSxcbiAgICAgICAgICAyNixcbiAgICAgICAgICAyNyxcbiAgICAgICAgICAyOCxcbiAgICAgICAgICAyOSxcbiAgICAgICAgICAzMCxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNCxcbiAgICAgICAgICAxMTVcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnQ09NTUVOVCc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0LFxuICAgICAgICAgIDExNVxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdDT05UUk9MJzoge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgIDAsXG4gICAgICAgICAgMzEsXG4gICAgICAgICAgMzIsXG4gICAgICAgICAgMzMsXG4gICAgICAgICAgMzQsXG4gICAgICAgICAgMzUsXG4gICAgICAgICAgMzYsXG4gICAgICAgICAgMzcsXG4gICAgICAgICAgMzgsXG4gICAgICAgICAgMzksXG4gICAgICAgICAgNDAsXG4gICAgICAgICAgNDEsXG4gICAgICAgICAgNDIsXG4gICAgICAgICAgNDMsXG4gICAgICAgICAgNDQsXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgNDYsXG4gICAgICAgICAgNDcsXG4gICAgICAgICAgNDgsXG4gICAgICAgICAgNDksXG4gICAgICAgICAgNTAsXG4gICAgICAgICAgNTEsXG4gICAgICAgICAgNTIsXG4gICAgICAgICAgNTMsXG4gICAgICAgICAgNTQsXG4gICAgICAgICAgNTUsXG4gICAgICAgICAgNTYsXG4gICAgICAgICAgNTcsXG4gICAgICAgICAgNTgsXG4gICAgICAgICAgNTksXG4gICAgICAgICAgNjAsXG4gICAgICAgICAgNjEsXG4gICAgICAgICAgNjIsXG4gICAgICAgICAgNjMsXG4gICAgICAgICAgODgsXG4gICAgICAgICAgODksXG4gICAgICAgICAgOTAsXG4gICAgICAgICAgOTEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTQsXG4gICAgICAgICAgOTUsXG4gICAgICAgICAgOTYsXG4gICAgICAgICAgOTcsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTAwLFxuICAgICAgICAgIDEwMSxcbiAgICAgICAgICAxMDIsXG4gICAgICAgICAgMTAzLFxuICAgICAgICAgIDEwNCxcbiAgICAgICAgICAxMDUsXG4gICAgICAgICAgMTA2LFxuICAgICAgICAgIDEwNyxcbiAgICAgICAgICAxMDgsXG4gICAgICAgICAgMTA5LFxuICAgICAgICAgIDExMCxcbiAgICAgICAgICAxMTEsXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMTQsXG4gICAgICAgICAgMTE1XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0VYUFJFU1NJT04nOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA3MSxcbiAgICAgICAgICA3MixcbiAgICAgICAgICA3MyxcbiAgICAgICAgICA3NCxcbiAgICAgICAgICA3NSxcbiAgICAgICAgICA3NixcbiAgICAgICAgICA3NyxcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNCxcbiAgICAgICAgICAxMTVcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnQ09OVFJPTF9DSElMRCc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDY0LFxuICAgICAgICAgIDY1LFxuICAgICAgICAgIDY2LFxuICAgICAgICAgIDY3LFxuICAgICAgICAgIDY4LFxuICAgICAgICAgIDY5LFxuICAgICAgICAgIDcwLFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0LFxuICAgICAgICAgIDExNVxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdUQUcnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAxNCxcbiAgICAgICAgICAxNSxcbiAgICAgICAgICAxNixcbiAgICAgICAgICAxNyxcbiAgICAgICAgICAxOCxcbiAgICAgICAgICAxOSxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAyMSxcbiAgICAgICAgICAyMixcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNCxcbiAgICAgICAgICAxMTVcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnSU5JVElBTCc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMixcbiAgICAgICAgICAzLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgNSxcbiAgICAgICAgICA2LFxuICAgICAgICAgIDcsXG4gICAgICAgICAgOCxcbiAgICAgICAgICA5LFxuICAgICAgICAgIDEwLFxuICAgICAgICAgIDExLFxuICAgICAgICAgIDEyLFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0LFxuICAgICAgICAgIDExNSxcbiAgICAgICAgICAxMTZcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxleGVyO1xufSgpO1xucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5cbmZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtcbnBhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5cbnJldHVybiBuZXcgUGFyc2VyKCk7XG59KSgpO1xuXG4gICAgICAgIFxuXG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4cG9ydHMucGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlci5QYXJzZXI7XG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZS5hcHBseShQYXJzZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbm9kZXMgPSByZXF1aXJlKFwiLi9BU1RcIik7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIENPTlRFWFQgPSAnX19fY29udGV4dCc7XG52YXIgVklFVyA9ICdfX192aWV3JztcbnZhciBXTUwgPSAnX19fd21sJztcbnZhciBwcmltcyA9IFsnU3RyaW5nJywgJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdVbmRlZmluZWQnLCAnTnVsbCcsICdWb2lkJywgJ05ldmVyJywgJ0FueSddO1xuLyoqXG4gKiBUeXBlcyBhbmQgZnVuY3Rpb25zIGZvciBnZW5lcmF0aW5nIHR5cGVzY3JpcHQgcHJvZ3JhbSB0ZXh0LlxuICovXG52YXIgX3Rocm93Tm90S25vd24gPSBmdW5jdGlvbiAobikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEFTVCBub2RlIFwiICsgKHR5cGVvZiBuID09PSAnb2JqZWN0JyA/IG4uY29uc3RydWN0b3IubmFtZSA6IG4pICsgXCIhXCIpO1xufTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJmdW5jdGlvbiAoKSB7fVwiOyB9O1xuLyoqXG4gKiB2aWV3IHRlbXBsYXRlLlxuICovXG5leHBvcnRzLnZpZXcgPSBmdW5jdGlvbiAoaWQsIHR5cGVDbGFzc2VzLCBwYXJhbXMsIGN0eCwgdGFnKSB7XG4gICAgcmV0dXJuIFwiZXhwb3J0IGNsYXNzIFwiICsgaWQgKyB0eXBlQ2xhc3NlcyArIFwiIGV4dGVuZHMgXCIgKyBXTUwgKyBcIi5BcHBWaWV3PFwiICsgY3R4ICsgXCI+IHtcXG5cXG4gICAgY29uc3RydWN0b3IoXCIgKyBDT05URVhUICsgXCI6IFwiICsgY3R4ICsgKHBhcmFtcyA/ICcsJyArIHBhcmFtcyA6ICcnKSArIFwiKSB7XFxuXFxuICAgICAgICBzdXBlcihcIiArIENPTlRFWFQgKyBcIik7XFxuXFxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gKFwiICsgVklFVyArIFwiOlwiICsgV01MICsgXCIuQXBwVmlldzxcIiArIGN0eCArIFwiPikgPT5cXG4gICAgICAgICAgXCIgKyAodGFnID8gdGFnIDogJzxOb2RlPmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKScpICsgXCI7XFxuXFxuICAgICAgIH1cXG5cXG4gICAgIH1cXG5cIjtcbn07XG4vKipcbiAqIGNvZGUgdHVybnMgYW4gQVNUIGludG8gdHlwZXNjcmlwdCBjb2RlLlxuICovXG5leHBvcnRzLmNvZGUgPSBmdW5jdGlvbiAobiwgbykgeyByZXR1cm4gZXhwb3J0cy5tb2R1bGUyVFMobiwgbyk7IH07XG4vKipcbiAqIG1vZHVsZTJUUyBjb252ZXJ0cyBhIG1vZHVsZSB0byBhIHR5cGVzY3JpcHQgbW9kdWxlLlxuICovXG5leHBvcnRzLm1vZHVsZTJUUyA9IGZ1bmN0aW9uIChuLCBfYSkge1xuICAgIHZhciBtb2R1bGUgPSBfYS5tb2R1bGU7XG4gICAgcmV0dXJuIFwiXFxuaW1wb3J0ICogYXMgXCIgKyBXTUwgKyBcIiBmcm9tICdcIiArIG1vZHVsZSArIFwiJztcXG5cIiArIG4uaW1wb3J0cy5tYXAoZXhwb3J0cy5pbXBvcnRTdGF0ZW1lbnQyVFMpLmpvaW4oJztcXG4nKSArIFwiXFxuXFxuXCIgKyBuLmV4cG9ydHMubWFwKGV4cG9ydHMuZXhwb3J0czJUUykuam9pbignO1xcbicpICsgXCJcXG5cXG5cIiArIChuLm1haW4gPyBleHBvcnRzLm1haW4yVFMobi5tYWluKSA6ICcnKSArIFwiXFxuXCI7XG59O1xuLyoqXG4gKiBleHBvcnRzMlRTIGNvbnZlcnRzIHZhcmlvdXMgZXhwb3J0cyB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmV4cG9ydHMyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRXhwb3J0U3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5leHBvcnRTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1blN0YXRlbWVudClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZnVuU3RhdGVtZW50MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5WaWV3U3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy52aWV3U3RhdGVtZW50MlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogaW1wb3J0U3RhdGVtZW50MlRTIGNvbnZlcnRzIGFuIGltcG9ydCBzdGF0ZW1lbnQuXG4gKi9cbmV4cG9ydHMuaW1wb3J0U3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJpbXBvcnQgXCIgKyBleHBvcnRzLmltcG9ydE1lbWJlcjJUUyhuLm1lbWJlcikgKyBcIiBmcm9tICdcIiArIG4ubW9kdWxlLnZhbHVlICsgXCInOyBcIjtcbn07XG4vKipcbiAqIGltcG9ydE1lbWJlcjJUUyBjb252ZXJ0cyB0aGUgbWVtYmVycyBvZiBhbiBpbXBvcnQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pbXBvcnRNZW1iZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQWdncmVnYXRlTWVtYmVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5hZ2dyZWdhdGVNZW1iZXIyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkFsaWFzZWRNZW1iZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmFsaWFzZWRNZW1iZXIyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNvbXBvc2l0ZU1lbWJlcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcG9zaXRlTWVtYmVyMlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duO1xufTtcbi8qKlxuICogYWxpYXNlZE1lbWJlcjJUUyBjb252ZXJ0cyBhIG1lbWJlciBhbGlhcyB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmFsaWFzZWRNZW1iZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4ubWVtYmVyKSArIFwiIGFzIFwiICsgZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLmFsaWFzKSArIFwiIFwiO1xufTtcbi8qKlxuICogYWdncmVnYXRlTWVtYmVyMlRTIGNvbnZlcnRzIGEgcXVhbGlmaWVkIG1lbWJlciB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmFnZ3JlZ2F0ZU1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiKiBhcyBcIiArIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5pZCkgKyBcIiBcIjtcbn07XG4vKipcbiAqIGNvbXBvc2l0ZU1lbWJlcjJUUyBjb3ZlcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuY29tcG9zaXRlTWVtYmVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gJ3snICsgKG4ubWVtYmVycy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIChtIGluc3RhbmNlb2Ygbm9kZXMuQWxpYXNlZE1lbWJlcikgP1xuICAgICAgICBleHBvcnRzLmFsaWFzZWRNZW1iZXIyVFMobSkgOlxuICAgICAgICBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG0pOyB9KS5qb2luKCcsJykpICsgJ30nO1xufTtcbi8qKlxuICogbWFpbjJUUyBjb252ZXJ0cyB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLm1haW4yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLlR5cGVkTWFpbikgP1xuICAgICAgICBleHBvcnRzLnR5cGVkTWFpbjJUUyhuKSA6XG4gICAgICAgIGV4cG9ydHMudW50eXBlZE1haW4yVFMobik7XG59O1xuLyoqXG4gKiB0eXBlZE1haW4yVFMgY29udmVydHMgYSB0eXBlZCBtYWluIGZpbGUgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy50eXBlZE1haW4yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLnZpZXcobi5pZCA/IGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4uaWQpIDogJ01haW4nLCBleHBvcnRzLnR5cGVDbGFzc2VzMlRTKG4udHlwZUNsYXNzZXMpLCBuLnBhcmFtZXRlcnMubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJyksIGV4cG9ydHMudHlwZTJUUyhuLmNvbnRleHQpLCBleHBvcnRzLnRhZzJUUyhuLnRhZykpO1xufTtcbi8qKlxuICogdW50eXBlZE1haW4yVFMgY29udmVydHMgYW4gdW50eXBlZCBtYWluIGZpbGUgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy51bnR5cGVkTWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldygnTWFpbicsICcnLCAnJywgJ3ZvaWQnLCBleHBvcnRzLnRhZzJUUyhuLnRhZykpO1xufTtcbi8qKlxuICogZXhwb3J0U3RhdGVtZW50MlRTIGNvbnZlcnRzIGFuIGV4cG9ydCBzdGF0ZW1lbnQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5leHBvcnRTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcImV4cG9ydCBcIiArIGV4cG9ydHMuY29tcG9zaXRlTWVtYmVyMlRTKG4ubWVtYmVycykgKyBcIiBmcm9tICdcIiArIG4ubW9kdWxlLnZhbHVlICsgXCInO1xcblwiO1xufTtcbi8qKlxuICogdmlld1N0YXRlbWVudDJUUyBjb252ZXJ0cyBhIHZpZXcgc3RhdGVtZW50IGludG8gYSB0eXBlc2NyaXB0IGNsYXNzLlxuICovXG5leHBvcnRzLnZpZXdTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLnZpZXcoZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuLmlkKSwgZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSwgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpLCBleHBvcnRzLnR5cGUyVFMobi5jb250ZXh0KSwgZXhwb3J0cy50YWcyVFMobi50YWcpKTtcbn07XG52YXIgX2Z1bkNvbnRleHQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCIoXCIgKyBDT05URVhUICsgXCI6XCIgKyBleHBvcnRzLnR5cGUyVFMobikgKyBcIik9PlwiOyB9O1xudmFyIF9mdW5WaWV3ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIoXCIgKyBWSUVXICsgXCI6XCIgKyBXTUwgKyBcIi5WaWV3KT0+XCI7IH07XG52YXIgX2N1cnJ5ID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5tYXAoZXhwb3J0cy5wYXJhbWV0ZXIyVFMpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCIoXCIgKyBzICsgXCIpPT5cIjsgfSkuam9pbignJyk7XG59O1xuLyoqXG4gKiBmdW5TdGF0ZW1lbnQyVFMgY29udmVydHMgYSBmdW5jdGlvbiBzdGF0ZW1lbnQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5mdW5TdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcImV4cG9ydCBjb25zdCBcIiArIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4uaWQpICsgXCIgPSBcIiArXG4gICAgICAgIChcIlwiICsgZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSkgK1xuICAgICAgICAoKG4uY29udGV4dCAhPSBudWxsKSA/IF9mdW5Db250ZXh0KG4uY29udGV4dCkgOiAnJykgK1xuICAgICAgICAoXCJcIiArIF9jdXJyeShuLnBhcmFtZXRlcnMpICsgX2Z1blZpZXcoKSkgK1xuICAgICAgICAoKEFycmF5LmlzQXJyYXkobi5ib2R5KSA/IGV4cG9ydHMuY2hpbGRyZW4yVFMobi5ib2R5KSA6IGV4cG9ydHMuY2hpbGQyVFMobi5ib2R5KSkgKyBcIjtcIik7XG59O1xuLyoqXG4gKiB0eXBlQ2xhc3NlczJUUyBjb252ZXJ0cyBhIGxpc3Qgb2YgdHlwZWNsYXNzZXMgaW50byB0aGUgYSBsaXN0IG9mIHR5cGVzY3JpcHQgdHlwZWNsYXNzZXMuXG4gKi9cbmV4cG9ydHMudHlwZUNsYXNzZXMyVFMgPSBmdW5jdGlvbiAobnMpIHtcbiAgICByZXR1cm4gKG5zLmxlbmd0aCA9PT0gMCkgPyAnJyA6IFwiPCBcIiArIG5zLm1hcChleHBvcnRzLnR5cGVDbGFzczJUUykuam9pbignLCcpICsgXCI+XCI7XG59O1xuLyoqXG4gKiB0eXBlQ2xhc3MyVFMgY29udmVydHMgYSB0eXBlY2xhc3MgaW50byBhIHR5cGVzY3JpcHQgdHlwZWNsYXNzLlxuICovXG5leHBvcnRzLnR5cGVDbGFzczJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5pZCkgKyBcIiBcIiArXG4gICAgICAgICgobi5jb25zdHJhaW50ID8gJ2V4dGVuZHMgJyArIGV4cG9ydHMudHlwZTJUUyhuLmNvbnN0cmFpbnQpIDogJycpICsgXCIgXCIpO1xufTtcbnZhciBfdG9QcmltID0gZnVuY3Rpb24gKHR5cCkge1xuICAgIHJldHVybiBwcmltcy5pbmRleE9mKHR5cCkgPiAtMSA/IHR5cC50b0xvd2VyQ2FzZSgpIDogdHlwO1xufTtcbi8qKlxuICogdHlwZTJUUyBjb252ZXJ0cyBhIHR5cGUgaGludCB0byBhIHR5cGVzY3JpcHQgdHlwZSBoaW50LlxuICovXG5leHBvcnRzLnR5cGUyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBfdG9QcmltKGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5pZCkpICsgXCIgXCIgK1xuICAgICAgICAoZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSArIFwiIFwiICsgKG4ubGlzdCA/ICdbXScgOiAnJykpO1xufTtcbi8qKlxuICogcGFyYW1ldGVyMlRTIGNvbnZlcnRzIGEgcGFyYW1ldGVyIHRvIGEgdHlwZXNjcmlwdCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMucGFyYW1ldGVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5UeXBlZFBhcmFtZXRlcikgPyBleHBvcnRzLnR5cGVkUGFyYW1ldGVyMlRTKG4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnR5cGVkUGFyYW1ldGVyKSA/IGV4cG9ydHMudW50eXBlZFBhcmFtZXRlcjJUUyhuKSA6XG4gICAgICAgICAgICBfdGhyb3dOb3RLbm93bjtcbn07XG4vKipcbiAqIHR5cGVkUGFyYW1ldGVyMlRTIGNvbnZlcnRzIGEgdHlwZWQgcGFyYW1ldGVyIGludG8gYSBub24tYW55IHR5cGVzY3JpcHQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLnR5cGVkUGFyYW1ldGVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4uaWQpICsgXCI6XCIgKyBleHBvcnRzLnR5cGUyVFMobi5oaW50KSArIFwiIFwiO1xufTtcbi8qKlxuICogdW50eXBlZFBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhbiB0eXBlIGluZmVycmVkIHBhcmFtZXRlciB0byBhIHR5cGVzY3JpcHQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLnVudHlwZWRQYXJhbWV0ZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXIyVFMobi5pZCkgKyBcIiBcIjtcbn07XG4vKipcbiAqIGNoaWxkcmVuMlRTIGNvbnZlcnRzIGEgbGlzdCBvZiBjaGlsZHJlbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmNoaWxkcmVuMlRTID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICByZXR1cm4gKGxpc3QubGVuZ3RoID09PSAwKSA/ICdkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7JyA6XG4gICAgICAgIChsaXN0Lmxlbmd0aCA9PT0gMSkgPyBleHBvcnRzLmNoaWxkMlRTKGxpc3RbMF0pIDpcbiAgICAgICAgICAgIFdNTCArIFwiLmJveChcIiArIGxpc3QubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBleHBvcnRzLmNoaWxkMlRTKGwpOyB9KS5qb2luKCcsJykgKyBcIikgXCI7XG59O1xuLyoqXG4gKiBjaGlsZDJUUyBjb252ZXJ0cyBjaGlsZHJlbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmNoaWxkMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoKG4gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlKSB8fCAobiBpbnN0YW5jZW9mIG5vZGVzLldpZGdldCkpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnRhZzJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSW50ZXJwb2xhdGlvbilcbiAgICAgICAgcmV0dXJuIFdNTCArIFwiLmRvbWlmeShcIiArIGV4cG9ydHMuaW50ZXJwb2xhdGlvbjJUUyhuKSArIFwiKSBcIjtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSWZTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmlmU3RhdGVtZW50MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Gb3JTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmZvclN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ2hhcmFjdGVycylcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2hhcmFjdGVyczJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29udGV4dFByb3BlcnR5KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb250ZXh0UHJvcGVydHkyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRJZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1YWxpZmllZElkZW50aWZpZXIyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiB0YWcyVFMgY29udmVydHMgYSB0YWcgKG5vZGUvd2lkZ2V0KSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnRhZzJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbi5jaGlsZHJlbi5tYXAoZXhwb3J0cy5jaGlsZDJUUyk7XG4gICAgdmFyIGF0dHJzID0gZXhwb3J0cy5hdHRyczJTdHJpbmcoZXhwb3J0cy5ncm91cEF0dHJzKG4uYXR0cmlidXRlcykpO1xuICAgIHZhciBuYW1lID0gZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLm9wZW4pO1xuICAgIHJldHVybiAobi50eXBlID09PSAnd2lkZ2V0JykgPyBXTUwgKyBcIi53aWRnZXQoXCIgKyBuYW1lICsgXCIsIFwiICsgYXR0cnMgKyBcIiwgW1wiICsgY2hpbGRyZW4gKyBcIl0sIFwiICsgVklFVyArIFwiKVwiIDpcbiAgICAgICAgV01MICsgXCIubm9kZSgnXCIgKyBuYW1lICsgXCInLCBcIiArIGF0dHJzICsgXCIsIFtcIiArIGNoaWxkcmVuICsgXCJdLCBcIiArIFZJRVcgKyBcIikgXCI7XG59O1xuLyoqXG4gKiBhdHRyczJTdHJpbmdcbiAqL1xuZXhwb3J0cy5hdHRyczJTdHJpbmcgPSBmdW5jdGlvbiAoYXR0cnMpIHsgcmV0dXJuICd7JyArXG4gICAgKE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoZnVuY3Rpb24gKG5zKSB7IHJldHVybiBucyArIFwiIDogeyBcIiArIGF0dHJzW25zXS5qb2luKCcsJykgKyBcIiB9IFwiOyB9KSkgKyAnfSc7IH07XG4vKipcbiAqIGdyb3VwQXR0cnMgZ3JvdXBzIGF0dHJpYnV0ZXMgYWNjb3JkaW5nIHRvIHRoZWlyIG5hbWVzcGFjZS5cbiAqL1xuZXhwb3J0cy5ncm91cEF0dHJzID0gZnVuY3Rpb24gKG5zKSB7IHJldHVybiBucy5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gYWZwbC51dGlsLm1lcmdlKHAsIChfYSA9IHt9LFxuICAgICAgICBfYVtjLm5hbWVzcGFjZS5pZCB8fCAnaHRtbCddID0gKHBbYy5uYW1lc3BhY2UuaWQgfHwgJ2h0bWwnXSB8fCBbXSkuY29uY2F0KGV4cG9ydHMuYXR0cmlidXRlMlRTKGMpKSxcbiAgICAgICAgX2EpKTtcbiAgICB2YXIgX2E7XG59LCB7IGh0bWw6IFtdLCB3bWw6IFtdIH0pOyB9O1xuLyoqXG4gKiBhdHRyaWJ1dGUyVmFsdWVcbiAqL1xuZXhwb3J0cy5hdHRyaWJ1dGUyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIidcIiArIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4ubmFtZSkgKyBcIicgOiBcIiArIGV4cG9ydHMuYXR0cmlidXRlVmFsdWUyVFMobi52YWx1ZSkgKyBcIiBcIjtcbn07XG4vKipcbiAqIGF0dHJpYnV0ZVZhbHVlMlRTIGNvbnZlcnRzIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmF0dHJpYnV0ZVZhbHVlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5JbnRlcnBvbGF0aW9uKSA/IGV4cG9ydHMuaW50ZXJwb2xhdGlvbjJUUyhuKSA6IGV4cG9ydHMubGl0ZXJhbDJUUyhuKTtcbn07XG4vKipcbiAqIGludGVycG9sYXRpb24yVFMgY29udmVydHMgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucyB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmludGVycG9sYXRpb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmZpbHRlcnMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiBleHBvcnRzLmV4cHJlc3Npb24yVFMoYykgKyBcIiAoXCIgKyBwICsgXCIpXCI7IH0sIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmV4cHJlc3Npb24pKTtcbn07XG4vKipcbiAqIGZvclN0YXRlbWVudDJUUyBjb252ZXJ0cyBhIGZvciBzdGF0ZW1lbnQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5mb3JTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBXTUwgKyBcIi5tYXAoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5saXN0KSArIFwiLCBmdW5jdGlvbiBfbWFwXCIgK1xuICAgICAgICAoXCIoXCIgKyBbbi52YXJpYWJsZSwgbi5pbmRleCwgbi5hbGxdLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSkubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJykgKyBcIikgXCIpICtcbiAgICAgICAgKFwieyByZXR1cm4gXCIgKyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uYm9keSkgKyBcIiB9LCBcIikgK1xuICAgICAgICAoXCJmdW5jdGlvbiBvdGhlcndpc2UoKSB7IHJldHVybiBcIiArIGV4cG9ydHMuY2hpbGRyZW4yVFMobi5vdGhlcndpc2UpICsgXCIgfSkgXCIpO1xufTtcbi8qKlxuICogaWZTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gaWYgc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuaWZTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIihcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmNvbmRpdGlvbikgKyBcIik/IFwiICtcbiAgICAgICAgKGV4cG9ydHMuY2hpbGRyZW4yVFMobi50aGVuKSArIFwiOlwiKSArXG4gICAgICAgIChcIlwiICsgKG4uZWxzZUNsYXVzZSA/IGVsc2UyVFMobi5lbHNlQ2xhdXNlKSA6IG5vb3AoKSkpO1xufTtcbnZhciBlbHNlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5FbHNlQ2xhdXNlKSA/IGV4cG9ydHMuY2hpbGRyZW4yVFMobi5jaGlsZHJlbikgOlxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLkVsc2VJZkNsYXVzZSkgPyBleHBvcnRzLmlmU3RhdGVtZW50MlRTKG4pIDpcbiAgICAgICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogY2hhcmFjdGVyczJUUyBjb252ZXJ0cyBjaGFyYWN0ZXIgdGV4dCB0byBhIHR5cGVzY3JpcHQgc3RyaW5nLlxuICovXG5leHBvcnRzLmNoYXJhY3RlcnMyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gV01MICsgXCIudGV4dChgXCIgKyBuLnZhbHVlICsgXCJgKVwiOyB9O1xuLyoqXG4gKiBleHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgd21sIGV4cHJlc3Npb24gdG8gYSB0eXBlc2NyaXB0IGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMuZXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5JZlRoZW5FeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5pZlRoZW5FeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5CaW5hcnlFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5iaW5hcnlFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbmFyeUV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVuYXJ5RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVmlld0NvbnN0cnVjdGlvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudmlld0NvbnN0cnVjdGlvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRnVuQXBwbGljYXRpb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLmZ1bkFwcGxpY2F0aW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Db25zdHJ1Y3RFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb25zdHJ1Y3RFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2FsbEV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLk1lbWJlckV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLm1lbWJlckV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlJlYWRFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZWFkRXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRnVuY3Rpb25FeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5jdGlvbkV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlJlY29yZClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVjb3JkMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5MaXN0KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5saXN0MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Cb29sZWFuTGl0ZXJhbClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYm9vbGVhbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuTnVtYmVyTGl0ZXJhbClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubnVtYmVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5TdHJpbmdMaXRlcmFsKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zdHJpbmcyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNvbnRleHRQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29udGV4dFByb3BlcnR5MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRJZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Db250ZXh0VmFyaWFibGUpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnRleHRWYXJpYWJsZTJUUyhuKTtcbiAgICBlbHNlXG4gICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogaWZUaGVuRXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhbiBpZi10aGVuLWVsc2UgZXhwcmVzc2lvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmlmVGhlbkV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIihcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmNvbmRpdGlvbikgKyBcIikgPyBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmlmdHJ1ZSkgKyBcIiA6IFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uaWZmYWxzZSkgKyBcIiBcIjtcbn07XG4vKipcbiAqIGJpbmFyeUV4cHJlc3Npb24yVFMgY29udmVydHMgYSBiaW5hcnkgZXhwcmVzc2lvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmJpbmFyeUV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIihcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmxlZnQpICsgXCIgXCIgKyBleHBvcnRzLmNvbnZlcnRPcGVyYXRvcihuLm9wZXJhdG9yKSArIFwiIFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4ucmlnaHQpICsgXCIpIFwiO1xufTtcbi8qKlxuICogY29udmVydE9wZXJhdG9yIGZvciBzdHJpY3RuZXNzLlxuICovXG5leHBvcnRzLmNvbnZlcnRPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHJldHVybiAob3AgPT09ICc9PScpID8gJz09PScgOlxuICAgICAgICAob3AgPT09ICchPScpID8gJyE9PScgOlxuICAgICAgICAgICAgb3A7XG59O1xuLyoqXG4gKiB1bmFyeUV4cHJlc3Npb24yVFMgY29udmVydHMgYSB1bmFyeSBleHByZXNzaW9uIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMudW5hcnlFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5vcGVyYXRvciArIFwiIChcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmV4cHJlc3Npb24pICsgXCIpXCI7XG59O1xuLyoqXG4gKiB2aWV3Q29uc3RydWN0aW9uMlRTIGNvbnZlcnMgYSB2aWV3IGNvbnN0cnVjdGlvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnZpZXdDb25zdHJ1Y3Rpb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIihuZXcgXCIgKyBleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4uY29ucykgKyBcIihcIiArIGV4cG9ydHMuYXJnczJUUyhuLmNvbnRleHQpICsgXCIpKS5yZW5kZXIoKVwiO1xufTtcbmV4cG9ydHMuX2N1cnJpZWRBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uIChucykge1xuICAgIHJldHVybiAobnMubGVuZ3RoID09PSAwKSA/ICcnIDogbnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBcIihcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhlKSArIFwiKVwiOyB9KS5qb2luKCcnKTtcbn07XG4vKipcbiAqIGZ1bkFwcGxpY2F0aW9uMlRTIGNvbnZlcnRzIGEgZnVuIGFwcGxpY2F0aW9uIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZnVuQXBwbGljYXRpb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIlwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIGV4cG9ydHMudHlwZUFyZ3MyVFMobi50eXBlQXJncykgKyBcIiBcIiArXG4gICAgICAgIChleHBvcnRzLl9jdXJyaWVkQXBwbGljYXRpb24obi5hcmdzKSArIFwiKFwiICsgVklFVyArIFwiKVwiKTtcbn07XG4vKipcbiAqIGNvbnN0cnVjdEV4cHJlc3Npb24yVFMgY29udmVydHMgYSBjb25zdHJ1Y3QgZXhwcmVzc2lvbiB0byBhIHR5cGVzY3JpcHQgbmV3IGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMuY29uc3RydWN0RXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwibmV3IFwiICsgZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuLmNvbnMpICsgXCIgKFwiICsgZXhwb3J0cy5hcmdzMlRTKG4uYXJncykgKyBcIilcIjtcbn07XG4vKipcbiAqIGNhbGxFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgY2FsbCBleHByZXNzaW9uIChhcHBseSkgdG8gYSB0eXBlc2NyaXB0IGludm9jYXRpb24uXG4gKi9cbmV4cG9ydHMuY2FsbEV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmV4cHJlc3Npb24yVFMobi50YXJnZXQpICsgXCIgXCIgKyBleHBvcnRzLnR5cGVBcmdzMlRTKG4udHlwZUFyZ3MpICsgXCIgKFwiICsgZXhwb3J0cy5hcmdzMlRTKG4uYXJncykgKyBcIilcIjtcbn07XG4vKipcbiAqIHR5cGVBcmdzMlRTIGNvbnZlcnRzIHBhc3NlZCB0eXBlIGFyZ3VtZW50cyB0byB0eXBlc2NyaXB0XG4gKi9cbmV4cG9ydHMudHlwZUFyZ3MyVFMgPSBmdW5jdGlvbiAobnMpIHtcbiAgICByZXR1cm4gbnMubGVuZ3RoID09PSAwID8gJycgOiBcIjwgXCIgKyBucy5tYXAoZXhwb3J0cy50eXBlMlRTKS5qb2luKCcsJykgKyBcIj5cIjtcbn07XG4vKipcbiAqIGFyZ3MyVFMgY29udmVydHMgYSBsaXN0IG9mIGFyZ3VtZW50cyB0byBhIHR5cGVzY3JpcHQgYXJndW1lbnQgdHVwcGxlLlxuICovXG5leHBvcnRzLmFyZ3MyVFMgPSBmdW5jdGlvbiAobnMpIHtcbiAgICByZXR1cm4gKG5zLmxlbmd0aCA9PT0gMCkgPyAnJyA6IG5zLm1hcChleHBvcnRzLmV4cHJlc3Npb24yVFMpLmpvaW4oJywnKTtcbn07XG4vKipcbiAqIG1lbWJlckV4cHJlc3Npb24yVFMgY29udmVydHMgYSBtZW1iZXIgZXhwcmVzc2lvbiBpbnRvIGEgdHlwZXNjcmlwdCBtZW1iZXIgZXhwcmVzc2lvbi5cbiAqL1xuZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIFwiLlwiICsgZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4ubWVtYmVyKSArIFwiIFwiO1xufTtcbi8qKlxuICogcmVhZEV4cHJlc3Npb24yVFMgY29udmVydHMgYSByZWFkIGV4cHJlc3Npb24gdG8gc2lkZSBlZmZlY3QgZnVsbCBwcm9wZXJ0eSBsb29rIHVwLlxuICpcbiAqIE5PVEU6IHRoaXMgcGFydCBvZiB0aGUgbGFuZ3VhZ2UgaXMgbW9zdCBsaWtlbHkgdG8gY2hhbmdlLlxuICovXG5leHBvcnRzLnJlYWRFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gV01MICsgXCIucmVhZCA8IFwiICsgZXhwb3J0cy50eXBlMlRTKG4uaGludCkgKyBcIj4oXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5wYXRoKSArIFwiLCBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIiBcIiArXG4gICAgICAgICgobi5kZWZhdWx0cyA/ICcsJyArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmRlZmF1bHRzKSA6ICcnKSArIFwiKVwiKTtcbn07XG4vKipcbiAqIGZ1bmN0aW9uRXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIGZ1bmN0aW9uIGV4cHJlc3Npb24gdG8gYSB0eXBlc2NyaXB0IGZ1bmN0aW9uIGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25FeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBuLnBhcmFtZXRlcnMubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJykgKyBcIik9PlwiICtcbiAgICAgICAgKFwiXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5ib2R5KSk7XG59O1xuLyoqXG4gKiBsaXRlcmFsMlRTIGNvbnZlcnRzIGxpdGVyYWxzLlxuICovXG5leHBvcnRzLmxpdGVyYWwyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLkJvb2xlYW5MaXRlcmFsKSA/IGV4cG9ydHMuYm9vbGVhbjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbCkgPyBleHBvcnRzLnN0cmluZzJUUyhuKSA6XG4gICAgICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLk51bWJlckxpdGVyYWwpID8gZXhwb3J0cy5udW1iZXIyVFMobikgOlxuICAgICAgICAgICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuUmVjb3JkKSA/IGV4cG9ydHMucmVjb3JkMlRTKG4pIDpcbiAgICAgICAgICAgICAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5MaXN0KSA/IGV4cG9ydHMubGlzdDJUUyhuKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGJvb2xlYW4yVFMgY29udmVydHMgYSBib29sZWFuIGxpdGVyYWwgdG8gYSB0eXBlc2NyaXB0IGJvb2xlYW4gbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5ib29sZWFuMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udmFsdWUgKyBcIiBcIjsgfTtcbi8qKlxuICogc3RyaW5nMlRTIGNvbnZlcnRzIGEgc3RyaW5nIGxpdGVyYWwgdG8gYSB0eXBlc2NyaXB0IHN0cmluZyBsaXRlcmFsLlxuICovXG5leHBvcnRzLnN0cmluZzJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcImBcIiArIG4udmFsdWUgKyBcImBcIjsgfTtcbi8qKlxuICogbnVtYmVyMlRTIGNvbnZlcnRzIGEgbnVtYmVyIGxpdGVyYWwgdG8gYSB0eXBlY3JpcHQgbnVtYmVyIGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMubnVtYmVyMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBwYXJzZUZsb2F0KG4udmFsdWUpOyB9O1xuLyoqXG4gKiByZWNvcmQyVFMgY29udmVydHMgYSByZWNvcmQgdG8gYSB0eXBlc2NyaXB0IG9iamVjdCBsaXRlcmFsLlxuICovXG5leHBvcnRzLnJlY29yZDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwie1wiICsgbi5wcm9wZXJ0aWVzLm1hcChleHBvcnRzLnByb3BlcnR5MlRTKS5qb2luKCcsJykgKyBcIn1cIjtcbn07XG4vKipcbiAqIGxpc3QyVFMgY29udmVydHMgYSBsaXN0IHRvIGEgdHlwZXNjcmlwdCBhcnJheSBsaXRlcmFsLlxuICovXG5leHBvcnRzLmxpc3QyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIltcIiArIG4ubWVtYmVycy5tYXAoZXhwb3J0cy5leHByZXNzaW9uMlRTKS5qb2luKCcsJykgKyBcIl1cIjtcbn07XG4vKipcbiAqIHByb3BlcnR5MlRTIGNvbnZlcnRzIGEgcHJvcGVydHkgb2YgYSBhIHJlY29yZCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnByb3BlcnR5MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCInXCIgKyBleHBvcnRzLmtleTJUUyhuLmtleSkgKyBcIicgOiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnZhbHVlKTtcbn07XG4vKipcbiAqIGtleTJUUyBjb252ZXJ0cyBhIHNpbmdsZSBrZXkgb24gYSByZWNvcmQuXG4gKi9cbmV4cG9ydHMua2V5MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5TdHJpbmdMaXRlcmFsKSA/IGV4cG9ydHMuc3RyaW5nMlRTKG4pIDogZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4pO1xufTtcbi8qKlxuICogY29udGV4dFByb3BlcnR5MlRTIHR1cm5zIHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgY29udGV4dCB0byByZWd1bGFyIFRTXG4gKiBwcm9wZXJ0eSBhY2Nlc3MuXG4gKi9cbmV4cG9ydHMuY29udGV4dFByb3BlcnR5MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gQ09OVEVYVCArIFwiLlwiICsgZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4ubWVtYmVyKTtcbn07XG4vKipcbiAqIGNvbnRleHRWYXJpYWJsZTJUUyB0dXJucyB0aGUgY29udGV4dCB2YXJpYWJsZSBpbnRvIHRoZSBjb250ZXh0IGlkZW50aWZpZXIuXG4gKi9cbmV4cG9ydHMuY29udGV4dFZhcmlhYmxlMlRTID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIFwiXCIgKyBDT05URVhUOyB9O1xuLyoqXG4gKiBpZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUU1xuICovXG5leHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpIHx8XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkSWRlbnRpZmllcikpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXIyVFMobik7XG4gICAgZWxzZSBpZiAoKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZENvbnN0cnVjdG9yKSB8fFxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZENvbnN0cnVjdG9yKSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBjb25zdHJ1Y3RvcjJUUyB0dXJucyBhIGNvbnN0cnVjdG9yIHRvIGEgdHlwZXNjcmlwdCBpZGVudGlmaWVyLlxuICpcbiAqIFJlbWVtYmVyIGNvbnN0cnVjdG9ycyBhcmUgcHJvcGVyIGNhc2VkLlxuICovXG5leHBvcnRzLmNvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcikgPyBleHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZENvbnN0cnVjdG9yKSA/IGV4cG9ydHMudW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKSA6XG4gICAgICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIHVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMgY29udmVydHMgYW4gdW5xdWFsaWZpZWQgY29uc3RydWN0b3IgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCJcIiArIG4uaWQ7IH07XG4vKipcbiAqIHF1YWxpZmllZENvbnN0cnVjdG9yIGNvbnZlcnRzIGEgcXVhbGlmaWVkIGNvbnN0cnVjdG9yIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLnF1YWxpZmllciArIFwiLlwiICsgbi5tZW1iZXI7XG59O1xuLyoqXG4gKiBpZGVudGlmaWVyMlRTIHR1cm5zIGFuIGlkZW50aWZpZXIgdG8gYSB0eXBlc2NyaXB0IGlkZW50aWZpZXIuXG4gKi9cbmV4cG9ydHMuaWRlbnRpZmllcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkSWRlbnRpZmllcikgPyBleHBvcnRzLnF1YWxpZmllZElkZW50aWZpZXIyVFMobikgOlxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkSWRlbnRpZmllcikgPyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKSA6XG4gICAgICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIHF1YWxpZmllZElkZW50aWZpZXIyVFMgY29udmVydHMgYSBxdWFsaWZpZWQgaWRlbnRpZmllciB0byB0eXBlc2NyaXB0XG4gKi9cbmV4cG9ydHMucXVhbGlmaWVkSWRlbnRpZmllcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ucXVhbGlmaWVyICsgXCIuXCIgKyBuLm1lbWJlcjtcbn07XG4vKipcbiAqIHVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyBjb252ZXJ0cyBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIHRvIHR5cGVzY3JpcHRcbiAqL1xuZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCJcIiArIG4uaWQ7IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlU2NyaXB0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByb3BlcnR5ID0gcmVxdWlyZShcInByb3BlcnR5LXNlZWtcIik7XG52YXIgTWF5YmVfMSA9IHJlcXVpcmUoXCJhZnBsL2xpYi9tb25hZC9NYXliZVwiKTtcbnZhciBDb21waWxlcl8xID0gcmVxdWlyZShcIi4vQ29tcGlsZXJcIik7XG5leHBvcnRzLnBhcnNlID0gQ29tcGlsZXJfMS5wYXJzZTtcbmV4cG9ydHMuY29tcGlsZSA9IENvbXBpbGVyXzEuY29tcGlsZTtcbjtcbi8qKlxuICogQ29tcG9uZW50IGlzIGFuIGFic3RyYWN0IFdpZGdldCBpbXBsZW1lbnRhdGlvblxuICogdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIG1hbnVhbGx5IGltcGxlbWVudGluZyB0aGUgd2hvbGUgaW50ZXJmYWNlLlxuICpcbiAqL1xudmFyIENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBhdHRycyBpcyB0aGUgYXR0cmlidXRlcyB0aGlzIENvbXBvbmVudCBleGNlcHRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGNoaWxkcmVuIGlzIGFuIGFycmF5IG9mIGNvbnRlbnQgcGFzc2VkIHRvIHRoaXMgQ29tcG9uZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudChhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3LnJlbmRlcigpOyB9O1xuICAgIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG47XG4vKipcbiAqIHJlYWQgYSB2YWx1ZSBmb3JtIGFuIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIHJlZ3VsYXIgcHJvcGVydHkgYWNjZXNzIHRoYXQgd2lsbCB0aHJvdyBleGNlcHRpb25zXG4gKiBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgcGFydCBhcmUgbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gbG9vayB1cCBvbiB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtvYmplY3R9IG8gLSBUaGUgb2JqZWN0XG4gKiBAcGFyYW0ge0F9IFtkZWZhdWx0VmFsdWVdIC0gVGhpcyB2YWx1ZSBpcyByZXR1cm5lZCBpZiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChwYXRoLCBvLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gcHJvcGVydHkuZ2V0KHBhdGguc3BsaXQoJzonKS5qb2luKCcuJyksIG8pO1xuICAgIHJldHVybiAocmV0ICE9IG51bGwpID8gcmV0IDogZGVmYXVsdFZhbHVlO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkb3B0ID0gZnVuY3Rpb24gKGNoaWxkLCBlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgY2hpbGQpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgY2hpbGQpKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGNoaWxkICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjaGlsZCk7XG4gICAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5ib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb250ZW50W19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZnJhZy5hcHBlbmRDaGlsZChjKTsgfSk7XG4gICAgcmV0dXJuIGZyYWc7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRvbWlmeSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5ib3guYXBwbHkobnVsbCwgYS5tYXAoZXhwb3J0cy5kb21pZnkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGVvZiBhID09PSAnc3RyaW5nJykgfHxcbiAgICAgICAgKHR5cGVvZiBhID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgKHR5cGVvZiBhID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnRleHQoYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHVzZSAnXCIgKyBhICsgXCInKHR5cGVvZiBcIiArIHR5cGVvZiBhICsgXCIpIGFzIENvbnRlbnQhXCIpO1xuICAgIH1cbn07XG4vKipcbiAqIHRleHQgY3JlYXRlcyBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIHZhbHVlKTtcbn07XG4vKipcbiAqIG5vZGUgaXMgY2FsbGVkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgRE9NIG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCB2aWV3KSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYWRvcHQoYywgZSk7IH0pO1xuICAgIHZhciBpZCA9IGF0dHJpYnV0ZXNbJ3dtbCddLmlkO1xuICAgIHZhciBncm91cCA9IGF0dHJpYnV0ZXMud21sLmdyb3VwO1xuICAgIGlmIChpZClcbiAgICAgICAgdmlldy5yZWdpc3RlckJ5SWQoaWQsIGUpO1xuICAgIGlmIChncm91cClcbiAgICAgICAgdmlldy5yZWdpc3RlckJ5R3JvdXAoZ3JvdXAsIGUpO1xuICAgIHJldHVybiBlO1xufTtcbi8qKlxuICogd2lkZ2V0IGNyZWF0ZXMgYW5kIHJlbmRlcnMgYSBuZXcgd21sIHdpZGdldCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbnN0cnV0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZ3xudW1iZXJ8V2lkZ2V0Pn0gY2hpbGRyZW5cbiAqIEBwYXJhbSB7Vmlld30gdmlld1xuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1dpZGdldH1cbiAqL1xuZXhwb3J0cy53aWRnZXQgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCB2aWV3KSB7XG4gICAgdmFyIGNoaWxkcyA9IFtdO1xuICAgIHZhciB3O1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAoY2hpbGQgaW5zdGFuY2VvZiBBcnJheSkgP1xuICAgICAgICBjaGlsZHMucHVzaC5hcHBseShjaGlsZHMsIGNoaWxkKSA6IGNoaWxkcy5wdXNoKGNoaWxkKTsgfSk7XG4gICAgdyA9IG5ldyBDb25zdHJ1Y3RvcihhdHRyaWJ1dGVzLCBjaGlsZHMpO1xuICAgIHZhciBpZCA9IGF0dHJpYnV0ZXMud21sLmlkO1xuICAgIHZhciBncm91cCA9IGF0dHJpYnV0ZXMud21sLmdyb3VwO1xuICAgIGlmIChpZClcbiAgICAgICAgdmlldy5yZWdpc3RlckJ5SWQoaWQsIHcpO1xuICAgIGlmIChncm91cClcbiAgICAgICAgdmlldy5yZWdpc3RlckJ5R3JvdXAoZ3JvdXAsIHcpO1xuICAgIHZpZXcucmVnaXN0ZXJXaWRnZXQodyk7XG4gICAgcmV0dXJuIHcucmVuZGVyKCk7XG59O1xuLyoqXG4gKiBpZnRoZW4gcHJvdmlkZXMgYW4gaWYgdGhlbiBleHByZXNzaW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmlmdGhlbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHBvc2l0aXZlLCBuZWdhdGl2ZSkge1xuICAgIHJldHVybiAocHJlZGljYXRlKSA/IHBvc2l0aXZlKCkgOiBuZWdhdGl2ZSgpO1xufTtcbi8qKlxuICogZm9yRSBwcm92aWRlcyBhIGZvciBleHByZXNzaW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjYiwgY2IyKSB7XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrLCBhKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGNiKHYsIGssIGEpKTsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2IyKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGwgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKGwubGVuZ3RoID4gMClcbiAgICAgICAgICAgIGwuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gZnJhZy5hcHBlbmRDaGlsZChjYihjb2xsZWN0aW9uW2tdLCBrLCBjb2xsZWN0aW9uKSk7IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNiMigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG59O1xuLyoqXG4gKiBBcHBWaWV3IGlzIHRoZSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIFZpZXcuXG4gKlxuICogQHByb3BlcnR5IHs8Qz59IGNvbnRleHQgLSBUaGUgY29udGV4dCB0aGUgdmlldyBpcyByZW5kZXJlZCBpbi5cbiAqL1xudmFyIEFwcFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwVmlldyhjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgIH1cbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlcldpZGdldCA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlZ2lzdGVyQnlJZCA9IGZ1bmN0aW9uIChpZCwgdykge1xuICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgdGhpcy5pZHNbaWRdID0gdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlckJ5R3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXAsIGUpIHtcbiAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdID0gdGhpcy5ncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0ucHVzaChlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gTWF5YmVfMS5NYXliZVxuICAgICAgICAgICAgLmZyb21BbnkodGhpcy5pZHNbaWRdKVxuICAgICAgICAgICAgLm9yRWxzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgaWQgJ1wiICsgaWQgKyBcIicgaXMgbWlzc2luZyFcIik7XG4gICAgICAgICAgICByZXR1cm4gTWF5YmVfMS5NYXliZS5ub3RoaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZmluZEdyb3VwQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUuZnJvbUFycmF5KHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpcy5ncm91cHNbbmFtZV0gOiBbXSk7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRzO1xuICAgICAgICB2YXIgcmVhbEZpcnN0Q2hpbGRJbmRleCA9IC0xO1xuICAgICAgICB2YXIgdHJlZSA9ICh0aGlzLl9mcmFnUm9vdCkgPyB0aGlzLl9mcmFnUm9vdCA6IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRyZWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGUoKTogQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdpbnZhbGlkYXRlKCk6IEF0dGVtcHQgdG8gaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gaW5zZXJ0ZWQgdG8gRE9NIScpO1xuICAgICAgICBjaGlsZHMgPSB0cmVlLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiB0cmVlIG9jY2FzaW9uYWxseSBlbmRzIHVwIHdpdGggYSBudWxsIHBhcmVudE5vZGVcbiAgICAgICAgLy8gd2hlbiB3ZSBhdHRlbXB0IHRvIGNhbGwgcmVwbGFjZUNoaWxkLiBOb3RpY2VhYmx5IGFmdGVyIGRvaW5nIHdvcmsgb24gYW4gYXJyYXkuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgdG8gdXNlIHRoZSBpbmRleCBpbnN0ZWFkIG9mIHBhc3NpbmcgdGhlIHJlZmVyZW5jZSBkaXJlY3RseS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hpbGRzW2ldID09PSB0cmVlKVxuICAgICAgICAgICAgICAgIHJlYWxGaXJzdENoaWxkSW5kZXggPSBpO1xuICAgICAgICAvLyBqdXN0IGluIGNhc2Ugd2UgbmV2ZXIgZ290IHRoZSBpbmRleC5cbiAgICAgICAgaWYgKHJlYWxGaXJzdENoaWxkSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGRpYXRlKCk6IENhbm5vdCBpbnZhbGlkYXRlIHZpZXcsIERPTSB0cmVlIGFwcGVhcnMgdG8gaGF2ZSBubyBwYXJlbnQhJyk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgcGFyZW50LmNoaWxkcmVuW3JlYWxGaXJzdENoaWxkSW5kZXhdKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuX2ZyYWdSb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/IHRoaXMuaWRzWydyb290J10gOiB0aGlzLnRyZWU7XG4gICAgICAgIGlmICh0aGlzLnRyZWUubm9kZU5hbWUgPT09IChkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpLm5vZGVOYW1lKVxuICAgICAgICAgICAgdGhpcy5fZnJhZ1Jvb3QgPSB0aGlzLnRyZWUuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gQXBwVmlldztcbn0oKSk7XG5leHBvcnRzLkFwcFZpZXcgPSBBcHBWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmYxID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGY7IH07XG5leHBvcnRzLmYyID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZihhLCBiKTsgfTsgfTsgfTtcbmV4cG9ydHMuZjMgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmKGEsIGIsIGMpOyB9OyB9OyB9O1xufTtcbmV4cG9ydHMuZjQgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZihhLCBiLCBjLCBkKTsgfTsgfTsgfTsgfTtcbn07XG5leHBvcnRzLmY1ID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHJldHVybiBmKGEsIGIsIGMsIGQsIGUpOyB9OyB9OyB9OyB9OyB9O1xufTtcbmV4cG9ydHMuZjYgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChfZikgeyByZXR1cm4gZihhLCBiLCBjLCBkLCBlLCBfZik7IH07IH07IH07IH07IH07IH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLnV0aWwgPSB1dGlsO1xudmFyIGN1cnJ5ID0gcmVxdWlyZShcIi4vY3VycnlcIik7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG52YXIgSWRlbnRpdHlfMSA9IHJlcXVpcmUoXCIuL21vbmFkL0lkZW50aXR5XCIpO1xuZXhwb3J0cy5JZGVudGl0eSA9IElkZW50aXR5XzEuSWRlbnRpdHk7XG52YXIgTWF5YmVfMSA9IHJlcXVpcmUoXCIuL21vbmFkL01heWJlXCIpO1xuZXhwb3J0cy5NYXliZSA9IE1heWJlXzEuTWF5YmU7XG52YXIgRWl0aGVyXzEgPSByZXF1aXJlKFwiLi9tb25hZC9FaXRoZXJcIik7XG5leHBvcnRzLkVpdGhlciA9IEVpdGhlcl8xLkVpdGhlcjtcbnZhciBTdGF0ZV8xID0gcmVxdWlyZShcIi4vbW9uYWQvU3RhdGVcIik7XG5leHBvcnRzLlN0YXRlID0gU3RhdGVfMS5TdGF0ZTtcbnZhciBGcmVlXzEgPSByZXF1aXJlKFwiLi9tb25hZC9GcmVlXCIpO1xuZXhwb3J0cy5GcmVlID0gRnJlZV8xLkZyZWU7XG52YXIgSU9fMSA9IHJlcXVpcmUoXCIuL21vbmFkL0lPXCIpO1xuZXhwb3J0cy5JTyA9IElPXzEuSU87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBsZWZ0IHdyYXBzIGEgdmFsdWUgb24gdGhlIGxlZnQgc2lkZS5cbiAqL1xuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBMZWZ0KGEpOyB9O1xuLyoqXG4gKiByaWdodCB3cmFwcyBhIHZhbHVlIG9uIHRoZSByaWdodCBzaWRlLlxuICovXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIG5ldyBSaWdodChiKTsgfTtcbi8qKlxuICogZnJvbUJvb2xlYW4gY29uc3RydWN0cyBhbiBFaXRoZXIgdXNpbmcgYSBib29sZWFuIHZhbHVlLlxuICovXG5leHBvcnRzLmZyb21Cb29sZWFuID0gZnVuY3Rpb24gKGIpIHtcbiAgICByZXR1cm4gYiA/IGV4cG9ydHMucmlnaHQodHJ1ZSkgOiBleHBvcnRzLmxlZnQoZmFsc2UpO1xufTtcbi8qKlxuICogRWl0aGVyIG1vbmFkIGltcGxlbWVudGF0aW9uXG4gKi9cbnZhciBFaXRoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVpdGhlcigpIHtcbiAgICB9XG4gICAgRWl0aGVyLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQodik7XG4gICAgfTtcbiAgICBFaXRoZXIubGVmdCA9IGV4cG9ydHMubGVmdDtcbiAgICBFaXRoZXIucmlnaHQgPSBleHBvcnRzLnJpZ2h0O1xuICAgIEVpdGhlci5mcm9tQm9vbGVhbiA9IGV4cG9ydHMuZnJvbUJvb2xlYW47XG4gICAgcmV0dXJuIEVpdGhlcjtcbn0oKSk7XG5leHBvcnRzLkVpdGhlciA9IEVpdGhlcjtcbnZhciBMZWZ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVmdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWZ0KGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubCA9IGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGVmdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KHRoaXMubCk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5tYXBMZWZ0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KGYodGhpcy5sKSk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5iaW1hcCA9IGZ1bmN0aW9uIChmLCBfKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmxlZnQoZih0aGlzLmwpKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KHRoaXMubCk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih0aGlzLmwpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUub3JSaWdodCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQoZih0aGlzLmwpKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KHRoaXMubCk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS50YWtlTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubDtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLnRha2VSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCByaWdodCFcIik7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKGYsIF8pIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5sKTtcbiAgICB9O1xuICAgIHJldHVybiBMZWZ0O1xufShFaXRoZXIpKTtcbmV4cG9ydHMuTGVmdCA9IExlZnQ7XG52YXIgUmlnaHQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaWdodCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaWdodChyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnIgPSByO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJpZ2h0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2h0KGYodGhpcy5yKSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUubWFwTGVmdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQodGhpcy5yKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5iaW1hcCA9IGZ1bmN0aW9uIChfLCBnKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJpZ2h0KGcodGhpcy5yKSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih0aGlzLnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogb3JFbHNlIHJldHVybnMgdGhlIHJlc3VsdCBvZiBmIGlmIHRoZSBFaXRoZXIgaXMgbGVmdC5cbiAgICAgKi9cbiAgICBSaWdodC5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUub3JSaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYXBcbiAgICAgKi9cbiAgICBSaWdodC5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZS5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoX3RoaXMucik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAqIHRha2VMZWZ0IGV4dHJhY3RzIHRoZSBsZWZ0IHZhbHVlIG9mIGFuIEVpdGhlciwgdGhyb3dpbmcgYW4gZXJyb3IgaWYgdGhlIEVpdGhlciBpcyByaWdodC5cbiAgICAgICovXG4gICAgUmlnaHQucHJvdG90eXBlLnRha2VMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGxlZnQhXCIpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLnRha2VSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNhdGFcbiAgICAgKi9cbiAgICBSaWdodC5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChfLCBnKSB7XG4gICAgICAgIHJldHVybiBnKHRoaXMucik7XG4gICAgfTtcbiAgICByZXR1cm4gUmlnaHQ7XG59KEVpdGhlcikpO1xuZXhwb3J0cy5SaWdodCA9IFJpZ2h0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWl0aGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRWl0aGVyXzEgPSByZXF1aXJlKFwiLi9FaXRoZXJcIik7XG4vKipcbiAqIGZyZWUgd3JhcHMgYSB2YWx1ZSBpbiBhIGZyZWVcbiAqL1xuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBSZXR1cm4oYSk7IH07XG4vKipcbiAqIHN1c3BlbmQgbGlmdHMgYSBmdW5jdGlvbiBpbnRvIGEgRnJlZSBtb25hZCB0byBtaW1pYyB0YWlsIGNhbGwgcmVjdXJzaW9uLlxuICovXG5leHBvcnRzLnN1c3BlbmQgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gbmV3IFN1c3BlbmQodXRpbF8xLmNvbXBvc2UoZXhwb3J0cy5mcmVlLCBmKSk7IH07XG4vKipcbiAqIGxpZnRGIGxpZnRzIGEgRnVuY3RvciBpbnRvIGEgRnJlZS5cbiAqL1xuZXhwb3J0cy5saWZ0RiA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBuZXcgU3VzcGVuZChmLm1hcChleHBvcnRzLmZyZWUpKTsgfTtcbi8qKlxuICogRnJlZSBpcyBhIEZyZWUgbW9uYWQgdGhhdCBhbHNvIGltcGxlbWVudHMgYSBGcmVlIEFwcGxpY2F0aXZlIChhbG1vc3QpLlxuICpcbiAqIEluc3BpcmVkIGJ5IGh0dHBzOi8vY3dteWVycy5naXRodWIuaW8vbW9uZXQuanMvI2ZyZWVcbiAqL1xudmFyIEZyZWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyZWUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9mXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IFJldHVybihhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1hcFxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYWluKGZ1bmN0aW9uIChhKSB7IHJldHVybiBleHBvcnRzLmZyZWUoZihhKSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW5cbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VzcGVuZCkge1xuICAgICAgICAgICAgdmFyIGZfMSA9IHRoaXMuZjtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGZfMSA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgICAgIG5ldyBTdXNwZW5kKGZ1bmN0aW9uICh4KSB7IHJldHVybiBmXzEoeCkuY2hhaW4oZyk7IH0pIDpcbiAgICAgICAgICAgICAgICBuZXcgU3VzcGVuZChmXzEubWFwKGZ1bmN0aW9uIChmcmVlKSB7IHJldHVybiBmcmVlLmNoYWluKGcpOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJldHVybikge1xuICAgICAgICAgICAgZyh0aGlzLmEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZXN1bWUgdGhlIG5leHQgc3RhZ2Ugb2YgdGhlIGNvbXB1dGF0aW9uXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBFaXRoZXJfMS5sZWZ0KHRoaXMuZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJldHVybikge1xuICAgICAgICAgICAgcmV0dXJuIEVpdGhlcl8xLnJpZ2h0KHRoaXMuYSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhvaXN0XG4gICAgaG9pc3Q8Qj4oZnVuYzogKGZiOiBGdW5jdG9yPEI+KSA9PiBGdW5jdG9yPEI+KTogRnJlZTxGLCBBPiB7XG5cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdXNwZW5kKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3VzcGVuZCgoZnVuYyh0aGlzLmYpKVxuICAgICAgICAgICAgICAgIC5tYXAoKGZyOiBGcmVlPEYsIEI+KSA9PiBmci5ob2lzdDxhbnk+KGZ1bmMpKSlcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogY2F0YVxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoZiwgZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bWUoKS5jYXRhKGYsIGcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ28gcnVucyB0aGUgY29tcHV0YXRpb24gdG8gY29tcGxldGlvbiB1c2luZyBmIHRvIGV4dHJhY3QgZWFjaCBzdGFnZS5cbiAgICAgKiBAc3VtbW1hcnkgZ28gOjogRnJlZTxGPCo+LCBBPiDihpIgIChGPEZyZWU8RixBPj4g4oaSICBGcmVlPEYsQT4pIOKGkiAgQVxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdXNwZW5kKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB3aGlsZSAociBpbnN0YW5jZW9mIEVpdGhlcl8xLkxlZnQpXG4gICAgICAgICAgICAgICAgciA9IChmKHIudGFrZUxlZnQoKSkpLnJlc3VtZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHIudGFrZVJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJldHVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogcnVuIHRoZSBGcmVlIGNoYWluIHRvIGNvbXBsZXRpb25cbiAgICAgKiBAc3VtbWFyeSBydW4gOjogRnJlZTxB4oaSIEEsQT4g4oaSICBBXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbyhmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICB9O1xuICAgIEZyZWUuZnJlZSA9IGV4cG9ydHMuZnJlZTtcbiAgICBGcmVlLnN1c3BlbmQgPSBleHBvcnRzLnN1c3BlbmQ7XG4gICAgRnJlZS5saWZ0RiA9IGV4cG9ydHMubGlmdEY7XG4gICAgcmV0dXJuIEZyZWU7XG59KCkpO1xuZXhwb3J0cy5GcmVlID0gRnJlZTtcbnZhciBTdXNwZW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VzcGVuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdXNwZW5kKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZiA9IGY7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN1c3BlbmQ7XG59KEZyZWUpKTtcbmV4cG9ydHMuU3VzcGVuZCA9IFN1c3BlbmQ7XG52YXIgUmV0dXJuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0dXJuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHVybihhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmEgPSBhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXR1cm47XG59KEZyZWUpKTtcbmV4cG9ydHMuUmV0dXJuID0gUmV0dXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogd3JhcElPIGEgdmFsdWUgaW4gdGhlIElPIG1vbmFkXG4gKi9cbmV4cG9ydHMud3JhcElPID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBJTyhmdW5jdGlvbiAoKSB7IHJldHVybiBhOyB9KTsgfTtcbi8qKlxuICogc2FmZUlPIGFjY2VwdHMgYSBmdW5jdGlvbiB0aGF0IGhhcyBzaWRlIGVmZmVjdHMgYW5kIHdyYXBJT3MgaXQgaW4gYW4gSU8gTW9uYWQuXG4gKi9cbmV4cG9ydHMuc2FmZUlPID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5ldyBJTyhmKTsgfTtcbmV4cG9ydHMucHVyZSA9IGV4cG9ydHMud3JhcElPO1xuZXhwb3J0cy5zdXNwZW5kID0gZXhwb3J0cy5zYWZlSU87XG4vKipcbiAqIElPIG1vbmFkaWMgdHlwZSBmb3IgY29udGFpbmluZyBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgJ3JlYWwgd29ybGQnLlxuICovXG52YXIgSU8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElPKGVmZmVjdCkge1xuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gICAgSU8ucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJTyhmdW5jdGlvbiAoKSB7IHJldHVybiB2OyB9KTtcbiAgICB9O1xuICAgIElPLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoX3RoaXMuZWZmZWN0KCkpOyB9KTtcbiAgICB9O1xuICAgIElPLnByb3RvdHlwZS5tYXBJbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBiOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluXG4gICAgICovXG4gICAgSU8ucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBJTyhmdW5jdGlvbiAoKSB7IHJldHVybiBmKF90aGlzLmVmZmVjdCgpKS5ydW4oKTsgfSk7XG4gICAgfTtcbiAgICBJTy5wcm90b3R5cGUuY2hhaW5JbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYWluKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMud3JhcElPKGIpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJ1blxuICAgICAqL1xuICAgIElPLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVmZmVjdCgpO1xuICAgIH07XG4gICAgSU8uc2FmZUlPID0gZXhwb3J0cy5zYWZlSU87XG4gICAgSU8ucHVyZSA9IGV4cG9ydHMucHVyZTtcbiAgICBJTy5zdXNwZW5kID0gZXhwb3J0cy5zdXNwZW5kO1xuICAgIElPLmNoYWluID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmNoYWluKGYpOyB9OyB9O1xuICAgIHJldHVybiBJTztcbn0oKSk7XG5leHBvcnRzLklPID0gSU87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JTy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSWRlbnRpdHlcbiAqL1xudmFyIElkZW50aXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZGVudGl0eShhKSB7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9mXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eShhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1hcFxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5KGYodGhpcy5nZXQoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW5cbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih0aGlzLmdldCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGkubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKF90aGlzLmdldCgpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHZhbHVlIG9mIGFuIElkZW50aXR5XG4gICAgICogQHN1bW1hcnkgZ2V0IDo6IElkZW50aXR5PEE+IOKGkiAgQVxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmE7XG4gICAgfTtcbiAgICByZXR1cm4gSWRlbnRpdHk7XG59KCkpO1xuZXhwb3J0cy5JZGVudGl0eSA9IElkZW50aXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWRlbnRpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFaXRoZXJfMSA9IHJlcXVpcmUoXCIuL0VpdGhlclwiKTtcbi8qKlxuICoganVzdCB3cmFwcyBhIHZhbHVlIGluIGEgSnVzdFxuICovXG5leHBvcnRzLmp1c3QgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IEp1c3QoYSk7IH07XG47XG4vKipcbiAqIG5vdGhpbmcgY29uc3RydWN0cyBub3RoaW5nXG4gKi9cbmV4cG9ydHMubm90aGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBOb3RoaW5nKCk7IH07XG4vKipcbiAqIGZyb21BbnkgY29uc3RydWN0cyBhIE1heWJlIGZyb20gYSB2YWx1ZSB0aGF0IG1heSBiZSBudWxsLlxuICovXG5leHBvcnRzLmZyb21BbnkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA9PSBudWxsID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3QoYSk7IH07XG4vKipcbiAqIGZyb21BcnJheSBjaGVja3MgYW4gYXJyYXkgdG8gc2VlIGlmIGl0J3MgZW1wdHkgKG9yIGZ1bGwgb2YgbnVsbHMpXG4gKiBhbmQgcmV0dXJucyBhIE1heWJlLlxuICovXG5leHBvcnRzLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICgoYS5sZW5ndGggPT09IDApIHx8IChhLnJlZHVjZShmdW5jdGlvbiAoYywgdikgeyByZXR1cm4gKHYgPT0gbnVsbCkgPyBjICsgMSA6IGM7IH0sIDApID09PSBhLmxlbmd0aCkpID9cbiAgICAgICAgZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3QoYSk7XG59O1xuLyoqXG4gKiBmcm9tT0JqZWN0IHVzZXMgT2JqZWN0LmtleXMgdG8gdHVybiBzZWUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgb3duIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydHMuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gMCA/IGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KG8pO1xufTtcbi8qKlxuICogZnJvbVN0cmluZyBjb25zdHJ1Y3RzIG5vdGhpbmcgaWYgdGhlIHN0cmluZyBpcyBlbXB0eSBvciBqdXN0IG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0cy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gKHMgPT09ICcnKSA/IGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KHMpO1xufTtcbi8qKlxuICogZnJvbUJvb2xlYW4gY29uc3RydWN0cyBub3RoaW5nIGlmIGIgaXMgZmFsc2UsIGp1c3Qgb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiAoYiA9PT0gZmFsc2UpID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3QoYik7XG59O1xuLyoqXG4gKiBmcm9tTnVtYmVyIGNvbnN0cnVjdHMgbm90aGluZyBpZiBuIGlzIDAganVzdCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuID09PSAwKSA/IGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KG4pO1xufTtcbi8qKlxuICogTWF5YmVcbiAqL1xudmFyIE1heWJlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXliZSgpIHtcbiAgICB9XG4gICAgTWF5YmUucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGEpO1xuICAgIH07XG4gICAgTWF5YmUuanVzdCA9IGV4cG9ydHMuanVzdDtcbiAgICBNYXliZS5ub3RoaW5nID0gZXhwb3J0cy5ub3RoaW5nO1xuICAgIE1heWJlLmZyb21BbnkgPSBleHBvcnRzLmZyb21Bbnk7XG4gICAgTWF5YmUuZnJvbU9iamVjdCA9IGV4cG9ydHMuZnJvbU9iamVjdDtcbiAgICBNYXliZS5mcm9tQXJyYXkgPSBleHBvcnRzLmZyb21BcnJheTtcbiAgICBNYXliZS5mcm9tU3RyaW5nID0gZXhwb3J0cy5mcm9tU3RyaW5nO1xuICAgIE1heWJlLmZyb21Cb29sZWFuID0gZXhwb3J0cy5mcm9tQm9vbGVhbjtcbiAgICBNYXliZS5mcm9tTnVtYmVyID0gZXhwb3J0cy5mcm9tTnVtYmVyO1xuICAgIHJldHVybiBNYXliZTtcbn0oKSk7XG5leHBvcnRzLk1heWJlID0gTWF5YmU7XG4vKipcbiAqIE5vdGhpbmdcbiAqL1xudmFyIE5vdGhpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RoaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdGhpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm90aGluZy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgTm90aGluZy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZ2V0IGFueXRoaW5nIGZyb20gTm90aGluZyEnKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvckp1c3Qgd2lsbCB0dXJuIE5vdGhpbmcgaW50byBKdXN0LCB3cmFwcGluZyB0aGUgdmFsdWUgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLm9ySnVzdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmp1c3QoZigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNhdGEgYXBwbGllcyB0aGUgY29ycmVzcG9uZGluZyBmdW5jdGlvbiB0byB0aGUgTWF5YmVcbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKGYsIF9nKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS50b0VpdGhlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEVpdGhlcl8xLmxlZnQodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RoaW5nO1xufShNYXliZSkpO1xuZXhwb3J0cy5Ob3RoaW5nID0gTm90aGluZztcbi8qKlxuICogSnVzdFxuICovXG52YXIgSnVzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEp1c3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSnVzdChhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmEgPSBhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEp1c3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChmKHRoaXMuYSkpO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5hKTtcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChfZikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLm9ySnVzdCA9IGZ1bmN0aW9uIChfZikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoX2YsIGcpIHtcbiAgICAgICAgcmV0dXJuIGcodGhpcy5hKTtcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLnRvRWl0aGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRWl0aGVyXzEucmlnaHQodGhpcy5hKTtcbiAgICB9O1xuICAgIHJldHVybiBKdXN0O1xufShNYXliZSkpO1xuZXhwb3J0cy5KdXN0ID0gSnVzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heWJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBnZXQgdGhlIHN0YXRlIGZyb20gdGhlIGludGVybmFscyBvZiB0aGUgbW9uYWRcbiAqL1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChbcywgc10pOyB9KTsgfTtcbi8qKlxuICogcHV0XG4gKi9cbmV4cG9ydHMucHV0ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiAoW251bGwsIHNdKTsgfSk7IH07XG4vKipcbiAqIG1vZGlmeSB0aGUgc3RhdGVcbiAqIEBzdW1tYXJ5ICAoUyDihpIgIFMpIOKGkiAgU3RhdGU8UyDihpIgIHtBLCBTfSA+XG4gKi9cbmV4cG9ydHMubW9kaWZ5ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGV4cG9ydHMuZ2V0KCkuY2hhaW4oZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGV4cG9ydHMucHV0KGYocykpOyB9KTsgfTtcbi8qKlxuICogZ2V0cyBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gdGhlIHN0YXRlIHB1dHRpbmcgdXNpbmcgdGhlIHJlc3VsdFxuICogYXMgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24uXG4gKiBAc3VtbWFyeSAoUyDihpIgIEEpIOKGkiAgU3RhdGU8UyDihpIgIHtBLCBTfT5cbiAqL1xuZXhwb3J0cy5nZXRzID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGV4cG9ydHMuZ2V0KCkuY2hhaW4oZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGV4cG9ydHMuc3RhdGUoZihzKSk7IH0pOyB9O1xuLyoqXG4gKiBzdGF0ZSBjcmVhdGUgYSBuZXcgU3RhdGUgbW9uYWRcbiAqL1xuZXhwb3J0cy5zdGF0ZSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChbYSwgc10pOyB9KTsgfTtcbi8qKlxuICogU3RhdGUgaXMgYSBtb25hZGljIGNsYXNzIHRoYXQgd2UgdXNlIHRvIGhvbGQgaW5mb3JtYXRpb24gdGhhdCBjaGFuZ2VzXG4gKiBkdXJpbmcgY29tcHV0YXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbmZsdWVuY2VkIGJ5OlxuICogQGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9uYWRfKGZ1bmN0aW9uYWxfcHJvZ3JhbW1pbmcpI1N0YXRlX21vbmFkc1xuICogQHByb3BlcnR5IHtzIOKGkiAgKGEsIHMpfSBhXG4gKi9cbnZhciBTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGUoZikge1xuICAgICAgICB0aGlzLmYgPSBmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvZiB3cmFwcyBhIHZhbHVlIGluIHRoZSBTdGF0ZSBtb25hZC5cbiAgICAgKiBAc3VtbWFyeSBBIOKGkiAgU3RhdGU8U+KGkiB7QSxTfT5cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoW2EsIHNdKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtYXBcbiAgICAgKiBAc3VtbWFyeSBTdGF0ZTxTIOKGkiB7QSxTfT4g4oaSICAoQSDihpIgIEIpIOKGkiAgU3RhdGU8UyDihpIgIHtDLCBTfT5cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnJ1bih4cyksIGEgPSBfYVswXSwgcyA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuIFtmKGEpLCBzXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBqb2luIHJlcGxhY2VzIHRoZSBvdXRlciBTdGF0ZSB3aXRoIGFuIGlubmVyIFN0YXRlXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5ydW4oeHMpLCBhID0gX2FbMF0sIHMgPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiBhLnJ1bihzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmKS5qb2luKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBldmFsdWF0ZSB0aGUgU3RhdGUgcmV0dXJuaW5nIHRoZSBmaW5hbCB2YWx1ZVxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bihzKVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4ZWN1dGUgdGhlIFN0YXRlIHJldHVybmluZyB0aGUgZmluYWwgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW4ocylbMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIFN0YXRlIHlpZWxkaW5nIHRoZSBmaW5hbCB2YWx1ZSBhbmQgc3RhdGUuXG4gICAgICogQHN1bW1hcnkgU3RhdGU8U+KGkiB7QTxTfT4g4oaSICBTIOKGkiAge0EsU31cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZihzKTtcbiAgICB9O1xuICAgIFN0YXRlLmdldCA9IGV4cG9ydHMuZ2V0O1xuICAgIFN0YXRlLnB1dCA9IGV4cG9ydHMucHV0O1xuICAgIFN0YXRlLm1vZGlmeSA9IGV4cG9ydHMubW9kaWZ5O1xuICAgIFN0YXRlLmdldHMgPSBleHBvcnRzLmdldHM7XG4gICAgU3RhdGUuc3RhdGUgPSBleHBvcnRzLnN0YXRlO1xuICAgIHJldHVybiBTdGF0ZTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbjtcbi8qKlxuICogaWRlbnRpdHkgaXMgdGhlIGZhbWVkIGlkZW50aXR5IGZ1bmN0aW9uLlxuICovXG5leHBvcnRzLmlkZW50aXR5ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4vKipcbiAqIG1lcmdlIHR3byBvYmplY3RzIGVhc2lseVxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KG8pKTtcbn07XG4vKipcbiAqIGZ1c2UgaXMgdGhlIGRlZXAgdmVyc2lvbiBvZiBtZXJnZVxuICovXG5leHBvcnRzLmZ1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAobywgYykge1xuICAgICAgICBpZiAoYyA9PT0gdm9pZCAwKSB7IGMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZWR1Y2UoYywgZnVuY3Rpb24gKGNvLCBjYywgaykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2MpID9cbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjb1trXSkgP1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKGNvLCAoX2EgPSB7fSwgX2Fba10gPSAoY29ba10pLm1hcChleHBvcnRzLmNvcHkpLmNvbmNhdChjYy5tYXAoZXhwb3J0cy5jb3B5KSksIF9hKSkgOlxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKGNvLCAoX2IgPSB7fSwgX2Jba10gPSBjYy5tYXAoZXhwb3J0cy5jb3B5KSwgX2IpKSkgOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjYyAhPT0gJ29iamVjdCcgP1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKGNvLCAoX2MgPSB7fSwgX2Nba10gPSBjYywgX2MpKSA6XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfZCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2Rba10gPSAodHlwZW9mIGNvW2tdICE9PSAnb2JqZWN0JykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY29ba10sIGNjKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5mdXNlKGNvW2tdLCBjYyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfZCkpO1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB9LCBvKTtcbiAgICB9LCB7fSk7XG59O1xuZXhwb3J0cy5jb3B5ID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobykpID9cbiAgICAgICAgby5tYXAoZXhwb3J0cy5jb3B5KSA6XG4gICAgICAgICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgIGV4cG9ydHMucmVkdWNlKG8sIGZ1bmN0aW9uIChwLCBjLCBrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMubWVyZ2UocCwgKF9hID0ge30sIF9hW2tdID0gZXhwb3J0cy5jb3B5KGMpLCBfYSkpO1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIH0sIHt9KSA6IG87XG59O1xuLyoqXG4gKiByZWR1Y2UgYW4gb2JqZWN0J3Mga2V5cyAoaW4gbm8gZ3VhcmFudGVlZCBvcmRlcilcbiAqL1xuZXhwb3J0cy5yZWR1Y2UgPSBmdW5jdGlvbiAobywgZiwgYWNjdW0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChwLCBrKSB7IHJldHVybiBmKHAsIG9ba10sIGssIG8pOyB9LCBhY2N1bSk7XG59O1xuLyoqXG4gKiBtYXAgb3ZlciBhbiBvYmplY3QgKGluIG5vIGd1YXJhbnRlZWQgb3JlZGVyKVxuICovXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChvLCBmKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLm1hcCgoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGYob1trXSwgaywgbyk7IH0pKTtcbn07XG4vKipcbiAqIGNvbXBvc2UgdHdvIGZ1bmN0aW9ucyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0cy5jb21wb3NlID0gZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiBmKGcoeCkpOyB9OyB9O1xuLyoqXG4gKiBmbGluZyByZW1vdmVzIGEga2V5IGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc3VtbWFyeSB7KHN0cmluZyxPYmplY3QpIOKGkiAgT2JqZWN0fVxuICovXG5leHBvcnRzLmZsaW5nID0gZnVuY3Rpb24gKHMsIG8pIHtcbiAgICBpZiAoKG8gPT0gbnVsbCkgfHwgKG8uY29uc3RydWN0b3IgIT09IE9iamVjdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZsaW5nKCk6IG9ubHkgd29ya3Mgd2l0aCBvYmplY3QgbGl0ZXJhbHMhJyk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZShmdW5jdGlvbiAobzIsIGspIHtcbiAgICAgICAgcmV0dXJuIGsgPT09IHMgPyBvMiA6IGV4cG9ydHMubWVyZ2UobzIsIChfYSA9IHt9LFxuICAgICAgICAgICAgX2Fba10gPSBvW2tdLFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH0sIHt9KTtcbn07XG4vKipcbiAqIGhlYWQgcmV0dXJucyB0aGUgaXRlbSBhdCBpbmRleCAwIG9mIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHN1bW1hcnkgeyBBcnJheSDihpIgICogfVxuICovXG5leHBvcnRzLmhlYWQgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdFswXTsgfTtcbi8qKlxuICogdGFpbCByZXR1cm5zIHRoZSBsYXN0IGl0ZW0gaW4gYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc3VtbWFyeSB7QXJyYXkg4oaSICAqfVxuICovXG5leHBvcnRzLnRhaWwgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdOyB9O1xuLyoqXG4gKiBjb25zdGFudCBnaXZlbiBhIHZhbHVlLCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoaXMgdmFsdWUuXG4gKiBAc3VtbWFyeSBjb25zdGFudCBYIOKGkiAgKiDihpIgIFhcbiAqXG4gKi9cbmV4cG9ydHMuY29uc3RhbnQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfTsgfTtcbi8qKlxuICogZjEgcGFydGlhbCBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0cy5mMSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSkpOyB9O1xufTtcbi8qKlxuICogZjIgcGFydGlhbCBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmYyID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhKSB7IHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhKSk7IH07IH07XG59O1xuLyoqXG4gKiBmMyBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjMgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWEpIHsgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSwgYWEsIGFhYSkpOyB9OyB9OyB9O1xufTtcbi8qKlxuICogZjQgcGFydGlhbCBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmY0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhYSkge1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhLCBhYSwgYWFhLCBhYWFhKSk7XG4gICAgfTsgfTsgfTsgfTtcbn07XG4vKipcbiAqIGY1IHBhcnRpYWwgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5mNSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWFhYSkge1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhLCBhYSwgYWFhLCBhYWFhLCBhYWFhYSkpO1xuICAgIH07IH07IH07IH07IH07XG59O1xuLyoqXG4gKiBleGNlcHQgY29waWVzIGFuIG9iamVjdCByZW1vdmluZyBhIHNpbmdsZSBrZXkuXG4gKi9cbmV4cG9ydHMuZXhjZXB0ID0gZnVuY3Rpb24gKGtleXMsIG8pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yZWR1Y2UobywgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgcmV0dXJuIGtleXMuaW5kZXhPZihrKSA+IC0xID8gcCA6IGV4cG9ydHMubWVyZ2UocCwgKF9hID0ge30sIF9hW2tdID0gYywgX2EpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH0sIHt9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiovXG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIC8vIHRoZSBkZWZhdWx0IGlzIGpzXG4gICAgdmFyIGJlYXV0aWZ5ID0gZnVuY3Rpb24oc3JjLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5KHNyYywgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgLy8gc2hvcnQgYWxpYXNlc1xuICAgIGJlYXV0aWZ5LmpzID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuY3NzID0gY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gICAgLy8gbGVnYWN5IGFsaWFzZXNcbiAgICBiZWF1dGlmeS5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuaHRtbF9iZWF1dGlmeSA9IGh0bWxfYmVhdXRpZnkuaHRtbF9iZWF1dGlmeTtcblxuICAgIHJldHVybiBiZWF1dGlmeTtcbn1cblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtcbiAgICAgICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgICAgICBcIi4vbGliL2JlYXV0aWZ5LWNzc1wiLFxuICAgICAgICBcIi4vbGliL2JlYXV0aWZ5LWh0bWxcIlxuICAgIF0sIGZ1bmN0aW9uKGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpIHtcbiAgICAgICAgcmV0dXJuIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KTtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgKGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2xpYi9iZWF1dGlmeScpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9saWIvYmVhdXRpZnktY3NzJyk7XG4gICAgICAgIHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9saWIvYmVhdXRpZnktaHRtbCcpO1xuXG4gICAgICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpO1xuXG4gICAgfSkobW9kdWxlKTtcbn0iLCIvKmpzaGludCBjdXJseTpmYWxzZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIENTUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuICAgIFdyaXR0ZW4gYnkgSGFydXR5dW4gQW1pcmphbnlhbiwgKGFtaXJqYW55YW5AZ21haWwuY29tKVxuXG4gICAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgICAgICBodHRwOi8vanNiZWF1dGlmaWVyLm9yZy9cblxuICAgIFVzYWdlOlxuICAgICAgICBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQpO1xuICAgICAgICBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gICAgVGhlIG9wdGlvbnMgYXJlIChkZWZhdWx0IGluIGJyYWNrZXRzKTpcbiAgICAgICAgaW5kZW50X3NpemUgKDQpICAgICAgICAgICAgICAgICAgICAgICAgIOKAlCBpbmRlbnRhdGlvbiBzaXplLFxuICAgICAgICBpbmRlbnRfY2hhciAoc3BhY2UpICAgICAgICAgICAgICAgICAgICAg4oCUIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICAgICAgc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgKHRydWUpICAgICAgIC0gc2VwYXJhdGUgc2VsZWN0b3JzIHdpdGggbmV3bGluZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgKGUuZy4gXCJhLFxcbmJyXCIgb3IgXCJhLCBiclwiKVxuICAgICAgICBlbmRfd2l0aF9uZXdsaW5lIChmYWxzZSkgICAgICAgICAgICAgICAgLSBlbmQgd2l0aCBhIG5ld2xpbmVcbiAgICAgICAgbmV3bGluZV9iZXR3ZWVuX3J1bGVzICh0cnVlKSAgICAgICAgICAgIC0gYWRkIGEgbmV3IGxpbmUgYWZ0ZXIgZXZlcnkgY3NzIHJ1bGVcbiAgICAgICAgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvciAoZmFsc2UpIC0gZW5zdXJlIHNwYWNlIGFyb3VuZCBzZWxlY3RvciBzZXBhcmF0b3JzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicsICcrJywgJ34nIChlLmcuIFwiYT5iXCIgLT4gXCJhID4gYlwiKVxuICAgIGUuZ1xuXG4gICAgY3NzX2JlYXV0aWZ5KGNzc19zb3VyY2VfdGV4dCwge1xuICAgICAgJ2luZGVudF9zaXplJzogMSxcbiAgICAgICdpbmRlbnRfY2hhcic6ICdcXHQnLFxuICAgICAgJ3NlbGVjdG9yX3NlcGFyYXRvcic6ICcgJyxcbiAgICAgICdlbmRfd2l0aF9uZXdsaW5lJzogZmFsc2UsXG4gICAgICAnbmV3bGluZV9iZXR3ZWVuX3J1bGVzJzogdHJ1ZSxcbiAgICAgICdzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yJzogdHJ1ZVxuICAgIH0pO1xuKi9cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3Rva2VuaXphdGlvblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvXG5cbihmdW5jdGlvbigpIHtcbnZhciBsZWdhY3lfYmVhdXRpZnlfY3NzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG52YXIgbWVyZ2VPcHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5tZXJnZU9wdHM7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIE91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMykuT3V0cHV0O1xuXG5cbnZhciBsaW5lQnJlYWsgPSBhY29ybi5saW5lQnJlYWs7XG52YXIgYWxsTGluZUJyZWFrcyA9IGFjb3JuLmFsbExpbmVCcmVha3M7XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0cyhvcHRpb25zLCAnY3NzJyk7XG5cbiAgICBzb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0IHx8ICcnO1xuXG4gICAgdmFyIG5ld2xpbmVzRnJvbUxhc3RXU0VhdCA9IDA7XG4gICAgdmFyIGluZGVudFNpemUgPSBvcHRpb25zLmluZGVudF9zaXplID8gcGFyc2VJbnQob3B0aW9ucy5pbmRlbnRfc2l6ZSwgMTApIDogNDtcbiAgICB2YXIgaW5kZW50Q2hhcmFjdGVyID0gb3B0aW9ucy5pbmRlbnRfY2hhciB8fCAnICc7XG4gICAgdmFyIHByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXM7XG4gICAgdmFyIHNlbGVjdG9yU2VwYXJhdG9yTmV3bGluZSA9IChvcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmU7XG4gICAgdmFyIGVuZF93aXRoX25ld2xpbmUgPSAob3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gICAgdmFyIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9IChvcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcztcbiAgICB2YXIgc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgPSAob3B0aW9ucy5zcGFjZV9hcm91bmRfY29tYmluYXRvciA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5zcGFjZV9hcm91bmRfY29tYmluYXRvcjtcbiAgICBzcGFjZV9hcm91bmRfY29tYmluYXRvciA9IHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yIHx8ICgob3B0aW9ucy5zcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IpO1xuICAgIHZhciBlb2wgPSBvcHRpb25zLmVvbCA/IG9wdGlvbnMuZW9sIDogJ2F1dG8nO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgICAgICBpbmRlbnRDaGFyYWN0ZXIgPSAnXFx0JztcbiAgICAgICAgaW5kZW50U2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGVvbCA9ICdcXG4nO1xuICAgICAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICAgICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW9sID0gZW9sLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpO1xuXG4gICAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgICBzb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0LnJlcGxhY2UoYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gICAgLy8gdG9rZW5pemVyXG4gICAgdmFyIHdoaXRlUmUgPSAvXlxccyskLztcblxuICAgIHZhciBwb3MgPSAtMSxcbiAgICAgICAgY2g7XG4gICAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgY2ggPSBzb3VyY2VfdGV4dC5jaGFyQXQoKytwb3MpO1xuICAgICAgICByZXR1cm4gY2ggfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVlayhza2lwV2hpdGVzcGFjZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBwcmV2X3BvcyA9IHBvcztcbiAgICAgICAgaWYgKHNraXBXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gc291cmNlX3RleHQuY2hhckF0KHBvcyArIDEpIHx8ICcnO1xuICAgICAgICBwb3MgPSBwcmV2X3BvcyAtIDE7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYXRTdHJpbmcoZW5kQ2hhcnMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MgKyAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrU3RyaW5nKGVuZENoYXIpIHtcbiAgICAgICAgdmFyIHByZXZfcG9zID0gcG9zO1xuICAgICAgICB2YXIgc3RyID0gZWF0U3RyaW5nKGVuZENoYXIpO1xuICAgICAgICBwb3MgPSBwcmV2X3BvcyAtIDE7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYXRXaGl0ZXNwYWNlKHByZXNlcnZlX25ld2xpbmVzX2xvY2FsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICB3aGlsZSAod2hpdGVSZS50ZXN0KHBlZWsoKSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgcHJlc2VydmVfbmV3bGluZXNfbG9jYWwgJiYgcHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld2xpbmVzRnJvbUxhc3RXU0VhdCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAoY2ggJiYgd2hpdGVSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHdoaXRlUmUudGVzdChuZXh0KCkpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYXRDb21tZW50KCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIHZhciBzaW5nbGVMaW5lID0gcGVlaygpID09PSBcIi9cIjtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICBpZiAoIXNpbmdsZUxpbmUgJiYgY2ggPT09IFwiKlwiICYmIHBlZWsoKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZUxpbmUgJiYgY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKSArIGNoO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbG9va0JhY2soc3RyKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcocG9zIC0gc3RyLmxlbmd0aCwgcG9zKS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgc3RyO1xuICAgIH1cblxuICAgIC8vIE5lc3RlZCBwc2V1ZG8tY2xhc3MgaWYgd2UgYXJlIGluc2lkZVJ1bGVcbiAgICAvLyBhbmQgdGhlIG5leHQgc3BlY2lhbCBjaGFyYWN0ZXIgZm91bmQgb3BlbnNcbiAgICAvLyBhIG5ldyBibG9ja1xuICAgIGZ1bmN0aW9uIGZvdW5kTmVzdGVkUHNldWRvQ2xhc3MoKSB7XG4gICAgICAgIHZhciBvcGVuUGFyZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gcG9zICsgMTsgaSA8IHNvdXJjZV90ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2VfdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAvLyBwc2V1ZG9jbGFzc2VzIGNhbiBjb250YWluICgpXG4gICAgICAgICAgICAgICAgb3BlblBhcmVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlblBhcmVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlblBhcmVuIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIjtcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHByaW50ZXJcbiAgICB2YXIgYmFzZUluZGVudFN0cmluZyA9ICcnO1xuICAgIHZhciBwcmVpbmRlbnRfaW5kZXggPSAwO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBzb3VyY2VfdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKChzb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJyAnIHx8XG4gICAgICAgICAgICAgICAgc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCkgPT09ICdcXHQnKSkge1xuICAgICAgICAgICAgcHJlaW5kZW50X2luZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0LnN1YnN0cmluZygwLCBwcmVpbmRlbnRfaW5kZXgpO1xuICAgICAgICBqc19zb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0LnN1YnN0cmluZyhwcmVpbmRlbnRfaW5kZXgpO1xuICAgIH1cblxuXG4gICAgdmFyIHNpbmdsZUluZGVudCA9IG5ldyBBcnJheShpbmRlbnRTaXplICsgMSkuam9pbihpbmRlbnRDaGFyYWN0ZXIpO1xuICAgIHZhciBpbmRlbnRMZXZlbDtcbiAgICB2YXIgbmVzdGVkTGV2ZWw7XG4gICAgdmFyIG91dHB1dDtcblxuICAgIGZ1bmN0aW9uIHByaW50X3N0cmluZyhvdXRwdXRfc3RyaW5nKSB7XG4gICAgICAgIGlmIChvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zZXRfaW5kZW50KGluZGVudExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuYWRkX3Rva2VuKG91dHB1dF9zdHJpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKSB7XG4gICAgICAgIGlmIChpc0FmdGVyU3BhY2UpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgICAgICBpbmRlbnRMZXZlbCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dGRlbnQoKSB7XG4gICAgICAgIGlmIChpbmRlbnRMZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGluZGVudExldmVsLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuICAgIHRoaXMuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgb3V0cHV0ID0gbmV3IE91dHB1dChzaW5nbGVJbmRlbnQsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICAgICAgICBpbmRlbnRMZXZlbCA9IDA7XG4gICAgICAgIG5lc3RlZExldmVsID0gMDtcblxuICAgICAgICBwb3MgPSAtMTtcbiAgICAgICAgY2ggPSBudWxsO1xuICAgICAgICBwYXJlbkxldmVsID0gMDtcblxuICAgICAgICB2YXIgaW5zaWRlUnVsZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gICAgICAgIHZhciB0b3BfY2ggPSAnJztcbiAgICAgICAgdmFyIGxhc3RfdG9wX2NoID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIHZhciBpc0FmdGVyU3BhY2UgPSB3aGl0ZXNwYWNlICE9PSAnJztcbiAgICAgICAgICAgIHZhciBpc0FmdGVyTmV3bGluZSA9IHdoaXRlc3BhY2UuaW5kZXhPZignXFxuJykgIT09IC0xO1xuICAgICAgICAgICAgbGFzdF90b3BfY2ggPSB0b3BfY2g7XG4gICAgICAgICAgICB0b3BfY2ggPSBjaDtcblxuICAgICAgICAgICAgaWYgKCFjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nICYmIHBlZWsoKSA9PT0gJyonKSB7IC8qIGNzcyBjb21tZW50ICovXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGluZGVudExldmVsID09PSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQWZ0ZXJOZXdsaW5lIHx8IGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdENvbW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnLycgJiYgcGVlaygpID09PSAnLycpIHsgLy8gc2luZ2xlIGxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICghaXNBZnRlck5ld2xpbmUgJiYgbGFzdF90b3BfY2ggIT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdENvbW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGxlc3MgcHJvcGVyeSBtaXhpbnMgQHsuLi59XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoJ30nKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZSwgaWYgcHJlc2VudCwgZm9yIGhhc2ggcHJvcGVydHkgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZU9yUnVsZSA9IHBlZWtTdHJpbmcoXCI6ICw7e30oKVtdLz0nXFxcIlwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUubWF0Y2goL1sgOl0kLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVPclJ1bGUgPSBlYXRTdHJpbmcoXCI6IFwiKS5yZXBsYWNlKC9cXHMkLywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKHZhcmlhYmxlT3JSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVPclJ1bGUgPSB2YXJpYWJsZU9yUnVsZS5yZXBsYWNlKC9cXHMkLywgJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgbmVzdGluZyBhdC1ydWxlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLk5FU1RFRF9BVF9SVUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnIycgJiYgcGVlaygpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdFN0cmluZygnfScpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIGlmIChwZWVrKHRydWUpID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3bGluZXNGcm9tTGFzdFdTRWF0IDwgMiAmJiBuZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgaW5kZW50TGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBlbnRlcmluZyBjb25kaXRpb25hbCBncm91cHMsIG9ubHkgcnVsZXNldHMgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gKGluZGVudExldmVsID4gbmVzdGVkTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBkZWNsYXJhdGlvbnMgYXJlIGFsc28gYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlUnVsZSA9IChpbmRlbnRMZXZlbCA+PSBuZXN0ZWRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBvdXRkZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgaW5zaWRlUnVsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkTGV2ZWwtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXdsaW5lc0Zyb21MYXN0V1NFYXQgPCAyICYmIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiBpbmRlbnRMZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIGlmICgoaW5zaWRlUnVsZSB8fCBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApICYmXG4gICAgICAgICAgICAgICAgICAgICEobG9va0JhY2soXCImXCIpIHx8IGZvdW5kTmVzdGVkUHNldWRvQ2xhc3MoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxvb2tCYWNrKFwiKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAncHJvcGVydHk6IHZhbHVlJyBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggY291bGQgYmUgaW4gYSBjb25kaXRpb25hbCBncm91cCBxdWVyeVxuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Fzcy9sZXNzIHBhcmVudCByZWZlcmVuY2UgZG9uJ3QgdXNlIGEgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FzcyBuZXN0ZWQgcHNldWRvLWNsYXNzIGRvbid0IHVzZSBhIHNwYWNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgc3BhY2UgYmVmb3JlIHBzZXVkb2NsYXNzZXMvcHNldWRvZWxlbWVudHMsIGFzIGl0IG1lYW5zIFwiaW4gYW55IGNoaWxkXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrKFwiIFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBzZXVkby1lbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoXCI6OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBzZXVkby1jbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSAnXFwnJykge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0U3RyaW5nKGNoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnOycpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcoJykgeyAvLyBtYXkgYmUgYSB1cmxcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2soXCJ1cmxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT09ICcpJyAmJiBjaCAhPT0gJ1wiJyAmJiBjaCAhPT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0U3RyaW5nKCcpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVuTGV2ZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSAmJiBzZWxlY3RvclNlcGFyYXRvck5ld2xpbmUgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGNoID09PSAnPicgfHwgY2ggPT09ICcrJyB8fCBjaCA9PT0gJ34nKSAmJlxuICAgICAgICAgICAgICAgICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPCAxKSB7XG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgY29tYmluYXRvciBzcGFjaW5nXG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNxdWFzaCBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCAmJiB3aGl0ZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJz0nKSB7IC8vIG5vIHdoaXRlc3BhY2UgYmVmb3JlIG9yIGFmdGVyXG4gICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZygnPScpO1xuICAgICAgICAgICAgICAgIGlmICh3aGl0ZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN3ZWV0Q29kZSA9IG91dHB1dC5nZXRfY29kZShlbmRfd2l0aF9uZXdsaW5lLCBlb2wpO1xuXG4gICAgICAgIHJldHVybiBzd2VldENvZGU7XG4gICAgfTtcblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9BdC1ydWxlXG4gICAgdGhpcy5ORVNURURfQVRfUlVMRSA9IHtcbiAgICAgICAgXCJAcGFnZVwiOiB0cnVlLFxuICAgICAgICBcIkBmb250LWZhY2VcIjogdHJ1ZSxcbiAgICAgICAgXCJAa2V5ZnJhbWVzXCI6IHRydWUsXG4gICAgICAgIC8vIGFsc28gaW4gQ09ORElUSU9OQUxfR1JPVVBfUlVMRSBiZWxvd1xuICAgICAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgICAgICBcIkBzdXBwb3J0c1wiOiB0cnVlLFxuICAgICAgICBcIkBkb2N1bWVudFwiOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLkNPTkRJVElPTkFMX0dST1VQX1JVTEUgPSB7XG4gICAgICAgIFwiQG1lZGlhXCI6IHRydWUsXG4gICAgICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgICAgIFwiQGRvY3VtZW50XCI6IHRydWVcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoganNoaW50IGN1cmx5OiBmYWxzZSAqL1xuLy8gVGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBwZXJtaXQgJCAoMzYpIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzYgfHwgY29kZSA9PT0gNjQ7XG4gICAgLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgLy8gcGVybWl0IF8gKDk1KS5cbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIG1lcmdlT3B0cyhhbGxPcHRpb25zLCB0YXJnZXRUeXBlKSB7XG4gICAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICAgIHZhciBuYW1lO1xuXG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhcmdldFR5cGUpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIHRhcmdldFR5cGVcbiAgICBpZiAodGFyZ2V0VHlwZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW3RhcmdldFR5cGVdKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW3RhcmdldFR5cGVdW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IG1lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgICB2YXIgX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gICAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICAgIHZhciBfaW5kZW50X2NvdW50ID0gLTE7XG5cbiAgICB2YXIgX2l0ZW1zID0gW107XG4gICAgdmFyIF9lbXB0eSA9IHRydWU7XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICBfY2hhcmFjdGVyX2NvdW50ID0gcGFyZW50LmJhc2VJbmRlbnRMZW5ndGggKyBsZXZlbCAqIHBhcmVudC5pbmRlbnRfbGVuZ3RoO1xuICAgICAgICBfaW5kZW50X2NvdW50ID0gbGV2ZWw7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0X2NoYXJhY3Rlcl9jb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB9O1xuXG4gICAgdGhpcy5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2VtcHR5O1xuICAgIH07XG5cbiAgICB0aGlzLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVtc1tfaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBfaXRlbXMucHVzaChpbnB1dCk7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgKz0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBfZW1wdHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBudWxsO1xuICAgICAgICBpZiAoIV9lbXB0eSkge1xuICAgICAgICAgICAgaXRlbSA9IF9pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICBfZW1wdHkgPSBfaXRlbXMubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgICAgICAgICBfaW5kZW50X2NvdW50IC09IDE7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IHBhcmVudC5pbmRlbnRfbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgICAgICAgICAgX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50LmluZGVudF9jYWNoZVtfaW5kZW50X2NvdW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBfaXRlbXMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBPdXRwdXQoaW5kZW50X3N0cmluZywgYmFzZUluZGVudFN0cmluZykge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICAgIHRoaXMuaW5kZW50X2NhY2hlID0gW2Jhc2VJbmRlbnRTdHJpbmddO1xuICAgIHRoaXMuYmFzZUluZGVudExlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xuICAgIHRoaXMuaW5kZW50X2xlbmd0aCA9IGluZGVudF9zdHJpbmcubGVuZ3RoO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG5cbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB0aGlzLmJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICAgIHRoaXMuaW5kZW50X3N0cmluZyA9IGluZGVudF9zdHJpbmc7XG4gICAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xuICAgIH07XG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuXG5cbiAgICB0aGlzLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbGluZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvLyBVc2luZyBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcgdG8gYWxsb3cgZm9yIGxhdGVyIGV4cGFuc2lvbiBvZiBpbmZvIGFib3V0IGVhY2ggbGluZVxuICAgIHRoaXMuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAgICAgICBpZiAodGhpcy5nZXRfbGluZV9udW1iZXIoKSA9PT0gMSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vIG5ld2xpbmUgb24gc3RhcnQgb2YgZmlsZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlX25ld2xpbmUgfHwgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY29kZSA9IGZ1bmN0aW9uKGVuZF93aXRoX25ld2xpbmUsIGVvbCkge1xuICAgICAgICB2YXIgc3dlZXRfY29kZSA9IGxpbmVzLmpvaW4oJ1xcbicpLnJlcGxhY2UoL1tcXHJcXG5cXHQgXSskLywgJycpO1xuXG4gICAgICAgIGlmIChlbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dlZXRfY29kZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgICAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHdoaWxlIChsZXZlbCA+PSB0aGlzLmluZGVudF9jYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9jYWNoZS5wdXNoKHRoaXMuaW5kZW50X2NhY2hlW3RoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCAtIDFdICsgdGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChsZXZlbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICAgICAgICB0aGlzLmFkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIG91dHB1dF9sZW5ndGggPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVzW2luZGV4XS5yZW1vdmVfaW5kZW50KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICAgICAgICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbShpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKTtcblxuICAgICAgICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIGxpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IGxpbmVzLmxlbmd0aCA+IDEgPyBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHN0YXJ0IG9mIHRoZSBmaWxlIGFuZCBuZXdsaW5lID0gYmxhbmtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmlzX2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG52YXIgQmVhdXRpZmllciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQmVhdXRpZmllcjtcblxuZnVuY3Rpb24gY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NfYmVhdXRpZnk7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBjc3NfYmVhdXRpZnkgPSBsZWdhY3lfYmVhdXRpZnlfY3NzO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3NzX2JlYXV0aWZ5OiBjc3NfYmVhdXRpZnlcbiAgICAgICAgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmh0bWxfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG4iLCIvKmpzaGludCBjdXJseTpmYWxzZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIFN0eWxlIEhUTUxcbi0tLS0tLS0tLS0tLS0tLVxuXG4gIFdyaXR0ZW4gYnkgTm9jaHVtIFNvc3NvbmtvLCAobnNvc3NvbmtvQGhvdG1haWwuY29tKVxuXG4gIEJhc2VkIG9uIGNvZGUgaW5pdGlhbGx5IGRldmVsb3BlZCBieTogRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAanNiZWF1dGlmaWVyLm9yZz5cbiAgICBodHRwOi8vanNiZWF1dGlmaWVyLm9yZy9cblxuICBVc2FnZTpcbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlKTtcblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfaW5uZXJfaHRtbCAoZGVmYXVsdCBmYWxzZSkgIOKAlCBpbmRlbnQgPGhlYWQ+IGFuZCA8Ym9keT4gc2VjdGlvbnMsXG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAg4oCUIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IDI1MCkgICAgICAgICAgICAtICBtYXhpbXVtIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHBlciBsaW5lICgwID0gZGlzYWJsZSlcbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIGlubGluZSB0YWdzKSAtIGxpc3Qgb2YgdGFncywgdGhhdCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBjb250ZW50X3VuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBwcmUgdGFnKSAtIGxpc3Qgb2YgdGFncywgd2hvc2UgY29udGVudCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBpbmRlbnRfc2NyaXB0cyAoZGVmYXVsdCBub3JtYWwpICAtIFwia2VlcFwifFwic2VwYXJhdGVcInxcIm5vcm1hbFwiXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIGJlZm9yZSBlbGVtZW50cyBzaG91bGQgYmUgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB3b3JrcyBiZWZvcmUgZWxlbWVudHMsIG5vdCBpbnNpZGUgdGFncyBvciBmb3IgdGV4dC5cbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmtcbiAgICBpbmRlbnRfaGFuZGxlYmFycyAoZGVmYXVsdCBmYWxzZSkgLSBmb3JtYXQgYW5kIGluZGVudCB7eyNmb299fSBhbmQge3svZm9vfX1cbiAgICBlbmRfd2l0aF9uZXdsaW5lIChmYWxzZSkgICAgICAgICAgLSBlbmQgd2l0aCBhIG5ld2xpbmVcbiAgICBleHRyYV9saW5lcnMgKGRlZmF1bHQgW2hlYWQsYm9keSwvaHRtbF0pIC1MaXN0IG9mIHRhZ3MgdGhhdCBzaG91bGQgaGF2ZSBhbiBleHRyYSBuZXdsaW5lIGJlZm9yZSB0aGVtLlxuXG4gICAgZS5nLlxuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwge1xuICAgICAgJ2luZGVudF9pbm5lcl9odG1sJzogZmFsc2UsXG4gICAgICAnaW5kZW50X3NpemUnOiAyLFxuICAgICAgJ2luZGVudF9jaGFyJzogJyAnLFxuICAgICAgJ3dyYXBfbGluZV9sZW5ndGgnOiA3OCxcbiAgICAgICdicmFjZV9zdHlsZSc6ICdleHBhbmQnLFxuICAgICAgJ3ByZXNlcnZlX25ld2xpbmVzJzogdHJ1ZSxcbiAgICAgICdtYXhfcHJlc2VydmVfbmV3bGluZXMnOiA1LFxuICAgICAgJ2luZGVudF9oYW5kbGViYXJzJzogZmFsc2UsXG4gICAgICAnZXh0cmFfbGluZXJzJzogWycvaHRtbCddXG4gICAgfSk7XG4qL1xuXG4oZnVuY3Rpb24oKSB7XG52YXIgbGVnYWN5X2JlYXV0aWZ5X2h0bWwgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbnZhciBtZXJnZU9wdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLm1lcmdlT3B0cztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxudmFyIGxpbmVCcmVhayA9IGFjb3JuLmxpbmVCcmVhaztcbnZhciBhbGxMaW5lQnJlYWtzID0gYWNvcm4uYWxsTGluZUJyZWFrcztcblxuLy8gZnVuY3Rpb24gdHJpbShzKSB7XG4vLyAgICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuLy8gfVxuXG5mdW5jdGlvbiBsdHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccysvZywgJycpO1xufVxuXG5mdW5jdGlvbiBydHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFxzKyQvZywgJycpO1xufVxuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KSB7XG4gICAgLy9XcmFwcGVyIGZ1bmN0aW9uIHRvIGludm9rZSBhbGwgdGhlIG5lY2Vzc2FyeSBjb25zdHJ1Y3RvcnMgYW5kIGRlYWwgd2l0aCB0aGUgb3V0cHV0LlxuICAgIGh0bWxfc291cmNlID0gaHRtbF9zb3VyY2UgfHwgJyc7XG5cbiAgICB2YXIgbXVsdGlfcGFyc2VyLFxuICAgICAgICBpbmRlbnRfaW5uZXJfaHRtbCxcbiAgICAgICAgaW5kZW50X2JvZHlfaW5uZXJfaHRtbCxcbiAgICAgICAgaW5kZW50X2hlYWRfaW5uZXJfaHRtbCxcbiAgICAgICAgaW5kZW50X3NpemUsXG4gICAgICAgIGluZGVudF9jaGFyYWN0ZXIsXG4gICAgICAgIHdyYXBfbGluZV9sZW5ndGgsXG4gICAgICAgIGJyYWNlX3N0eWxlLFxuICAgICAgICB1bmZvcm1hdHRlZCxcbiAgICAgICAgY29udGVudF91bmZvcm1hdHRlZCxcbiAgICAgICAgcHJlc2VydmVfbmV3bGluZXMsXG4gICAgICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyxcbiAgICAgICAgaW5kZW50X2hhbmRsZWJhcnMsXG4gICAgICAgIHdyYXBfYXR0cmlidXRlcyxcbiAgICAgICAgd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplLFxuICAgICAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UsXG4gICAgICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lLFxuICAgICAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCxcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSxcbiAgICAgICAgZXh0cmFfbGluZXJzLFxuICAgICAgICBlb2w7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0cyhvcHRpb25zLCAnaHRtbCcpO1xuXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8gMS4zLjRcbiAgICBpZiAoKG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCwgMTApID09PSAwKSAmJlxuICAgICAgICAob3B0aW9ucy5tYXhfY2hhciAhPT0gdW5kZWZpbmVkICYmIHBhcnNlSW50KG9wdGlvbnMubWF4X2NoYXIsIDEwKSAhPT0gMCkpIHtcbiAgICAgICAgb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoID0gb3B0aW9ucy5tYXhfY2hhcjtcbiAgICB9XG5cbiAgICBpbmRlbnRfaW5uZXJfaHRtbCA9IChvcHRpb25zLmluZGVudF9pbm5lcl9odG1sID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmluZGVudF9pbm5lcl9odG1sO1xuICAgIGluZGVudF9ib2R5X2lubmVyX2h0bWwgPSAob3B0aW9ucy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICBpbmRlbnRfaGVhZF9pbm5lcl9odG1sID0gKG9wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLmluZGVudF9oZWFkX2lubmVyX2h0bWw7XG4gICAgaW5kZW50X3NpemUgPSAob3B0aW9ucy5pbmRlbnRfc2l6ZSA9PT0gdW5kZWZpbmVkKSA/IDQgOiBwYXJzZUludChvcHRpb25zLmluZGVudF9zaXplLCAxMCk7XG4gICAgaW5kZW50X2NoYXJhY3RlciA9IChvcHRpb25zLmluZGVudF9jaGFyID09PSB1bmRlZmluZWQpID8gJyAnIDogb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgICBicmFjZV9zdHlsZSA9IChvcHRpb25zLmJyYWNlX3N0eWxlID09PSB1bmRlZmluZWQpID8gJ2NvbGxhcHNlJyA6IG9wdGlvbnMuYnJhY2Vfc3R5bGU7XG4gICAgd3JhcF9saW5lX2xlbmd0aCA9IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCwgMTApID09PSAwID8gMzI3ODYgOiBwYXJzZUludChvcHRpb25zLndyYXBfbGluZV9sZW5ndGggfHwgMjUwLCAxMCk7XG4gICAgdW5mb3JtYXR0ZWQgPSBvcHRpb25zLnVuZm9ybWF0dGVkIHx8IFtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbiAgICAgICAgJ2EnLCAnYWJicicsICdhcmVhJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NpdGUnLFxuICAgICAgICAnY29kZScsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RlbCcsICdkZm4nLCAnZW0nLCAnZW1iZWQnLCAnaScsICdpZnJhbWUnLCAnaW1nJyxcbiAgICAgICAgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ21hcCcsICdtYXJrJywgJ21hdGgnLCAnbWV0ZXInLCAnbm9zY3JpcHQnLFxuICAgICAgICAnb2JqZWN0JywgJ291dHB1dCcsICdwcm9ncmVzcycsICdxJywgJ3J1YnknLCAncycsICdzYW1wJywgLyogJ3NjcmlwdCcsICovICdzZWxlY3QnLCAnc21hbGwnLFxuICAgICAgICAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICdzdmcnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGltZScsICd1JywgJ3ZhcicsXG4gICAgICAgICd2aWRlbycsICd3YnInLCAndGV4dCcsXG4gICAgICAgIC8vIHByZXhpc3RpbmcgLSBub3Qgc3VyZSBvZiBmdWxsIGVmZmVjdCBvZiByZW1vdmluZywgbGVhdmluZyBpblxuICAgICAgICAnYWNyb255bScsICdhZGRyZXNzJywgJ2JpZycsICdkdCcsICdpbnMnLCAnc3RyaWtlJywgJ3R0JyxcbiAgICBdO1xuICAgIGNvbnRlbnRfdW5mb3JtYXR0ZWQgPSBvcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQgfHwgW1xuICAgICAgICAncHJlJyxcbiAgICBdO1xuICAgIHByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgPSBwcmVzZXJ2ZV9uZXdsaW5lcyA/XG4gICAgICAgIChpc05hTihwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywgMTApKSA/IDMyNzg2IDogcGFyc2VJbnQob3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMsIDEwKSkgOlxuICAgICAgICAwO1xuICAgIGluZGVudF9oYW5kbGViYXJzID0gKG9wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnM7XG4gICAgd3JhcF9hdHRyaWJ1dGVzID0gKG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpID8gJ2F1dG8nIDogb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXM7XG4gICAgd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplID0gKGlzTmFOKHBhcnNlSW50KG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplLCAxMCkpKSA/IGluZGVudF9zaXplIDogcGFyc2VJbnQob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsIDEwKTtcbiAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgPSB3cmFwX2F0dHJpYnV0ZXMuc3Vic3RyKDAsICdmb3JjZScubGVuZ3RoKSA9PT0gJ2ZvcmNlJztcbiAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSA9ICh3cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1leHBhbmQtbXVsdGlsaW5lJyk7XG4gICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQgPSAod3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtYWxpZ25lZCcpO1xuICAgIGVuZF93aXRoX25ld2xpbmUgPSAob3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gICAgZXh0cmFfbGluZXJzID0gKHR5cGVvZiBvcHRpb25zLmV4dHJhX2xpbmVycyA9PT0gJ29iamVjdCcpICYmIG9wdGlvbnMuZXh0cmFfbGluZXJzID9cbiAgICAgICAgb3B0aW9ucy5leHRyYV9saW5lcnMuY29uY2F0KCkgOiAodHlwZW9mIG9wdGlvbnMuZXh0cmFfbGluZXJzID09PSAnc3RyaW5nJykgP1xuICAgICAgICBvcHRpb25zLmV4dHJhX2xpbmVycy5zcGxpdCgnLCcpIDogJ2hlYWQsYm9keSwvaHRtbCcuc3BsaXQoJywnKTtcbiAgICBlb2wgPSBvcHRpb25zLmVvbCA/IG9wdGlvbnMuZW9sIDogJ2F1dG8nO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgICAgICBpbmRlbnRfY2hhcmFjdGVyID0gJ1xcdCc7XG4gICAgICAgIGluZGVudF9zaXplID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICAgICAgZW9sID0gJ1xcbic7XG4gICAgICAgIGlmIChodG1sX3NvdXJjZSAmJiBsaW5lQnJlYWsudGVzdChodG1sX3NvdXJjZSB8fCAnJykpIHtcbiAgICAgICAgICAgIGVvbCA9IGh0bWxfc291cmNlLm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlb2wgPSBlb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgIGh0bWxfc291cmNlID0gaHRtbF9zb3VyY2UucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XG5cbiAgICAgICAgdGhpcy5wb3MgPSAwOyAvL1BhcnNlciBwb3NpdGlvblxuICAgICAgICB0aGlzLnRva2VuID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnOyAvL3JlZmxlY3RzIHRoZSBjdXJyZW50IFBhcnNlciBtb2RlOiBUQUcvQ09OVEVOVFxuICAgICAgICB0aGlzLnRhZ3MgPSB7IC8vQW4gb2JqZWN0IHRvIGhvbGQgdGFncywgdGhlaXIgcG9zaXRpb24sIGFuZCB0aGVpciBwYXJlbnQtdGFncywgaW5pdGlhdGVkIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICAgIHBhcmVudDogJ3BhcmVudDEnLFxuICAgICAgICAgICAgcGFyZW50Y291bnQ6IDEsXG4gICAgICAgICAgICBwYXJlbnQxOiAnJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRhZ190eXBlID0gJyc7XG4gICAgICAgIHRoaXMudG9rZW5fdGV4dCA9IHRoaXMubGFzdF90b2tlbiA9IHRoaXMubGFzdF90ZXh0ID0gdGhpcy50b2tlbl90eXBlID0gJyc7XG4gICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICB0aGlzLmluZGVudF9jb250ZW50ID0gaW5kZW50X2lubmVyX2h0bWw7XG4gICAgICAgIHRoaXMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IGluZGVudF9ib2R5X2lubmVyX2h0bWw7XG4gICAgICAgIHRoaXMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IGluZGVudF9oZWFkX2lubmVyX2h0bWw7XG5cbiAgICAgICAgdGhpcy5VdGlscyA9IHsgLy9VaWxpdGllcyBtYWRlIGF2YWlsYWJsZSB0byB0aGUgdmFyaW91cyBmdW5jdGlvbnNcbiAgICAgICAgICAgIHdoaXRlc3BhY2U6IFwiXFxuXFxyXFx0IFwiLnNwbGl0KCcnKSxcblxuICAgICAgICAgICAgc2luZ2xlX3Rva2VuOiBvcHRpb25zLnZvaWRfZWxlbWVudHMgfHwgW1xuICAgICAgICAgICAgICAgIC8vIEhUTE0gdm9pZCBlbGVtZW50cyAtIGFrYSBzZWxmLWNsb3NpbmcgdGFncyAtIGFrYSBzaW5nbGV0b25zXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL3N5bnRheC5odG1sI3ZvaWQtZWxlbWVudHNcbiAgICAgICAgICAgICAgICAnYXJlYScsICdiYXNlJywgJ2JyJywgJ2NvbCcsICdlbWJlZCcsICdocicsICdpbWcnLCAnaW5wdXQnLCAna2V5Z2VuJyxcbiAgICAgICAgICAgICAgICAnbGluaycsICdtZW51aXRlbScsICdtZXRhJywgJ3BhcmFtJywgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IE9wdGlvbmFsIHRhZ3MgLSBhcmUgbm90IHVuZGVyc3Rvb2QuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3NcbiAgICAgICAgICAgICAgICAvLyBUaGUgcnVsZXMgZm9yIG9wdGlvbmFsIHRhZ3MgYXJlIHRvbyBjb21wbGV4IGZvciBhIHNpbXBsZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gQWxzbywgdGhlIGNvbnRlbnQgb2YgdGhlc2UgdGFncyBzaG91bGQgc3RpbGwgYmUgaW5kZW50ZWQgaW4gbWFueSBjYXNlcy5cbiAgICAgICAgICAgICAgICAvLyAnbGknIGlzIGEgZ29vZCBleG1wbGUuXG5cbiAgICAgICAgICAgICAgICAvLyBEb2N0eXBlIGFuZCB4bWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAnIWRvY3R5cGUnLCAnP3htbCcsXG4gICAgICAgICAgICAgICAgLy8gP3BocCB0YWdcbiAgICAgICAgICAgICAgICAnP3BocCcsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGFncyB0aGF0IHdlcmUgaW4gdGhpcyBsaXN0LCBrZWVwaW5nIGp1c3QgaW4gY2FzZVxuICAgICAgICAgICAgICAgICdiYXNlZm9udCcsICdpc2luZGV4J1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4dHJhX2xpbmVyczogZXh0cmFfbGluZXJzLCAvL2ZvciB0YWdzIHRoYXQgbmVlZCBhIGxpbmUgb2Ygd2hpdGVzcGFjZSBiZWZvcmUgdGhlbVxuICAgICAgICAgICAgaW5fYXJyYXk6IGZ1bmN0aW9uKHdoYXQsIGFycikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aGF0ID09PSBhcnJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gdGV4dCBpcyBjb21wb3NlZCBlbnRpcmVseSBvZiB3aGl0ZXNwYWNlLlxuICAgICAgICB0aGlzLmlzX3doaXRlc3BhY2UgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRleHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuVXRpbHMuaW5fYXJyYXkodGV4dC5jaGFyQXQobiksIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJztcblxuICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld2xpbmVzID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbnB1dF9jaGFyID09PSAnXFxuJyAmJiB0aGlzLm5ld2xpbmVzIDw9IG1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdsaW5lcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgc3BhY2UgdG8gdGhlIGdpdmVuIGNvbnRlbnQgKHN0cmluZyBhcnJheSkgb3IsIGlmIHdlIGFyZVxuICAgICAgICAvLyBhdCB0aGUgd3JhcF9saW5lX2xlbmd0aCwgYXBwZW5kIGEgbmV3bGluZS9pbmRlbnRhdGlvbi5cbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgYSBuZXdsaW5lIHdhcyBhZGRlZCwgZmFsc2UgaWYgYSBzcGFjZSB3YXMgYWRkZWRcbiAgICAgICAgdGhpcy5zcGFjZV9vcl93cmFwID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZV9jaGFyX2NvdW50ID49IHRoaXMud3JhcF9saW5lX2xlbmd0aCkgeyAvL2luc2VydCBhIGxpbmUgd2hlbiB0aGUgd3JhcF9saW5lX2xlbmd0aCBpcyByZWFjaGVkXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9jb250ZW50ID0gZnVuY3Rpb24oKSB7IC8vZnVuY3Rpb24gdG8gY2FwdHVyZSByZWd1bGFyIGNvbnRlbnQgYmV0d2VlbiB0YWdzXG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbXSxcbiAgICAgICAgICAgICAgICBoYW5kbGViYXJzU3RhcnRlZCA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcykgIT09ICc8JyB8fCBoYW5kbGViYXJzU3RhcnRlZCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudC5sZW5ndGggPyBjb250ZW50LmpvaW4oJycpIDogWycnLCAnVEtfRU9GJ107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWJhcnNTdGFydGVkIDwgMiAmJiB0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlX29yX3dyYXAoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlYmFyc1N0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGViYXJzU3RhcnRlZCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWJhcnNTdGFydGVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnfScgJiYgaGFuZGxlYmFyc1N0YXJ0ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlYmFyc1N0YXJ0ZWQtLSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWJhcnMgcGFyc2luZyBpcyBjb21wbGljYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8ge3sjZm9vfX0gYW5kIHt7L2Zvb319IGFyZSBmb3JtYXR0ZWQgdGFncy5cbiAgICAgICAgICAgICAgICAgICAgLy8ge3tzb21ldGhpbmd9fSBzaG91bGQgZ2V0IHRyZWF0ZWQgYXMgY29udGVudCwgZXhjZXB0OlxuICAgICAgICAgICAgICAgICAgICAvLyB7e2Vsc2V9fSBzcGVjaWZpY2FsbHkgYmVoYXZlcyBsaWtlIHt7I2lmfX0gYW5kIHt7L2lmfX1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlZWszID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MsIDMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlazMgPT09ICd7eyMnIHx8IHBlZWszID09PSAne3svJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRhZ3MgYW5kIG5vdCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVlazMgPT09ICd7eyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0X3RhZygpLCAnVEtfVEFHX0hBTkRMRUJBUlNfQ09NTUVOVCddO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zLCAyKSA9PT0gJ3t7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0X3RhZyh0cnVlKSA9PT0gJ3t7ZWxzZX19Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChpbnB1dF9jaGFyKTsgLy9sZXR0ZXIgYXQtYS10aW1lIChvciBzdHJpbmcpIGluc2VydGVkIHRvIGFuIGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudC5sZW5ndGggPyBjb250ZW50LmpvaW4oJycpIDogJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfY29udGVudHNfdG8gPSBmdW5jdGlvbihuYW1lKSB7IC8vZ2V0IHRoZSBmdWxsIGNvbnRlbnQgb2YgYSBzY3JpcHQgb3Igc3R5bGUgdG8gcGFzcyB0byBqc19iZWF1dGlmeVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgICAgICB2YXIgcmVnX21hdGNoID0gbmV3IFJlZ0V4cCgnPC8nICsgbmFtZSArICdcXFxccyo+JywgJ2lnbScpO1xuICAgICAgICAgICAgcmVnX21hdGNoLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdmFyIHJlZ19hcnJheSA9IHJlZ19tYXRjaC5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgICAgICAgdmFyIGVuZF9zY3JpcHQgPSByZWdfYXJyYXkgPyByZWdfYXJyYXkuaW5kZXggOiB0aGlzLmlucHV0Lmxlbmd0aDsgLy9hYnNvbHV0ZSBlbmQgb2Ygc2NyaXB0XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPCBlbmRfc2NyaXB0KSB7IC8vZ2V0IGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiB0aGUgc2NyaXB0IHRhZ3NcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5wb3MsIGVuZF9zY3JpcHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZW5kX3NjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVjb3JkX3RhZyA9IGZ1bmN0aW9uKHRhZykgeyAvL2Z1bmN0aW9uIHRvIHJlY29yZCBhIHRhZyBhbmQgaXRzIHBhcmVudCBpbiB0aGlzLnRhZ3MgT2JqZWN0XG4gICAgICAgICAgICBpZiAodGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7IC8vY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhpcyB0YWcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dID0gdGhpcy5pbmRlbnRfbGV2ZWw7IC8vYW5kIHJlY29yZCB0aGUgcHJlc2VudCBpbmRlbnQgbGV2ZWxcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vb3RoZXJ3aXNlIGluaXRpYWxpemUgdGhpcyB0YWcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV0gPSB0aGlzLmluZGVudF9sZXZlbDsgLy9hbmQgcmVjb3JkIHRoZSBwcmVzZW50IGluZGVudCBsZXZlbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSArICdwYXJlbnQnXSA9IHRoaXMudGFncy5wYXJlbnQ7IC8vc2V0IHRoZSBwYXJlbnQgKGkuZS4gaW4gdGhlIGNhc2Ugb2YgYSBkaXYgdGhpcy50YWdzLmRpdjFwYXJlbnQpXG4gICAgICAgICAgICB0aGlzLnRhZ3MucGFyZW50ID0gdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddOyAvL2FuZCBtYWtlIHRoaXMgdGhlIGN1cnJlbnQgcGFyZW50IChpLmUuIGluIHRoZSBjYXNlIG9mIGEgZGl2ICdkaXYxJylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJldHJpZXZlX3RhZyA9IGZ1bmN0aW9uKHRhZykgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10pIHsgLy9pZiB0aGUgb3BlbmVuZXIgaXMgbm90IGluIHRoZSBPYmplY3Qgd2UgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzLnBhcmVudDsgLy9jaGVjayB0byBzZWUgaWYgaXQncyBhIGNsb3NhYmxlIHRhZy5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGVtcF9wYXJlbnQpIHsgLy90aWxsIHdlIHJlYWNoICcnICh0aGUgaW5pdGlhbCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPT09IHRlbXBfcGFyZW50KSB7IC8vaWYgdGhpcyBpcyBpdCB1c2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzW3RlbXBfcGFyZW50ICsgJ3BhcmVudCddOyAvL290aGVyd2lzZSBrZWVwIG9uIGNsaW1iaW5nIHVwIHRoZSBET00gVHJlZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcF9wYXJlbnQpIHsgLy9pZiB3ZSBjYXVnaHQgc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV07IC8vc2V0IHRoZSBpbmRlbnRfbGV2ZWwgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnBhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTsgLy9hbmQgc2V0IHRoZSBjdXJyZW50IHBhcmVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSArICdwYXJlbnQnXTsgLy9kZWxldGUgdGhlIGNsb3NlZCB0YWdzIHBhcmVudCByZWZlcmVuY2UuLi5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV07IC8vLi4uYW5kIHRoZSB0YWcgaXRzZWxmXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWdzW3RhZyArICdjb3VudCddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmluZGVudF90b190YWcgPSBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgIC8vIE1hdGNoIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCB0byB0aGUgbGFzdCB1c2Ugb2YgdGhpcyB0YWcsIGJ1dCBkb24ndCByZW1vdmUgaXQuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFnc1t0YWcgKyAnY291bnQnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZW1wX3BhcmVudCA9IHRoaXMudGFncy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddID09PSB0ZW1wX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3NbdGVtcF9wYXJlbnQgKyAncGFyZW50J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X3RhZyA9IGZ1bmN0aW9uKHBlZWspIHsgLy9mdW5jdGlvbiB0byBnZXQgYSBmdWxsIHRhZyBhbmQgcGFyc2UgaXRzIHR5cGVcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJycsXG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnJyxcbiAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpcnN0X2F0dHIgPSB0cnVlLFxuICAgICAgICAgICAgICAgIGhhc193cmFwcGVkX2F0dHJzID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFnX3N0YXJ0LCB0YWdfZW5kLFxuICAgICAgICAgICAgICAgIHRhZ19zdGFydF9jaGFyLFxuICAgICAgICAgICAgICAgIG9yaWdfcG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgb3JpZ19saW5lX2NoYXJfY291bnQgPSB0aGlzLmxpbmVfY2hhcl9jb3VudCxcbiAgICAgICAgICAgICAgICBpc190YWdfY2xvc2VkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFpbDtcblxuICAgICAgICAgICAgcGVlayA9IHBlZWsgIT09IHVuZGVmaW5lZCA/IHBlZWsgOiBmYWxzZTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBvcmlnX3BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gb3JpZ19saW5lX2NoYXJfY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQubGVuZ3RoID8gY29udGVudC5qb2luKCcnKSA6IFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHsgLy9kb24ndCB3YW50IHRvIGluc2VydCB1bm5lY2Vzc2FyeSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSBcIidcIiB8fCBpbnB1dF9jaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoaW5wdXRfY2hhcik7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJz0nKSB7IC8vbm8gc3BhY2UgYmVmb3JlID1cbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFpbCA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lICYmIGhhc193cmFwcGVkX2F0dHJzICYmICFpc190YWdfY2xvc2VkICYmIChpbnB1dF9jaGFyID09PSAnPicgfHwgaW5wdXRfY2hhciA9PT0gJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbC5tYXRjaCgvXlxcLz9cXHMqPi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNfdGFnX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbihjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnPScgJiYgaW5wdXRfY2hhciAhPT0gJz4nICYmIHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbm8gc3BhY2UgYWZ0ZXIgPSBvciBiZWZvcmUgPlxuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuc3BhY2Vfb3Jfd3JhcChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudEF0dHJzID0gd3JhcHBlZCAmJiBpbnB1dF9jaGFyICE9PSAnLycgJiYgIWlzX3dyYXBfYXR0cmlidXRlc19mb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlICYmIGlucHV0X2NoYXIgIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmNlX2ZpcnN0X2F0dHJfd3JhcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lICYmIGZpcnN0X2F0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfb25seV9hdHRyaWJ1dGUgPSB0YWlsLm1hdGNoKC9eXFxTKig9XCIoW15cIl18XFxcXFwiKSpcIik/XFxzKlxcLz9cXHMqPi8pICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlX2ZpcnN0X2F0dHJfd3JhcCA9ICFpc19vbmx5X2F0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3RfYXR0ciB8fCBmb3JjZV9maXJzdF9hdHRyX3dyYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24oY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50QXR0cnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3dyYXBwZWRfYXR0cnMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2luZGVudCBhdHRyaWJ1dGVzIGFuIGF1dG8sIGZvcmNlZCwgb3IgZm9yY2VkLWFsaWduIGxpbmUtd3JhcFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWdubWVudF9zaXplID0gd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50X3NpemUgPSBjb250ZW50LmluZGV4T2YoJyAnKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ID0gMDsgY291bnQgPCBhbGlnbm1lbnRfc2l6ZTsgY291bnQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZXZlciBmdXJ0aGVyIGluZGVudCB3aXRoIHNwYWNlcyBzaW5jZSB3ZSdyZSB0cnlpbmcgdG8gYWxpZ24gY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdF9hdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2F0dHIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIHRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBpbnNpZGUgYW4gYW5nbGUtYnJhY2tldCB0YWcsIHB1dCBzcGFjZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZWJhcnMgbm90IGluc2lkZSBvZiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoKGlucHV0X2NoYXIgKyB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcykpID09PSAne3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyICs9IHRoaXMuZ2V0X3VuZm9ybWF0dGVkKCd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSAhPT0gJyAnICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9ICcgJyArIGlucHV0X2NoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJzwnICYmICF0YWdfc3RhcnRfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnQgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydF9jaGFyID0gJzwnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiAhdGFnX3N0YXJ0X2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID49IDIgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAneycgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDJdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnIycgfHwgaW5wdXRfY2hhciA9PT0gJy8nIHx8IGlucHV0X2NoYXIgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0ID0gdGhpcy5wb3MgLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIgPSAneyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChpbnB1dF9jaGFyKTsgLy9pbnNlcnRzIGNoYXJhY3RlciBhdC1hLXRpbWUgKG9yIHN0cmluZylcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50WzFdICYmIChjb250ZW50WzFdID09PSAnIScgfHwgY29udGVudFsxXSA9PT0gJz8nIHx8IGNvbnRlbnRbMV0gPT09ICclJykpIHsgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbdGhpcy5nZXRfY29tbWVudCh0YWdfc3RhcnQpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIGNvbnRlbnRbMV0gJiYgY29udGVudFsxXSA9PT0gJ3snICYmIGNvbnRlbnRbMl0gJiYgY29udGVudFsyXSA9PT0gJyEnKSB7IC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gW3RoaXMuZ2V0X2NvbW1lbnQodGFnX3N0YXJ0KV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiB0YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIGNvbnRlbnQubGVuZ3RoID4gMiAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMl0gPT09ICd9JyAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpbnB1dF9jaGFyICE9PSAnPicpO1xuXG4gICAgICAgICAgICB2YXIgdGFnX2NvbXBsZXRlID0gY29udGVudC5qb2luKCcnKTtcbiAgICAgICAgICAgIHZhciB0YWdfaW5kZXg7XG4gICAgICAgICAgICB2YXIgdGFnX29mZnNldDtcblxuICAgICAgICAgICAgLy8gbXVzdCBjaGVjayBmb3Igc3BhY2UgZmlyc3Qgb3RoZXJ3aXNlIHRoZSB0YWcgY291bGQgaGF2ZSB0aGUgZmlyc3QgYXR0cmlidXRlIGluY2x1ZGVkLCBhbmRcbiAgICAgICAgICAgIC8vIHRoZW4gbm90IHVuLWluZGVudCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuaW5kZXhPZignICcpICE9PSAtMSkgeyAvL2lmIHRoZXJlJ3Mgd2hpdGVzcGFjZSwgdGhhdHMgd2hlcmUgdGhlIHRhZyBuYW1lIGVuZHNcbiAgICAgICAgICAgICAgICB0YWdfaW5kZXggPSB0YWdfY29tcGxldGUuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY29tcGxldGUuaW5kZXhPZignXFxuJykgIT09IC0xKSB7IC8vaWYgdGhlcmUncyBhIGxpbmUgYnJlYWssIHRoYXRzIHdoZXJlIHRoZSB0YWcgbmFtZSBlbmRzXG4gICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICB0YWdfaW5kZXggPSB0YWdfY29tcGxldGUuaW5kZXhPZignfScpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgZ28gd2l0aCB0aGUgdGFnIGVuZGluZ1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCc+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFnX2NvbXBsZXRlLmNoYXJBdCgwKSA9PT0gJzwnIHx8ICFpbmRlbnRfaGFuZGxlYmFycykge1xuICAgICAgICAgICAgICAgIHRhZ19vZmZzZXQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWdfb2Zmc2V0ID0gdGFnX2NvbXBsZXRlLmNoYXJBdCgyKSA9PT0gJyMnID8gMyA6IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFnX2NoZWNrID0gdGFnX2NvbXBsZXRlLnN1YnN0cmluZyh0YWdfb2Zmc2V0LCB0YWdfaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGFnX2NvbXBsZXRlLmNoYXJBdCh0YWdfY29tcGxldGUubGVuZ3RoIC0gMikgPT09ICcvJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB0aGlzLlV0aWxzLnNpbmdsZV90b2tlbikpIHsgLy9pZiB0aGlzIHRhZyBuYW1lIGlzIGEgc2luZ2xlIHRhZyB0eXBlIChlaXRoZXIgaW4gdGhlIGxpc3Qgb3IgaGFzIGEgY2xvc2luZyAvKVxuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NJTkdMRSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiB0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAneycgJiYgdGFnX2NoZWNrID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfdG9fdGFnKCdpZicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ0hBTkRMRUJBUlNfRUxTRSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNfdW5mb3JtYXR0ZWQodGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmlzX3VuZm9ybWF0dGVkKHRhZ19jaGVjaywgY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgcmVmb3JtYXQgdGhlIFwidW5mb3JtYXR0ZWRcIiBvciBcImNvbnRlbnRfdW5mb3JtYXR0ZWRcIiB0YWdzXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRoaXMuZ2V0X3VuZm9ybWF0dGVkKCc8LycgKyB0YWdfY2hlY2sgKyAnPicsIHRhZ19jb21wbGV0ZSk7IC8vLi4uZGVsZWdhdGUgdG8gZ2V0X3VuZm9ybWF0dGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRhZ19lbmQgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTSU5HTEUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY2hlY2sgPT09ICdzY3JpcHQnICYmXG4gICAgICAgICAgICAgICAgKHRhZ19jb21wbGV0ZS5zZWFyY2goJ3R5cGUnKSA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRhZ19jb21wbGV0ZS5zZWFyY2goJ3R5cGUnKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfY29tcGxldGUuc2VhcmNoKC9cXGIodGV4dHxhcHBsaWNhdGlvbnxkb2pvKVxcLyh4LSk/KGphdmFzY3JpcHR8ZWNtYXNjcmlwdHxqc2NyaXB0fGxpdmVzY3JpcHR8KGxkXFwrKT9qc29ufG1ldGhvZHxhc3BlY3QpLykgPiAtMSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkX3RhZyh0YWdfY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NDUklQVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY2hlY2sgPT09ICdzdHlsZScgJiZcbiAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID4gLTEgJiYgdGFnX2NvbXBsZXRlLnNlYXJjaCgndGV4dC9jc3MnKSA+IC0xKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU1RZTEUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NoZWNrLmNoYXJBdCgwKSA9PT0gJyEnKSB7IC8vcGVlayBmb3IgPCEgY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIGZvciBjb21tZW50cyBjb250ZW50IGlzIGFscmVhZHkgY29ycmVjdC5cbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTSU5HTEUnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ19jaGVjay5jaGFyQXQoMCkgPT09ICcvJykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXZlX3RhZyh0YWdfY2hlY2suc3Vic3RyaW5nKDEpKTsgLy9yZW1vdmUgaXQgYW5kIGFsbCBhbmNlc3RvcnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdFTkQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vb3RoZXJ3aXNlIGl0J3MgYSBzdGFydC10YWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7IC8vcHVzaCBpdCBvbiB0aGUgdGFnIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdfY2hlY2sudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9jb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NUQVJUJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBwcmVzZXJ2aW5nIG9mIG5ld2xpbmVzIGFmdGVyIGEgc3RhcnQgb3IgZW5kIHRhZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlX29yX3dyYXAoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB0aGlzLlV0aWxzLmV4dHJhX2xpbmVycykpIHsgLy9jaGVjayBpZiB0aGlzIGRvdWJsZSBuZWVkcyBhbiBleHRyYSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICYmIHRoaXMub3V0cHV0W3RoaXMub3V0cHV0Lmxlbmd0aCAtIDJdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKHRydWUsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBlZWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG9yaWdfcG9zO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gb3JpZ19saW5lX2NoYXJfY291bnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LmpvaW4oJycpOyAvL3JldHVybnMgZnVsbHkgZm9ybWF0dGVkIHRhZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X2NvbW1lbnQgPSBmdW5jdGlvbihzdGFydF9wb3MpIHsgLy9mdW5jdGlvbiB0byByZXR1cm4gY29tbWVudCBjb250ZW50IGluIGl0cyBlbnRpcmV0eVxuICAgICAgICAgICAgLy8gdGhpcyBpcyB3aWxsIGhhdmUgdmVyeSBwb29yIHBlcmYsIGJ1dCB3aWxsIHdvcmsgZm9yIG5vdy5cbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gJycsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJz4nLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydF9wb3M7XG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gaW5wdXRfY2hhcjtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgbmVlZCB0byBjaGVjayBmb3IgdGhlIGRlbGltaXRlciBpZiB0aGUgbGFzdCBjaGFycyBtYXRjaFxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmNoYXJBdChjb21tZW50Lmxlbmd0aCAtIDEpID09PSBkZWxpbWl0ZXIuY2hhckF0KGRlbGltaXRlci5sZW5ndGggLSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21tZW50LmluZGV4T2YoZGVsaW1pdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIHNlYXJjaCBmb3IgY3VzdG9tIGRlbGltaXRlciBmb3IgdGhlIGZpcnN0IGZldyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkICYmIGNvbW1lbnQubGVuZ3RoIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuaW5kZXhPZignPCFbaWYnKSA9PT0gMCkgeyAvL3BlZWsgZm9yIDwhW2lmIGNvbmRpdGlvbmFsIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICc8IVtlbmRpZl0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPCFbY2RhdGFbJykgPT09IDApIHsgLy9pZiBpdCdzIGEgPFtjZGF0YVsgY29tbWVudC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ11dPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhWycpID09PSAwKSB7IC8vIHNvbWUgb3RoZXIgIVsgY29tbWVudD8gLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8IS0tJykgPT09IDApIHsgLy8gPCEtLSBjb21tZW50IC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJy0tPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJ3t7IS0tJykgPT09IDApIHsgLy8ge3shLS0gaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnLS19fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJ3t7IScpID09PSAwKSB7IC8vIHt7ISBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA9PT0gNSAmJiBjb21tZW50LmluZGV4T2YoJ3t7IS0tJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ319JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzw/JykgPT09IDApIHsgLy8ge3shIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJz8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPCUnKSA9PT0gMCkgeyAvLyB7eyEgaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnJT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHRva2VuTWF0Y2hlcihkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9ICcnO1xuXG4gICAgICAgICAgICB2YXIgYWRkID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1Rva2VuID0gdG9rZW4gKyBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IG5ld1Rva2VuLmxlbmd0aCA8PSBkZWxpbWl0ZXIubGVuZ3RoID8gbmV3VG9rZW4gOiBuZXdUb2tlbi5zdWJzdHIobmV3VG9rZW4ubGVuZ3RoIC0gZGVsaW1pdGVyLmxlbmd0aCwgZGVsaW1pdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZG9lc05vdE1hdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmluZGV4T2YoZGVsaW1pdGVyKSA9PT0gLTE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZDogYWRkLFxuICAgICAgICAgICAgICAgIGRvZXNOb3RNYXRjaDogZG9lc05vdE1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRfdW5mb3JtYXR0ZWQgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIG9yaWdfdGFnKSB7IC8vZnVuY3Rpb24gdG8gcmV0dXJuIHVuZm9ybWF0dGVkIGNvbnRlbnQgaW4gaXRzIGVudGlyZXR5XG4gICAgICAgICAgICBpZiAob3JpZ190YWcgJiYgb3JpZ190YWcudG9Mb3dlckNhc2UoKS5pbmRleE9mKGRlbGltaXRlcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJztcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgZGVsaW1pdGVyTWF0Y2hlciA9IHRva2VuTWF0Y2hlcihkZWxpbWl0ZXIpO1xuXG4gICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICdcXG4nIHx8IGlucHV0X2NoYXIgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogIERvbid0IGNoYW5nZSB0YWIgaW5kZW50aW9uIGZvciB1bmZvcm1hdHRlZCBibG9ja3MuICBJZiB1c2luZyBjb2RlIGZvciBodG1sIGVkaXRpbmcsIHRoaXMgd2lsbCBncmVhdGx5IGFmZmVjdCA8cHJlPiB0YWdzIGlmIHRoZXkgYXJlIHNwZWNpZmllZCBpbiB0aGUgJ3VuZm9ybWF0dGVkIGFycmF5J1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuaW5kZW50X2xldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udGVudCArPSB0aGlzLmluZGVudF9zdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFjZSA9IGZhbHNlOyAvLy4uLmFuZCBtYWtlIHN1cmUgb3RoZXIgaW5kZW50YXRpb24gaXMgZXJhc2VkXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBpbnB1dF9jaGFyO1xuICAgICAgICAgICAgICAgIGRlbGltaXRlck1hdGNoZXIuYWRkKGlucHV0X2NoYXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIGlucHV0X2NoYXIgPT09ICd7JyAmJiBjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50LmNoYXJBdChjb250ZW50Lmxlbmd0aCAtIDIpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlYmFycyBleHByZXNzaW9ucyBpbiBzdHJpbmdzIHNob3VsZCBhbHNvIGJlIHVuZm9ybWF0dGVkLlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9IHRoaXMuZ2V0X3VuZm9ybWF0dGVkKCd9fScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25zaWRlciB3aGVuIHN0b3BwaW5nIGZvciBkZWxpbWl0ZXJzLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGRlbGltaXRlck1hdGNoZXIuZG9lc05vdE1hdGNoKCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF90b2tlbiA9IGZ1bmN0aW9uKCkgeyAvL2luaXRpYWwgaGFuZGxlciBmb3IgdG9rZW4tcmV0cmlldmFsXG4gICAgICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfdG9rZW4gPT09ICdUS19UQUdfU0NSSVBUJyB8fCB0aGlzLmxhc3RfdG9rZW4gPT09ICdUS19UQUdfU1RZTEUnKSB7IC8vY2hlY2sgaWYgd2UgbmVlZCB0byBmb3JtYXQgamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sYXN0X3Rva2VuLnN1YnN0cig3KTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X2NvbnRlbnRzX3RvKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlbiwgJ1RLXycgKyB0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfbW9kZSA9PT0gJ0NPTlRFTlQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF9jb250ZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sICdUS19DT05URU5UJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50X21vZGUgPT09ICdUQUcnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90YWcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19uYW1lX3R5cGUgPSAnVEtfVEFHXycgKyB0aGlzLnRhZ190eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuLCB0YWdfbmFtZV90eXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfZnVsbF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmluZGVudF9sZXZlbCArIGxldmVsIHx8IDA7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKHRoaXMuaW5kZW50X3N0cmluZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pc191bmZvcm1hdHRlZCA9IGZ1bmN0aW9uKHRhZ19jaGVjaywgdW5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIC8vaXMgdGhpcyBhbiBIVE1MNSBibG9jay1sZXZlbCBsaW5rP1xuICAgICAgICAgICAgaWYgKCF0aGlzLlV0aWxzLmluX2FycmF5KHRhZ19jaGVjaywgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFnX2NoZWNrLnRvTG93ZXJDYXNlKCkgIT09ICdhJyB8fCAhdGhpcy5VdGlscy5pbl9hcnJheSgnYScsIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2F0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbiAgdGFnOyBpcyBpdHMgZmlyc3QgY2hpbGQgc29tZXRoaW5nIHdlIHdhbnQgdG8gcmVtYWluXG4gICAgICAgICAgICAvL3VuZm9ybWF0dGVkP1xuICAgICAgICAgICAgdmFyIG5leHRfdGFnID0gdGhpcy5nZXRfdGFnKHRydWUgLyogcGVlay4gKi8gKTtcblxuICAgICAgICAgICAgLy8gdGVzdCBuZXh0X3RhZyB0byBzZWUgaWYgaXQgaXMganVzdCBodG1sIHRhZyAobm8gZXh0ZXJuYWwgY29udGVudClcbiAgICAgICAgICAgIHZhciB0YWcgPSAobmV4dF90YWcgfHwgXCJcIikubWF0Y2goL15cXHMqPFxccypcXC8/KFthLXpdKilcXHMqW14+XSo+XFxzKiQvKTtcblxuICAgICAgICAgICAgLy8gaWYgbmV4dF90YWcgY29tZXMgYmFjayBidXQgaXMgbm90IGFuIGlzb2xhdGVkIHRhZywgdGhlblxuICAgICAgICAgICAgLy8gbGV0J3MgdHJlYXQgdGhlICdhJyB0YWcgYXMgaGF2aW5nIGNvbnRlbnRcbiAgICAgICAgICAgIC8vIGFuZCByZXNwZWN0IHRoZSB1bmZvcm1hdHRlZCBvcHRpb25cbiAgICAgICAgICAgIGlmICghdGFnIHx8IHRoaXMuVXRpbHMuaW5fYXJyYXkodGFnWzFdLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucHJpbnRlciA9IGZ1bmN0aW9uKGpzX3NvdXJjZSwgaW5kZW50X2NoYXJhY3RlciwgaW5kZW50X3NpemUsIHdyYXBfbGluZV9sZW5ndGgsIGJyYWNlX3N0eWxlKSB7IC8vaGFuZGxlcyBpbnB1dC9vdXRwdXQgYW5kIHNvbWUgb3RoZXIgcHJpbnRpbmcgZnVuY3Rpb25zXG5cbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBqc19zb3VyY2UgfHwgJyc7IC8vZ2V0cyB0aGUgaW5wdXQgZm9yIHRoZSBQYXJzZXJcblxuICAgICAgICAgICAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmlucHV0LnJlcGxhY2UoL1xcclxcbnxbXFxyXFx1MjAyOFxcdTIwMjldL2csICdcXG4nKTtcblxuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X2NoYXJhY3RlciA9IGluZGVudF9jaGFyYWN0ZXI7XG4gICAgICAgICAgICB0aGlzLmluZGVudF9zdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X3NpemUgPSBpbmRlbnRfc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHdyYXBfbGluZV9sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IDA7IC8vY291bnQgdG8gc2VlIGlmIHdyYXBfbGluZV9sZW5ndGggd2FzIGV4Y2VlZGVkXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmRlbnRfc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfc3RyaW5nICs9IHRoaXMuaW5kZW50X2NoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lID0gZnVuY3Rpb24oZm9yY2UsIGFycikge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWFyciB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JjZSB8fCAoYXJyW2Fyci5sZW5ndGggLSAxXSAhPT0gJ1xcbicpKSB7IC8vd2UgbWlnaHQgd2FudCB0aGUgZXh0cmEgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGFyclthcnIubGVuZ3RoIC0gMV0gIT09ICdcXG4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGggLSAxXSA9IHJ0cmltKGFyclthcnIubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGVudF9sZXZlbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuaW5kZW50X3N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ICs9IHRoaXMuaW5kZW50X3N0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wcmludF90b2tlbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBwcmludGluZyBpbml0aWFsIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNfd2hpdGVzcGFjZSh0ZXh0KSAmJiAhdGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQgfHwgdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAmJiB0aGlzLm91dHB1dFt0aGlzLm91dHB1dC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24odGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGx0cmltKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfdG9rZW5fcmF3KHRleHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wcmludF90b2tlbl9yYXcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHByaW50IG5ld2xpbmVzLCB0cnVuY2F0ZSB0cmFpbGluZ1xuICAgICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UsIGFzIHRoZSBuZXdsaW5lcyB3aWxsIHJlcHJlc2VudCB0aGUgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV3bGluZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBydHJpbSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dCAmJiB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmIHRleHQuY2hhckF0KHRleHQubGVuZ3RoIC0gMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmZvcm1hdHRlZCB0YWdzIGNhbiBncmFiIG5ld2xpbmVzIGFzIHRoZWlyIGxhc3QgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRleHQuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhpcy5uZXdsaW5lczsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShuID4gMCwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5ld2xpbmVzID0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwrKztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMudW5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLypfX19fX19fX19fX19fX19fX19fX18tLS0tLS0tLS0tLS0tLS0tLS0tLV9fX19fX19fX19fX19fX19fX19fXyovXG5cbiAgICB0aGlzLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG11bHRpX3BhcnNlciA9IG5ldyBQYXJzZXIoKTsgLy93cmFwcGluZyBmdW5jdGlvbnMgUGFyc2VyXG4gICAgICAgIG11bHRpX3BhcnNlci5wcmludGVyKGh0bWxfc291cmNlLCBpbmRlbnRfY2hhcmFjdGVyLCBpbmRlbnRfc2l6ZSwgd3JhcF9saW5lX2xlbmd0aCwgYnJhY2Vfc3R5bGUpOyAvL2luaXRpYWxpemUgc3RhcnRpbmcgdmFsdWVzXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG11bHRpX3BhcnNlci5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIG11bHRpX3BhcnNlci50b2tlbl90ZXh0ID0gdFswXTtcbiAgICAgICAgICAgIG11bHRpX3BhcnNlci50b2tlbl90eXBlID0gdFsxXTtcblxuICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90eXBlID09PSAnVEtfRU9GJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKG11bHRpX3BhcnNlci50b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NUQVJUJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG11bHRpX3BhcnNlci5pbmRlbnRfYm9keV9pbm5lcl9odG1sIHx8ICFtdWx0aV9wYXJzZXIudG9rZW5fdGV4dC5tYXRjaCgvPGJvZHkoPzouKik+LykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11bHRpX3BhcnNlci5pbmRlbnRfaGVhZF9pbm5lcl9odG1sIHx8ICFtdWx0aV9wYXJzZXIudG9rZW5fdGV4dC5tYXRjaCgvPGhlYWQoPzouKik+LykpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19TVFlMRSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NDUklQVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX0VORCc6XG4gICAgICAgICAgICAgICAgICAgIC8vUHJpbnQgbmV3IGxpbmUgb25seSBpZiB0aGUgdGFnIGhhcyBubyBjb250ZW50IGFuZCBoYXMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5sYXN0X3Rva2VuID09PSAnVEtfQ09OVEVOVCcgJiYgbXVsdGlfcGFyc2VyLmxhc3RfdGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdfbmFtZSA9IChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dC5tYXRjaCgvXFx3Ky8pIHx8IFtdKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0ID0gbXVsdGlfcGFyc2VyLm91dHB1dFttdWx0aV9wYXJzZXIub3V0cHV0Lmxlbmd0aCAtIDFdLm1hdGNoKC8oPzo8fHt7IylcXHMqKFxcdyspLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dFsxXSAhPT0gdGFnX25hbWUgJiYgIW11bHRpX3BhcnNlci5VdGlscy5pbl9hcnJheSh0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXRbMV0sIHVuZm9ybWF0dGVkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NJTkdMRSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgYmVmb3JlIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlbWFpbiB1bmZvcm1hdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19jaGVjayA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC9eXFxzKjwoW2Etei1dKykvaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFnX2NoZWNrIHx8ICFtdWx0aV9wYXJzZXIuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrWzFdLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfSEFORExFQkFSU19FTFNFJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBpZiBvcGVuaW5nIHt7I2lmfX0gdGFnIGlzIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gbXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLm91dHB1dFtsYXN0Q2hlY2tlZE91dHB1dF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0W2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaCgve3sjaWYvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZElmT25DdXJyZW50TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kSWZPbkN1cnJlbnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5pbmRlbnRfY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX0hBTkRMRUJBUlNfQ09NTUVOVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnVEFHJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfQ09OVEVOVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnVEFHJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfU1RZTEUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1NDUklQVCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbXVsdGlfcGFyc2VyLnRva2VuX3RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19TQ1JJUFQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIgPSB0eXBlb2YganNfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicgJiYganNfYmVhdXRpZnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG11bHRpX3BhcnNlci50b2tlbl90eXBlID09PSAnVEtfU1RZTEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIgPSB0eXBlb2YgY3NzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nICYmIGNzc19iZWF1dGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAtbXVsdGlfcGFyc2VyLmluZGVudF9sZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudGF0aW9uID0gbXVsdGlfcGFyc2VyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYmVhdXRpZmllcikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgQmVhdXRpZmllciBpZiBhdmFsaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ2hpbGRfb3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVvbCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hpbGRfb3B0aW9ucy5wcm90b3R5cGUgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZF9vcHRpb25zID0gbmV3IENoaWxkX29wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX2JlYXV0aWZpZXIodGV4dC5yZXBsYWNlKC9eXFxzKi8sIGluZGVudGF0aW9uKSwgY2hpbGRfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbXBseSBpbmRlbnQgdGhlIHN0cmluZyBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hpdGUgPSB0ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbGV2ZWwgPSB3aGl0ZS5tYXRjaCgvW15cXG5cXHJdKiQvKVswXS5zcGxpdChtdWx0aV9wYXJzZXIuaW5kZW50X3N0cmluZykubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVpbmRlbnQgPSBtdWx0aV9wYXJzZXIuZ2V0X2Z1bGxfaW5kZW50KHNjcmlwdF9pbmRlbnRfbGV2ZWwgLSBfbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cXHMqLywgaW5kZW50YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCAnXFxuJyArIHJlaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbl9yYXcodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUodHJ1ZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdUQUcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IGJlIGdldHRpbmcgaGVyZSBidXQgd2UgZG9uJ3Qgd2FudCB0byBkcm9wIGlucHV0IG9uIHRoZSBmbG9vclxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IG91dHB1dCB0aGUgdGV4dCBhbmQgbW92ZSBvblxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3RleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmxhc3RfdG9rZW4gPSBtdWx0aV9wYXJzZXIudG9rZW5fdHlwZTtcbiAgICAgICAgICAgIG11bHRpX3BhcnNlci5sYXN0X3RleHQgPSBtdWx0aV9wYXJzZXIudG9rZW5fdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3dlZXRfY29kZSA9IG11bHRpX3BhcnNlci5vdXRwdXQuam9pbignJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCAnJyk7XG5cbiAgICAgICAgLy8gZXN0YWJsaXNoIGVuZF93aXRoX25ld2xpbmVcbiAgICAgICAgaWYgKGVuZF93aXRoX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgICAgICAgICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBqc2hpbnQgY3VybHk6IGZhbHNlICovXG4vLyBUaGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIHBlcm1pdCAkICgzNikgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNiB8fCBjb2RlID09PSA2NDtcbiAgICAvLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBwZXJtaXQgXyAoOTUpLlxuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAvLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIHRhcmdldFR5cGUpIHtcbiAgICB2YXIgZmluYWxPcHRzID0ge307XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgdGFyZ2V0VHlwZVxuICAgIGlmICh0YXJnZXRUeXBlIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV0pIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5CZWF1dGlmaWVyO1xuXG5mdW5jdGlvbiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KSB7XG4gICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZV9odG1sO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG52YXIgc3R5bGVfaHRtbCA9IGxlZ2FjeV9iZWF1dGlmeV9odG1sO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcIi4vYmVhdXRpZnlcIiwgXCIuL2JlYXV0aWZ5LWNzc1wiXSwgZnVuY3Rpb24ocmVxdWlyZWFtZCkge1xuICAgICAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlYW1kKFwiLi9iZWF1dGlmeVwiKTtcbiAgICAgICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5LWNzc1wiKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHRtbF9iZWF1dGlmeTogZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9iZWF1dGlmeS5qcycpO1xuICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LWNzcy5qcycpO1xuXG4gICAgZXhwb3J0cy5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIHdpbmRvdy5qc19iZWF1dGlmeSwgd2luZG93LmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgZ2xvYmFsLmpzX2JlYXV0aWZ5LCBnbG9iYWwuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufVxuXG59KCkpO1xuIiwiLypqc2hpbnQgY3VybHk6ZmFsc2UsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qIHNlZSBqcy9zcmMvamF2YXNjcmlwdC9pbmRleC5qcyAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiBKUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuXG4gIFdyaXR0ZW4gYnkgRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAanNiZWF1dGlmaWVyLm9yZz5cbiAgICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gIE9yaWdpbmFsbHkgY29udmVydGVkIHRvIGphdmFzY3JpcHQgYnkgVml0YWwsIDx2aXRhbDc2QGdtYWlsLmNvbT5cbiAgXCJFbmQgYnJhY2VzIG9uIG93biBsaW5lXCIgYWRkZWQgYnkgQ2hyaXMgSi4gU2h1bGwsIDxjaHJpc2pzaHVsbEBnbWFpbC5jb20+XG4gIFBhcnNpbmcgaW1wcm92ZW1lbnRzIGZvciBicmFjZS1sZXNzIHN0YXRlbWVudHMgYnkgTGlhbSBOZXdtYW4gPGJpdHdpc2VtYW5AZ21haWwuY29tPlxuXG5cbiAgVXNhZ2U6XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQpO1xuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAgLSBpbmRlbnRhdGlvbiBzaXplLFxuICAgIGluZGVudF9jaGFyIChkZWZhdWx0IHNwYWNlKSAgICAgIC0gY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBzaG91bGQgYmUgcHJlc2VydmVkLFxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVuayxcblxuICAgIGpzbGludF9oYXBweSAoZGVmYXVsdCBmYWxzZSkgLSBpZiB0cnVlLCB0aGVuIGpzbGludC1zdHJpY3RlciBtb2RlIGlzIGVuZm9yY2VkLlxuXG4gICAgICAgICAgICBqc2xpbnRfaGFwcHkgICAgICAgICFqc2xpbnRfaGFwcHlcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgICAgICAgICBmdW5jdGlvbigpXG5cbiAgICAgICAgICAgIHN3aXRjaCAoKSB7ICAgICAgICAgc3dpdGNoKCkge1xuICAgICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICB9XG5cbiAgICBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGFuIGFub255bW91cyBmdW5jdGlvbidzIHBhcmVucyBiZSBhZGRlZCwgXCJmdW5jdGlvbigpXCIgdnMgXCJmdW5jdGlvbiAoKVwiLFxuICAgICAgICAgIE5PVEU6IFRoaXMgb3B0aW9uIGlzIG92ZXJyaWRlbiBieSBqc2xpbnRfaGFwcHkgKGkuZS4gaWYganNsaW50X2hhcHB5IGlzIHRydWUsIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gaXMgdHJ1ZSBieSBkZXNpZ24pXG5cbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCIgfCBhbnkgb2YgdGhlIGZvcm1lciArIFwiLHByZXNlcnZlLWlubGluZVwiXG4gICAgICAgICAgICBwdXQgYnJhY2VzIG9uIHRoZSBzYW1lIGxpbmUgYXMgY29udHJvbCBzdGF0ZW1lbnRzIChkZWZhdWx0KSwgb3IgcHV0IGJyYWNlcyBvbiBvd24gbGluZSAoQWxsbWFuIC8gQU5TSSBzdHlsZSksIG9yIGp1c3QgcHV0IGVuZCBicmFjZXMgb24gb3duIGxpbmUsIG9yIGF0dGVtcHQgdG8ga2VlcCB0aGVtIHdoZXJlIHRoZXkgYXJlLlxuICAgICAgICAgICAgcHJlc2VydmUtaW5saW5lIHdpbGwgdHJ5IHRvIHByZXNlcnZlIGlubGluZSBibG9ja3Mgb2YgY3VybHkgYnJhY2VzXG5cbiAgICBzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgKGRlZmF1bHQgdHJ1ZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgYmUgYWRkZWQsIFwiaWYodHJ1ZSlcIiB2cyBcImlmICh0cnVlKVwiLFxuXG4gICAgdW5lc2NhcGVfc3RyaW5ncyAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgcHJpbnRhYmxlIGNoYXJhY3RlcnMgaW4gc3RyaW5ncyBlbmNvZGVkIGluIFxceE5OIG5vdGF0aW9uIGJlIHVuZXNjYXBlZCwgXCJleGFtcGxlXCIgdnMgXCJcXHg2NVxceDc4XFx4NjFcXHg2ZFxceDcwXFx4NmNcXHg2NVwiXG5cbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IHVubGltaXRlZCkgLSBsaW5lcyBzaG91bGQgd3JhcCBhdCBuZXh0IG9wcG9ydHVuaXR5IGFmdGVyIHRoaXMgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgICAgTk9URTogVGhpcyBpcyBub3QgYSBoYXJkIGxpbWl0LiBMaW5lcyB3aWxsIGNvbnRpbnVlIHVudGlsIGEgcG9pbnQgd2hlcmUgYSBuZXdsaW5lIHdvdWxkXG4gICAgICAgICAgICAgICAgYmUgcHJlc2VydmVkIGlmIGl0IHdlcmUgcHJlc2VudC5cblxuICAgIGVuZF93aXRoX25ld2xpbmUgKGRlZmF1bHQgZmFsc2UpICAtIGVuZCBvdXRwdXQgd2l0aCBhIG5ld2xpbmVcblxuXG4gICAgZS5nXG5cbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwge1xuICAgICAgJ2luZGVudF9zaXplJzogMSxcbiAgICAgICdpbmRlbnRfY2hhcic6ICdcXHQnXG4gICAgfSk7XG5cbiovXG5cbihmdW5jdGlvbigpIHtcbnZhciBsZWdhY3lfYmVhdXRpZnlfanMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGpzaGludCBjdXJseTogZmFsc2UgKi9cbi8vIFRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbi8vIFdoZXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyIGRlbm90ZXMgYSBuZXdsaW5lLlxuXG5leHBvcnRzLm5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWsgPSBuZXcgUmVnRXhwKCdcXHJcXG58JyArIGV4cG9ydHMubmV3bGluZS5zb3VyY2UpO1xuZXhwb3J0cy5hbGxMaW5lQnJlYWtzID0gbmV3IFJlZ0V4cChleHBvcnRzLmxpbmVCcmVhay5zb3VyY2UsICdnJyk7XG5cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gcGVybWl0ICQgKDM2KSBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2IHx8IGNvZGUgPT09IDY0O1xuICAgIC8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIC8vIHBlcm1pdCBfICg5NSkuXG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIC8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG52YXIgbWVyZ2VPcHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5tZXJnZU9wdHM7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIE91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oNCkuT3V0cHV0O1xudmFyIFRva2VuaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oNykuVG9rZW5pemVyO1xuXG5mdW5jdGlvbiByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKG91dHB1dCwgZnJhbWUpIHtcbiAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGVmZmVjdGl2ZSBidXQgaGFzIHNvbWUgaXNzdWVzOlxuICAgIC8vICAgICAtIGNhbiBjYXVzZSBsaW5lIHdyYXAgdG8gaGFwcGVuIHRvbyBzb29uIGR1ZSB0byBpbmRlbnQgcmVtb3ZhbFxuICAgIC8vICAgICAgICAgICBhZnRlciB3cmFwIHBvaW50cyBhcmUgY2FsY3VsYXRlZFxuICAgIC8vIFRoZXNlIGlzc3VlcyBhcmUgbWlub3IgY29tcGFyZWQgdG8gdWdseSBpbmRlbnRhdGlvbi5cblxuICAgIGlmIChmcmFtZS5tdWx0aWxpbmVfZnJhbWUgfHxcbiAgICAgICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fFxuICAgICAgICBmcmFtZS5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgb25lIGluZGVudCBmcm9tIGVhY2ggbGluZSBpbnNpZGUgdGhpcyBzZWN0aW9uXG4gICAgdmFyIHN0YXJ0X2luZGV4ID0gZnJhbWUuc3RhcnRfbGluZV9pbmRleDtcblxuICAgIG91dHB1dC5yZW1vdmVfaW5kZW50KHN0YXJ0X2luZGV4KTtcbn1cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gd2hhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzKy9nLCAnJyk7XG59XG5cbi8vIGZ1bmN0aW9uIHJ0cmltKHMpIHtcbi8vICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXHMrJC9nLCAnJyk7XG4vLyB9XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyhsaXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgbGlzdC5sZW5ndGg7IHgrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSBtYXBwZWQgbmFtZXMgdW5kZXJzY29yZWQgaW5zdGVhZCBvZiBkYXNoXG4gICAgICAgIHJlc3VsdFtsaXN0W3hdLnJlcGxhY2UoLy0vZywgJ18nKV0gPSBsaXN0W3hdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZU9wZXJhdG9yUG9zaXRpb24ob3BQb3NpdGlvbikge1xuICAgIG9wUG9zaXRpb24gPSBvcFBvc2l0aW9uIHx8IE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lO1xuXG4gICAgaWYgKCFpbl9hcnJheShvcFBvc2l0aW9uLCB2YWxpZFBvc2l0aW9uVmFsdWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnb3BlcmF0b3JfcG9zaXRpb24nIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzXFxuXCIgK1xuICAgICAgICAgICAgdmFsaWRQb3NpdGlvblZhbHVlcyArXG4gICAgICAgICAgICBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIG9wUG9zaXRpb24gKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wUG9zaXRpb247XG59XG5cbnZhciB2YWxpZFBvc2l0aW9uVmFsdWVzID0gWydiZWZvcmUtbmV3bGluZScsICdhZnRlci1uZXdsaW5lJywgJ3ByZXNlcnZlLW5ld2xpbmUnXTtcblxuLy8gR2VuZXJhdGUgbWFwIGZyb20gYXJyYXlcbnZhciBPUEVSQVRPUl9QT1NJVElPTiA9IGdlbmVyYXRlTWFwRnJvbVN0cmluZ3ModmFsaWRQb3NpdGlvblZhbHVlcyk7XG5cbnZhciBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUgPSBbT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmUsIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmVdO1xuXG52YXIgTU9ERSA9IHtcbiAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JywgLy8gJ0JMT0NLJ1xuICAgIFN0YXRlbWVudDogJ1N0YXRlbWVudCcsIC8vICdTVEFURU1FTlQnXG4gICAgT2JqZWN0TGl0ZXJhbDogJ09iamVjdExpdGVyYWwnLCAvLyAnT0JKRUNUJyxcbiAgICBBcnJheUxpdGVyYWw6ICdBcnJheUxpdGVyYWwnLCAvLydbRVhQUkVTU0lPTl0nLFxuICAgIEZvckluaXRpYWxpemVyOiAnRm9ySW5pdGlhbGl6ZXInLCAvLycoRk9SLUVYUFJFU1NJT04pJyxcbiAgICBDb25kaXRpb25hbDogJ0NvbmRpdGlvbmFsJywgLy8nKENPTkQtRVhQUkVTU0lPTiknLFxuICAgIEV4cHJlc3Npb246ICdFeHByZXNzaW9uJyAvLycoRVhQUkVTU0lPTiknXG59O1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG91dHB1dDtcbiAgICB2YXIgdG9rZW5zID0gW10sXG4gICAgICAgIHRva2VuX3BvcztcbiAgICB2YXIgdG9rZW5pemVyO1xuICAgIHZhciBjdXJyZW50X3Rva2VuO1xuICAgIHZhciBsYXN0X3R5cGUsIGxhc3RfbGFzdF90ZXh0LCBpbmRlbnRfc3RyaW5nO1xuICAgIHZhciBmbGFncywgcHJldmlvdXNfZmxhZ3MsIGZsYWdfc3RvcmU7XG4gICAgdmFyIHByZWZpeDtcblxuICAgIHZhciBoYW5kbGVycywgb3B0O1xuICAgIHZhciBiYXNlSW5kZW50U3RyaW5nID0gJyc7XG5cbiAgICBoYW5kbGVycyA9IHtcbiAgICAgICAgJ1RLX1NUQVJUX0VYUFInOiBoYW5kbGVfc3RhcnRfZXhwcixcbiAgICAgICAgJ1RLX0VORF9FWFBSJzogaGFuZGxlX2VuZF9leHByLFxuICAgICAgICAnVEtfU1RBUlRfQkxPQ0snOiBoYW5kbGVfc3RhcnRfYmxvY2ssXG4gICAgICAgICdUS19FTkRfQkxPQ0snOiBoYW5kbGVfZW5kX2Jsb2NrLFxuICAgICAgICAnVEtfV09SRCc6IGhhbmRsZV93b3JkLFxuICAgICAgICAnVEtfUkVTRVJWRUQnOiBoYW5kbGVfd29yZCxcbiAgICAgICAgJ1RLX1NFTUlDT0xPTic6IGhhbmRsZV9zZW1pY29sb24sXG4gICAgICAgICdUS19TVFJJTkcnOiBoYW5kbGVfc3RyaW5nLFxuICAgICAgICAnVEtfRVFVQUxTJzogaGFuZGxlX2VxdWFscyxcbiAgICAgICAgJ1RLX09QRVJBVE9SJzogaGFuZGxlX29wZXJhdG9yLFxuICAgICAgICAnVEtfQ09NTUEnOiBoYW5kbGVfY29tbWEsXG4gICAgICAgICdUS19CTE9DS19DT01NRU5UJzogaGFuZGxlX2Jsb2NrX2NvbW1lbnQsXG4gICAgICAgICdUS19DT01NRU5UJzogaGFuZGxlX2NvbW1lbnQsXG4gICAgICAgICdUS19ET1QnOiBoYW5kbGVfZG90LFxuICAgICAgICAnVEtfVU5LTk9XTic6IGhhbmRsZV91bmtub3duLFxuICAgICAgICAnVEtfRU9GJzogaGFuZGxlX2VvZlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfZmxhZ3MoZmxhZ3NfYmFzZSwgbW9kZSkge1xuICAgICAgICB2YXIgbmV4dF9pbmRlbnRfbGV2ZWwgPSAwO1xuICAgICAgICBpZiAoZmxhZ3NfYmFzZSkge1xuICAgICAgICAgICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmluZGVudGF0aW9uX2xldmVsO1xuICAgICAgICAgICAgaWYgKCFvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiZcbiAgICAgICAgICAgICAgICBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsID4gbmV4dF9pbmRlbnRfbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dF9mbGFncyA9IHtcbiAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICBwYXJlbnQ6IGZsYWdzX2Jhc2UsXG4gICAgICAgICAgICBsYXN0X3RleHQ6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3RfdGV4dCA6ICcnLCAvLyBsYXN0IHRva2VuIHRleHRcbiAgICAgICAgICAgIGxhc3Rfd29yZDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF93b3JkIDogJycsIC8vIGxhc3QgJ1RLX1dPUkQnIHBhc3NlZFxuICAgICAgICAgICAgZGVjbGFyYXRpb25fc3RhdGVtZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgbXVsdGlsaW5lX2ZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGlubGluZV9mcmFtZTogZmFsc2UsXG4gICAgICAgICAgICBpZl9ibG9jazogZmFsc2UsXG4gICAgICAgICAgICBlbHNlX2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGRvX2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGRvX3doaWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGltcG9ydF9ibG9jazogZmFsc2UsXG4gICAgICAgICAgICBpbl9jYXNlX3N0YXRlbWVudDogZmFsc2UsIC8vIHN3aXRjaCguLil7IElOU0lERSBIRVJFIH1cbiAgICAgICAgICAgIGluX2Nhc2U6IGZhbHNlLCAvLyB3ZSdyZSBvbiB0aGUgZXhhY3QgbGluZSB3aXRoIFwiY2FzZSAwOlwiXG4gICAgICAgICAgICBjYXNlX2JvZHk6IGZhbHNlLCAvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2tcbiAgICAgICAgICAgIGluZGVudGF0aW9uX2xldmVsOiBuZXh0X2luZGVudF9sZXZlbCxcbiAgICAgICAgICAgIGxpbmVfaW5kZW50X2xldmVsOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA6IG5leHRfaW5kZW50X2xldmVsLFxuICAgICAgICAgICAgc3RhcnRfbGluZV9pbmRleDogb3V0cHV0LmdldF9saW5lX251bWJlcigpLFxuICAgICAgICAgICAgdGVybmFyeV9kZXB0aDogMFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV4dF9mbGFncztcbiAgICB9XG5cbiAgICAvLyBTb21lIGludGVycHJldGVycyBoYXZlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aXRoIGZvbyA9IGJheiB8fCBiYXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAgIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdHMob3B0aW9ucywgJ2pzJyk7XG5cbiAgICBvcHQgPSB7fTtcblxuICAgIC8vIGNvbXBhdGliaWxpdHksIHJlXG4gICAgaWYgKG9wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kLXN0cmljdFwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICAgICAgb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiZXhwYW5kXCI7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImNvbGxhcHNlLXByZXNlcnZlLWlubGluZVwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICAgICAgb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2UscHJlc2VydmUtaW5saW5lXCI7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSAhPT0gdW5kZWZpbmVkKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICAgICAgb3B0aW9ucy5icmFjZV9zdHlsZSA9IG9wdGlvbnMuYnJhY2VzX29uX293bl9saW5lID8gXCJleHBhbmRcIiA6IFwiY29sbGFwc2VcIjtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmJyYWNlX3N0eWxlKSAvL05vdGhpbmcgZXhpc3RzIHRvIHNldCBpdFxuICAgIHtcbiAgICAgICAgb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2VcIjtcbiAgICB9XG5cblxuICAgIHZhciBicmFjZV9zdHlsZV9zcGxpdCA9IG9wdGlvbnMuYnJhY2Vfc3R5bGUuc3BsaXQoL1teYS16QS1aMC05X1xcLV0rLyk7XG4gICAgb3B0LmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGVfc3BsaXRbMF07XG4gICAgb3B0LmJyYWNlX3ByZXNlcnZlX2lubGluZSA9IGJyYWNlX3N0eWxlX3NwbGl0WzFdID8gYnJhY2Vfc3R5bGVfc3BsaXRbMV0gOiBmYWxzZTtcblxuICAgIG9wdC5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemUgPyBwYXJzZUludChvcHRpb25zLmluZGVudF9zaXplLCAxMCkgOiA0O1xuICAgIG9wdC5pbmRlbnRfY2hhciA9IG9wdGlvbnMuaW5kZW50X2NoYXIgPyBvcHRpb25zLmluZGVudF9jaGFyIDogJyAnO1xuICAgIG9wdC5lb2wgPSBvcHRpb25zLmVvbCA/IG9wdGlvbnMuZW9sIDogJ2F1dG8nO1xuICAgIG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyA9IChvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXM7XG4gICAgb3B0LnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyA9IChvcHRpb25zLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy51bmluZGVudF9jaGFpbmVkX21ldGhvZHM7XG4gICAgb3B0LmJyZWFrX2NoYWluZWRfbWV0aG9kcyA9IChvcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5icmVha19jaGFpbmVkX21ldGhvZHM7XG4gICAgb3B0Lm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IDAgOiBwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywgMTApO1xuICAgIG9wdC5zcGFjZV9pbl9wYXJlbiA9IChvcHRpb25zLnNwYWNlX2luX3BhcmVuID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2luX3BhcmVuO1xuICAgIG9wdC5zcGFjZV9pbl9lbXB0eV9wYXJlbiA9IChvcHRpb25zLnNwYWNlX2luX2VtcHR5X3BhcmVuID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2luX2VtcHR5X3BhcmVuO1xuICAgIG9wdC5qc2xpbnRfaGFwcHkgPSAob3B0aW9ucy5qc2xpbnRfaGFwcHkgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuanNsaW50X2hhcHB5O1xuICAgIG9wdC5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gKG9wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uO1xuICAgIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gKG9wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uO1xuICAgIG9wdC5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgPSAob3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw7XG4gICAgb3B0LnVuZXNjYXBlX3N0cmluZ3MgPSAob3B0aW9ucy51bmVzY2FwZV9zdHJpbmdzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnVuZXNjYXBlX3N0cmluZ3M7XG4gICAgb3B0LndyYXBfbGluZV9sZW5ndGggPSAob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoID09PSB1bmRlZmluZWQpID8gMCA6IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCwgMTApO1xuICAgIG9wdC5lNHggPSAob3B0aW9ucy5lNHggPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZTR4O1xuICAgIG9wdC5lbmRfd2l0aF9uZXdsaW5lID0gKG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZSA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICAgIG9wdC5jb21tYV9maXJzdCA9IChvcHRpb25zLmNvbW1hX2ZpcnN0ID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmNvbW1hX2ZpcnN0O1xuICAgIG9wdC5vcGVyYXRvcl9wb3NpdGlvbiA9IHNhbml0aXplT3BlcmF0b3JQb3NpdGlvbihvcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uKTtcblxuICAgIC8vIEZvciB0ZXN0aW5nIG9mIGJlYXV0aWZ5IGlnbm9yZTpzdGFydCBkaXJlY3RpdmVcbiAgICBvcHQudGVzdF9vdXRwdXRfcmF3ID0gKG9wdGlvbnMudGVzdF9vdXRwdXRfcmF3ID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnRlc3Rfb3V0cHV0X3JhdztcblxuICAgIC8vIGZvcmNlIG9wdC5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIHRvIHRydWUgaWYgb3B0LmpzbGludF9oYXBweVxuICAgIGlmIChvcHQuanNsaW50X2hhcHB5KSB7XG4gICAgICAgIG9wdC5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgIG9wdC5pbmRlbnRfY2hhciA9ICdcXHQnO1xuICAgICAgICBvcHQuaW5kZW50X3NpemUgPSAxO1xuICAgIH1cblxuICAgIGlmIChvcHQuZW9sID09PSAnYXV0bycpIHtcbiAgICAgICAgb3B0LmVvbCA9ICdcXG4nO1xuICAgICAgICBpZiAoanNfc291cmNlX3RleHQgJiYgYWNvcm4ubGluZUJyZWFrLnRlc3QoanNfc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICAgICAgICBvcHQuZW9sID0ganNfc291cmNlX3RleHQubWF0Y2goYWNvcm4ubGluZUJyZWFrKVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wdC5lb2wgPSBvcHQuZW9sLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaW5kZW50X3N0cmluZyA9ICcnO1xuICAgIHdoaWxlIChvcHQuaW5kZW50X3NpemUgPiAwKSB7XG4gICAgICAgIGluZGVudF9zdHJpbmcgKz0gb3B0LmluZGVudF9jaGFyO1xuICAgICAgICBvcHQuaW5kZW50X3NpemUgLT0gMTtcbiAgICB9XG5cbiAgICB2YXIgcHJlaW5kZW50X2luZGV4ID0gMDtcbiAgICBpZiAoanNfc291cmNlX3RleHQgJiYganNfc291cmNlX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICgoanNfc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCkgPT09ICcgJyB8fFxuICAgICAgICAgICAgICAgIGpzX3NvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpID09PSAnXFx0JykpIHtcbiAgICAgICAgICAgIHByZWluZGVudF9pbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBqc19zb3VyY2VfdGV4dC5zdWJzdHJpbmcoMCwgcHJlaW5kZW50X2luZGV4KTtcbiAgICAgICAganNfc291cmNlX3RleHQgPSBqc19zb3VyY2VfdGV4dC5zdWJzdHJpbmcocHJlaW5kZW50X2luZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0X3R5cGUgPSAnVEtfU1RBUlRfQkxPQ0snOyAvLyBsYXN0IHRva2VuIHR5cGVcbiAgICBsYXN0X2xhc3RfdGV4dCA9ICcnOyAvLyBwcmUtbGFzdCB0b2tlbiB0ZXh0XG4gICAgb3V0cHV0ID0gbmV3IE91dHB1dChpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKTtcblxuICAgIC8vIElmIHRlc3RpbmcgdGhlIGlnbm9yZSBkaXJlY3RpdmUsIHN0YXJ0IHdpdGggb3V0cHV0IGRpc2FibGUgc2V0IHRvIHRydWVcbiAgICBvdXRwdXQucmF3ID0gb3B0LnRlc3Rfb3V0cHV0X3JhdztcblxuXG4gICAgLy8gU3RhY2sgb2YgcGFyc2luZy9mb3JtYXR0aW5nIHN0YXRlcywgaW5jbHVkaW5nIE1PREUuXG4gICAgLy8gV2UgdG9rZW5pemUsIHBhcnNlLCBhbmQgb3V0cHV0IGluIGFuIGFsbW9zdCBwdXJlbHkgYSBmb3J3YXJkLW9ubHkgc3RyZWFtIG9mIHRva2VuIGlucHV0XG4gICAgLy8gYW5kIGZvcm1hdHRlZCBvdXRwdXQuICBUaGlzIG1ha2VzIHRoZSBiZWF1dGlmaWVyIGxlc3MgYWNjdXJhdGUgdGhhbiBmdWxsIHBhcnNlcnNcbiAgICAvLyBidXQgYWxzbyBmYXIgbW9yZSB0b2xlcmFudCBvZiBzeW50YXggZXJyb3JzLlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IG1vZGUgaXMgTU9ERS5CbG9ja1N0YXRlbWVudC4gSWYgd2Ugc2VlIGEgJ3snIHdlIHB1c2ggYSBuZXcgZnJhbWUgb2YgdHlwZVxuICAgIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgb24gdGhlIHRoZSBzdGFjaywgZXZlbiB0aG91Z2ggaXQgY291bGQgYmUgb2JqZWN0IGxpdGVyYWwuICBJZiB3ZSBsYXRlclxuICAgIC8vIGVuY291bnRlciBhIFwiOlwiLCB3ZSdsbCBzd2l0Y2ggdG8gdG8gTU9ERS5PYmplY3RMaXRlcmFsLiAgSWYgd2UgdGhlbiBzZWUgYSBcIjtcIixcbiAgICAvLyBtb3N0IGZ1bGwgcGFyc2VycyB3b3VsZCBkaWUsIGJ1dCB0aGUgYmVhdXRpZmllciBncmFjZWZ1bGx5IGZhbGxzIGJhY2sgdG9cbiAgICAvLyBNT0RFLkJsb2NrU3RhdGVtZW50IGFuZCBjb250aW51ZXMgb24uXG4gICAgZmxhZ19zdG9yZSA9IFtdO1xuICAgIHNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuXG4gICAgdGhpcy5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qanNoaW50IG9uZXZhcjp0cnVlICovXG4gICAgICAgIHZhciBzd2VldF9jb2RlO1xuICAgICAgICB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKGpzX3NvdXJjZV90ZXh0LCBvcHQsIGluZGVudF9zdHJpbmcpO1xuICAgICAgICB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoKTtcbiAgICAgICAgdG9rZW5fcG9zID0gMDtcblxuICAgICAgICBjdXJyZW50X3Rva2VuID0gZ2V0X3Rva2VuKCk7XG4gICAgICAgIHdoaWxlIChjdXJyZW50X3Rva2VuKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tjdXJyZW50X3Rva2VuLnR5cGVdKCk7XG5cbiAgICAgICAgICAgIGxhc3RfbGFzdF90ZXh0ID0gZmxhZ3MubGFzdF90ZXh0O1xuICAgICAgICAgICAgbGFzdF90eXBlID0gY3VycmVudF90b2tlbi50eXBlO1xuICAgICAgICAgICAgZmxhZ3MubGFzdF90ZXh0ID0gY3VycmVudF90b2tlbi50ZXh0O1xuXG4gICAgICAgICAgICB0b2tlbl9wb3MgKz0gMTtcbiAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4gPSBnZXRfdG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3ZWV0X2NvZGUgPSBvdXRwdXQuZ2V0X2NvZGUob3B0LmVuZF93aXRoX25ld2xpbmUsIG9wdC5lb2wpO1xuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMobG9jYWxfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICB2YXIgbmV3bGluZXMgPSBsb2NhbF90b2tlbi5uZXdsaW5lcztcbiAgICAgICAgdmFyIGtlZXBfd2hpdGVzcGFjZSA9IG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uICYmIGlzX2FycmF5KGZsYWdzLm1vZGUpO1xuICAgICAgICB2YXIgdGVtcF90b2tlbiA9IGN1cnJlbnRfdG9rZW47XG5cbiAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBsb2NhbF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICAgIC8vIFRoZSBjbGVhbmVzdCBoYW5kbGluZyBvZiBpbmxpbmUgY29tbWVudHMgaXMgdG8gdHJlYXQgdGhlbSBhcyB0aG91Z2ggdGhleSBhcmVuJ3QgdGhlcmUuXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnRpbnVlIGZvcm1hdHRpbmcgYW5kIHRoZSBiZWhhdmlvciBzaG91bGQgYmUgbG9naWNhbC5cbiAgICAgICAgICAgIC8vIEFsc28gaWdub3JlIHVua25vd24gdG9rZW5zLiAgQWdhaW4sIHRoaXMgc2hvdWxkIHJlc3VsdCBpbiBiZXR0ZXIgYmVoYXZpb3IuXG4gICAgICAgICAgICBjdXJyZW50X3Rva2VuID0gbG9jYWxfdG9rZW4uY29tbWVudHNfYmVmb3JlW2hdO1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgICAgICBoYW5kbGVyc1tjdXJyZW50X3Rva2VuLnR5cGVdKHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudF90b2tlbiA9IHRlbXBfdG9rZW47XG5cbiAgICAgICAgaWYgKGtlZXBfd2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdsaW5lczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShpID4gMCwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzICYmIG5ld2xpbmVzID4gb3B0Lm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgIG5ld2xpbmVzID0gb3B0Lm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbF90b2tlbi5uZXdsaW5lcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBuZXdsaW5lczsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKHRydWUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHdlIGNvdWxkIHVzZSBqdXN0IHN0cmluZy5zcGxpdCwgYnV0XG4gICAgLy8gSUUgZG9lc24ndCBsaWtlIHJldHVybmluZyBlbXB0eSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gc3BsaXRfbGluZWJyZWFrcyhzKSB7XG4gICAgICAgIC8vcmV0dXJuIHMuc3BsaXQoL1xceDBkXFx4MGF8XFx4MGEvKTtcblxuICAgICAgICBzID0gcy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgICAgdmFyIG91dCA9IFtdLFxuICAgICAgICAgICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICB3aGlsZSAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgb3V0LnB1c2gocy5zdWJzdHJpbmcoMCwgaWR4KSk7XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgICAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHZhciBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zID0gWydicmVhaycsICdjb250aW51ZScsICdyZXR1cm4nLCAndGhyb3cnLCAneWllbGQnXTtcblxuICAgIGZ1bmN0aW9uIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoZm9yY2VfbGluZXdyYXApIHtcbiAgICAgICAgZm9yY2VfbGluZXdyYXAgPSAoZm9yY2VfbGluZXdyYXAgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGZvcmNlX2xpbmV3cmFwO1xuXG4gICAgICAgIC8vIE5ldmVyIHdyYXAgdGhlIGZpcnN0IHRva2VuIG9uIGEgbGluZVxuICAgICAgICBpZiAob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gKG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB8fCBmb3JjZV9saW5ld3JhcDtcbiAgICAgICAgdmFyIG9wZXJhdG9yTG9naWNBcHBsaWVzID0gaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycykgfHwgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yTG9naWNBcHBsaWVzKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmUgPSAoXG4gICAgICAgICAgICAgICAgICAgIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpICYmXG4gICAgICAgICAgICAgICAgICAgIGluX2FycmF5KG9wdC5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKVxuICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcbiAgICAgICAgICAgIHNob3VsZFByZXNlcnZlT3JGb3JjZSA9IHNob3VsZFByZXNlcnZlT3JGb3JjZSAmJiBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRQcmVzZXJ2ZU9yRm9yY2UpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0b2tlbnMgc2hvdWxkIG5ldmVyIGhhdmUgYSBuZXdsaW5lIGluc2VydGVkXG4gICAgICAgICAgICAgICAgLy8gYmV0d2VlbiB0aGVtIGFuZCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3Bvc2VkX2xpbmVfbGVuZ3RoID0gb3V0cHV0LmN1cnJlbnRfbGluZS5nZXRfY2hhcmFjdGVyX2NvdW50KCkgKyBjdXJyZW50X3Rva2VuLnRleHQubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAob3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChwcm9wb3NlZF9saW5lX2xlbmd0aCA+PSBvcHQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRfbmV3bGluZShmb3JjZV9uZXdsaW5lLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5sYXN0X3RleHQgIT09ICc7JyAmJiBmbGFncy5sYXN0X3RleHQgIT09ICcsJyAmJiBmbGFncy5sYXN0X3RleHQgIT09ICc9JyAmJiBsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShmbGFncy5pZl9ibG9jayAmJiBuZXh0X3Rva2VuICYmIG5leHRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBuZXh0X3Rva2VuLnRleHQgPT09ICdlbHNlJykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXQuYWRkX25ld19saW5lKGZvcmNlX25ld2xpbmUpKSB7XG4gICAgICAgICAgICBmbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbigpIHtcbiAgICAgICAgaWYgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uICYmIGlzX2FycmF5KGZsYWdzLm1vZGUpICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuY3VycmVudF9saW5lLnB1c2goY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXQuc2V0X2luZGVudChmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5saW5lX2luZGVudF9sZXZlbCA9IGZsYWdzLmluZGVudGF0aW9uX2xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRfdG9rZW4ocHJpbnRhYmxlX3Rva2VuKSB7XG4gICAgICAgIGlmIChvdXRwdXQucmF3KSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuY29tbWFfZmlyc3QgJiYgbGFzdF90eXBlID09PSAnVEtfQ09NTUEnICYmXG4gICAgICAgICAgICBvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQucHJldmlvdXNfbGluZS5sYXN0KCkgPT09ICcsJykge1xuICAgICAgICAgICAgICAgIHZhciBwb3BwZWQgPSBvdXRwdXQucHJldmlvdXNfbGluZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29tbWEgd2FzIGFscmVhZHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLFxuICAgICAgICAgICAgICAgIC8vIHB1bGwgYmFjayBvbnRvIHRoYXQgbGluZSBhbmQgcmVwcmludCB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJldmlvdXNfbGluZS5wdXNoKHBvcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY3VycmVudF9saW5lLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgY29tbWEgaW4gZnJvbnQgb2YgdGhlIG5leHQgdG9rZW5cbiAgICAgICAgICAgICAgICBwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF90b2tlbignLCcpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJpbnRhYmxlX3Rva2VuID0gcHJpbnRhYmxlX3Rva2VuIHx8IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICAgICAgcHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbigpO1xuICAgICAgICBvdXRwdXQuYWRkX3Rva2VuKHByaW50YWJsZV90b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgICAgICBmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCArPSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlaW5kZW50KCkge1xuICAgICAgICBpZiAoZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiAwICYmXG4gICAgICAgICAgICAoKCFmbGFncy5wYXJlbnQpIHx8IGZsYWdzLmluZGVudGF0aW9uX2xldmVsID4gZmxhZ3MucGFyZW50LmluZGVudGF0aW9uX2xldmVsKSkge1xuICAgICAgICAgICAgZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgLT0gMTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0X21vZGUobW9kZSkge1xuICAgICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICAgIGZsYWdfc3RvcmUucHVzaChmbGFncyk7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncyA9IGZsYWdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNfZmxhZ3MgPSBjcmVhdGVfZmxhZ3MobnVsbCwgbW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbGFncyA9IGNyZWF0ZV9mbGFncyhwcmV2aW91c19mbGFncywgbW9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfYXJyYXkobW9kZSkge1xuICAgICAgICByZXR1cm4gbW9kZSA9PT0gTU9ERS5BcnJheUxpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfZXhwcmVzc2lvbihtb2RlKSB7XG4gICAgICAgIHJldHVybiBpbl9hcnJheShtb2RlLCBbTU9ERS5FeHByZXNzaW9uLCBNT0RFLkZvckluaXRpYWxpemVyLCBNT0RFLkNvbmRpdGlvbmFsXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdG9yZV9tb2RlKCkge1xuICAgICAgICBpZiAoZmxhZ19zdG9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncyA9IGZsYWdzO1xuICAgICAgICAgICAgZmxhZ3MgPSBmbGFnX3N0b3JlLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmICFvcHQudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihvdXRwdXQsIHByZXZpb3VzX2ZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgKFxuICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzonICYmIGZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHx8IChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2dldCcsICdzZXQnXSkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydF9vZl9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfV09SRCcpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2RvJykgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSAmJiAhY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZWxzZScgJiZcbiAgICAgICAgICAgICAgICAhKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLmxlbmd0aCkpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInICYmIChwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8IHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1dPUkQnICYmIGZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW5fY2FzZSAmJlxuICAgICAgICAgICAgICAgICEoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykgJiZcbiAgICAgICAgICAgICAgICBsYXN0X2xhc3RfdGV4dCAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gJ1RLX1dPUkQnICYmIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gJ1RLX1JFU0VSVkVEJykgfHxcbiAgICAgICAgICAgIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgKFxuICAgICAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICc6JyAmJiBmbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydnZXQnLCAnc2V0J10pKSkpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBzZXRfbW9kZShNT0RFLlN0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAoIW9wdC51bmluZGVudF9jaGFpbmVkX21ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBJc3N1ZSAjMjc2OlxuICAgICAgICAgICAgLy8gSWYgc3RhcnRpbmcgYSBuZXcgc3RhdGVtZW50IHdpdGggW2lmLCBmb3IsIHdoaWxlLCBkb10sIHB1c2ggdG8gYSBuZXcgbGluZS5cbiAgICAgICAgICAgIC8vIGlmIChhKSBpZiAoYikgaWYoYykgZCgpOyBlbHNlIGUoKTsgZWxzZSBmKCk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydkbycsICdmb3InLCAnaWYnLCAnd2hpbGUnXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsX2xpbmVzX3N0YXJ0X3dpdGgobGluZXMsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0cmltKGxpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSAhPT0gYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMsIGluZGVudCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBsaW5lO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyB0byBwYXNzIHRocm91Z2hcbiAgICAgICAgICAgIGlmIChsaW5lICYmIGxpbmUuaW5kZXhPZihpbmRlbnQpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX3NwZWNpYWxfd29yZCh3b3JkKSB7XG4gICAgICAgIHJldHVybiBpbl9hcnJheSh3b3JkLCBbJ2Nhc2UnLCAncmV0dXJuJywgJ2RvJywgJ2lmJywgJ3Rocm93JywgJ2Vsc2UnXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3Rva2VuKG9mZnNldCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0b2tlbl9wb3MgKyAob2Zmc2V0IHx8IDApO1xuICAgICAgICByZXR1cm4gKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0b2tlbnMubGVuZ3RoKSA/IG51bGwgOiB0b2tlbnNbaW5kZXhdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zdGFydF9leHByKCkge1xuICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIGlmICghc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0X21vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdbJykge1xuXG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfV09SRCcgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFycmF5IGluZGV4IHNwZWNpZmllciwgYnJlYWsgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAvLyBhW3hdLCBmbigpW3hdXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgICAgICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5BcnJheUxpdGVyYWw7XG4gICAgICAgICAgICBpZiAoaXNfYXJyYXkoZmxhZ3MubW9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MubGFzdF90ZXh0ID09PSAnWycgfHxcbiAgICAgICAgICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJywnICYmIChsYXN0X2xhc3RfdGV4dCA9PT0gJ10nIHx8IGxhc3RfbGFzdF90ZXh0ID09PSAnfScpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBdLCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gfSwgWyBnb2VzIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdmb3InKSB7XG4gICAgICAgICAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5Gb3JJbml0aWFsaXplcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydpZicsICd3aGlsZSddKSkge1xuICAgICAgICAgICAgICAgIG5leHRfbW9kZSA9IE1PREUuQ29uZGl0aW9uYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5leHRfbW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5sYXN0X3RleHQgPT09ICc7JyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSycpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUicgfHwgbGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgfHwgbGFzdF90eXBlID09PSAnVEtfRU5EX0JMT0NLJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICcuJykge1xuICAgICAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgd2hldGhlciBmb3JjaW5nIHRoaXMgaXMgcmVxdWlyZWQuICBSZXZpZXcgZmFpbGluZyB0ZXN0cyB3aGVuIHJlbW92ZWQuXG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpO1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBvbiAoKCBhbmQgKSggYW5kIF1bIGFuZCBdKCBhbmQgLihcbiAgICAgICAgfSBlbHNlIGlmICghKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJykgJiYgbGFzdF90eXBlICE9PSAnVEtfV09SRCcgJiYgbGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIChmbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgfHwgZmxhZ3MubGFzdF93b3JkID09PSAndHlwZW9mJykpIHx8XG4gICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uKCkgdnMgZnVuY3Rpb24gKClcbiAgICAgICAgICAgIC8vIHlpZWxkKigpIHZzIHlpZWxkKiAoKVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24qKCkgdnMgZnVuY3Rpb24qICgpXG4gICAgICAgICAgICBpZiAob3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2NhdGNoJykpIHtcbiAgICAgICAgICAgIGlmIChvcHQuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgYmUgYSBzcGFjZSBiZXR3ZWVuIGF3YWl0IGFuZCBhbiBJSUZFLCBvciBhc3luYyBhbmQgYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJygnICYmIGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3dvcmQsIFsnYXdhaXQnLCAnYXN5bmMnXSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydCBvZiB0aGlzIGtpbmQgb2YgbmV3bGluZSBwcmVzZXJ2YXRpb24uXG4gICAgICAgIC8vIGEgPSAoYiAmJlxuICAgICAgICAvLyAgICAgKGMgfHwgZCkpO1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKCcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19FUVVBTFMnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQgcHJlc2VydmluZyB3cmFwcGVkIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25zXG4gICAgICAgIC8vIGEuYignYycsXG4gICAgICAgIC8vICAgICAoKSA9PiBkLmVcbiAgICAgICAgLy8gKVxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKCcgJiYgbGFzdF90eXBlICE9PSAnVEtfV09SRCcgJiYgbGFzdF90eXBlICE9PSAnVEtfUkVTRVJWRUQnKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRfbW9kZShuZXh0X21vZGUpO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBpZiAob3B0LnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGFsbCBjYXNlcywgaWYgd2UgbmV3bGluZSB3aGlsZSBpbnNpZGUgYW4gZXhwcmVzc2lvbiBpdCBzaG91bGQgYmUgaW5kZW50ZWQuXG4gICAgICAgIGluZGVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9lbmRfZXhwcigpIHtcbiAgICAgICAgLy8gc3RhdGVtZW50cyBpbnNpZGUgZXhwcmVzc2lvbnMgYXJlIG5vdCB2YWxpZCBzeW50YXgsIGJ1dC4uLlxuICAgICAgICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICBpZiAoZmxhZ3MubXVsdGlsaW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ10nICYmIGlzX2FycmF5KGZsYWdzLm1vZGUpICYmICFvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0LnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgJiYgIW9wdC5zcGFjZV9pbl9lbXB0eV9wYXJlbikge1xuICAgICAgICAgICAgICAgIC8vICgpIFtdIG5vIGlubmVyIHNwYWNlIGluIGVtcHR5IHBhcmVucyBsaWtlIHRoZXNlLCBldmVyLCByZWYgIzMyMFxuICAgICAgICAgICAgICAgIG91dHB1dC50cmltKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKG91dHB1dCwgcHJldmlvdXNfZmxhZ3MpO1xuXG4gICAgICAgIC8vIGRvIHt9IHdoaWxlICgpIC8vIG5vIHN0YXRlbWVudCByZXF1aXJlZCBhZnRlclxuICAgICAgICBpZiAoZmxhZ3MuZG9fd2hpbGUgJiYgcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgcHJldmlvdXNfZmxhZ3MubW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICBmbGFncy5kb193aGlsZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc3RhcnRfYmxvY2soKSB7XG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgT2JqZWN0TGl0ZXJhbFxuICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgdmFyIHNlY29uZF90b2tlbiA9IGdldF90b2tlbigyKTtcbiAgICAgICAgaWYgKHNlY29uZF90b2tlbiAmJiAoXG4gICAgICAgICAgICAgICAgKGluX2FycmF5KHNlY29uZF90b2tlbi50ZXh0LCBbJzonLCAnLCddKSAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFsnVEtfU1RSSU5HJywgJ1RLX1dPUkQnLCAnVEtfUkVTRVJWRUQnXSkpIHx8XG4gICAgICAgICAgICAgICAgKGluX2FycmF5KG5leHRfdG9rZW4udGV4dCwgWydnZXQnLCAnc2V0JywgJy4uLiddKSAmJiBpbl9hcnJheShzZWNvbmRfdG9rZW4udHlwZSwgWydUS19XT1JEJywgJ1RLX1JFU0VSVkVEJ10pKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBUeXBlU2NyaXB0LGJ1dCB3ZSBkaWRuJ3QgYnJlYWsgaXQgZm9yIGEgdmVyeSBsb25nIHRpbWUuXG4gICAgICAgICAgICAvLyBXZSdsbCB0cnkgdG8ga2VlcCBub3QgYnJlYWtpbmcgaXQuXG4gICAgICAgICAgICBpZiAoIWluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ2NsYXNzJywgJ2ludGVyZmFjZSddKSkge1xuICAgICAgICAgICAgICAgIHNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICc9PicpIHtcbiAgICAgICAgICAgIC8vIGFycm93IGZ1bmN0aW9uOiAocGFyYW0xLCBwYXJhbU4pID0+IHsgc3RhdGVtZW50cyB9XG4gICAgICAgICAgICBzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbl9hcnJheShsYXN0X3R5cGUsIFsnVEtfRVFVQUxTJywgJ1RLX1NUQVJUX0VYUFInLCAnVEtfQ09NTUEnLCAnVEtfT1BFUkFUT1InXSkgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ3JldHVybicsICd0aHJvdycsICdpbXBvcnQnLCAnZGVmYXVsdCddKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3Rpbmcgc2hvcnRoYW5kIGZ1bmN0aW9uIHN5bnRheCBpcyBkaWZmaWN1bHQgYnkgc2Nhbm5pbmcgZm9yd2FyZCxcbiAgICAgICAgICAgIC8vICAgICBzbyBjaGVjayB0aGUgc3Vycm91bmRpbmcgY29udGV4dC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBpcyBiZWluZyByZXR1cm5lZCwgaW1wb3J0ZWQsIGV4cG9ydCBkZWZhdWx0LCBwYXNzZWQgYXMgYXJnLFxuICAgICAgICAgICAgLy8gICAgIGFzc2lnbmVkIHdpdGggPSBvciBhc3NpZ25lZCBpbiBhIG5lc3RlZCBvYmplY3QsIHRyZWF0IGFzIGFuIE9iamVjdExpdGVyYWwuXG4gICAgICAgICAgICBzZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW1wdHlfYnJhY2VzID0gIW5leHRfdG9rZW4uY29tbWVudHNfYmVmb3JlLmxlbmd0aCAmJiBuZXh0X3Rva2VuLnRleHQgPT09ICd9JztcbiAgICAgICAgdmFyIGVtcHR5X2Fub255bW91c19mdW5jdGlvbiA9IGVtcHR5X2JyYWNlcyAmJiBmbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJztcblxuICAgICAgICBpZiAob3B0LmJyYWNlX3ByZXNlcnZlX2lubGluZSkgLy8gY2hlY2sgZm9yIGlubGluZSwgc2V0IGlubGluZV9mcmFtZSBpZiBzb1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yd2FyZCBmb3IgYSBuZXdsaW5lIHdhbnRlZCBpbnNpZGUgdGhpcyBibG9ja1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBjaGVja190b2tlbiA9IG51bGw7XG4gICAgICAgICAgICBmbGFncy5pbmxpbmVfZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgY2hlY2tfdG9rZW4gPSBnZXRfdG9rZW4oaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja190b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5pbmxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY2hlY2tfdG9rZW4udHlwZSAhPT0gJ1RLX0VPRicgJiZcbiAgICAgICAgICAgICAgICAhKGNoZWNrX3Rva2VuLnR5cGUgPT09ICdUS19FTkRfQkxPQ0snICYmIGNoZWNrX3Rva2VuLm9wZW5lZCA9PT0gY3VycmVudF90b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAob3B0LmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSkgJiZcbiAgICAgICAgICAgICFmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicgJiZcbiAgICAgICAgICAgICAgICAoZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSAmJiBmbGFncy5sYXN0X3RleHQgIT09ICdlbHNlJykpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBjb2xsYXBzZSB8fCBpbmxpbmVfZnJhbWVcbiAgICAgICAgICAgIGlmIChpc19hcnJheShwcmV2aW91c19mbGFncy5tb2RlKSAmJiAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgfHwgbGFzdF90eXBlID09PSAnVEtfQ09NTUEnKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19DT01NQScgfHwgb3B0LnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19DT01NQScgfHwgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInICYmIGZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSBwcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgfHwgZmxhZ3MubXVsdGlsaW5lX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5tdWx0aWxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InICYmIGxhc3RfdHlwZSAhPT0gJ1RLX1NUQVJUX0VYUFInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJyAmJiAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VuZF9ibG9jaygpIHtcbiAgICAgICAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVtcHR5X2JyYWNlcyA9IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJztcblxuICAgICAgICBpZiAoZmxhZ3MuaW5saW5lX2ZyYW1lICYmICFlbXB0eV9icmFjZXMpIHsgLy8gdHJ5IGlubGluZV9mcmFtZSAob25seSBzZXQgaWYgb3B0LmJyYWNlcy1wcmVzZXJ2ZS1pbmxpbmUpIGZpcnN0XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIpIHtcbiAgICAgICAgICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2tpcCB7fVxuICAgICAgICAgICAgaWYgKCFlbXB0eV9icmFjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgUkVBTExZIG5lZWQgYSBuZXdsaW5lIGhlcmUsIGJ1dCBuZXdsaW5lciB3b3VsZCBza2lwIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV93b3JkKCkge1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnKSB7XG4gICAgICAgICAgICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ3NldCcsICdnZXQnXSkgJiYgZmxhZ3MubW9kZSAhPT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gJ1RLX1dPUkQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnYXMnLCAnZnJvbSddKSAmJiAhZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gJ1RLX1dPUkQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gJ1RLX1dPUkQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19XT1JEJykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSAmJiAhaXNfZXhwcmVzc2lvbihmbGFncy5tb2RlKSAmJlxuICAgICAgICAgICAgKGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJyB8fCAoZmxhZ3MubGFzdF90ZXh0ID09PSAnLS0nIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJysrJykpICYmXG4gICAgICAgICAgICBsYXN0X3R5cGUgIT09ICdUS19FUVVBTFMnICYmXG4gICAgICAgICAgICAob3B0LnByZXNlcnZlX25ld2xpbmVzIHx8ICEobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyd2YXInLCAnbGV0JywgJ2NvbnN0JywgJ3NldCcsICdnZXQnXSkpKSkge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzLmRvX2Jsb2NrICYmICFmbGFncy5kb193aGlsZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICd3aGlsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyB7fSAjIyB3aGlsZSAoKVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZG9fd2hpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8ge30gc2hvdWxkIGFsd2F5cyBoYXZlIHdoaWxlIGFzIHRoZSBuZXh0IHdvcmQuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3Qgc2VlIHRoZSBleHBlY3RlZCB3aGlsZSwgcmVjb3ZlclxuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICBmbGFncy5kb19ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbWF5IGJlIGZvbGxvd2VkIGJ5IGVsc2UsIG9yIG5vdFxuICAgICAgICAvLyBCYXJlL2lubGluZSBpZnMgYXJlIHRyaWNreVxuICAgICAgICAvLyBOZWVkIHRvIHVud2luZCB0aGUgbW9kZXMgY29ycmVjdGx5OiBpZiAoYSkgaWYgKGIpIGMoKTsgZWxzZSBkKCk7IGVsc2UgZSgpO1xuICAgICAgICBpZiAoZmxhZ3MuaWZfYmxvY2spIHtcbiAgICAgICAgICAgIGlmICghZmxhZ3MuZWxzZV9ibG9jayAmJiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnKSkge1xuICAgICAgICAgICAgICAgIGZsYWdzLmVsc2VfYmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZsYWdzLmlmX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZWxzZV9ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnY2FzZScgfHwgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2RlZmF1bHQnICYmIGZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50KSkpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIGlmIChmbGFncy5jYXNlX2JvZHkgfHwgb3B0LmpzbGludF9oYXBweSkge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBjYXNlcyBmb2xsb3dpbmcgb25lIGFub3RoZXJcbiAgICAgICAgICAgICAgICBkZWluZGVudCgpO1xuICAgICAgICAgICAgICAgIGZsYWdzLmNhc2VfYm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGZsYWdzLmluX2Nhc2UgPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19FUVVBTFMnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgaWYgKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ30nLCAnOyddKSB8fFxuICAgICAgICAgICAgICAgIChvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiYgIShpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnKCcsICdbJywgJ3snLCAnOicsICc9JywgJywnXSkgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgYSBuaWNlIGNsZWFuIHNwYWNlIG9mIGF0IGxlYXN0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGEgbmV3IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpICYmICFjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgfHwgbGFzdF90eXBlID09PSAnVEtfV09SRCcpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydnZXQnLCAnc2V0JywgJ25ldycsICdleHBvcnQnLCAnYXN5bmMnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2RlZmF1bHQnICYmIGxhc3RfbGFzdF90ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyBmb28gPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZmxhZ3MubXVsdGlsaW5lX2ZyYW1lICYmIChpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpIHx8IGlzX2FycmF5KGZsYWdzLm1vZGUpKSkge1xuICAgICAgICAgICAgICAgIC8vIChmdW5jdGlvblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBmbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcmVmaXggPSAnTk9ORSc7XG5cbiAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9CTE9DSycpIHtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydlbHNlJywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAnZnJvbSddKSkpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAob3B0LmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NFTUlDT0xPTicgJiYgZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgZm9yIFNUQVRFTUVOVCBhcyB3ZWxsP1xuICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NFTUlDT0xPTicgJiYgaXNfZXhwcmVzc2lvbihmbGFncy5tb2RlKSkge1xuICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVFJJTkcnKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1dPUkQnIHx8XG4gICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJykge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJyknKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MuaW5saW5lX2ZyYW1lIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2Vsc2UnIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseSddKSkge1xuICAgICAgICAgICAgaWYgKCghKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9CTE9DSycgJiYgcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdC5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkpICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBvdXRwdXQuY3VycmVudF9saW5lO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHRyaW1tZWQgYW5kIHRoZXJlJ3Mgc29tZXRoaW5nIG90aGVyIHRoYW4gYSBjbG9zZSBibG9jayBiZWZvcmUgdXNcbiAgICAgICAgICAgICAgICAvLyBwdXQgYSBuZXdsaW5lIGJhY2sgaW4uICBIYW5kbGVzICd9IC8vIGNvbW1lbnQnIHNjZW5hcmlvLlxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxhc3QoKSAhPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAnTkVXTElORScpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaXNfc3BlY2lhbF93b3JkKGZsYWdzLmxhc3RfdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZXdsaW5lIGJldHdlZW4gJ3JldHVybiBubm4nXG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSAhPT0gJ1RLX0VORF9FWFBSJykge1xuICAgICAgICAgICAgICAgIGlmICgobGFzdF90eXBlICE9PSAnVEtfU1RBUlRfRVhQUicgfHwgIShjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkpKSAmJiBmbGFncy5sYXN0X3RleHQgIT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGZvcmNlIG5ld2xpbmUgb24gJ3Zhcic6IGZvciAodmFyIHggPSAwLi4uKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3bGluZSBmb3IgfSBlbHNlIGlmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnKScpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MubXVsdGlsaW5lX2ZyYW1lICYmIGlzX2FycmF5KGZsYWdzLm1vZGUpICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJywnICYmIGxhc3RfbGFzdF90ZXh0ID09PSAnfScpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTsgLy8gfSwgaW4gbGlzdHMgZ2V0IGEgbmV3bGluZSB0cmVhdG1lbnRcbiAgICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICdTUEFDRScpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIGZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZG8nKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZG9fYmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5pZl9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5pbXBvcnRfYmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFncy5pbXBvcnRfYmxvY2sgJiYgY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuaW1wb3J0X2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc2VtaWNvbG9uKCkge1xuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIC8vIFNlbWljb2xvbiBjYW4gYmUgdGhlIHN0YXJ0IChhbmQgZW5kKSBvZiBhIHN0YXRlbWVudFxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBnZXRfdG9rZW4oMSk7XG4gICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAgICAgIShmbGFncy5pZl9ibG9jayAmJiBuZXh0X3Rva2VuICYmIG5leHRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBuZXh0X3Rva2VuLnRleHQgPT09ICdlbHNlJykgJiZcbiAgICAgICAgICAgICFmbGFncy5kb19ibG9jaykge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYWNreSBidXQgZWZmZWN0aXZlIGZvciB0aGUgbW9tZW50XG4gICAgICAgIGlmIChmbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICAgICAgICAgIGZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3N0cmluZygpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAvLyBPbmUgZGlmZmVyZW5jZSAtIHN0cmluZ3Mgd2FudCBhdCBsZWFzdCBhIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1dPUkQnIHx8IGZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19DT01NQScgfHwgbGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgfHwgbGFzdF90eXBlID09PSAnVEtfRVFVQUxTJyB8fCBsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9lcXVhbHMoKSB7XG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgICAgICAgICAgLy8ganVzdCBnb3QgYW4gJz0nIGluIGEgdmFyLWxpbmUsIGRpZmZlcmVudCBmb3JtYXR0aW5nL2xpbmUtYnJlYWtpbmcsIGV0YyB3aWxsIG5vdyBiZSBkb25lXG4gICAgICAgICAgICBmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2NvbW1hKCkge1xuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIGlmIChmbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChpc19leHByZXNzaW9uKGZsYWdzLnBhcmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBicmVhayBvbiBjb21tYSwgZm9yKHZhciBhID0gMSwgYiA9IDIpXG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0LmNvbW1hX2ZpcnN0KSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAgICAgICAgICAgLy8gdG8gdHVybiBpbnRvIGEgbmV3bGluZSBhZnRlciB0aGUgY29tbWEsIHdoaWNoIHdlIHdpbGwgZml4dXAgbGF0ZXJcbiAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsIHx8XG4gICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcHQuY29tbWFfZmlyc3QpIHtcbiAgICAgICAgICAgIC8vIEVYUFIgb3IgRE9fQkxPQ0tcbiAgICAgICAgICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgICAgICAgICAgLy8gdG8gdHVybiBpbnRvIGEgbmV3bGluZSBhZnRlciB0aGUgY29tbWEsIHdoaWNoIHdlIHdpbGwgZml4dXAgbGF0ZXJcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9vcGVyYXRvcigpIHtcbiAgICAgICAgdmFyIGlzR2VuZXJhdG9yQXN0ZXJpc2sgPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgICAgICAgICAgKChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pKSB8fFxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X3R5cGUsIFsnVEtfU1RBUlRfQkxPQ0snLCAnVEtfQ09NTUEnLCAnVEtfRU5EX0JMT0NLJywgJ1RLX1NFTUlDT0xPTiddKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciBpc1VuYXJ5ID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0nLCAnKyddKSAmJiAoXG4gICAgICAgICAgICBpbl9hcnJheShsYXN0X3R5cGUsIFsnVEtfU1RBUlRfQkxPQ0snLCAnVEtfU1RBUlRfRVhQUicsICdUS19FUVVBTFMnLCAnVEtfT1BFUkFUT1InXSkgfHxcbiAgICAgICAgICAgIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpIHx8XG4gICAgICAgICAgICBmbGFncy5sYXN0X3RleHQgPT09ICcsJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyA9ICFpc0dlbmVyYXRvckFzdGVyaXNrO1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpKSB7XG4gICAgICAgICAgICAvLyBcInJldHVyblwiIGhhZCBhIHNwZWNpYWwgaGFuZGxpbmcgaW4gVEtfV09SRC4gTm93IHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBmYXZvclxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFjayBmb3IgYWN0aW9uc2NyaXB0J3MgaW1wb3J0IC4qO1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiYgbGFzdF90eXBlID09PSAnVEtfRE9UJykge1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6OicpIHtcbiAgICAgICAgICAgIC8vIG5vIHNwYWNlcyBhcm91bmQgZXhvdGljIG5hbWVzcGFjaW5nIHN5bnRheCBvcGVyYXRvclxuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGxpbmUgd3JhcHBpbmcgYmV0d2VlbiBvcGVyYXRvcnMgd2hlbiBvcGVyYXRvcl9wb3NpdGlvbiBpc1xuICAgICAgICAvLyAgIHNldCB0byBiZWZvcmUgb3IgcHJlc2VydmVcbiAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJyAmJiBpbl9hcnJheShvcHQub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSkpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JyAmJiBmbGFncy5pbl9jYXNlKSB7XG4gICAgICAgICAgICBmbGFncy5jYXNlX2JvZHkgPSB0cnVlO1xuICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgZmxhZ3MuaW5fY2FzZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgICAgIHZhciBzcGFjZV9hZnRlciA9IHRydWU7XG4gICAgICAgIHZhciBpbl90ZXJuYXJ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb2xvbiBpcyBpbnZhbGlkIGphdmFzY3JpcHQgb3V0c2lkZSBvZiB0ZXJuYXJ5IGFuZCBvYmplY3QsIGJ1dCBkbyBvdXIgYmVzdCB0byBndWVzcyB3aGF0IHdhcyBtZWFudC5cbiAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MudGVybmFyeV9kZXB0aCAtPSAxO1xuICAgICAgICAgICAgICAgIGluX3Rlcm5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJz8nKSB7XG4gICAgICAgICAgICBmbGFncy50ZXJuYXJ5X2RlcHRoICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXQncyBoYW5kbGUgdGhlIG9wZXJhdG9yX3Bvc2l0aW9uIG9wdGlvbiBwcmlvciB0byBhbnkgY29uZmxpY3RpbmcgbG9naWNcbiAgICAgICAgaWYgKCFpc1VuYXJ5ICYmICFpc0dlbmVyYXRvckFzdGVyaXNrICYmIG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKSkge1xuICAgICAgICAgICAgdmFyIGlzQ29sb24gPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JztcbiAgICAgICAgICAgIHZhciBpc1Rlcm5hcnlDb2xvbiA9IChpc0NvbG9uICYmIGluX3Rlcm5hcnkpO1xuICAgICAgICAgICAgdmFyIGlzT3RoZXJDb2xvbiA9IChpc0NvbG9uICYmICFpbl90ZXJuYXJ5KTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHQub3BlcmF0b3JfcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50IHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gIWlzT3RoZXJDb2xvbjtcblxuICAgICAgICAgICAgICAgICAgICBwcmludF90b2tlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYWZ0ZXJfbmV3bGluZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgYW55dGhpbmcgYnV0IGNvbG9uLCBvciAodmlhIGRlZHVjdGlvbikgaXQncyBhIGNvbG9uIGFuZCBpbiBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoZW4gcHJpbnQgYSBuZXdsaW5lLlxuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldF90b2tlbigxKS53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcmludF90b2tlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmU6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPdGhlckNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBqdXN0IGFkZGVkIGEgbmV3bGluZSwgb3IgdGhlIGN1cnJlbnQgdG9rZW4gaXMgOiBhbmQgaXQncyBub3QgYSB0ZXJuYXJ5IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gIShvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgfHwgaXNPdGhlckNvbG9uKTtcblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gc3BhY2VfYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzR2VuZXJhdG9yQXN0ZXJpc2spIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBnZXRfdG9rZW4oMSk7XG4gICAgICAgICAgICBzcGFjZV9hZnRlciA9IG5leHRfdG9rZW4gJiYgaW5fYXJyYXkobmV4dF90b2tlbi50eXBlLCBbJ1RLX1dPUkQnLCAnVEtfUkVTRVJWRUQnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLi4uJykge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gbGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snO1xuICAgICAgICAgICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLS0nLCAnKysnLCAnIScsICd+J10pIHx8IGlzVW5hcnkpIHtcbiAgICAgICAgICAgIC8vIHVuYXJ5IG9wZXJhdG9ycyAoYW5kIGJpbmFyeSArLy0gcHJldGVuZGluZyB0byBiZSB1bmFyeSkgc3BlY2lhbCBjYXNlc1xuXG4gICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjkuMVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBuZXdsaW5lIGJldHdlZW4gLS0gb3IgKysgYW5kIGFueXRoaW5nIGVsc2Ugd2Ugc2hvdWxkIHByZXNlcnZlIGl0LlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbGFncy5sYXN0X3RleHQgPT09ICc7JyAmJiBpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yICg7OyArK2kpXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIF5eXlxuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUicpIHtcbiAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKGZsYWdzLmxhc3RfdGV4dCA9PT0gJ10nICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIC8vIGErKyArICsrYjtcbiAgICAgICAgICAgICAgICAvLyBhIC0gLWJcbiAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLS0nLCAnLScsICcrKycsICcrJ10pICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyctLScsICctJywgJysrJywgJysnXSk7XG4gICAgICAgICAgICAgICAgLy8gKyBhbmQgLSBhcmUgbm90IHVuYXJ5IHdoZW4gcHJlY2VlZGVkIGJ5IC0tIG9yICsrIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgLy8gYS0tICsgYlxuICAgICAgICAgICAgICAgIC8vIGEgKiArYlxuICAgICAgICAgICAgICAgIC8vIGEgLSAtYlxuICAgICAgICAgICAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnKycsICctJ10pICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyctLScsICcrKyddKSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZV9hZnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmICgoKGZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiYgIWZsYWdzLmlubGluZV9mcmFtZSkgfHwgZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJ3snIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJzsnKSkge1xuICAgICAgICAgICAgICAgIC8vIHsgZm9vOyAtLWkgfVxuICAgICAgICAgICAgICAgIC8vIGZvbygpOyAtLWJhcjtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiB8fCBzcGFjZV9iZWZvcmU7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9hZnRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfYmxvY2tfY29tbWVudChwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgaWYgKG91dHB1dC5yYXcpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcyAmJiBjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdGVzdGluZyB0aGUgcmF3IG91dHB1dCBiZWhhdmlvciwgZG8gbm90IGFsbG93IGEgZGlyZWN0aXZlIHRvIHR1cm4gaXQgb2ZmLlxuICAgICAgICAgICAgICAgIG91dHB1dC5yYXcgPSBvcHQudGVzdF9vdXRwdXRfcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlubGluZSBibG9ja1xuICAgICAgICBpZiAoIWFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X3Rva2VuLnRleHQpICYmICFjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lcyA9IHNwbGl0X2xpbmVicmVha3MoY3VycmVudF90b2tlbi50ZXh0KTtcbiAgICAgICAgdmFyIGo7IC8vIGl0ZXJhdG9yIGZvciB0aGlzIGNhc2VcbiAgICAgICAgdmFyIGphdmFkb2MgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXJsZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBsYXN0SW5kZW50ID0gY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZTtcbiAgICAgICAgdmFyIGxhc3RJbmRlbnRMZW5ndGggPSBsYXN0SW5kZW50Lmxlbmd0aDtcblxuICAgICAgICAvLyBibG9jayBjb21tZW50IHN0YXJ0cyB3aXRoIGEgbmV3IGxpbmVcbiAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGphdmFkb2MgPSBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcy5zbGljZSgxKSwgJyonKTtcbiAgICAgICAgICAgIHN0YXJsZXNzID0gZWFjaF9saW5lX21hdGNoZXNfaW5kZW50KGxpbmVzLnNsaWNlKDEpLCBsYXN0SW5kZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IGxpbmUgYWx3YXlzIGluZGVudGVkXG4gICAgICAgIHByaW50X3Rva2VuKGxpbmVzWzBdKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gamF2YWRvYzogcmVmb3JtYXQgYW5kIHJlLWluZGVudFxuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCcgJyArIGx0cmltKGxpbmVzW2pdKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJsZXNzICYmIGxpbmVzW2pdLmxlbmd0aCA+IGxhc3RJbmRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFybGVzczogcmUtaW5kZW50IG5vbi1lbXB0eSBjb250ZW50LCBhdm9pZGluZyB0cmltXG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4obGluZXNbal0uc3Vic3RyaW5nKGxhc3RJbmRlbnRMZW5ndGgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIGNvbW1lbnRzIG91dHB1dCByYXdcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBjb21tZW50cyBvZiBtb3JlIHRoYW4gb25lIGxpbmUsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgbmV3IGxpbmUgYWZ0ZXJcbiAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfY29tbWVudChwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9kb3QoKSB7XG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBwcmVzZXJ2ZWQgbmV3bGluZXMgYmVmb3JlIGRvdHMgaW4gZ2VuZXJhbFxuICAgICAgICAgICAgLy8gZm9yY2UgbmV3bGluZXMgb24gZG90cyBhZnRlciBjbG9zZSBwYXJlbiB3aGVuIGJyZWFrX2NoYWluZWQgLSBmb3IgYmFyKCkuYmF6KClcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoZmxhZ3MubGFzdF90ZXh0ID09PSAnKScgJiYgb3B0LmJyZWFrX2NoYWluZWRfbWV0aG9kcyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV91bmtub3duKHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBwcmludF90b2tlbigpO1xuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHRbY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9lb2YoKSB7XG4gICAgICAgIC8vIFVud2luZCBhbnkgb3BlbiBzdGF0ZW1lbnRzXG4gICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXQpIHtcbiAgICB2YXIgX2lucHV0ID0gaW5wdXQ7XG4gICAgdmFyIF9pbnB1dF9sZW5ndGggPSBfaW5wdXQubGVuZ3RoO1xuICAgIHZhciBfcG9zaXRpb24gPSAwO1xuXG4gICAgdGhpcy5iYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9wb3NpdGlvbiAtPSAxO1xuICAgIH07XG5cbiAgICB0aGlzLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbiA8IF9pbnB1dF9sZW5ndGg7XG4gICAgfTtcblxuICAgIHRoaXMubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICB2YWwgPSBfaW5wdXQuY2hhckF0KF9wb3NpdGlvbik7XG4gICAgICAgICAgICBfcG9zaXRpb24gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBpbmRleCArPSBfcG9zaXRpb247XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgX2lucHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgdmFsID0gX2lucHV0LmNoYXJBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy5wZWVrQ2hhckNvZGUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgdmFsID0gMDtcbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBpbmRleCArPSBfcG9zaXRpb247XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgX2lucHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgdmFsID0gX2lucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBfcG9zaXRpb24gKyBpbmRleDtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChfaW5wdXQpO1xuICAgIH07XG5cbiAgICB0aGlzLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gICAgICAgIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG4gICAgfTtcblxuICAgIHRoaXMubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gX3Bvc2l0aW9uO1xuICAgICAgICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyhfaW5wdXQpO1xuICAgICAgICBpZiAocGF0dGVybl9tYXRjaCAmJiBwYXR0ZXJuX21hdGNoLmluZGV4ID09PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIF9wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuX21hdGNoO1xuICAgIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIG1lcmdlT3B0cyhhbGxPcHRpb25zLCB0YXJnZXRUeXBlKSB7XG4gICAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICAgIHZhciBuYW1lO1xuXG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhcmdldFR5cGUpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIHRhcmdldFR5cGVcbiAgICBpZiAodGFyZ2V0VHlwZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW3RhcmdldFR5cGVdKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW3RhcmdldFR5cGVdW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IG1lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgICB2YXIgX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gICAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICAgIHZhciBfaW5kZW50X2NvdW50ID0gLTE7XG5cbiAgICB2YXIgX2l0ZW1zID0gW107XG4gICAgdmFyIF9lbXB0eSA9IHRydWU7XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICBfY2hhcmFjdGVyX2NvdW50ID0gcGFyZW50LmJhc2VJbmRlbnRMZW5ndGggKyBsZXZlbCAqIHBhcmVudC5pbmRlbnRfbGVuZ3RoO1xuICAgICAgICBfaW5kZW50X2NvdW50ID0gbGV2ZWw7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0X2NoYXJhY3Rlcl9jb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB9O1xuXG4gICAgdGhpcy5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2VtcHR5O1xuICAgIH07XG5cbiAgICB0aGlzLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVtc1tfaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBfaXRlbXMucHVzaChpbnB1dCk7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgKz0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBfZW1wdHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBudWxsO1xuICAgICAgICBpZiAoIV9lbXB0eSkge1xuICAgICAgICAgICAgaXRlbSA9IF9pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICBfZW1wdHkgPSBfaXRlbXMubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgICAgICAgICBfaW5kZW50X2NvdW50IC09IDE7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IHBhcmVudC5pbmRlbnRfbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgICAgICAgICAgX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50LmluZGVudF9jYWNoZVtfaW5kZW50X2NvdW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBfaXRlbXMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBPdXRwdXQoaW5kZW50X3N0cmluZywgYmFzZUluZGVudFN0cmluZykge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICAgIHRoaXMuaW5kZW50X2NhY2hlID0gW2Jhc2VJbmRlbnRTdHJpbmddO1xuICAgIHRoaXMuYmFzZUluZGVudExlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xuICAgIHRoaXMuaW5kZW50X2xlbmd0aCA9IGluZGVudF9zdHJpbmcubGVuZ3RoO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG5cbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB0aGlzLmJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICAgIHRoaXMuaW5kZW50X3N0cmluZyA9IGluZGVudF9zdHJpbmc7XG4gICAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xuICAgIH07XG5cbiAgICAvLyBpbml0aWFsaXplXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuXG5cbiAgICB0aGlzLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbGluZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvLyBVc2luZyBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcgdG8gYWxsb3cgZm9yIGxhdGVyIGV4cGFuc2lvbiBvZiBpbmZvIGFib3V0IGVhY2ggbGluZVxuICAgIHRoaXMuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAgICAgICBpZiAodGhpcy5nZXRfbGluZV9udW1iZXIoKSA9PT0gMSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vIG5ld2xpbmUgb24gc3RhcnQgb2YgZmlsZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlX25ld2xpbmUgfHwgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY29kZSA9IGZ1bmN0aW9uKGVuZF93aXRoX25ld2xpbmUsIGVvbCkge1xuICAgICAgICB2YXIgc3dlZXRfY29kZSA9IGxpbmVzLmpvaW4oJ1xcbicpLnJlcGxhY2UoL1tcXHJcXG5cXHQgXSskLywgJycpO1xuXG4gICAgICAgIGlmIChlbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dlZXRfY29kZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgICAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHdoaWxlIChsZXZlbCA+PSB0aGlzLmluZGVudF9jYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9jYWNoZS5wdXNoKHRoaXMuaW5kZW50X2NhY2hlW3RoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCAtIDFdICsgdGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChsZXZlbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICAgICAgICB0aGlzLmFkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIG91dHB1dF9sZW5ndGggPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVzW2luZGV4XS5yZW1vdmVfaW5kZW50KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICAgICAgICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbShpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKTtcblxuICAgICAgICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIGxpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IGxpbmVzLmxlbmd0aCA+IDEgPyBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHN0YXJ0IG9mIHRoZSBmaWxlIGFuZCBuZXdsaW5lID0gYmxhbmtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmlzX2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGV4dCwgbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlLCBwYXJlbnQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgICAvLyBjb21tZW50c19iZWZvcmUgYXJlXG4gICAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgICAvLyBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBhIG5ld2xpbmUgYWZ0ZXJcbiAgICAvLyB0aGlzIGlzIGEgc2V0IG9mIGNvbW1lbnRzIGJlZm9yZVxuICAgIHRoaXMuY29tbWVudHNfYmVmb3JlID0gLyogaW5saW5lIGNvbW1lbnQqLyBbXTtcblxuXG4gICAgdGhpcy5jb21tZW50c19hZnRlciA9IFtdOyAvLyBubyBuZXcgbGluZSBiZWZvcmUgYW5kIG5ld2xpbmUgYWZ0ZXJcbiAgICB0aGlzLm5ld2xpbmVzID0gbmV3bGluZXMgfHwgMDtcbiAgICB0aGlzLndhbnRlZF9uZXdsaW5lID0gbmV3bGluZXMgPiAwO1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmUgPSB3aGl0ZXNwYWNlX2JlZm9yZSB8fCAnJztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CZWF1dGlmaWVyO1xuXG5mdW5jdGlvbiBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNfYmVhdXRpZnk7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBJbnB1dFNjYW5uZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLklucHV0U2Nhbm5lcjtcbnZhciBUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuVG9rZW47XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IHdoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gVG9rZW5pemVyKGlucHV0X3N0cmluZywgb3B0cykge1xuXG4gICAgdmFyIHdoaXRlc3BhY2UgPSBcIlxcblxcclxcdCBcIi5zcGxpdCgnJyk7XG4gICAgdmFyIGRpZ2l0ID0gL1swLTldLztcbiAgICB2YXIgZGlnaXRfYmluID0gL1swMV0vO1xuICAgIHZhciBkaWdpdF9vY3QgPSAvWzAxMjM0NTY3XS87XG4gICAgdmFyIGRpZ2l0X2hleCA9IC9bMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRl0vO1xuXG4gICAgdGhpcy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gJyE9ICE9PSAlICYgJiYgKiAqKiArIC0gLyA6IDwgPDwgPD0gPT0gPT09ID4gPj0gPj4gPj4+ID8gXiB8IHx8Jy5zcGxpdCgnICcpO1xuICAgIHZhciBwdW5jdCA9IHRoaXMucG9zaXRpb25hYmxlX29wZXJhdG9ycy5jb25jYXQoXG4gICAgICAgIC8vIG5vbi1wb3NpdGlvbmFibGUgb3BlcmF0b3JzIC0gdGhlc2UgZG8gbm90IGZvbGxvdyBvcGVyYXRvciBwb3NpdGlvbiBzZXR0aW5nc1xuICAgICAgICAnISAlPSAmPSAqPSAqKj0gKysgKz0gLCAtLSAtPSAvPSA6OiA8PD0gPSA9PiA+Pj0gPj4+PSBePSB8PSB+IC4uLicuc3BsaXQoJyAnKSk7XG5cbiAgICAvLyB3b3JkcyB3aGljaCBzaG91bGQgYWx3YXlzIHN0YXJ0IG9uIG5ldyBsaW5lLlxuICAgIHRoaXMubGluZV9zdGFydGVycyA9ICdjb250aW51ZSx0cnksdGhyb3cscmV0dXJuLHZhcixsZXQsY29uc3QsaWYsc3dpdGNoLGNhc2UsZGVmYXVsdCxmb3Isd2hpbGUsYnJlYWssZnVuY3Rpb24saW1wb3J0LGV4cG9ydCcuc3BsaXQoJywnKTtcbiAgICB2YXIgcmVzZXJ2ZWRfd29yZHMgPSB0aGlzLmxpbmVfc3RhcnRlcnMuY29uY2F0KFsnZG8nLCAnaW4nLCAnb2YnLCAnZWxzZScsICdnZXQnLCAnc2V0JywgJ25ldycsICdjYXRjaCcsICdmaW5hbGx5JywgJ3R5cGVvZicsICd5aWVsZCcsICdhc3luYycsICdhd2FpdCcsICdmcm9tJywgJ2FzJ10pO1xuXG4gICAgLy8gIC8qIC4uLiAqLyBjb21tZW50IGVuZHMgd2l0aCBuZWFyZXN0ICovIG9yIGVuZCBvZiBmaWxlXG4gICAgdmFyIGJsb2NrX2NvbW1lbnRfcGF0dGVybiA9IC8oW1xcc1xcU10qPykoKD86XFwqXFwvKXwkKS9nO1xuXG4gICAgLy8gY29tbWVudCBlbmRzIGp1c3QgYmVmb3JlIG5lYXJlc3QgbGluZWZlZWQgb3IgZW5kIG9mIGZpbGVcbiAgICB2YXIgY29tbWVudF9wYXR0ZXJuID0gLyhbXlxcblxcclxcdTIwMjhcXHUyMDI5XSopL2c7XG5cbiAgICB2YXIgZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gL1xcL1xcKiBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyBcXCpcXC8vZztcbiAgICB2YXIgZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuICAgIHZhciBkaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IC8oW1xcc1xcU10qPykoKD86XFwvXFwqXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzXFwqXFwvKXwkKS9nO1xuXG4gICAgdmFyIHRlbXBsYXRlX3BhdHRlcm4gPSAvKCg8XFw/cGhwfDxcXD89KVtcXHNcXFNdKj9cXD8+KXwoPCVbXFxzXFxTXSo/JT4pL2c7XG5cbiAgICB2YXIgbl9uZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4sIGluX2h0bWxfY29tbWVudCwgdG9rZW5zO1xuICAgIHZhciBpbnB1dDtcblxuICAgIHRoaXMudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gICAgICAgIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0b2tlbnMgPSBbXTtcblxuICAgICAgICB2YXIgbmV4dCwgbGFzdDtcbiAgICAgICAgdmFyIHRva2VuX3ZhbHVlcztcbiAgICAgICAgdmFyIG9wZW4gPSBudWxsO1xuICAgICAgICB2YXIgb3Blbl9zdGFjayA9IFtdO1xuICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoIShsYXN0ICYmIGxhc3QudHlwZSA9PT0gJ1RLX0VPRicpKSB7XG4gICAgICAgICAgICB0b2tlbl92YWx1ZXMgPSB0b2tlbml6ZV9uZXh0KCk7XG4gICAgICAgICAgICBuZXh0ID0gbmV3IFRva2VuKHRva2VuX3ZhbHVlc1sxXSwgdG9rZW5fdmFsdWVzWzBdLCBuX25ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbik7XG4gICAgICAgICAgICB3aGlsZSAobmV4dC50eXBlID09PSAnVEtfQ09NTUVOVCcgfHwgbmV4dC50eXBlID09PSAnVEtfQkxPQ0tfQ09NTUVOVCcgfHwgbmV4dC50eXBlID09PSAnVEtfVU5LTk9XTicpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC50eXBlID09PSAnVEtfQkxPQ0tfQ09NTUVOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJlY3RpdmVzID0gdG9rZW5fdmFsdWVzWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIHRva2VuX3ZhbHVlcyA9IHRva2VuaXplX25leHQoKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV3IFRva2VuKHRva2VuX3ZhbHVlc1sxXSwgdG9rZW5fdmFsdWVzWzBdLCBuX25ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXh0LmNvbW1lbnRzX2JlZm9yZSA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0LnR5cGUgPT09ICdUS19TVEFSVF9CTE9DSycgfHwgbmV4dC50eXBlID09PSAnVEtfU1RBUlRfRVhQUicpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnBhcmVudCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgb3Blbl9zdGFjay5wdXNoKG9wZW4pO1xuICAgICAgICAgICAgICAgIG9wZW4gPSBuZXh0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgobmV4dC50eXBlID09PSAnVEtfRU5EX0JMT0NLJyB8fCBuZXh0LnR5cGUgPT09ICdUS19FTkRfRVhQUicpICYmXG4gICAgICAgICAgICAgICAgKG9wZW4gJiYgKFxuICAgICAgICAgICAgICAgICAgICAobmV4dC50ZXh0ID09PSAnXScgJiYgb3Blbi50ZXh0ID09PSAnWycpIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXh0LnRleHQgPT09ICcpJyAmJiBvcGVuLnRleHQgPT09ICcoJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5leHQudGV4dCA9PT0gJ30nICYmIG9wZW4udGV4dCA9PT0gJ3snKSkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5wYXJlbnQgPSBvcGVuLnBhcmVudDtcbiAgICAgICAgICAgICAgICBuZXh0Lm9wZW5lZCA9IG9wZW47XG5cbiAgICAgICAgICAgICAgICBvcGVuID0gb3Blbl9zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW5zLnB1c2gobmV4dCk7XG4gICAgICAgICAgICBsYXN0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldF9kaXJlY3RpdmVzKHRleHQpIHtcbiAgICAgICAgaWYgKCF0ZXh0Lm1hdGNoKGRpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgICAgICAgZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IGRpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG5cbiAgICAgICAgd2hpbGUgKGRpcmVjdGl2ZV9tYXRjaCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgICAgICAgICAgZGlyZWN0aXZlX21hdGNoID0gZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplX25leHQoKSB7XG4gICAgICAgIHZhciByZXN1bHRpbmdfc3RyaW5nO1xuICAgICAgICB2YXIgd2hpdGVzcGFjZV9vbl90aGlzX2xpbmUgPSBbXTtcblxuICAgICAgICBuX25ld2xpbmVzID0gMDtcbiAgICAgICAgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcblxuICAgICAgICB2YXIgYyA9IGlucHV0Lm5leHQoKTtcblxuICAgICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnJywgJ1RLX0VPRiddO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RfdG9rZW47XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0X3Rva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciB0aGUgc2FrZSBvZiB0b2tlbml6aW5nIHdlIGNhbiBwcmV0ZW5kIHRoYXQgdGhlcmUgd2FzIG9uIG9wZW4gYnJhY2UgdG8gc3RhcnRcbiAgICAgICAgICAgIGxhc3RfdG9rZW4gPSBuZXcgVG9rZW4oJ1RLX1NUQVJUX0JMT0NLJywgJ3snKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbl9hcnJheShjLCB3aGl0ZXNwYWNlKSkge1xuXG4gICAgICAgICAgICBpZiAoYWNvcm4ubmV3bGluZS50ZXN0KGMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYyA9PT0gJ1xcbicgJiYgaW5wdXQucGVlaygtMikgPT09ICdcXHInKSkge1xuICAgICAgICAgICAgICAgICAgICBuX25ld2xpbmVzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2Vfb25fdGhpc19saW5lID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZS5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjID0gaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGl0ZXNwYWNlX29uX3RoaXNfbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gd2hpdGVzcGFjZV9vbl90aGlzX2xpbmUuam9pbignJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlnaXQudGVzdChjKSB8fCAoYyA9PT0gJy4nICYmIGlucHV0LnRlc3RDaGFyKGRpZ2l0KSkpIHtcbiAgICAgICAgICAgIHZhciBhbGxvd19kZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBhbGxvd19lID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBsb2NhbF9kaWdpdCA9IGRpZ2l0O1xuXG4gICAgICAgICAgICBpZiAoYyA9PT0gJzAnICYmIGlucHV0LnRlc3RDaGFyKC9bWHhPb0JiXS8pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGhleC9vY3QvYmluIG51bWJlciwgbm8gZGVjaW1hbCBvciBlLCBqdXN0IGhleC9vY3QvYmluIGRpZ2l0c1xuICAgICAgICAgICAgICAgIGFsbG93X2RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbGxvd19lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnRlc3RDaGFyKC9bQmJdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfZGlnaXQgPSBkaWdpdF9iaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC50ZXN0Q2hhcigvW09vXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsX2RpZ2l0ID0gZGlnaXRfb2N0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsX2RpZ2l0ID0gZGlnaXRfaGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGEgZGVjaW1hbCBmb3IgdGhpcyBsaXRlcmFsLCBkb24ndCBhbGxvdyBhbm90aGVyXG4gICAgICAgICAgICAgICAgYWxsb3dfZGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoaXMgZmlyc3QgbG9vcCB3aWxsIHJ1bi4gIEl0IGtlZXBzIHRoZSBsb2dpYyBzaW1wbGVyLlxuICAgICAgICAgICAgICAgIGMgPSAnJztcbiAgICAgICAgICAgICAgICBpbnB1dC5iYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZGlnaXRzXG4gICAgICAgICAgICB3aGlsZSAoaW5wdXQudGVzdENoYXIobG9jYWxfZGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dfZGVjaW1hbCAmJiBpbnB1dC5wZWVrKCkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfZGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGEgPSAxLmUtNyBpcyB2YWxpZCwgc28gd2UgdGVzdCBmb3IgLiB0aGVuIGUgaW4gb25lIGxvb3BcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dfZSAmJiBpbnB1dC50ZXN0Q2hhcigvW0VlXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC50ZXN0Q2hhcigvWystXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFsbG93X2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfZGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfV09SRCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjb3JuLmlzSWRlbnRpZmllclN0YXJ0KGlucHV0LnBlZWtDaGFyQ29kZSgtMSkpKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGFjb3JuLmlzSWRlbnRpZmllckNoYXIoaW5wdXQucGVla0NoYXJDb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX0RPVCcgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShsYXN0X3Rva2VuLnRleHQsIFsnc2V0JywgJ2dldCddKSkpICYmXG4gICAgICAgICAgICAgICAgaW5fYXJyYXkoYywgcmVzZXJ2ZWRfd29yZHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdpbicgfHwgYyA9PT0gJ29mJykgeyAvLyBoYWNrIGZvciAnaW4nIGFuZCAnb2YnIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19PUEVSQVRPUiddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19SRVNFUlZFRCddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19XT1JEJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJygnIHx8IGMgPT09ICdbJykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfU1RBUlRfRVhQUiddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcpJyB8fCBjID09PSAnXScpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0VORF9FWFBSJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJ3snKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19TVEFSVF9CTE9DSyddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICd9Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfRU5EX0JMT0NLJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19TRU1JQ09MT04nXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gJyc7XG4gICAgICAgICAgICB2YXIgY29tbWVudF9tYXRjaDtcbiAgICAgICAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLyogLi4uICovXG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29tbWVudF9tYXRjaCA9IGlucHV0Lm1hdGNoKGJsb2NrX2NvbW1lbnRfcGF0dGVybik7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9ICcvKicgKyBjb21tZW50X21hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gZ2V0X2RpcmVjdGl2ZXMoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudF9tYXRjaCA9IGlucHV0Lm1hdGNoKGRpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjb21tZW50X21hdGNoWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbW1lbnQsICdUS19CTE9DS19DT01NRU5UJywgZGlyZWN0aXZlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwZWVrIGZvciBjb21tZW50IC8vIC4uLlxuICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRfbWF0Y2ggPSBpbnB1dC5tYXRjaChjb21tZW50X3BhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnLy8nICsgY29tbWVudF9tYXRjaFswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbW1lbnQsICdUS19DT01NRU5UJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFhtbFJlZ0V4cCA9IC88KCkoWy1hLXpBLVo6MC05Xy5dK3x7W1xcc1xcU10rP318IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXSkoXFxzK3tbXFxzXFxTXSs/fXxcXHMrWy1hLXpBLVo6MC05Xy5dK3xcXHMrWy1hLXpBLVo6MC05Xy5dK1xccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8e1tcXHNcXFNdKz99KSkqXFxzKihcXC8/KVxccyo+L2c7XG5cbiAgICAgICAgaWYgKGMgPT09ICdgJyB8fCBjID09PSBcIidcIiB8fCBjID09PSAnXCInIHx8IC8vIHN0cmluZ1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIChjID09PSAnLycpIHx8IC8vIHJlZ2V4cFxuICAgICAgICAgICAgICAgIChvcHRzLmU0eCAmJiBjID09PSBcIjxcIiAmJiBpbnB1dC50ZXN0KHN0YXJ0WG1sUmVnRXhwLCAtMSkpIC8vIHhtbFxuICAgICAgICAgICAgKSAmJiAoIC8vIHJlZ2V4IGFuZCB4bWwgY2FuIG9ubHkgYXBwZWFyIGluIHNwZWNpZmljIGxvY2F0aW9ucyBkdXJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgICAgIChsYXN0X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkobGFzdF90b2tlbi50ZXh0LCBbJ3JldHVybicsICdjYXNlJywgJ3Rocm93JywgJ2Vsc2UnLCAnZG8nLCAndHlwZW9mJywgJ3lpZWxkJ10pKSB8fFxuICAgICAgICAgICAgICAgIChsYXN0X3Rva2VuLnR5cGUgPT09ICdUS19FTkRfRVhQUicgJiYgbGFzdF90b2tlbi50ZXh0ID09PSAnKScgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdF90b2tlbi5wYXJlbnQgJiYgbGFzdF90b2tlbi5wYXJlbnQudHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShsYXN0X3Rva2VuLnBhcmVudC50ZXh0LCBbJ2lmJywgJ3doaWxlJywgJ2ZvciddKSkgfHxcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobGFzdF90b2tlbi50eXBlLCBbJ1RLX0NPTU1FTlQnLCAnVEtfU1RBUlRfRVhQUicsICdUS19TVEFSVF9CTE9DSycsXG4gICAgICAgICAgICAgICAgICAgICdUS19FTkRfQkxPQ0snLCAnVEtfT1BFUkFUT1InLCAnVEtfRVFVQUxTJywgJ1RLX0VPRicsICdUS19TRU1JQ09MT04nLCAnVEtfQ09NTUEnXG4gICAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICApKSB7XG5cbiAgICAgICAgICAgIHZhciBzZXAgPSBjLFxuICAgICAgICAgICAgICAgIGVzYyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhhc19jaGFyX2VzY2FwZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IGM7XG5cbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlZ2V4cFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmXG4gICAgICAgICAgICAgICAgICAgICgoZXNjIHx8IGluX2NoYXJfY2xhc3MgfHwgaW5wdXQucGVlaygpICE9PSBzZXApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gaW5wdXQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVzYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gaW5wdXQucGVlaygpID09PSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQucGVlaygpID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmU0eCAmJiBzZXAgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGU0eCB4bWwgbGl0ZXJhbHNcbiAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgdmFyIHhtbFJlZ0V4cCA9IC9bXFxzXFxTXSo/PChcXC8/KShbLWEtekEtWjowLTlfLl0rfHtbXFxzXFxTXSs/fXwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdKShcXHMre1tcXHNcXFNdKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7W1xcc1xcU10rP30pKSpcXHMqKFxcLz8pXFxzKj4vZztcbiAgICAgICAgICAgICAgICBpbnB1dC5iYWNrKCk7XG4gICAgICAgICAgICAgICAgdmFyIHhtbFN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKHN0YXJ0WG1sUmVnRXhwKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSByb290IHRhZyB0byBhdHRlbXB0IHRvXG4gICAgICAgICAgICAgICAgICAgIHZhciByb290VGFnID0gbWF0Y2hbMl0ucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDdXJseVJvb3QgPSByb290VGFnLmluZGV4T2YoJ3snKSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbmRUYWcgPSAhIW1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1NpbmdsZXRvblRhZyA9ICghIW1hdGNoW21hdGNoLmxlbmd0aCAtIDFdKSB8fCAodGFnTmFtZS5zbGljZSgwLCA4KSA9PT0gXCIhW0NEQVRBW1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNTaW5nbGV0b25UYWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFnTmFtZSA9PT0gcm9vdFRhZyB8fCAoaXNDdXJseVJvb3QgJiYgdGFnTmFtZS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9JykpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VuZFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWRlcHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sU3RyICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goeG1sUmVnRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2xvc2UgY29ycmVjdGx5LCBrZWVwIHVuZm9ybWF0dGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxTdHIgKz0gaW5wdXQubWF0Y2goL1tcXHNcXFNdKi9nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4bWxTdHIgPSB4bWxTdHIucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbeG1sU3RyLCBcIlRLX1NUUklOR1wiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlX3N0cmluZyA9IGZ1bmN0aW9uKGRlbGltaXRlciwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCBzdGFydF9zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgc3RyaW5ncyBjYW4gdHJhdmVycyBsaW5lcyB3aXRob3V0IGVzY2FwZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBzdHJpbmdzIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudF9jaGFyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NoYXIgPSBpbnB1dC5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlc2MgfHwgKGN1cnJlbnRfY2hhciAhPT0gZGVsaW1pdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbGxvd191bmVzY2FwZWRfbmV3bGluZXMgfHwgIWFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X2NoYXIpKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBcXHJcXG4gbGluZWJyZWFrcyBhZnRlciBlc2NhcGVzIG9yIGluIHRlbXBsYXRlIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZXNjIHx8IGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcykgJiYgYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfY2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09PSAnXFxyJyAmJiBpbnB1dC5wZWVrKDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY2hhciA9IGlucHV0LnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBjdXJyZW50X2NoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09PSAneCcgfHwgY3VycmVudF9jaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2NoYXJfZXNjYXBlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2MgPSBjdXJyZW50X2NoYXIgPT09ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRfc3ViICYmIHJlc3VsdGluZ19zdHJpbmcuaW5kZXhPZihzdGFydF9zdWIsIHJlc3VsdGluZ19zdHJpbmcubGVuZ3RoIC0gc3RhcnRfc3ViLmxlbmd0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltaXRlciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZygnfScsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJ2AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9zdHJpbmcoJ2AnLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsICckeycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICdgJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZV9zdHJpbmcoJ2AnLCB0cnVlLCAnJHsnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZV9zdHJpbmcoc2VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNfY2hhcl9lc2NhcGVzICYmIG9wdHMudW5lc2NhcGVfc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB1bmVzY2FwZV9zdHJpbmcocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09IHNlcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gc2VwO1xuICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWdleHBzIG1heSBoYXZlIG1vZGlmaWVycyAvcmVnZXhwL01PRCAsIHNvIGZldGNoIHRob3NlLCB0b29cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBbZ2ltXSBhcmUgdmFsaWQsIGJ1dCBpZiB0aGUgdXNlciBwdXRzIGluIGdhcmJhZ2UsIGRvIHdoYXQgd2UgY2FuIHRvIHRha2UgaXQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgYWNvcm4uaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQucGVla0NoYXJDb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0aW5nX3N0cmluZywgJ1RLX1NUUklORyddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcjJykge1xuXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCAmJiBpbnB1dC5wZWVrKCkgPT09ICchJykge1xuICAgICAgICAgICAgICAgIC8vIHNoZWJhbmdcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gYztcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmIGMgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cmltKHJlc3VsdGluZ19zdHJpbmcpICsgJ1xcbicsICdUS19VTktOT1dOJ107XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAvLyBTcGlkZXJtb25rZXktc3BlY2lmaWMgc2hhcnAgdmFyaWFibGVzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9TaGFycF92YXJpYWJsZXNfaW5fSmF2YVNjcmlwdFxuICAgICAgICAgICAgLy8gaHR0cDovL214ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2pzL3NyYy9qc3NjYW4uY3BwIGFyb3VuZCBsaW5lIDE5MzVcbiAgICAgICAgICAgIHZhciBzaGFycCA9ICcjJztcbiAgICAgICAgICAgIGlmIChpbnB1dC5oYXNOZXh0KCkgJiYgaW5wdXQudGVzdENoYXIoZGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjID0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBzaGFycCArPSBjO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBjICE9PSAnIycgJiYgYyAhPT0gJz0nKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5wZWVrKCkgPT09ICdbJyAmJiBpbnB1dC5wZWVrKDEpID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcnAgKz0gJ1tdJztcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5wZWVrKCkgPT09ICd7JyAmJiBpbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcnAgKz0gJ3t9JztcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2hhcnAsICdUS19XT1JEJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJzwnICYmIChpbnB1dC5wZWVrKCkgPT09ICc/JyB8fCBpbnB1dC5wZWVrKCkgPT09ICclJykpIHtcbiAgICAgICAgICAgIGlucHV0LmJhY2soKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZV9tYXRjaCA9IGlucHV0Lm1hdGNoKHRlbXBsYXRlX3BhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgYyA9IHRlbXBsYXRlX21hdGNoWzBdO1xuICAgICAgICAgICAgICAgIGMgPSBjLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NUUklORyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICc8JyAmJiBpbnB1dC5tYXRjaCgvXFwhLS0vZykpIHtcbiAgICAgICAgICAgIGMgPSAnPCEtLSc7XG4gICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmICFpbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkge1xuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5faHRtbF9jb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0NPTU1FTlQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnLScgJiYgaW5faHRtbF9jb21tZW50ICYmIGlucHV0Lm1hdGNoKC8tPi9nKSkge1xuICAgICAgICAgICAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gWyctLT4nLCAnVEtfQ09NTUVOVCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gJy4nICYmIGlucHV0LnBlZWsoMSkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpICsgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX09QRVJBVE9SJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19ET1QnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbl9hcnJheShjLCBwdW5jdCkpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgaW5fYXJyYXkoYyArIGlucHV0LnBlZWsoKSwgcHVuY3QpKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfQ09NTUEnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfRVFVQUxTJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX09QRVJBVE9SJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2MsICdUS19VTktOT1dOJ107XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiB1bmVzY2FwZV9zdHJpbmcocykge1xuICAgICAgICAvLyBZb3UgdGhpbmsgdGhhdCBhIHJlZ2V4IHdvdWxkIHdvcmsgZm9yIHRoaXNcbiAgICAgICAgLy8gcmV0dXJuIHMucmVwbGFjZSgvXFxcXHgoWzAtOWEtZl17Mn0pL2dpLCBmdW5jdGlvbihtYXRjaCwgdmFsKSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodmFsLCAxNikpO1xuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gSG93ZXZlciwgZGVhbGluZyB3aXRoICdcXHhmZicsICdcXFxceGZmJywgJ1xcXFxcXHhmZicgbWFrZXMgdGhpcyBtb3JlIGZ1bi5cbiAgICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgICAgZXNjYXBlZCA9IDA7XG5cbiAgICAgICAgdmFyIGlucHV0X3NjYW4gPSBuZXcgSW5wdXRTY2FubmVyKHMpO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAvLyBLZWVwIGFueSB3aGl0ZXNwYWNlLCBub24tc2xhc2ggY2hhcmFjdGVyc1xuICAgICAgICAgICAgLy8gYWxzbyBrZWVwIHNsYXNoIHBhaXJzLlxuICAgICAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goLyhbXFxzXXxbXlxcXFxdfFxcXFxcXFxcKSsvZyk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IG1hdGNoZWRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfc2Nhbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3goWzAtOUEtRmEtZl17Mn0pL2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvdShbMC05QS1GYS1mXXs0fSkvZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaW5wdXRfc2Nhbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBzb21lIGVycm9yIGRlY29kaW5nLCByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gcGFyc2VJbnQobWF0Y2hlZFsxXSwgMTYpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWQgPiAweDdlICYmIGVzY2FwZWQgPD0gMHhmZiAmJiBtYXRjaGVkWzBdLmluZGV4T2YoJ3gnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBiYWlsIG91dCBvbiBcXHg3Zi4uXFx4ZmYsXG4gICAgICAgICAgICAgICAgICAgIC8vIGxlYXZpbmcgd2hvbGUgc3RyaW5nIGVzY2FwZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0J3MgcHJvYmFibHkgY29tcGxldGVseSBiaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID49IDB4MDAgJiYgZXNjYXBlZCA8IDB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmUgMHgwMC4uLjB4MWYgZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcXFwnICsgbWF0Y2hlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID09PSAweDIyIHx8IGVzY2FwZWQgPT09IDB4MjcgfHwgZXNjYXBlZCA9PT0gMHg1Yykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUtcXVvdGUsIGFwb3N0cm9waGUsIGJhY2tzbGFzaCAtIGVzY2FwZSB0aGVzZVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcXFwnICsgU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG52YXIganNfYmVhdXRpZnkgPSBsZWdhY3lfYmVhdXRpZnlfanM7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IGpzX2JlYXV0aWZ5OiBqc19iZWF1dGlmeSB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmpzX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuIiwiLy8hIG1vbWVudC5qc1xuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGhvb2tDYWxsYmFjaztcblxuZnVuY3Rpb24gaG9va3MgKCkge1xuICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbi8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgIH1cbiAgICByZXR1cm4gbS5fcGY7XG59XG5cbnZhciBzb21lO1xuaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xufSBlbHNlIHtcbiAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbmZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xufVxuXG52YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4vLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgLy8gb2JqZWN0cy5cbiAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xufVxuXG5mdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgIHZhbHVlID0gMDtcblxuICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgZm4pO1xufVxuXG52YXIgZGVwcmVjYXRpb25zID0ge307XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgfVxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB9XG59XG5cbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgdmFyIHByb3AsIGk7XG4gICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgfVxufVxuXG52YXIga2V5cztcblxuaWYgKE9iamVjdC5rZXlzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xufSBlbHNlIHtcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5cbnZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgc2FtZUVsc2UgOiAnTCdcbn07XG5cbmZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbn1cblxudmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgTFQgICA6ICdoOm1tIEEnLFxuICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xufTtcblxuZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbn1cblxudmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG5mdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xufVxuXG52YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xudmFyIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xufVxuXG52YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICBoICA6ICdhbiBob3VyJyxcbiAgICBoaCA6ICclZCBob3VycycsXG4gICAgZCAgOiAnYSBkYXknLFxuICAgIGRkIDogJyVkIGRheXMnLFxuICAgIE0gIDogJ2EgbW9udGgnLFxuICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgeSAgOiAnYSB5ZWFyJyxcbiAgICB5eSA6ICclZCB5ZWFycydcbn07XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG59XG5cbnZhciBhbGlhc2VzID0ge307XG5cbmZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICBwcm9wO1xuXG4gICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG59XG5cbnZhciBwcmlvcml0aWVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgIHZhciB1bml0cyA9IFtdO1xuICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICB9XG4gICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuaXRzO1xufVxuXG5mdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbn1cblxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxudmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgIH1cbiAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cblxuLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG5mdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgdmFyIGkgPSA1O1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH1cblxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxudmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbnZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbnZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbnZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG52YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG52YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxudmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG52YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxudmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG52YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG52YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbnZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG52YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG52YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4vLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbi8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbnZhciBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaTtcblxudmFyIHJlZ2V4ZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG5cbnZhciB0b2tlbnMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgfVxuICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgfVxufVxuXG52YXIgWUVBUiA9IDA7XG52YXIgTU9OVEggPSAxO1xudmFyIERBVEUgPSAyO1xudmFyIEhPVVIgPSAzO1xudmFyIE1JTlVURSA9IDQ7XG52YXIgU0VDT05EID0gNTtcbnZhciBNSUxMSVNFQ09ORCA9IDY7XG52YXIgV0VFSyA9IDc7XG52YXIgV0VFS0RBWSA9IDg7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xufVxuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMRVNcblxudmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG52YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG59XG5cbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxudmFyIGJhc2VDb25maWcgPSB7XG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG59O1xuXG4vLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG52YXIgbG9jYWxlcyA9IHt9O1xudmFyIGxvY2FsZUZhbWlsaWVzID0ge307XG52YXIgZ2xvYmFsTG9jYWxlO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xufVxuXG4vLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbi8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4vLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG5mdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvY2FsZSAnICsga2V5ICsgICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIC8vIE1FUkdFXG4gICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbG9jYWxlO1xuXG4gICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICB9XG5cbiAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDID8gY29uZmlnLl9kLmdldFVUQ0RheSgpIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgIF07XG5cbiAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgIH1cbiAgICByZXR1cm4geWVhcjtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICBVVDogMCxcbiAgICBHTVQ6IDAsXG4gICAgRURUOiAtNCAqIDYwLFxuICAgIEVTVDogLTUgKiA2MCxcbiAgICBDRFQ6IC01ICogNjAsXG4gICAgQ1NUOiAtNiAqIDYwLFxuICAgIE1EVDogLTYgKiA2MCxcbiAgICBNU1Q6IC03ICogNjAsXG4gICAgUERUOiAtNyAqIDYwLFxuICAgIFBTVDogLTggKiA2MFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICB9XG59XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbmhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25maWcuX2EgPSBbXTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbn1cblxuXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICB2YXIgaXNQbTtcblxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICBpLFxuICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgYy5faSA9IGlucHV0O1xuICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG59XG5cbnZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxudmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZnVuY3Rpb24gbWluICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1heCAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG59XG5cbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG59O1xuXG52YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG5cbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICB9KTtcbn1cblxub2Zmc2V0KCdaJywgJzonKTtcbm9mZnNldCgnWlonLCAnJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIHRpbWV6b25lIGNodW5rZXJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbmZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAwIDpcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgIGxvY2FsQWRqdXN0O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbn1cblxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgLS1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICB9XG5cbiAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChkYXlzKSB7XG4gICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICB9XG59XG5cbnZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbnZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbn1cblxuZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xufVxuXG5mdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgaW5wdXRNcztcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICB2YXIgdGhhdCxcbiAgICAgICAgem9uZURlbHRhLFxuICAgICAgICBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgfVxuXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgIH1cbiAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgfVxuXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG59XG5cbmZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xufVxuXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xufVxuXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xufSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG5hZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbn0pO1xuXG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG5hZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxudmFyIHRva2VuO1xuZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG59XG5cbmZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbn1cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG5cbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xucHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xucHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbnByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xucHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xucHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xucHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG5wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG5wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbnByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xucHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG5wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbnByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbnByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG5wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG5wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xucHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG5wcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xucHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xucHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG5wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xucHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xucHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xucHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xucHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbnByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbnByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5wcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG5wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbnByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG5wcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbnByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG5wcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xucHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xucHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG5wcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xucHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbnByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbnByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG5wcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG5wcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfVxufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBhYnMgKCkge1xuICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG5mdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbn1cblxuZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWJibGUgKCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgIG1vbnRocyA9IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG4gICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5Nztcbn1cblxuZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbn1cblxuZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5cztcbiAgICB2YXIgbW9udGhzO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICB9O1xufVxuXG52YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG52YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbnZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xudmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG52YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbnZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xudmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG52YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgIH07XG59XG5cbnZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbnZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG52YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xudmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG52YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xudmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xudmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbmZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbn1cblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciB0aHJlc2hvbGRzID0ge1xuICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG59O1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgIH1cbiAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgIH1cbiAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbnZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHZhciBZID0geWVhcnM7XG4gICAgdmFyIE0gPSBtb250aHM7XG4gICAgdmFyIEQgPSBkYXlzO1xuICAgIHZhciBoID0gaG91cnM7XG4gICAgdmFyIG0gPSBtaW51dGVzO1xuICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgIHJldHVybiAnUDBEJztcbiAgICB9XG5cbiAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG59XG5cbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5wcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xucHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbnByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbnByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xucHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xucHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbnByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG5wcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbnByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG5wcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbnByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbnByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xucHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbnByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG5wcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbnByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbnByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG5wcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbnByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xucHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xucHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG5wcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG5wcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xucHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xucHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xucHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbnByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xucHJvdG8kMi5sYW5nID0gbGFuZztcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbmFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbmFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbn0pO1xuYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbmhvb2tzLnZlcnNpb24gPSAnMi4yMS4wJztcblxuc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG5ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbmhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbmhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG5ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbmhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICBXRUVLOiAnWVlZWS1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxufTtcblxucmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBib3VuZGFyeV90b19kb3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJ11bJykuam9pbignLicpLnNwbGl0KCdbJykuam9pbignLicpO1xufVxuZnVuY3Rpb24gc3RyaXBfYnJhY2VzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCdbJykuam9pbignLicpLnNwbGl0KCddJykuam9pbignJyk7XG59XG5mdW5jdGlvbiBlc2NhcGVfZG90cyh2YWx1ZSkge1xuICAgIHZhciB2YWwgPSB2YWx1ZS5zcGxpdCgnXFwnJyk7XG4gICAgcmV0dXJuICh2YWwubGVuZ3RoIDwgMykgPyB2YWwuam9pbignXFwnJykgOiB2YWwubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgaWYgKHNlZy5sZW5ndGggPCAzKVxuICAgICAgICAgICAgcmV0dXJuIHNlZztcbiAgICAgICAgaWYgKChzZWdbMF0gPT09ICcuJykgfHwgKHNlZ1tzZWcubGVuZ3RoIC0gMV0gPT09ICcuJykpXG4gICAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICByZXR1cm4gc2VnLnNwbGl0KCcuJykuam9pbignJiYnKTtcbiAgICB9KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHVuZXNjYXBlX2RvdHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJyYmJykuam9pbignLicpO1xufVxuZnVuY3Rpb24gcGFydGlmeSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gZXNjYXBlX2RvdHMoc3RyaXBfYnJhY2VzKGJvdW5kYXJ5X3RvX2RvdCgnJyArIHZhbHVlKSkpLnNwbGl0KCcuJyk7XG59XG5mdW5jdGlvbiBjYW5DbG9uZShvKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygby5fX0NMT05FX18gPT09ICdmdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gY2xvbmUobykge1xuICAgIGlmICgodHlwZW9mIG8gIT09ICdvYmplY3QnKSB8fCAobyA9PT0gbnVsbCkpXG4gICAgICAgIHJldHVybiBvO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKVxuICAgICAgICByZXR1cm4gby5tYXAoY2xvbmUpO1xuICAgIHJldHVybiAoY2FuQ2xvbmUobykpID9cbiAgICAgICAgby5fX0NMT05FX18oY2xvbmUpIDogKG8uY29uc3RydWN0b3IgIT09IE9iamVjdCkgPyBvIDpcbiAgICAgICAgT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChwcmUsIGspIHtcbiAgICAgICAgICAgIHByZVtrXSA9ICh0eXBlb2Ygb1trXSA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgICAgICBjbG9uZShvW2tdKSA6IG9ba107XG4gICAgICAgICAgICByZXR1cm4gcHJlO1xuICAgICAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXQocGF0aCwgbykge1xuICAgIHZhciBwYXJ0cyA9IHBhcnRpZnkocGF0aCk7XG4gICAgdmFyIGZpcnN0O1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBvW3VuZXNjYXBlX2RvdHMocGFydHNbMF0pXTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZmlyc3QgPSBvW3BhcnRzLnNoaWZ0KCldO1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgbyA9PT0gJ29iamVjdCcpICYmIChvICE9PSBudWxsKSkgP1xuICAgICAgICAgICAgcGFydHMucmVkdWNlKGZ1bmN0aW9uICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFt1bmVzY2FwZV9kb3RzKHByb3ApXTtcbiAgICAgICAgICAgIH0sIGZpcnN0KSA6IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXQoKTogZXhwZWN0cyBhbiBvYmplY3QgZ290ICcgKyB0eXBlb2Ygbyk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXQgPSBnZXQ7XG47XG5mdW5jdGlvbiBzZXQocGF0aCwgdmFsdWUsIG9iaikge1xuICAgIHZhciBwYXJ0cyA9IHBhcnRpZnkocGF0aCk7XG4gICAgaWYgKCh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgfHwgKG9iaiA9PSBudWxsKSkge1xuICAgICAgICByZXR1cm4gY2xvbmUob2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfc2V0KG9iaiwgdmFsdWUsIHBhcnRzKTtcbiAgICB9XG59XG5leHBvcnRzLnNldCA9IHNldDtcbjtcbmZ1bmN0aW9uIF9zZXQob2JqLCB2YWx1ZSwgcGFydHMpIHtcbiAgICB2YXIgbztcbiAgICB2YXIgaztcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgbyA9ICgodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHx8IChvYmogPT09IG51bGwpKSA/IHt9IDogY2xvbmUob2JqKTtcbiAgICBrID0gdW5lc2NhcGVfZG90cyhwYXJ0c1swXSk7XG4gICAgb1trXSA9IF9zZXQob1trXSwgdmFsdWUsIHBhcnRzLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRfMShrLCB2LCBvKSB7XG4gICAgaWYgKG8gPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGdldChrLCB2KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBzZXQoaywgdiwgbyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXX0=
