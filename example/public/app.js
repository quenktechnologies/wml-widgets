(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var landing = require("./wml/landing");
var views = require("./wml/views");
var app_1 = require("./wml/app");
var navigation_1 = require("./wml/navigation");
var App = /** @class */ (function () {
    function App() {
        var _this = this;
        /**
         * page currently displayed.
         */
        this.page = '';
        /**
         * views to show the user.
         */
        this.views = {
            panels: new views.PanelScreen(this)
        };
        /**
         * navigation view
         */
        this.navigation = new navigation_1.Navigation(this);
        /**
         * values used within the template.
         */
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * view is the current application view.
         */
        this.view = new app_1.Main(this);
        this.content = new landing.Main(this);
        /**
         * toggleDrawer
         */
        this.toggleDrawer = function () {
            _this
                .view
                .findById(_this.values.id.layout)
                .map(function (d) { return d.toggleDrawer(); });
        };
        this.navigate = function (_a) {
            var name = _a.name;
            _this.page = name;
            if (_this.views.hasOwnProperty(name))
                _this.content = _this.views[name];
            _this.view.invalidate();
            _this.navigation.invalidate();
        };
    }
    /**
     * run the application.
     */
    App.prototype.run = function () {
        var root = document.getElementById('app');
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        this.layout = this.view.findById(this.values.id.layout);
    };
    App.main = function () {
        return new App();
    };
    return App;
}());
exports.App = App;
var w = window;
w.app = App.main();
w.app.run();

},{"./wml/app":2,"./wml/landing":3,"./wml/navigation":4,"./wml/views":5}],2:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Drawer_1 = require("@package/self/layout/drawer/Drawer");
;
var ActionBar_1 = require("@package/self/app/action-bar/ActionBar");
;
;
var IconButton_1 = require("@package/self/control/icon-button/IconButton");
;
var Dash_1 = require("@package/self/control/dash/Dash");
;
var Main_1 = require("@package/self/layout/main/Main");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.widget(Drawer_1.Drawer, {
                html: {},
                wml: {
                    id: ___context.values.id.layout
                },
                ww: {
                    drawer: ___context.navigation
                }
            }, [$wml.widget(ActionBar_1.ActionBar, {
                    html: {},
                    wml: {}
                }, [$wml.widget(IconButton_1.IconButton, {
                        html: {},
                        wml: {},
                        ww: {
                            onClick: ___context.toggleDrawer
                        }
                    }, [$wml.widget(Dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), $wml.widget(Dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), $wml.widget(Dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view), $wml.widget(Main_1.Main, {
                    html: {},
                    wml: {}
                }, [$wml.domify(___context.content.render())], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@package/self/app/action-bar/ActionBar":6,"@package/self/control/dash/Dash":11,"@package/self/control/icon-button/IconButton":13,"@package/self/layout/drawer/Drawer":17,"@package/self/layout/main/Main":21,"@quenk/wml":39}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Panel_1 = require("@package/self/layout/panel/Panel");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [$wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [$wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            size: 4
                        }
                    }, [$wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [$wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [$wml.text("Funding")], ___view), $wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [$wml.text("$742.00")], ___view)], ___view)], ___view), $wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            size: 4
                        }
                    }, [$wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [$wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [$wml.text("Clients")], ___view), $wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [$wml.text("3")], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":19,"@package/self/layout/panel/Panel":23,"@quenk/wml":39}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
;
var List_1 = require("@package/self/nav/list/List");
;
var Item_1 = require("@package/self/nav/list/Item");
;
var Link_1 = require("@package/self/nav/link/Link");
;
var Text_1 = require("@package/self/nav/list/Text");
var Navigation = /** @class */ (function (_super) {
    __extends(Navigation, _super);
    function Navigation(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.widget(List_1.List, {
                html: {},
                wml: {}
            }, [$wml.widget(Item_1.Item, {
                    html: {},
                    wml: {}
                }, [$wml.widget(Link_1.Link, {
                        html: {},
                        wml: {
                            group: "links"
                        },
                        ww: {
                            active: (___context.page === "home"),
                            name: "home",
                            onClick: ___context.navigate,
                            text: "Home"
                        }
                    }, [], ___view)], ___view), $wml.widget(Item_1.Item, {
                    html: {},
                    wml: {}
                }, [$wml.widget(Text_1.Text, {
                        html: {},
                        wml: {},
                        ww: {
                            text: "Layout"
                        }
                    }, [], ___view), $wml.widget(List_1.List, {
                        html: {},
                        wml: {}
                    }, [$wml.widget(Item_1.Item, {
                            html: {},
                            wml: {}
                        }, [$wml.widget(Link_1.Link, {
                                html: {},
                                wml: {
                                    group: "links"
                                },
                                ww: {
                                    name: "panels",
                                    onClick: ___context.navigate,
                                    active: (___context.page === "panels"),
                                    text: "Panels"
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), $wml.widget(Item_1.Item, {
                    html: {},
                    wml: {}
                }, [$wml.widget(Link_1.Link, {
                        html: {},
                        wml: {
                            group: "links"
                        },
                        ww: {
                            name: "tables",
                            onClick: ___context.navigate,
                            active: (___context.page === "tables"),
                            text: "Tables"
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Navigation;
}($wml.AppView));
exports.Navigation = Navigation;

},{"@package/self/nav/link/Link":25,"@package/self/nav/list/Item":28,"@package/self/nav/list/List":29,"@package/self/nav/list/Text":30,"@quenk/wml":39}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var PanelScreen = /** @class */ (function (_super) {
    __extends(PanelScreen, _super);
    function PanelScreen(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('b', {
                html: {},
                wml: {}
            }, [$wml.text("Panel")], ___view);
        };
        return _this;
    }
    return PanelScreen;
}($wml.AppView));
exports.PanelScreen = PanelScreen;

},{"@quenk/wml":39}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
var action_bar_1 = require("./wml/action_bar");
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
var ActionBar = /** @class */ (function (_super) {
    __extends(ActionBar, _super);
    function ActionBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new action_bar_1.Main(_this);
        _this.values = {
            id: {
                content: 'content'
            },
            class: {
                root: util.combine([names.ACTION_BAR, names.FIXED_PUSHABLE]),
                content: names.ACTION_BAR_CONTENT
            }
        };
        return _this;
    }
    return ActionBar;
}(Group_1.Group));
exports.ActionBar = ActionBar;

},{"./wml/action_bar":7,"@package/self/common/names":8,"@package/self/common/util":9,"@package/self/content/Group":10}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.node('div', {
                    html: {
                        class: ___context.values.class.content
                    },
                    wml: {
                        id: ___context.values.id.content
                    }
                }, [$wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HIDDEN indicates an element should be hidden from sight.
 */
exports.HIDDEN = '-hidden';
/**
 * DISABLED indicates an element should appear to be inaccesible
 */
exports.DISABLED = '-disabled';
/**
 * ON indicates an 'on' state.
 */
exports.ON = '-on';
/**
 * OFF indicates an 'off' state.
 */
exports.OFF = '-off';
/**
 * open indicates an open state in collapsable widgets
 */
exports.OPEN = '-open';
/**
 * PUSHABLE is used by other styles to move an element around.
 */
exports.PUSHABLE = '-pushable';
/**
 * FIXED_PUSHABLE is like PUSHABLE but used for fixed elements.
 */
exports.FIXED_PUSHABLE = '-fixed-pushable';
/**
 * NO_HOVER indicates hover effects should be disabled.
 */
exports.NO_HOVER = '-no-hover';
exports.SPACED = '-spaced';
exports.DEFAULT = '-default';
exports.PRIMARY = '-primary';
exports.SUCCESS = '-success';
exports.INFO = '-info';
exports.WARNING = '-warning';
exports.DANGER = '-danger';
exports.LARGE = '-large';
exports.SMALL = '-small';
exports.EXTRA_SMALL = '-extra-small';
exports.ACTIVE = 'active'; //@todo: refactor to flag syntax
exports.DRAWER = 'ww-drawer-layout';
exports.ASIDE = 'ww-drawer';
exports.ASIDE_CONTENT = 'ww-drawer__content';
exports.ASIDE_PUSHABLE = '-drawer-pushable';
exports.ASIDE_PUSHABLE_FIXED = '-drawer-pushable-fixed';
/**
 * ACTION_BAR classes for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT classes
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * BUTTON_MENU classes
 */
exports.BUTTON_MENU = 'ww-button-menu';
/**
 * BUTTON_MENU_BUTTON classes
 */
exports.BUTTON_MENU_BUTTON = exports.BUTTON_MENU + "__button";
/**
 * BUTTON_MENU_MENU classes
 */
exports.BUTTON_MENU_MENU = exports.BUTTON_MENU_BUTTON + "__menu";
exports.MAIN_VIEW = 'ww-main-view';
/**
 * MENU classes
 */
exports.MENU = 'ww-menu';
/**
 * MENU_BUTTON clasess for the MenuButton.
 */
exports.MENU_BUTTON = 'ww-menu-button';
/**
 * DASH classes
 */
exports.DASH = 'ww-dash';
/**
 * NAV classes
 */
exports.NAV = 'ww-nav';
/**
 * NAV_LINK classes
 */
exports.NAV_LINK = 'ww-nav-link';
/**
 * NAV_LIST classes
 */
exports.NAV_LIST = 'ww-nav-list';
/**
 * NAV_LIST_ITEM classes
 */
exports.NAV_LIST_ITEM = 'ww-nav-list__item';
/**
 * NAV_LIST_ITEM_TEXT classes
 */
exports.NAV_LIST_ITEM_TEXT = 'ww-nav-list__item__text';
exports.BUTTON = 'ww-button';
exports.BUTTON_GROUP = 'ww-button-group';
//@todo: refactor this to be inline with other class names
exports.GRID = 'container-fluid';
exports.GRID_COL = '';
exports.GRID_ROW = 'row';
exports.PANEL = 'ww-panel';
exports.PANEL_HEADER = 'ww-panel__header';
exports.PANEL_BODY = 'ww-panel__body';
exports.PANEL_FOOTER = 'ww-panel__footer';
exports.MODAL = 'ww-modal';
exports.MODAL_DIALOG = 'ww-modal__dialog';
exports.MODAL_CONTENT = 'ww-modal__content';
exports.MODAL_HEADER = 'ww-modal__header';
exports.MODAL_BODY = 'ww-modal__body';
exports.MODAL_FOOTER = 'ww-moadl__footer';
exports.FORM_GROUP = 'form-group';
exports.CONTROL_LABEL = 'control-label';
exports.INPUT = 'form-control';
exports.TEXTAREA = 'form-control';
exports.SELECT = 'form-control';
exports.TABS = 'nav nav-tabs'; //@todo un-bootstrap
exports.SWITCH = 'ww-switch';
exports.SWITCH_SLIDER = 'ww-switch__slider';
exports.TABLE = 'table'; //@todo un-bootstrap
exports.TREE_NAV = 'tree-nav';
exports.TREE_NAV_LIST = 'tree-nav__list';
exports.TREE_NAV_LIST_ITEM = 'tree-nav__item';
exports.BREAD_CRUMBS = 'breadcrumb'; //@todo un-bootstrap
exports.BREAD_CRUMBS_CRUMB = exports.BREAD_CRUMBS + "__crumb";
exports.LIST = 'ww-list';
exports.LIST_ITEM = 'ww-list__item';
exports.SEARCH_INPUT = 'ww-search__input';
exports.FINDER = 'ww-finder';

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * combine the members of an array into one string.
 */
exports.combine = function (str, joiner) {
    if (joiner === void 0) { joiner = ' '; }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(joiner);
};
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
exports.concat = function () {
    var str = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        str[_i] = arguments[_i];
    }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(' ');
};
/**
 * noop
 */
exports.noop = function () { };
/**
 * replaceContent
 */
exports.replaceContent = function (r, node) {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};

},{}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_runtime_1 = require("@quenk/wml-runtime");
/**
 * Group is an abstract class providing an api for
 * widgets whose primary purpose is displaying content.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * setContent changes the content value.
     */
    Group.prototype.setContent = function (content) {
        this.content = content;
        this.view.invalidate();
        return this;
    };
    /**
     * removeContent removes existing content.
     */
    Group.prototype.removeContent = function () {
        this.content = null;
        return this;
    };
    return Group;
}(wml_runtime_1.Component));
exports.Group = Group;

},{"@quenk/wml-runtime":34}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_runtime_1 = require("@quenk/wml-runtime");
var dash_1 = require("./wml/dash");
/**
 * Dash are literal horizontal dashes.
 *
 * These can be used with app/menu/Button to create 'hamburger' menus.
 */
var Dash = /** @class */ (function (_super) {
    __extends(Dash, _super);
    function Dash() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new dash_1.Main(_this);
        _this.values = {
            class: {
                root: names.DASH
            }
        };
        return _this;
    }
    return Dash;
}(wml_runtime_1.Component));
exports.Dash = Dash;

},{"./wml/dash":12,"@package/self/common/names":8,"@quenk/wml-runtime":34}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_runtime_1 = require("@quenk/wml-runtime");
var icon_button_1 = require("./wml/icon-button");
/**
 * IconButton provides a 'hamburger' menu button.
 */
var IconButton = /** @class */ (function (_super) {
    __extends(IconButton, _super);
    function IconButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new icon_button_1.Main(_this);
        _this.values = {
            class: {
                root: names.MENU_BUTTON
            }
        };
        return _this;
    }
    return IconButton;
}(wml_runtime_1.Component));
exports.IconButton = IconButton;

},{"./wml/icon-button":14,"@package/self/common/names":8,"@quenk/wml-runtime":34}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('button', {
                html: {
                    class: ___context.values.class.root,
                    onclick: $wml.read("ww:onClick", ___context.attrs)
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Group_1 = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var aside_1 = require("./wml/aside");
/**
 * Aside provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as querying the
 * current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears in-front
 * of other content. Adjust the respective style variables to change.
 */
var Aside = /** @class */ (function (_super) {
    __extends(Aside, _super);
    function Aside() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * values is a hash of values used in the template
         */
        _this.values = {
            id: {
                root: 'aside',
            },
            class: {
                root: names.ASIDE,
                content: names.ASIDE_CONTENT
            },
            attrs: {
                content: 'ww:content'
            }
        };
        _this.view = new aside_1.Main(_this);
        return _this;
    }
    Aside.prototype._getDrawerDOM = function (f) {
        return this.view.findById(this.values.id.root).cata(function () { return null; }, f);
    };
    /**
     * visible queries whether the Drawer is visible or not.
     */
    Aside.prototype.visible = function () {
        return !this._getDrawerDOM(function (e) { return e.classList.contains(names.HIDDEN); });
    };
    /**
     * hide the drawer.
     */
    Aside.prototype.hide = function () {
        if (this.visible())
            this._getDrawerDOM(function (e) { return e.classList.add(names.HIDDEN); });
    };
    /**
     * showDrawer shows the drawer
     */
    Aside.prototype.show = function () {
        if (!this.visible())
            this._getDrawerDOM(function (e) { return e.classList.remove(names.HIDDEN); });
    };
    /**
     * toggle the visibility of this Drawer
     */
    Aside.prototype.toggle = function () {
        this._getDrawerDOM(function (e) { return e.classList.toggle(names.HIDDEN); });
    };
    return Aside;
}(Group_1.Group));
exports.Aside = Aside;

},{"./wml/aside":16,"@package/self/common/names":8,"@package/self/content/Group":10}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {
                    id: ___context.values.id.root
                }
            }, [$wml.node('div', {
                    html: {
                        class: ___context.values.class.content
                    },
                    wml: {}
                }, [$wml.ifthen($wml.read("ww:content", ___context.attrs), function then() {
                        return $wml.domify($wml.read("ww:content", ___context.attrs).render());
                    }, function else_clause() {
                        return $wml.domify(___context.children);
                    })], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Group_1 = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var drawer_1 = require("./wml/drawer");
;
/**
 * Drawer provides a 2 column application layout with the first typically used as navaigation
 * and the second main application content.
 *
 * ```wml
 *
 *  <Drawer
 *   wml:id="layout"
 *   content={{this.getContent()}} />
 *
 * ```
 */
var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_1.Main(_this);
        /**
         * values is a hash of values used in the template.
         */
        _this.values = {
            id: {
                root: 'content',
                drawer: 'drawer'
            },
            class: {
                root: names.DRAWER,
            },
            attrs: {
                DRAWER: 'ww:drawer',
                CONTENT: 'ww:content'
            }
        };
        return _this;
    }
    Drawer.prototype._getAside = function (f) {
        return this.view.findById(this.values.id.drawer).cata(function () { return null; }, f);
    };
    Drawer.prototype._combine = function (classes) {
        return classes.join(' ');
    };
    /**
     * drawerVisible queries whether the Aside is visible or not.
     */
    Drawer.prototype.drawerVisible = function () {
        return this._getAside(function (a) { return a.visible(); });
    };
    /**
     * hideDrawer hides the drawer.
     */
    Drawer.prototype.hideDrawer = function () {
        return this._getAside(function (a) { return a.hide(); });
    };
    /**
     * showDrawer shows the drawer
     */
    Drawer.prototype.showDrawer = function () {
        return this._getAside(function (a) { return a.show(); });
    };
    /**
     * toggle the visibility of the Aside.
     */
    Drawer.prototype.toggleDrawer = function () {
        return this._getAside(function (a) { return a.toggle(); });
    };
    return Drawer;
}(Group_1.Group));
exports.Drawer = Drawer;

},{"./wml/drawer":18,"@package/self/common/names":8,"@package/self/content/Group":10}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Aside_1 = require("@package/self/layout/aside/Aside");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {
                    id: ___context.values.id.root
                }
            }, [$wml.widget(Aside_1.Aside, {
                    html: {},
                    wml: {
                        id: ___context.values.id.drawer
                    },
                    ww: {
                        content: $wml.read("ww:drawer", ___context.attrs)
                    }
                }, [], ___view), $wml.ifthen(___context.content, function then() {
                    return $wml.domify(___context.content);
                }, function elseif() {
                    return $wml.ifthen($wml.read("ww:content", ___context.attrs), function then() {
                        return $wml.domify(___context.attrs.ww.content.render());
                    }, function else_clause() {
                        return $wml.domify(___context.children);
                    });
                })], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@package/self/layout/aside/Aside":15,"@quenk/wml":39}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/grid");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
;
/**
 * Grid
 */
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Grid(_this);
        _this.values = {
            class: {
                root: names.GRID
            }
        };
        return _this;
    }
    return Grid;
}(wml_1.Component));
exports.Grid = Grid;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Row(_this);
        _this.values = {
            class: {
                root: names.GRID_ROW
            }
        };
        return _this;
    }
    return Row;
}(wml_1.Component));
exports.Row = Row;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Column(_this);
        _this.values = {
            class: {
                root: _this.attrs.ww ? util_1.concat(_this.attrs.ww.size ?
                    "col-md-" + _this.attrs.ww.size : 'col-md-12', _this.attrs.ww.class) : 'col-md-12'
            }
        };
        return _this;
    }
    return Column;
}(wml_1.Component));
exports.Column = Column;

},{"./wml/grid":20,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('section', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Grid;
}($wml.AppView));
exports.Grid = Grid;
;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Row;
}($wml.AppView));
exports.Row = Row;
;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Column;
}($wml.AppView));
exports.Column = Column;

},{"@quenk/wml":39}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/main");
var names = require("@package/self/common/names");
var util_1 = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
/**
 * Main provides a container for the main content of an application.
 */
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.MAIN_VIEW, names.PUSHABLE, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Main;
}(Group_1.Group));
exports.Main = Main;

},{"./wml/main":22,"@package/self/common/names":8,"@package/self/common/util":9,"@package/self/content/Group":10}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/panel");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Panel(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL, _this.attrs.ww ?
                    _this.attrs.ww.style : names.DEFAULT)
            }
        };
        return _this;
    }
    return Panel;
}(wml_1.Component));
exports.Panel = Panel;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Header(_this);
        _this.values = {
            class: {
                root: names.PANEL_HEADER
            }
        };
        return _this;
    }
    return Header;
}(wml_1.Component));
exports.Header = Header;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Body(_this);
        _this.values = {
            class: {
                root: names.PANEL_BODY
            }
        };
        return _this;
    }
    return Body;
}(wml_1.Component));
exports.Body = Body;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Footer(_this);
        _this.values = {
            class: {
                root: names.PANEL_FOOTER
            }
        };
        return _this;
    }
    return Footer;
}(wml_1.Component));
exports.Footer = Footer;

},{"./wml/panel":24,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Panel;
}($wml.AppView));
exports.Panel = Panel;
;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Header;
}($wml.AppView));
exports.Header = Header;
;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Body;
}($wml.AppView));
exports.Body = Body;
;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('div', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Footer;
}($wml.AppView));
exports.Footer = Footer;

},{"@quenk/wml":39}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/link");
var LinkClickedEvent_1 = require("./LinkClickedEvent");
var util_1 = require("@package/self/common/util");
/**
 * Link generates an <a> element.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * name assigned to this Link.
         */
        _this.name = (_this.attrs.ww && _this.attrs.ww.name) ?
            _this.attrs.ww.name : '';
        /**
         * title assigned to this Link.
         */
        _this.title = (_this.attrs.ww && _this.attrs.ww.title) ?
            _this.attrs.ww.title : '';
        /**
         * href assigned to this link
         */
        _this.href = (_this.attrs.ww && _this.attrs.ww.href) ?
            _this.attrs.ww.href : '';
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_LINK, _this.attrs.ww ? _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    names.ACTIVE : '')
            },
            a: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : null,
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : null,
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false
            }
        };
        _this.clicked = function (e) {
            if (_this.attrs.ww) {
                var _a = _this.attrs.ww, name_1 = _a.name, href = _a.href, onClick = _a.onClick;
                if (!href)
                    e.preventDefault();
                if (onClick)
                    onClick(new LinkClickedEvent_1.LinkClickedEvent(name_1, href));
            }
        };
        return _this;
    }
    /**
      * activate this nav list Item.
      */
    Link.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Link.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Link;
}(wml.Component));
exports.Link = Link;

},{"./LinkClickedEvent":26,"./wml/link":27,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * LinkClickedEvent indicates a link has been clicked.
 */
var LinkClickedEvent = /** @class */ (function () {
    function LinkClickedEvent(name, href) {
        this.name = name;
        this.href = href;
    }
    return LinkClickedEvent;
}());
exports.LinkClickedEvent = LinkClickedEvent;

},{}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('a', {
                html: {
                    class: ___context.values.class.root,
                    href: ___context.values.a.href,
                    name: ___context.values.a.name,
                    title: ___context.values.a.title,
                    onclick: ___context.clicked
                },
                wml: {}
            }, [$wml.ifthen($wml.read("ww:text", ___context.attrs), function then() {
                    return $wml.domify($wml.read("ww:text", ___context.attrs));
                }, function else_clause() {
                    return $wml.domify(___context.children);
                })], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/item");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_LIST_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? names.ACTIVE : null)
            }
        };
        return _this;
    }
    /**
     * activate this nav list Item.
     */
    Item.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Item.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Item;
}(wml.Component));
exports.Item = Item;

},{"./wml/item":31,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var views = require("./wml/list");
var wml = require("@quenk/wml");
/**
 * List of navigation links.
 */
var List = /** @class */ (function (_super) {
    __extends(List, _super);
    function List() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util.concat(names.NAV_LIST, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return List;
}(wml.Component));
exports.List = List;

},{"./wml/list":32,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/text");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Text can be used to display non-clickable heading text in a nav list.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.NAV_LIST_ITEM_TEXT, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Text;
}(wml.Component));
exports.Text = Text;

},{"./wml/text":33,"@package/self/common/names":8,"@package/self/common/util":9,"@quenk/wml":39}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('li', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('ul', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return $wml.node('span', {
                html: {
                    class: ___context.values.class.root
                },
                wml: {}
            }, [$wml.ifthen(___context.values.text, function then() {
                    return $wml.domify(___context.values.text);
                }, function else_clause() {
                    return $wml.domify(___context.children);
                })], ___view);
        };
        return _this;
    }
    return Main;
}($wml.AppView));
exports.Main = Main;

},{"@quenk/wml":39}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property = require("property-seek");
var Maybe_1 = require("afpl/lib/monad/Maybe");
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 *
 */
var Component = (function () {
    /**
     * attrs is the attributes this Component excepts.
     */
    /**
     * children is an array of content passed to this Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;
/**
 * read a value form an object.
 *
 * This is an alternative to regular property access that will throw exceptions
 * if any of the values in the part are null.
 * @param {string} path - The path to look up on the object.
 * @param {object} o - The object
 * @param {A} [defaultValue] - This value is returned if the value is not set.
 * @private
 */
exports.read = function (path, o, defaultValue) {
    var ret = property.get(path.split(':').join('.'), o);
    return (ret != null) ? ret : defaultValue;
};
/**
 * @private
 */
var adopt = function (child, e) {
    switch (typeof child) {
        case 'string':
        case 'number':
        case 'boolean':
            e.appendChild(document.createTextNode('' + child));
        case 'object':
            e.appendChild(child);
            break;
        default:
            throw new TypeError("Can not adopt child " + child + " of type " + typeof child);
    }
};
/**
 * @private
 */
exports.box = function () {
    var content = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        content[_i] = arguments[_i];
    }
    var frag = document.createDocumentFragment();
    content.forEach(function (c) { return frag.appendChild(c); });
    return frag;
};
/**
 * @private
 */
exports.domify = function (a) {
    if (a instanceof Array) {
        return exports.box.apply(null, a.map(exports.domify));
    }
    else if ((typeof a === 'string') ||
        (typeof a === 'number') ||
        (typeof a === 'boolean')) {
        return exports.text(a);
    }
    else if (a instanceof Node) {
        return a;
    }
    else if (a == null) {
        return _empty;
    }
    else {
        throw new TypeError("Can not use '" + a + "'(typeof " + typeof a + ") as Content!");
    }
};
/**
 * @private
 */
var _empty = document.createDocumentFragment();
/**
 * @private
 */
exports.empty = function () { return _empty; };
/**
 * text creates a new TextNode.
 * @private
 */
exports.text = function (value) {
    return document.createTextNode('' + value);
};
/**
 * node is called to create a regular DOM node
 * @private
 */
exports.node = function (tag, attributes, children, view) {
    var e = document.createElement(tag);
    if (typeof attributes['html'] === 'object')
        Object.keys(attributes['html']).forEach(function (key) {
            var value = attributes['html'][key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, "" + value);
            }
        });
    children.forEach(function (c) { return adopt(c, e); });
    var id = attributes['wml'].id;
    var group = attributes.wml.group;
    if (id)
        view.register(id, e);
    if (group)
        view.registerGroup(group, e);
    return e;
};
/**
 * widget creates and renders a new wml widget instance.
 * @param {function} Construtor
 * @param {object} attributes
 * @param {array<string|number|Widget>} children
 * @param {View} view
 * @private
 * @return {Widget}
 */
exports.widget = function (Constructor, attributes, children, view) {
    var childs = [];
    var w;
    children.forEach(function (child) { return (child instanceof Array) ?
        childs.push.apply(childs, child) : childs.push(child); });
    w = new Constructor(attributes, childs);
    var id = attributes.wml.id;
    var group = attributes.wml.group;
    if (id)
        view.register(id, w);
    if (group)
        view.registerGroup(group, w);
    view.widgets.push(w);
    return w.render();
};
/**
 * ifE provides an if then expression
 * @private
 */
exports.ifE = function (predicate, positive, negative) {
    return (predicate) ? positive() : negative();
};
/**
 * forE provides a for expression
 * @private
 */
exports.forE = function (collection, cb, cb2) {
    var frag = document.createDocumentFragment();
    if (collection instanceof Array) {
        if (collection.length > 0)
            collection.forEach(function (v, k, a) { return frag.appendChild(cb(v, k, a)); });
        else
            frag.appendChild(cb2());
    }
    else if (typeof collection === 'object') {
        var l = Object.keys(collection);
        if (l.length > 0)
            l.forEach(function (k) { return frag.appendChild(cb(collection[k], k, collection)); });
        else
            frag.appendChild(cb2());
    }
    return frag;
};
/**
 * switchE simulates a switch statement
 * @param {string|number|boolean} value
 * @param {object} cases
 * @private
 */
exports.switchE = function (value, cases) {
    var result = cases[value];
    var defaul = cases['default'];
    if (result)
        return result;
    if (defaul)
        return defaul;
};
/**
 * AppView is the concrete implementation of a View.
 *
 * @property {<C>} context - The context the view is rendered in.
 */
var AppView = (function () {
    function AppView(context) {
        this.context = context;
        this.ids = {};
        this.groups = {};
        this.widgets = [];
    }
    AppView.prototype.register = function (id, w) {
        if (this.ids.hasOwnProperty(id))
            throw new Error("Duplicate id '" + id + "' detected!");
        this.ids[id] = w;
        return this;
    };
    AppView.prototype.registerGroup = function (group, e) {
        this.groups[group] = this.groups[group] || [];
        this.groups[group].push(e);
        return this;
    };
    AppView.prototype.findById = function (id) {
        return Maybe_1.Maybe.fromAny(this.ids[id]);
    };
    AppView.prototype.findGroupByName = function (name) {
        return Maybe_1.Maybe.fromArray(this.groups[name]);
    };
    AppView.prototype.invalidate = function () {
        var childs;
        var realFirstChild;
        var realFirstChildIndex;
        var tree = (this._fragRoot) ? this._fragRoot : this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            throw new ReferenceError('Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new ReferenceError('Attempt to invalidate a view that has not been inserted to DOM!');
        childs = tree.parentNode.children;
        //for some reason the reference stored does not have the correct parent node.
        //we do this to get a 'live' version of the node.
        for (var i = 0; i < childs.length; i++)
            if (childs[i] === tree) {
                realFirstChild = childs[i];
                realFirstChildIndex = i;
            }
        parent.replaceChild(this.render(), realFirstChild);
    };
    AppView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this._fragRoot = null;
        this.tree = this.template(this, this.context);
        this.ids['root'] = (this.ids['root']) ? this.ids['root'] : this.tree;
        if (this.tree.nodeName === (document.createDocumentFragment()).nodeName)
            this._fragRoot = this.tree.firstChild;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return AppView;
}());
exports.AppView = AppView;

},{"afpl/lib/monad/Maybe":50,"property-seek":55}],35:[function(require,module,exports){
"use strict";
/**
 * Types corresponding to the WML AST.
 */
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * Module is what a wml file compiles to.
 *
 * A module contains a list of imports and exported symbols.
 * All declarations in wml are exported. There is no such thing
 * as private here.
 */
var Module = /** @class */ (function () {
    function Module(imports, exports, main, location) {
        this.imports = imports;
        this.exports = exports;
        this.main = main;
        this.location = location;
        this.type = 'module';
    }
    return Module;
}());
exports.Module = Module;
/**
 * ImportStatement
 */
var ImportStatement = /** @class */ (function () {
    function ImportStatement(member, module, location) {
        this.member = member;
        this.module = module;
        this.location = location;
        this.type = 'import-statement';
    }
    return ImportStatement;
}());
exports.ImportStatement = ImportStatement;
/**
 * AliasedMember
 * @property {Identifier} alias - The identifier introduced to scope.
 * @property {Identifier} member - The identifier that is aliased.
 */
var AliasedMember = /** @class */ (function () {
    function AliasedMember(member, alias, location) {
        this.member = member;
        this.alias = alias;
        this.location = location;
        this.type = 'aliased-member';
    }
    return AliasedMember;
}());
exports.AliasedMember = AliasedMember;
/**
 * AggregateMember
 */
var AggregateMember = /** @class */ (function () {
    function AggregateMember(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'qualified-member';
    }
    return AggregateMember;
}());
exports.AggregateMember = AggregateMember;
/**
 * CompositeMember
 * @property {...Identifier|Aliased_Member} members
 */
var CompositeMember = /** @class */ (function () {
    function CompositeMember(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'composite-member';
    }
    return CompositeMember;
}());
exports.CompositeMember = CompositeMember;
var TypedMain = /** @class */ (function () {
    function TypedMain(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'typed-main';
    }
    return TypedMain;
}());
exports.TypedMain = TypedMain;
var UntypedMain = /** @class */ (function () {
    function UntypedMain(tag, location) {
        this.tag = tag;
        this.location = location;
        this.type = 'untyped-main';
    }
    return UntypedMain;
}());
exports.UntypedMain = UntypedMain;
var ExportStatement = /** @class */ (function () {
    function ExportStatement(members, module, location) {
        this.members = members;
        this.module = module;
        this.location = location;
        this.type = 'export-statement';
    }
    return ExportStatement;
}());
exports.ExportStatement = ExportStatement;
/**
 * ViewStatement
 */
var ViewStatement = /** @class */ (function () {
    function ViewStatement(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'view-statement';
    }
    return ViewStatement;
}());
exports.ViewStatement = ViewStatement;
var FunStatement = /** @class */ (function () {
    function FunStatement(id, typeClasses, context, parameters, body, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'fun-statement';
    }
    return FunStatement;
}());
exports.FunStatement = FunStatement;
/**
 * TypeClass
 */
var TypeClass = /** @class */ (function () {
    function TypeClass(id, constraint, location) {
        this.id = id;
        this.constraint = constraint;
        this.location = location;
        this.type = 'type-class';
    }
    return TypeClass;
}());
exports.TypeClass = TypeClass;
var Type = /** @class */ (function () {
    function Type(id, typeClasses, list, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.list = list;
        this.location = location;
        this.type = 'type';
    }
    return Type;
}());
exports.Type = Type;
var TypedParameter = /** @class */ (function () {
    function TypedParameter(id, hint, location) {
        this.id = id;
        this.hint = hint;
        this.location = location;
        this.type = 'typed-parameter';
    }
    return TypedParameter;
}());
exports.TypedParameter = TypedParameter;
var UntypedParameter = /** @class */ (function () {
    function UntypedParameter(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'untyped-parameter';
    }
    return UntypedParameter;
}());
exports.UntypedParameter = UntypedParameter;
var Node = /** @class */ (function () {
    function Node(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'node';
    }
    return Node;
}());
exports.Node = Node;
var Widget = /** @class */ (function () {
    function Widget(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'widget';
    }
    return Widget;
}());
exports.Widget = Widget;
var Attribute = /** @class */ (function () {
    function Attribute(namespace, name, value, location) {
        this.namespace = namespace;
        this.name = name;
        this.value = value;
        this.location = location;
        this.type = 'attribute';
    }
    return Attribute;
}());
exports.Attribute = Attribute;
var Interpolation = /** @class */ (function () {
    function Interpolation(expression, filters, location) {
        this.expression = expression;
        this.filters = filters;
        this.location = location;
        this.type = 'interpolation';
    }
    return Interpolation;
}());
exports.Interpolation = Interpolation;
var ForStatement = /** @class */ (function () {
    function ForStatement(variable, index, all, list, body, otherwise, location) {
        this.variable = variable;
        this.index = index;
        this.all = all;
        this.list = list;
        this.body = body;
        this.otherwise = otherwise;
        this.location = location;
        this.type = 'for-statement';
    }
    return ForStatement;
}());
exports.ForStatement = ForStatement;
var IfStatement = /** @class */ (function () {
    function IfStatement(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'if-statement';
    }
    return IfStatement;
}());
exports.IfStatement = IfStatement;
var ElseClause = /** @class */ (function () {
    function ElseClause(children, location) {
        this.children = children;
        this.location = location;
        this.type = 'else-clause';
    }
    return ElseClause;
}());
exports.ElseClause = ElseClause;
var ElseIfClause = /** @class */ (function () {
    function ElseIfClause(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'else-if-clause';
    }
    return ElseIfClause;
}());
exports.ElseIfClause = ElseIfClause;
var Characters = /** @class */ (function () {
    function Characters(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'characters';
    }
    return Characters;
}());
exports.Characters = Characters;
var IfThenExpression = /** @class */ (function () {
    function IfThenExpression(condition, iftrue, iffalse, location) {
        this.condition = condition;
        this.iftrue = iftrue;
        this.iffalse = iffalse;
        this.location = location;
        this.type = 'if-then-expression';
    }
    return IfThenExpression;
}());
exports.IfThenExpression = IfThenExpression;
var BinaryExpression = /** @class */ (function () {
    function BinaryExpression(left, operator, right, location) {
        this.left = left;
        this.operator = operator;
        this.right = right;
        this.location = location;
        this.type = 'binary-expression';
    }
    return BinaryExpression;
}());
exports.BinaryExpression = BinaryExpression;
var UnaryExpression = /** @class */ (function () {
    function UnaryExpression(operator, expression) {
        this.operator = operator;
        this.expression = expression;
        this.type = 'unary-expression';
    }
    return UnaryExpression;
}());
exports.UnaryExpression = UnaryExpression;
var ViewConstruction = /** @class */ (function () {
    function ViewConstruction(cons, context, location) {
        this.cons = cons;
        this.context = context;
        this.location = location;
        this.type = 'view-construction';
    }
    return ViewConstruction;
}());
exports.ViewConstruction = ViewConstruction;
var FunApplication = /** @class */ (function () {
    function FunApplication(target, typeArgs, context, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.context = context;
        this.args = args;
        this.location = location;
        this.type = 'fun-application';
    }
    return FunApplication;
}());
exports.FunApplication = FunApplication;
var ConstructExpression = /** @class */ (function () {
    function ConstructExpression(cons, args, location) {
        this.cons = cons;
        this.args = args;
        this.location = location;
        this.type = 'construct-expression';
    }
    return ConstructExpression;
}());
exports.ConstructExpression = ConstructExpression;
var CallExpression = /** @class */ (function () {
    function CallExpression(target, typeArgs, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.args = args;
        this.location = location;
        this.type = 'call-expression';
    }
    return CallExpression;
}());
exports.CallExpression = CallExpression;
/**
 * MemberExpression
 */
var MemberExpression = /** @class */ (function () {
    function MemberExpression(target, member, location) {
        this.target = target;
        this.member = member;
        this.location = location;
    }
    return MemberExpression;
}());
exports.MemberExpression = MemberExpression;
var ReadExpression = /** @class */ (function () {
    function ReadExpression(target, path, hint, defaults, location) {
        this.target = target;
        this.path = path;
        this.hint = hint;
        this.defaults = defaults;
        this.location = location;
        this.type = 'read-expression';
    }
    return ReadExpression;
}());
exports.ReadExpression = ReadExpression;
var FunctionExpression = /** @class */ (function () {
    function FunctionExpression(parameters, body, location) {
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'function-expression';
    }
    return FunctionExpression;
}());
exports.FunctionExpression = FunctionExpression;
var List = /** @class */ (function () {
    function List(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'list';
    }
    return List;
}());
exports.List = List;
var Record = /** @class */ (function () {
    function Record(properties, location) {
        this.properties = properties;
        this.location = location;
        this.type = 'record';
    }
    return Record;
}());
exports.Record = Record;
var Property = /** @class */ (function () {
    function Property(key, value, location) {
        this.key = key;
        this.value = value;
        this.location = location;
        this.type = 'property';
    }
    return Property;
}());
exports.Property = Property;
var StringLiteral = /** @class */ (function () {
    function StringLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'string';
    }
    return StringLiteral;
}());
exports.StringLiteral = StringLiteral;
var NumberLiteral = /** @class */ (function () {
    function NumberLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'number-literal';
    }
    return NumberLiteral;
}());
exports.NumberLiteral = NumberLiteral;
var BooleanLiteral = /** @class */ (function () {
    function BooleanLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'boolean-literal';
    }
    return BooleanLiteral;
}());
exports.BooleanLiteral = BooleanLiteral;
var ContextProperty = /** @class */ (function () {
    function ContextProperty(member, location) {
        this.member = member;
        this.location = location;
        this.type = 'context-property';
    }
    return ContextProperty;
}());
exports.ContextProperty = ContextProperty;
var ContextVariable = /** @class */ (function () {
    function ContextVariable(location) {
        this.location = location;
        this.type = 'context-variable';
    }
    return ContextVariable;
}());
exports.ContextVariable = ContextVariable;
var UnqualifiedConstructor = /** @class */ (function () {
    function UnqualifiedConstructor(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-constructor';
    }
    return UnqualifiedConstructor;
}());
exports.UnqualifiedConstructor = UnqualifiedConstructor;
var QualifiedConstructor = /** @class */ (function () {
    function QualifiedConstructor(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-constructor';
    }
    return QualifiedConstructor;
}());
exports.QualifiedConstructor = QualifiedConstructor;
var UnqualifiedIdentifier = /** @class */ (function () {
    function UnqualifiedIdentifier(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-identifier';
    }
    return UnqualifiedIdentifier;
}());
exports.UnqualifiedIdentifier = UnqualifiedIdentifier;
/**
 * QualifiedIdentifier
 */
var QualifiedIdentifier = /** @class */ (function () {
    function QualifiedIdentifier(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-identifier';
    }
    return QualifiedIdentifier;
}());
exports.QualifiedIdentifier = QualifiedIdentifier;

},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path='Parser.d.ts' />
var Parser = require("./Parser");
var nodes = require("./AST");
var afpl = require("afpl");
var jsfmt = require("js-beautify");
var TypeScript = require("./TypeScript");
var afpl_1 = require("afpl");
var defaultOptions = {
    debug: false,
    main: 'Main',
    module: '@quenk/wml',
};
/**
 * parse a string as WML returning either an error or an AST.
 */
exports.parse = function (str, ast) {
    if (ast === void 0) { ast = nodes; }
    Parser.parser.yy = { ast: ast };
    try {
        return afpl_1.Either.right(Parser.parser.parse(str));
    }
    catch (e) {
        return afpl_1.Either.left(e);
    }
};
/**
 * pretty up the output.
 */
exports.pretty = function (doit) { return function (s) {
    return doit ? jsfmt(s, {}) : s;
}; };
/**
 * compile a string of WML turning it into typescript code.
 */
exports.compile = function (src, options) {
    if (options === void 0) { options = {}; }
    var opts = afpl.util.merge(defaultOptions, options);
    return exports.parse(src)
        .map(function (m) { return TypeScript.code(m, opts); })
        .map(exports.pretty(options.pretty));
};

},{"./AST":35,"./Parser":37,"./TypeScript":38,"afpl":41,"js-beautify":51}],37:[function(require,module,exports){

/* parser generated by jison 0.6.1-203 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var Parser = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   no try..catch: ................... false
    //   no default resolve on conflict:    false
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main(): 
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3,
  ebnf: true
},
symbols_: {
  "!": 16,
  "!=": 60,
  "$accept": 0,
  "$end": 1,
  "%}": 30,
  "&&": 61,
  "(": 7,
  ")": 8,
  "*": 3,
  "+": 21,
  ",": 6,
  "-": 23,
  ".": 17,
  "/": 22,
  "/>": 37,
  ":": 12,
  ";": 20,
  "<": 13,
  "</": 36,
  "<=": 58,
  "=": 9,
  "==": 59,
  "=>": 50,
  ">": 14,
  ">=": 57,
  "?": 18,
  "@": 19,
  "AS": 27,
  "CHARACTERS": 47,
  "CONSTRUCTOR": 56,
  "ELSE": 45,
  "ENDFOR": 42,
  "ENDFUN": 35,
  "ENDIF": 46,
  "ENDVIEW": 33,
  "EOF": 1,
  "EXPORT": 31,
  "FALSE": 54,
  "FOR": 40,
  "FROM": 26,
  "FUN": 34,
  "IDENTIFIER": 55,
  "IF": 44,
  "IMPORT": 25,
  "IN": 41,
  "INSTANCEOF": 63,
  "MAIN": 29,
  "NUMBER_LITERAL": 52,
  "OTHERWISE": 43,
  "STRING_LITERAL": 51,
  "THEN": 48,
  "TRUE": 53,
  "VIEW": 32,
  "[": 10,
  "\\\\": 49,
  "]": 11,
  "^": 24,
  "aggregate_member": 69,
  "aliased_member": 68,
  "argument_list": 104,
  "arguments": 103,
  "attribute": 93,
  "attribute_value": 94,
  "attribute_value_group": 153,
  "attributes": 92,
  "binary_expression": 107,
  "binary_operator": 137,
  "binary_operator_group": 159,
  "boolean_literal": 128,
  "call_expression": 116,
  "characters": 102,
  "child": 88,
  "child_group": 148,
  "children": 87,
  "composite_member": 70,
  "cons": 131,
  "construct_expression": 115,
  "context_property": 129,
  "context_type": 79,
  "context_variable": 130,
  "control": 98,
  "control_group": 154,
  "else_clause": 101,
  "error": 2,
  "export": 75,
  "export_statement": 76,
  "exports": 74,
  "expression": 105,
  "filter": 97,
  "filters": 96,
  "for_statement": 99,
  "fun_application": 111,
  "fun_statement": 78,
  "fun_target": 112,
  "function_expression": 120,
  "identifier": 134,
  "if_expression": 106,
  "if_statement": 100,
  "import_member": 67,
  "import_statement": 66,
  "import_statement_option": 138,
  "imports": 65,
  "interpolation": 95,
  "list": 125,
  "literal": 121,
  "literal_group": 157,
  "main": 73,
  "main_option": 142,
  "main_option2": 143,
  "main_option3": 144,
  "member": 72,
  "member_expression": 117,
  "member_group": 141,
  "member_list": 71,
  "member_list_group": 139,
  "member_list_group2": 140,
  "module": 64,
  "node": 90,
  "node_option": 149,
  "node_option2": 150,
  "number_literal": 127,
  "parameter": 86,
  "parameter_list": 85,
  "parameters": 84,
  "properties": 123,
  "property": 124,
  "property_group": 158,
  "qualified_constructor": 132,
  "qualified_identifier": 135,
  "read_expression": 118,
  "readable_expression": 119,
  "readable_expression_group": 156,
  "record": 122,
  "simple_expression": 109,
  "simple_expression_group": 155,
  "string_literal": 126,
  "tag": 89,
  "type": 83,
  "type_arg_list": 114,
  "type_arguments": 113,
  "type_class": 82,
  "type_class_list": 81,
  "type_classes": 80,
  "type_option": 147,
  "unary_expression": 108,
  "unqualified_constructor": 133,
  "unqualified_identifier": 136,
  "view_construction": 110,
  "view_statement": 77,
  "view_statement_option": 145,
  "view_statement_option2": 146,
  "widget": 91,
  "widget_option": 151,
  "widget_option2": 152,
  "{": 4,
  "{%": 28,
  "{{": 38,
  "|": 15,
  "||": 62,
  "}": 5,
  "}}": 39
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "*",
  4: "{",
  5: "}",
  6: ",",
  7: "(",
  8: ")",
  9: "=",
  10: "[",
  11: "]",
  12: ":",
  13: "<",
  14: ">",
  15: "|",
  16: "!",
  17: ".",
  18: "?",
  19: "@",
  20: ";",
  21: "+",
  22: "/",
  23: "-",
  24: "^",
  25: "IMPORT",
  26: "FROM",
  27: "AS",
  28: "{%",
  29: "MAIN",
  30: "%}",
  31: "EXPORT",
  32: "VIEW",
  33: "ENDVIEW",
  34: "FUN",
  35: "ENDFUN",
  36: "</",
  37: "/>",
  38: "{{",
  39: "}}",
  40: "FOR",
  41: "IN",
  42: "ENDFOR",
  43: "OTHERWISE",
  44: "IF",
  45: "ELSE",
  46: "ENDIF",
  47: "CHARACTERS",
  48: "THEN",
  49: "\\\\",
  50: "=>",
  51: "STRING_LITERAL",
  52: "NUMBER_LITERAL",
  53: "TRUE",
  54: "FALSE",
  55: "IDENTIFIER",
  56: "CONSTRUCTOR",
  57: ">=",
  58: "<=",
  59: "==",
  60: "!=",
  61: "&&",
  62: "||",
  63: "INSTANCEOF"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [64, 7],
  65,
  65,
  66,
  s,
  [67, 3],
  s,
  [68, 4, 1],
  71,
  72,
  73,
  73,
  74,
  74,
  s,
  [75, 3],
  76,
  77,
  s,
  [78, 16],
  79,
  80,
  81,
  81,
  s,
  [82, 4],
  s,
  [83, 3],
  84,
  84,
  85,
  85,
  86,
  86,
  87,
  87,
  88,
  89,
  89,
  s,
  [90, 4],
  s,
  [91, 4],
  92,
  92,
  s,
  [93, 4],
  94,
  95,
  95,
  96,
  s,
  [96, 4, 1],
  s,
  [99, 5],
  100,
  101,
  101,
  102,
  103,
  103,
  104,
  104,
  s,
  [105, 7],
  106,
  s,
  [107, 4],
  108,
  s,
  [108, 4, 1],
  s,
  [111, 3],
  s,
  [112, 3],
  113,
  114,
  114,
  115,
  s,
  [116, 8],
  s,
  [117, 10],
  s,
  [118, 10],
  119,
  119,
  120,
  120,
  121,
  122,
  122,
  123,
  123,
  124,
  125,
  s,
  [125, 4, 1],
  s,
  [128, 4, 1],
  131,
  132,
  132,
  133,
  134,
  134,
  135,
  s,
  [135, 4, 1],
  138,
  139,
  139,
  140,
  140,
  141,
  141,
  142,
  142,
  143,
  143,
  144,
  144,
  145,
  145,
  146,
  146,
  147,
  147,
  s,
  [148, 5],
  149,
  149,
  150,
  150,
  151,
  151,
  152,
  152,
  153,
  153,
  154,
  154,
  s,
  [155, 10],
  s,
  [156, 4],
  s,
  [157, 5],
  158,
  158,
  s,
  [159, 14]
]),
  rule: u([
  4,
  3,
  3,
  2,
  3,
  2,
  2,
  1,
  2,
  5,
  s,
  [1, 3],
  s,
  [3, 3],
  1,
  3,
  1,
  10,
  1,
  1,
  2,
  s,
  [1, 3],
  6,
  13,
  11,
  10,
  10,
  9,
  10,
  9,
  9,
  8,
  9,
  8,
  8,
  7,
  8,
  7,
  7,
  6,
  c,
  [30, 5],
  c,
  [4, 3],
  2,
  4,
  c,
  [52, 3],
  c,
  [45, 3],
  c,
  [40, 6],
  8,
  7,
  4,
  3,
  c,
  [4, 4],
  c,
  [67, 3],
  c,
  [19, 4],
  3,
  4,
  1,
  c,
  [79, 3],
  10,
  12,
  14,
  14,
  16,
  18,
  6,
  7,
  7,
  1,
  c,
  [42, 4],
  s,
  [1, 6],
  3,
  6,
  3,
  5,
  5,
  7,
  2,
  4,
  1,
  4,
  6,
  5,
  5,
  4,
  c,
  [110, 4],
  c,
  [75, 3],
  c,
  [126, 4],
  3,
  2,
  5,
  c,
  [135, 3],
  s,
  [3, 6],
  5,
  3,
  6,
  8,
  6,
  8,
  c,
  [4, 4],
  10,
  8,
  c,
  [76, 3],
  c,
  [153, 3],
  c,
  [106, 4],
  c,
  [5, 3],
  s,
  [1, 3],
  c,
  [110, 4],
  c,
  [99, 4],
  c,
  [5, 5],
  0,
  s,
  [1, 7],
  0,
  c,
  [10, 3],
  c,
  [4, 8],
  c,
  [17, 13],
  s,
  [1, 39]
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : module $end */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 1];
    this._$ = yylstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 1:
    /*! Production::    module : imports exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 2:
    /*! Production::    module : imports exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 3:
    /*! Production::    module : imports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 4:
    /*! Production::    module : imports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 1], [], null, this._$); 
    return this.$;
    break;

case 5:
    /*! Production::    module : exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 6:
    /*! Production::    module : exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 7:
    /*! Production::    module : main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 8:
    /*! Production::    imports : import_statement */
case 84:
    /*! Production::    filters : filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =  [yyvstack[yysp]];
    break;

case 9:
    /*! Production::    imports : imports import_statement */
case 23:
    /*! Production::    exports : exports export */
case 63:
    /*! Production::    children : children child */
case 76:
    /*! Production::    attributes : attributes attribute */
case 85:
    /*! Production::    filters : filters filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    break;

case 10:
    /*! Production::    import_statement : IMPORT import_member FROM string_literal import_statement_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ImportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 11:
    /*! Production::    import_member : aggregate_member */
case 12:
    /*! Production::    import_member : aliased_member */
case 13:
    /*! Production::    import_member : composite_member */
case 19:
    /*! Production::    member : member_group */
case 24:
    /*! Production::    export : export_statement */
case 25:
    /*! Production::    export : view_statement */
case 161:
    /*! Production::    literal : literal_group */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp];
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 14:
    /*! Production::    aliased_member : member AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AliasedMember(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 15:
    /*! Production::    aggregate_member : "*" AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AggregateMember(yyvstack[yysp], this._$);
    break;

case 16:
    /*! Production::    composite_member : "{" member_list "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CompositeMember(yyvstack[yysp - 1], this._$);
    break;

case 17:
    /*! Production::    member_list : member_list_group */
case 22:
    /*! Production::    exports : export */
case 47:
    /*! Production::    type_class_list : type_class */
case 58:
    /*! Production::    parameter_list : parameter */
case 62:
    /*! Production::    children : child */
case 75:
    /*! Production::    attributes : attribute */
case 100:
    /*! Production::    argument_list : expression */
case 126:
    /*! Production::    type_arg_list : type */
case 164:
    /*! Production::    properties : property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp]];
    break;

case 18:
    /*! Production::    member_list : member_list "," member_list_group2 */
case 48:
    /*! Production::    type_class_list : type_class_list "," type_class */
case 59:
    /*! Production::    parameter_list : parameter_list "," parameter */
case 101:
    /*! Production::    argument_list : argument_list "," expression */
case 127:
    /*! Production::    type_arg_list : type_arg_list "," type */
case 165:
    /*! Production::    properties : properties "," property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 2].concat(yyvstack[yysp]);
    break;

case 20:
    /*! Production::    main : "{%" MAIN main_option main_option2 "(" type ")" main_option3 "%}" tag */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedMain(yyvstack[yysp - 7], yyvstack[yysp - 6]||[], yyvstack[yysp - 4], yyvstack[yysp - 2]||[], yyvstack[yysp], this._$);
    break;

case 21:
    /*! Production::    main : tag */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedMain(yyvstack[yysp], this._$);
    break;

case 26:
    /*! Production::    export : fun_statement */
case 64:
    /*! Production::    child : child_group */
case 65:
    /*! Production::    tag : node */
case 66:
    /*! Production::    tag : widget */
case 81:
    /*! Production::    attribute_value : attribute_value_group */
case 87:
    /*! Production::    control : control_group */
case 102:
    /*! Production::    expression : if_expression */
case 103:
    /*! Production::    expression : binary_expression */
case 105:
    /*! Production::    expression : simple_expression */
case 106:
    /*! Production::    expression : read_expression */
case 107:
    /*! Production::    expression : function_expression */
case 116:
    /*! Production::    simple_expression : simple_expression_group */
case 122:
    /*! Production::    fun_target : identifier */
case 123:
    /*! Production::    fun_target : context_property */
case 157:
    /*! Production::    readable_expression : readable_expression_group */
case 175:
    /*! Production::    cons : qualified_constructor */
case 176:
    /*! Production::    cons : unqualified_constructor */
case 180:
    /*! Production::    identifier : qualified_identifier */
case 181:
    /*! Production::    identifier : unqualified_identifier */
case 185:
    /*! Production::    binary_operator : binary_operator_group */
case 187:
    /*! Production::    import_statement_option : ";" */
case 188:
    /*! Production::    member_list_group : member */
case 189:
    /*! Production::    member_list_group : aliased_member */
case 190:
    /*! Production::    member_list_group2 : member */
case 191:
    /*! Production::    member_list_group2 : aliased_member */
case 192:
    /*! Production::    member_group : unqualified_identifier */
case 193:
    /*! Production::    member_group : unqualified_constructor */
case 195:
    /*! Production::    main_option : unqualified_constructor */
case 197:
    /*! Production::    main_option2 : type_classes */
case 199:
    /*! Production::    main_option3 : parameters */
case 201:
    /*! Production::    view_statement_option : type_classes */
case 203:
    /*! Production::    view_statement_option2 : parameters */
case 205:
    /*! Production::    type_option : type_classes */
case 206:
    /*! Production::    child_group : tag */
case 207:
    /*! Production::    child_group : interpolation */
case 208:
    /*! Production::    child_group : control */
case 209:
    /*! Production::    child_group : characters */
case 210:
    /*! Production::    child_group : identifier */
case 212:
    /*! Production::    node_option : children */
case 214:
    /*! Production::    node_option2 : children */
case 216:
    /*! Production::    widget_option : children */
case 218:
    /*! Production::    widget_option2 : children */
case 219:
    /*! Production::    attribute_value_group : interpolation */
case 220:
    /*! Production::    attribute_value_group : literal */
case 221:
    /*! Production::    control_group : for_statement */
case 222:
    /*! Production::    control_group : if_statement */
case 223:
    /*! Production::    simple_expression_group : view_construction */
case 224:
    /*! Production::    simple_expression_group : fun_application */
case 225:
    /*! Production::    simple_expression_group : construct_expression */
case 226:
    /*! Production::    simple_expression_group : call_expression */
case 227:
    /*! Production::    simple_expression_group : member_expression */
case 228:
    /*! Production::    simple_expression_group : literal */
case 229:
    /*! Production::    simple_expression_group : context_property */
case 230:
    /*! Production::    simple_expression_group : cons */
case 231:
    /*! Production::    simple_expression_group : identifier */
case 232:
    /*! Production::    simple_expression_group : context_variable */
case 233:
    /*! Production::    readable_expression_group : string_literal */
case 234:
    /*! Production::    readable_expression_group : member_expression */
case 235:
    /*! Production::    readable_expression_group : context_property */
case 236:
    /*! Production::    readable_expression_group : call_expression */
case 237:
    /*! Production::    literal_group : record */
case 238:
    /*! Production::    literal_group : list */
case 239:
    /*! Production::    literal_group : string_literal */
case 240:
    /*! Production::    literal_group : number_literal */
case 241:
    /*! Production::    literal_group : boolean_literal */
case 242:
    /*! Production::    property_group : unqualified_identifier */
case 243:
    /*! Production::    property_group : string_literal */
case 244:
    /*! Production::    binary_operator_group : ">" */
case 245:
    /*! Production::    binary_operator_group : ">=" */
case 246:
    /*! Production::    binary_operator_group : "<" */
case 247:
    /*! Production::    binary_operator_group : "<=" */
case 248:
    /*! Production::    binary_operator_group : "==" */
case 249:
    /*! Production::    binary_operator_group : "!=" */
case 250:
    /*! Production::    binary_operator_group : "+" */
case 251:
    /*! Production::    binary_operator_group : "/" */
case 252:
    /*! Production::    binary_operator_group : "-" */
case 253:
    /*! Production::    binary_operator_group : "=" */
case 254:
    /*! Production::    binary_operator_group : "&&" */
case 255:
    /*! Production::    binary_operator_group : "||" */
case 256:
    /*! Production::    binary_operator_group : "^" */
case 257:
    /*! Production::    binary_operator_group : INSTANCEOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp];
    break;

case 27:
    /*! Production::    export_statement : "{%" EXPORT composite_member FROM string_literal "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ExportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 28:
    /*! Production::    view_statement : "{%" VIEW unqualified_constructor view_statement_option "(" type ")" view_statement_option2 "%}" tag "{%" ENDVIEW "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 12, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewStatement(yyvstack[yysp - 10], yyvstack[yysp - 9]||[], yyvstack[yysp - 7], yyvstack[yysp - 5]||[], yyvstack[yysp - 3], this._$);
    break;

case 29:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 8], yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 30:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 31:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], null, yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 32:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], null, [], yyvstack[yysp - 3], this._$);
    break;

case 33:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], [], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 34:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], [], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 35:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6],[],null,yyvstack[yysp - 5],yyvstack[yysp - 3],this._$);
    break;

case 36:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5],[],null,[],yyvstack[yysp - 3],this._$);
    break;

case 37:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 38:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 39:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], null, yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 40:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], yyvstack[yysp - 3], null, [], yyvstack[yysp - 1], this._$);
    break;

case 41:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], [], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 42:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], [], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 43:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4],[],null,yyvstack[yysp - 3],yyvstack[yysp - 1],this._$);
    break;

case 44:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 3],[],null,[],yyvstack[yysp - 1],this._$);
    break;

case 45:
    /*! Production::    context_type : "(" type ")" */
case 46:
    /*! Production::    type_classes : "[" type_class_list "]" */
case 57:
    /*! Production::    parameters : "(" parameter_list ")" */
case 99:
    /*! Production::    arguments : "(" argument_list ")" */
case 108:
    /*! Production::    expression : "(" expression ")" */
case 124:
    /*! Production::    fun_target : "(" expression ")" */
case 125:
    /*! Production::    type_arguments : "[" type_arg_list "]" */
case 158:
    /*! Production::    readable_expression : "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1];
    break;

case 49:
    /*! Production::    type_class : unqualified_identifier */
case 51:
    /*! Production::    type_class : unqualified_constructor */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp], null, this._$);
    break;

case 50:
    /*! Production::    type_class : unqualified_identifier ":" type */
case 52:
    /*! Production::    type_class : unqualified_constructor ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 53:
    /*! Production::    type : cons type_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 1], yyvstack[yysp]||[], false, this._$);
    break;

case 54:
    /*! Production::    type : cons type_classes "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 3], yyvstack[yysp - 2], true, this._$);
    break;

case 55:
    /*! Production::    type : cons "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 2], [], true, this._$);
    break;

case 56:
    /*! Production::    parameters : "(" ")" */
case 98:
    /*! Production::    arguments : "(" ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [];
    break;

case 60:
    /*! Production::    parameter : unqualified_identifier ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedParameter(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 61:
    /*! Production::    parameter : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedParameter(yyvstack[yysp], this._$);
    break;

case 67:
    /*! Production::    node : "<" identifier attributes ">" node_option "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 68:
    /*! Production::    node : "<" identifier ">" node_option2 "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 69:
    /*! Production::    node : "<" identifier attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 70:
    /*! Production::    node : "<" identifier "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 71:
    /*! Production::    widget : "<" cons attributes ">" widget_option "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 72:
    /*! Production::    widget : "<" cons ">" widget_option2 "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 73:
    /*! Production::    widget : "<" cons attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 74:
    /*! Production::    widget : "<" cons "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 77:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 78:
    /*! Production::    attribute : unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Attribute(new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 79:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 2], yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 80:
    /*! Production::    attribute : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(
    new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 82:
    /*! Production::    interpolation : "{{" expression "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 1], [], this._$);
    break;

case 83:
    /*! Production::    interpolation : "{{" expression filters "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 86:
    /*! Production::    filter : "|" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp]
    break;

case 88:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 7], null, null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 89:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 11, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 9], yyvstack[yysp - 7], null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 90:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 91:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" OTHERWISE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], null, null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 92:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" OTHERWISE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 15, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 13], yyvstack[yysp - 11], null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 93:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" OTHERWISE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 17, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 15], yyvstack[yysp - 13], null, yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 3], this._$);
    break;

case 94:
    /*! Production::    if_statement : "{%" IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 95:
    /*! Production::    else_clause : "{%" ELSE "%}" children "{%" ENDIF "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseClause(yyvstack[yysp - 3], this._$);
    break;

case 96:
    /*! Production::    else_clause : "{%" ELSE IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseIfClause(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 97:
    /*! Production::    characters : CHARACTERS */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Characters(yyvstack[yysp], this._$);
    break;

case 104:
    /*! Production::    expression : unary_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =yyvstack[yysp];
    break;

case 109:
    /*! Production::    if_expression : IF expression THEN expression ELSE expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfThenExpression(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 110:
    /*! Production::    binary_expression : simple_expression binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 111:
    /*! Production::    binary_expression : simple_expression binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 112:
    /*! Production::    binary_expression : "(" expression ")" binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 113:
    /*! Production::    binary_expression : "(" expression ")" binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 114:
    /*! Production::    unary_expression : "!" simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 115:
    /*! Production::    unary_expression : "!" "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 117:
    /*! Production::    view_construction : "<" cons arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewConstruction(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 118:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 119:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$);
    break;

case 120:
    /*! Production::    fun_application : "<" fun_target arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], [], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 121:
    /*! Production::    fun_application : "<" fun_target arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 2], [], [], yyvstack[yysp - 1], this._$);
    break;

case 128:
    /*! Production::    construct_expression : cons arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ConstructExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 129:
    /*! Production::    call_expression : identifier type_arguments arguments */
case 131:
    /*! Production::    call_expression : context_property type_arguments arguments */
case 133:
    /*! Production::    call_expression : member_expression type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 130:
    /*! Production::    call_expression : identifier arguments */
case 132:
    /*! Production::    call_expression : context_property arguments */
case 134:
    /*! Production::    call_expression : member_expression arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 1], [], yyvstack[yysp], this._$);
    break;

case 135:
    /*! Production::    call_expression : "(" expression ")" type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 136:
    /*! Production::    call_expression : "(" expression ")" arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], [], yyvstack[yysp], this._$);
    break;

case 137:
    /*! Production::    member_expression : qualified_identifier "." unqualified_identifier */
case 138:
    /*! Production::    member_expression : qualified_constructor "." unqualified_identifier */
case 139:
    /*! Production::    member_expression : context_variable "." unqualified_identifier */
case 140:
    /*! Production::    member_expression : context_property "." unqualified_identifier */
case 141:
    /*! Production::    member_expression : list "." unqualified_identifier */
case 142:
    /*! Production::    member_expression : record "." unqualified_identifier */
case 143:
    /*! Production::    member_expression : string_literal "." unqualified_identifier */
case 144:
    /*! Production::    member_expression : call_expression "." unqualified_identifier */
case 146:
    /*! Production::    member_expression : member_expression "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 145:
    /*! Production::    member_expression : "(" expression ")" "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 3], yyvstack[yysp], this._$);
    break;

case 147:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "]" */
case 149:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "]" */
case 151:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "]" */
case 153:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], null, this._$);
    break;

case 148:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "?" expression "]" */
case 150:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "?" expression "]" */
case 152:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "?" expression "]" */
case 154:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 155:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 156:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], null, this._$);
    break;

case 159:
    /*! Production::    function_expression : "\\" parameter_list "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 160:
    /*! Production::    function_expression : "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression([], yyvstack[yysp], this._$);
    break;

case 162:
    /*! Production::    record : "{" "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record([], this._$);
    break;

case 163:
    /*! Production::    record : "{" properties "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record(yyvstack[yysp - 1], this._$);
    break;

case 166:
    /*! Production::    property : property_group ":" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Property(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 167:
    /*! Production::    list : "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List([], this._$);
    break;

case 168:
    /*! Production::    list : "[" argument_list "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List(yyvstack[yysp - 1], this._$);
    break;

case 169:
    /*! Production::    string_literal : STRING_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.StringLiteral(yyvstack[yysp].slice(1, yyvstack[yysp].length - 1, this._$));
    break;

case 170:
    /*! Production::    number_literal : NUMBER_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.NumberLiteral(yyvstack[yysp], this._$);
    break;

case 171:
    /*! Production::    boolean_literal : TRUE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(true, this._$);
    break;

case 172:
    /*! Production::    boolean_literal : FALSE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(false, this._$);
    break;

case 173:
    /*! Production::    context_property : "@" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextProperty(yyvstack[yysp], this._$)
    break;

case 174:
    /*! Production::    context_variable : "@" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextVariable(this._$);
    break;

case 177:
    /*! Production::    qualified_constructor : IDENTIFIER "." CONSTRUCTOR */
case 178:
    /*! Production::    qualified_constructor : CONSTRUCTOR "." CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedConstructor(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 179:
    /*! Production::    unqualified_constructor : CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedConstructor(yyvstack[yysp], this._$);
    break;

case 182:
    /*! Production::    qualified_identifier : IDENTIFIER "." IDENTIFIER */
case 183:
    /*! Production::    qualified_identifier : CONSTRUCTOR "." IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedIdentifier(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 184:
    /*! Production::    unqualified_identifier : IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedIdentifier(yyvstack[yysp], this._$);
    break;

case 186:
    /*! Production::    import_statement_option : %epsilon */
case 194:
    /*! Production::    main_option : %epsilon */
case 196:
    /*! Production::    main_option2 : %epsilon */
case 198:
    /*! Production::    main_option3 : %epsilon */
case 200:
    /*! Production::    view_statement_option : %epsilon */
case 202:
    /*! Production::    view_statement_option2 : %epsilon */
case 204:
    /*! Production::    type_option : %epsilon */
case 211:
    /*! Production::    node_option : %epsilon */
case 213:
    /*! Production::    node_option2 : %epsilon */
case 215:
    /*! Production::    widget_option : %epsilon */
case 217:
    /*! Production::    widget_option2 : %epsilon */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = undefined;
    break;

}
},
table: bt({
  len: u([
  15,
  1,
  14,
  11,
  1,
  0,
  0,
  4,
  0,
  12,
  s,
  [0, 5],
  8,
  c,
  [13, 4],
  c,
  [3, 3],
  0,
  5,
  s,
  [2, 3],
  c,
  [8, 4],
  1,
  1,
  9,
  s,
  [0, 5],
  6,
  6,
  s,
  [0, 4],
  29,
  29,
  c,
  [20, 4],
  4,
  0,
  1,
  4,
  7,
  2,
  6,
  6,
  2,
  0,
  3,
  0,
  5,
  23,
  c,
  [44, 3],
  c,
  [5, 3],
  2,
  2,
  c,
  [55, 3],
  6,
  c,
  [51, 3],
  5,
  4,
  2,
  21,
  20,
  10,
  c,
  [46, 5],
  8,
  c,
  [28, 3],
  1,
  21,
  s,
  [0, 7],
  43,
  s,
  [0, 4],
  10,
  1,
  2,
  2,
  17,
  23,
  c,
  [21, 7],
  c,
  [64, 4],
  3,
  1,
  6,
  c,
  [48, 4],
  c,
  [3, 3],
  5,
  21,
  20,
  20,
  1,
  1,
  0,
  2,
  9,
  c,
  [66, 3],
  c,
  [115, 4],
  3,
  c,
  [38, 3],
  5,
  c,
  [107, 3],
  0,
  0,
  26,
  c,
  [61, 3],
  43,
  33,
  0,
  28,
  26,
  29,
  29,
  4,
  c,
  [70, 4],
  25,
  0,
  26,
  27,
  28,
  27,
  s,
  [25, 3],
  12,
  0,
  45,
  8,
  s,
  [0, 5],
  1,
  1,
  3,
  43,
  c,
  [42, 4],
  c,
  [12, 5],
  21,
  5,
  c,
  [71, 3],
  5,
  c,
  [176, 3],
  1,
  c,
  [86, 3],
  c,
  [85, 4],
  c,
  [4, 4],
  20,
  1,
  3,
  c,
  [84, 5],
  7,
  7,
  6,
  1,
  1,
  5,
  1,
  c,
  [10, 3],
  c,
  [82, 3],
  s,
  [0, 14],
  c,
  [54, 3],
  43,
  15,
  15,
  14,
  11,
  24,
  2,
  0,
  45,
  20,
  2,
  24,
  c,
  [209, 3],
  c,
  [4, 4],
  2,
  0,
  c,
  [4, 5],
  s,
  [2, 4],
  c,
  [98, 3],
  43,
  c,
  [13, 4],
  c,
  [3, 3],
  c,
  [262, 3],
  2,
  1,
  17,
  5,
  1,
  c,
  [117, 4],
  4,
  c,
  [96, 8],
  c,
  [4, 4],
  c,
  [182, 3],
  c,
  [29, 4],
  c,
  [294, 4],
  c,
  [46, 3],
  31,
  43,
  1,
  7,
  1,
  2,
  c,
  [251, 3],
  c,
  [301, 4],
  s,
  [1, 3],
  c,
  [47, 3],
  c,
  [7, 4],
  c,
  [34, 7],
  c,
  [274, 5],
  c,
  [10, 3],
  2,
  3,
  c,
  [122, 3],
  0,
  6,
  43,
  43,
  3,
  21,
  c,
  [62, 5],
  1,
  c,
  [74, 8],
  c,
  [3, 3],
  c,
  [387, 5],
  33,
  45,
  c,
  [350, 4],
  15,
  6,
  0,
  6,
  c,
  [355, 3],
  c,
  [393, 4],
  c,
  [49, 3],
  c,
  [58, 6],
  21,
  0,
  4,
  4,
  c,
  [38, 5],
  c,
  [17, 3],
  15,
  0,
  43,
  1,
  22,
  c,
  [163, 5],
  6,
  c,
  [444, 6],
  21,
  43,
  c,
  [70, 5],
  c,
  [67, 5],
  c,
  [53, 3],
  43,
  c,
  [101, 3],
  c,
  [4, 4],
  c,
  [358, 3],
  c,
  [30, 3],
  15,
  c,
  [137, 4],
  1,
  4,
  21,
  43,
  21,
  43,
  1,
  c,
  [137, 6],
  1,
  c,
  [197, 3],
  20,
  c,
  [74, 4],
  21,
  4,
  21,
  c,
  [138, 3],
  c,
  [39, 3],
  c,
  [315, 3],
  3,
  c,
  [14, 3],
  c,
  [27, 3],
  c,
  [410, 4],
  c,
  [11, 3],
  1,
  20,
  c,
  [123, 4]
]),
  symbol: u([
  13,
  25,
  28,
  64,
  65,
  66,
  s,
  [73, 6, 1],
  89,
  90,
  91,
  1,
  1,
  c,
  [17, 3],
  c,
  [15, 11],
  13,
  28,
  73,
  c,
  [11, 8],
  29,
  31,
  32,
  34,
  3,
  4,
  55,
  56,
  s,
  [67, 4, 1],
  72,
  133,
  136,
  141,
  55,
  56,
  s,
  [131, 6, 1],
  c,
  [36, 12],
  1,
  7,
  10,
  56,
  133,
  142,
  4,
  70,
  56,
  133,
  55,
  136,
  26,
  27,
  27,
  55,
  56,
  68,
  71,
  c,
  [43, 3],
  139,
  141,
  14,
  37,
  55,
  92,
  93,
  136,
  c,
  [6, 6],
  s,
  [5, 7, 1],
  13,
  14,
  15,
  17,
  s,
  [21, 4, 1],
  27,
  30,
  37,
  39,
  45,
  48,
  55,
  s,
  [57, 7, 1],
  c,
  [29, 29],
  c,
  [94, 3],
  80,
  143,
  26,
  c,
  [5, 3],
  145,
  7,
  9,
  10,
  30,
  79,
  80,
  84,
  51,
  126,
  55,
  56,
  c,
  [139, 6],
  c,
  [6, 4],
  5,
  6,
  5,
  6,
  27,
  c,
  [100, 3],
  93,
  136,
  13,
  28,
  36,
  38,
  47,
  55,
  56,
  s,
  [87, 5, 1],
  95,
  98,
  99,
  100,
  102,
  c,
  [167, 3],
  148,
  150,
  154,
  9,
  12,
  c,
  [30, 3],
  c,
  [33, 26],
  152,
  154,
  55,
  56,
  55,
  56,
  7,
  55,
  56,
  81,
  82,
  133,
  136,
  51,
  126,
  7,
  7,
  9,
  30,
  79,
  84,
  c,
  [5, 3],
  84,
  9,
  30,
  13,
  28,
  c,
  [47, 18],
  154,
  c,
  [21, 6],
  c,
  [20, 14],
  8,
  55,
  56,
  83,
  85,
  86,
  c,
  [281, 3],
  c,
  [279, 3],
  20,
  25,
  28,
  138,
  c,
  [258, 3],
  c,
  [155, 3],
  140,
  141,
  c,
  [113, 21],
  149,
  154,
  36,
  c,
  [24, 7],
  c,
  [69, 14],
  s,
  [4, 6, 3],
  44,
  s,
  [49, 8, 1],
  s,
  [105, 7, 1],
  s,
  [115, 4, 1],
  120,
  121,
  122,
  s,
  [125, 12, 1],
  155,
  157,
  13,
  14,
  17,
  28,
  30,
  c,
  [67, 5],
  17,
  40,
  44,
  55,
  136,
  4,
  10,
  38,
  c,
  [52, 4],
  94,
  95,
  c,
  [40, 6],
  153,
  157,
  c,
  [120, 21],
  151,
  c,
  [120, 23],
  c,
  [188, 3],
  c,
  [88, 3],
  6,
  11,
  6,
  11,
  12,
  c,
  [3, 3],
  30,
  c,
  [15, 6],
  c,
  [257, 47],
  c,
  [300, 45],
  85,
  86,
  c,
  [394, 3],
  c,
  [46, 39],
  c,
  [20, 20],
  30,
  8,
  6,
  8,
  6,
  8,
  10,
  11,
  18,
  41,
  50,
  80,
  147,
  6,
  8,
  12,
  41,
  50,
  c,
  [5, 3],
  17,
  c,
  [18, 4],
  14,
  17,
  c,
  [20, 3],
  c,
  [527, 3],
  c,
  [233, 24],
  c,
  [7, 3],
  15,
  39,
  96,
  97,
  5,
  6,
  8,
  9,
  c,
  [621, 4],
  c,
  [620, 6],
  c,
  [619, 3],
  c,
  [618, 7],
  137,
  159,
  c,
  [388, 43],
  c,
  [43, 47],
  19,
  c,
  [39, 6],
  c,
  [35, 6],
  c,
  [33, 16],
  c,
  [768, 10],
  c,
  [147, 16],
  103,
  113,
  c,
  [173, 4],
  c,
  [795, 12],
  c,
  [28, 10],
  c,
  [822, 17],
  c,
  [55, 14],
  c,
  [29, 27],
  c,
  [387, 4],
  c,
  [192, 43],
  c,
  [304, 8],
  c,
  [130, 22],
  c,
  [183, 21],
  c,
  [127, 27],
  c,
  [209, 19],
  c,
  [1003, 8],
  c,
  [1062, 18],
  c,
  [55, 14],
  c,
  [25, 71],
  7,
  19,
  55,
  56,
  112,
  129,
  c,
  [222, 6],
  c,
  [263, 3],
  11,
  c,
  [264, 12],
  s,
  [104, 8, 1],
  c,
  [265, 22],
  51,
  55,
  123,
  124,
  126,
  136,
  158,
  s,
  [55, 3],
  c,
  [321, 45],
  9,
  c,
  [1151, 3],
  c,
  [660, 24],
  c,
  [36, 3],
  8,
  17,
  55,
  56,
  c,
  [1149, 3],
  c,
  [890, 6],
  c,
  [6, 6],
  8,
  c,
  [850, 43],
  c,
  [845, 62],
  c,
  [62, 68],
  c,
  [21, 15],
  35,
  c,
  [1173, 3],
  86,
  136,
  c,
  [931, 7],
  11,
  c,
  [1370, 6],
  c,
  [215, 6],
  56,
  c,
  [1387, 3],
  c,
  [36, 3],
  14,
  15,
  39,
  97,
  c,
  [832, 76],
  8,
  48,
  c,
  [718, 45],
  7,
  c,
  [154, 3],
  15,
  17,
  c,
  [530, 5],
  c,
  [809, 6],
  c,
  [15, 18],
  c,
  [14, 9],
  8,
  c,
  [27, 8],
  c,
  [98, 3],
  19,
  51,
  c,
  [198, 3],
  114,
  116,
  117,
  119,
  c,
  [82, 3],
  c,
  [80, 8],
  156,
  7,
  103,
  4,
  c,
  [50, 3],
  c,
  [579, 41],
  c,
  [71, 7],
  c,
  [69, 8],
  132,
  c,
  [67, 4],
  c,
  [1474, 3],
  c,
  [93, 23],
  55,
  136,
  c,
  [95, 4],
  c,
  [28, 26],
  6,
  50,
  55,
  136,
  55,
  136,
  c,
  [4, 8],
  7,
  103,
  7,
  10,
  103,
  113,
  c,
  [267, 43],
  55,
  136,
  6,
  11,
  5,
  6,
  12,
  6,
  41,
  30,
  c,
  [1603, 17],
  c,
  [665, 5],
  14,
  7,
  30,
  84,
  144,
  c,
  [4, 3],
  146,
  c,
  [549, 86],
  c,
  [24, 24],
  c,
  [3, 3],
  30,
  11,
  14,
  c,
  [467, 47],
  c,
  [1261, 25],
  c,
  [1494, 45],
  c,
  [1994, 4],
  114,
  c,
  [13, 3],
  27,
  6,
  11,
  c,
  [54, 43],
  17,
  27,
  7,
  10,
  17,
  27,
  103,
  113,
  c,
  [6, 6],
  17,
  27,
  s,
  [17, 3],
  c,
  [394, 4],
  6,
  8,
  c,
  [10, 3],
  27,
  27,
  c,
  [73, 43],
  14,
  c,
  [451, 3],
  14,
  103,
  8,
  c,
  [50, 43],
  51,
  55,
  c,
  [1169, 4],
  c,
  [1720, 86],
  c,
  [965, 3],
  c,
  [505, 21],
  14,
  30,
  c,
  [467, 25],
  c,
  [443, 4],
  c,
  [4, 4],
  30,
  c,
  [196, 5],
  c,
  [949, 29],
  c,
  [137, 15],
  83,
  c,
  [138, 7],
  s,
  [114, 5, 1],
  c,
  [682, 19],
  7,
  103,
  45,
  c,
  [939, 15],
  c,
  [1328, 13],
  c,
  [13, 12],
  c,
  [2243, 7],
  14,
  103,
  14,
  30,
  6,
  41,
  c,
  [170, 14],
  101,
  c,
  [679, 7],
  c,
  [15, 3],
  c,
  [4, 4],
  c,
  [171, 5],
  30,
  c,
  [88, 15],
  c,
  [290, 43],
  27,
  6,
  c,
  [2708, 3],
  c,
  [632, 3],
  c,
  [630, 5],
  c,
  [626, 7],
  80,
  103,
  147,
  c,
  [66, 43],
  11,
  18,
  c,
  [565, 6],
  11,
  18,
  11,
  18,
  11,
  18,
  14,
  c,
  [368, 21],
  c,
  [435, 46],
  40,
  44,
  45,
  28,
  30,
  c,
  [272, 7],
  c,
  [2256, 90],
  c,
  [43, 82],
  c,
  [595, 21],
  41,
  30,
  44,
  33,
  c,
  [415, 15],
  c,
  [296, 3],
  s,
  [11, 3],
  40,
  42,
  43,
  c,
  [1088, 7],
  c,
  [301, 58],
  c,
  [64, 64],
  30,
  c,
  [44, 44],
  c,
  [819, 22],
  c,
  [21, 21],
  11,
  c,
  [153, 21],
  c,
  [242, 25],
  40,
  44,
  46,
  c,
  [1440, 41],
  c,
  [135, 37],
  c,
  [805, 7],
  40,
  42,
  c,
  [112, 23],
  c,
  [137, 3],
  c,
  [71, 22],
  30,
  c,
  [51, 24],
  c,
  [47, 21],
  c,
  [45, 3],
  30
]),
  type: u([
  s,
  [2, 3],
  s,
  [0, 12],
  1,
  s,
  [2, 4],
  s,
  [0, 10],
  c,
  [13, 11],
  s,
  [2, 9],
  c,
  [17, 10],
  c,
  [36, 22],
  c,
  [7, 3],
  0,
  2,
  c,
  [4, 4],
  c,
  [45, 11],
  c,
  [10, 6],
  c,
  [6, 9],
  s,
  [2, 58],
  c,
  [69, 7],
  c,
  [91, 7],
  c,
  [101, 4],
  c,
  [139, 10],
  c,
  [36, 13],
  c,
  [200, 14],
  c,
  [195, 14],
  c,
  [33, 32],
  c,
  [11, 5],
  c,
  [100, 7],
  c,
  [5, 4],
  c,
  [250, 16],
  c,
  [46, 13],
  c,
  [20, 17],
  c,
  [268, 13],
  c,
  [293, 11],
  c,
  [146, 30],
  c,
  [22, 20],
  c,
  [53, 23],
  c,
  [43, 26],
  c,
  [103, 18],
  c,
  [120, 47],
  c,
  [83, 15],
  c,
  [210, 8],
  c,
  [257, 46],
  c,
  [43, 42],
  c,
  [25, 23],
  c,
  [89, 27],
  c,
  [254, 25],
  c,
  [600, 31],
  c,
  [122, 21],
  c,
  [52, 26],
  c,
  [388, 59],
  c,
  [43, 40],
  c,
  [76, 37],
  c,
  [225, 42],
  c,
  [55, 53],
  c,
  [743, 4],
  c,
  [235, 60],
  c,
  [128, 36],
  c,
  [1000, 55],
  s,
  [2, 106],
  c,
  [220, 24],
  s,
  [0, 29],
  c,
  [32, 8],
  c,
  [556, 60],
  c,
  [782, 23],
  c,
  [905, 11],
  c,
  [1400, 21],
  c,
  [804, 47],
  c,
  [845, 48],
  c,
  [62, 76],
  c,
  [642, 17],
  c,
  [215, 14],
  c,
  [1118, 15],
  c,
  [832, 85],
  c,
  [718, 41],
  c,
  [15, 29],
  c,
  [762, 20],
  c,
  [79, 18],
  c,
  [579, 49],
  c,
  [36, 17],
  c,
  [1474, 19],
  c,
  [26, 10],
  c,
  [28, 32],
  c,
  [1912, 8],
  c,
  [16, 7],
  c,
  [664, 46],
  c,
  [45, 26],
  c,
  [1979, 10],
  c,
  [84, 10],
  c,
  [549, 81],
  c,
  [1798, 34],
  c,
  [1185, 65],
  c,
  [1451, 50],
  c,
  [82, 23],
  c,
  [128, 34],
  c,
  [735, 8],
  c,
  [1412, 31],
  c,
  [73, 30],
  c,
  [3, 6],
  c,
  [50, 45],
  c,
  [1485, 61],
  c,
  [543, 30],
  c,
  [505, 28],
  c,
  [443, 64],
  c,
  [822, 44],
  c,
  [777, 12],
  c,
  [351, 11],
  c,
  [257, 13],
  c,
  [13, 12],
  c,
  [332, 9],
  c,
  [1351, 24],
  c,
  [4, 8],
  c,
  [2053, 78],
  c,
  [48, 8],
  c,
  [571, 55],
  c,
  [1525, 30],
  c,
  [435, 46],
  c,
  [536, 93],
  c,
  [43, 91],
  c,
  [352, 32],
  c,
  [1970, 33],
  c,
  [114, 63],
  c,
  [510, 60],
  c,
  [44, 36],
  c,
  [1307, 43],
  c,
  [110, 25],
  c,
  [911, 38],
  c,
  [2985, 43],
  c,
  [88, 52],
  c,
  [2969, 32],
  c,
  [232, 38]
]),
  state: u([
  1,
  2,
  5,
  4,
  3,
  6,
  10,
  11,
  12,
  8,
  13,
  14,
  19,
  17,
  16,
  c,
  [10, 7],
  20,
  22,
  c,
  [8, 6],
  28,
  30,
  29,
  31,
  33,
  37,
  36,
  35,
  41,
  44,
  45,
  40,
  42,
  43,
  48,
  c,
  [22, 7],
  53,
  52,
  54,
  55,
  56,
  63,
  60,
  62,
  37,
  36,
  61,
  35,
  64,
  67,
  68,
  69,
  67,
  68,
  76,
  75,
  80,
  79,
  82,
  81,
  83,
  87,
  89,
  c,
  [44, 3],
  90,
  c,
  [4, 3],
  95,
  68,
  97,
  98,
  100,
  13,
  14,
  101,
  102,
  108,
  109,
  103,
  104,
  42,
  43,
  99,
  96,
  106,
  95,
  68,
  118,
  c,
  [18, 13],
  117,
  106,
  124,
  125,
  127,
  126,
  128,
  130,
  131,
  134,
  140,
  c,
  [24, 13],
  106,
  141,
  c,
  [14, 13],
  142,
  144,
  146,
  145,
  44,
  45,
  147,
  150,
  154,
  153,
  37,
  36,
  152,
  35,
  156,
  c,
  [43, 13],
  155,
  106,
  158,
  c,
  [44, 13],
  s,
  [159, 5, 1],
  s,
  [176, 4, 1],
  173,
  164,
  165,
  180,
  186,
  185,
  187,
  192,
  193,
  172,
  171,
  181,
  184,
  45,
  170,
  182,
  43,
  169,
  189,
  201,
  202,
  s,
  [204, 5, 1],
  192,
  193,
  203,
  189,
  210,
  c,
  [69, 13],
  209,
  c,
  [69, 15],
  212,
  c,
  [111, 3],
  219,
  c,
  [4, 3],
  220,
  225,
  c,
  [151, 14],
  226,
  c,
  [14, 13],
  229,
  c,
  [29, 14],
  230,
  c,
  [14, 13],
  144,
  146,
  147,
  231,
  c,
  [32, 14],
  232,
  c,
  [14, 13],
  c,
  [113, 14],
  239,
  238,
  c,
  [16, 14],
  245,
  42,
  43,
  247,
  248,
  250,
  251,
  266,
  c,
  [205, 27],
  267,
  c,
  [28, 27],
  268,
  c,
  [24, 4],
  270,
  c,
  [22, 6],
  271,
  273,
  c,
  [22, 3],
  272,
  c,
  [22, 4],
  276,
  275,
  283,
  282,
  287,
  286,
  288,
  146,
  147,
  289,
  c,
  [59, 27],
  291,
  293,
  299,
  301,
  298,
  44,
  45,
  300,
  42,
  43,
  305,
  306,
  c,
  [39, 27],
  308,
  309,
  312,
  311,
  310,
  313,
  147,
  314,
  c,
  [35, 27],
  c,
  [210, 14],
  317,
  44,
  45,
  319,
  127,
  126,
  320,
  c,
  [341, 3],
  321,
  c,
  [4, 3],
  325,
  c,
  [283, 14],
  326,
  c,
  [14, 13],
  327,
  c,
  [29, 14],
  328,
  c,
  [312, 27],
  331,
  c,
  [43, 14],
  332,
  c,
  [43, 27],
  c,
  [14, 14],
  338,
  147,
  c,
  [634, 4],
  341,
  c,
  [139, 3],
  342,
  42,
  43,
  345,
  346,
  c,
  [199, 27],
  347,
  c,
  [332, 21],
  351,
  c,
  [50, 27],
  287,
  286,
  283,
  282,
  276,
  275,
  357,
  354,
  361,
  359,
  353,
  364,
  363,
  358,
  360,
  362,
  145,
  184,
  45,
  365,
  182,
  43,
  355,
  366,
  368,
  c,
  [337, 28],
  361,
  359,
  369,
  c,
  [45, 5],
  370,
  c,
  [43, 4],
  372,
  c,
  [61, 4],
  373,
  c,
  [61, 12],
  374,
  375,
  c,
  [19, 4],
  376,
  c,
  [19, 12],
  377,
  378,
  s,
  [380, 7, 1],
  388,
  387,
  389,
  c,
  [89, 27],
  293,
  398,
  c,
  [757, 9],
  399,
  44,
  45,
  402,
  401,
  404,
  403,
  405,
  c,
  [309, 14],
  406,
  c,
  [309, 41],
  c,
  [14, 14],
  419,
  c,
  [117, 27],
  424,
  423,
  420,
  251,
  425,
  c,
  [32, 27],
  357,
  354,
  c,
  [378, 3],
  430,
  c,
  [324, 33],
  435,
  c,
  [34, 27],
  437,
  438,
  441,
  c,
  [30, 27],
  442,
  c,
  [671, 3],
  443,
  c,
  [32, 27],
  444,
  c,
  [28, 27],
  445,
  147,
  446,
  c,
  [290, 14],
  c,
  [248, 14],
  459,
  c,
  [529, 21],
  357,
  461,
  c,
  [82, 6],
  354,
  c,
  [83, 13],
  462,
  c,
  [83, 7],
  463,
  464,
  424,
  423,
  466,
  c,
  [243, 3],
  467,
  c,
  [4, 3],
  469,
  c,
  [4, 3],
  470,
  c,
  [4, 3],
  471,
  c,
  [4, 3],
  472,
  c,
  [91, 8],
  478,
  c,
  [92, 6],
  480,
  13,
  14,
  481,
  13,
  14,
  424,
  423,
  486,
  c,
  [159, 27],
  239,
  291,
  238,
  488,
  c,
  [379, 29],
  498,
  c,
  [190, 14],
  499,
  c,
  [45, 27],
  500,
  147,
  505,
  c,
  [134, 3],
  506,
  c,
  [34, 27],
  507,
  c,
  [28, 27],
  508,
  c,
  [28, 27],
  509,
  c,
  [1050, 41],
  424,
  423,
  524,
  c,
  [177, 14],
  525,
  c,
  [59, 27],
  526,
  c,
  [43, 14],
  527,
  c,
  [43, 27],
  529,
  c,
  [130, 41],
  c,
  [14, 14],
  537,
  c,
  [99, 14],
  540,
  c,
  [15, 14],
  542,
  c,
  [539, 28],
  c,
  [14, 22],
  548,
  c,
  [15, 6],
  550,
  c,
  [58, 28],
  558,
  c,
  [29, 28]
]),
  mode: u([
  s,
  [1, 26],
  2,
  2,
  c,
  [17, 17],
  s,
  [2, 8],
  c,
  [11, 11],
  s,
  [2, 18],
  c,
  [29, 19],
  1,
  c,
  [75, 3],
  c,
  [78, 13],
  c,
  [92, 8],
  c,
  [7, 8],
  c,
  [16, 7],
  c,
  [114, 16],
  c,
  [152, 24],
  c,
  [47, 6],
  c,
  [46, 8],
  c,
  [54, 20],
  c,
  [135, 10],
  c,
  [23, 14],
  c,
  [51, 16],
  c,
  [77, 9],
  s,
  [1, 55],
  c,
  [104, 9],
  c,
  [7, 6],
  c,
  [6, 13],
  c,
  [104, 14],
  c,
  [261, 10],
  c,
  [151, 18],
  c,
  [246, 41],
  c,
  [372, 29],
  c,
  [377, 21],
  c,
  [27, 50],
  c,
  [122, 18],
  c,
  [472, 27],
  s,
  [2, 31],
  c,
  [33, 33],
  c,
  [36, 21],
  c,
  [231, 30],
  c,
  [25, 62],
  c,
  [370, 44],
  c,
  [45, 4],
  c,
  [541, 60],
  c,
  [560, 26],
  c,
  [62, 59],
  c,
  [731, 12],
  c,
  [13, 17],
  c,
  [249, 16],
  s,
  [1, 96],
  c,
  [725, 5],
  c,
  [270, 62],
  c,
  [355, 5],
  c,
  [1023, 7],
  c,
  [179, 48],
  c,
  [417, 8],
  c,
  [135, 63],
  c,
  [483, 82],
  c,
  [408, 9],
  c,
  [44, 60],
  c,
  [467, 16],
  c,
  [79, 23],
  c,
  [251, 109],
  c,
  [221, 44],
  s,
  [1, 142]
]),
  goto: u([
  15,
  9,
  7,
  18,
  c,
  [4, 3],
  21,
  15,
  7,
  s,
  [23, 5, 1],
  32,
  34,
  38,
  39,
  46,
  47,
  49,
  15,
  7,
  50,
  51,
  194,
  194,
  39,
  34,
  39,
  38,
  57,
  58,
  59,
  38,
  39,
  65,
  66,
  38,
  70,
  71,
  38,
  s,
  [184, 10],
  72,
  s,
  [184, 18],
  s,
  [179, 10],
  73,
  s,
  [179, 18],
  74,
  196,
  77,
  78,
  200,
  77,
  86,
  85,
  77,
  84,
  88,
  38,
  39,
  38,
  39,
  91,
  92,
  188,
  188,
  59,
  93,
  94,
  38,
  15,
  112,
  213,
  105,
  107,
  110,
  111,
  114,
  113,
  s,
  [80, 3],
  115,
  116,
  c,
  [15, 3],
  217,
  c,
  [15, 4],
  s,
  [119, 5, 1],
  38,
  39,
  88,
  129,
  86,
  133,
  132,
  137,
  136,
  135,
  139,
  138,
  15,
  112,
  c,
  [23, 4],
  c,
  [6, 6],
  143,
  148,
  149,
  186,
  186,
  151,
  186,
  186,
  38,
  39,
  15,
  112,
  211,
  c,
  [17, 4],
  157,
  15,
  112,
  214,
  c,
  [8, 4],
  191,
  166,
  190,
  188,
  168,
  183,
  167,
  174,
  175,
  88,
  194,
  195,
  196,
  46,
  47,
  184,
  184,
  197,
  s,
  [184, 7],
  198,
  199,
  200,
  38,
  191,
  190,
  105,
  c,
  [23, 4],
  15,
  112,
  215,
  c,
  [43, 4],
  211,
  15,
  112,
  218,
  c,
  [8, 4],
  213,
  149,
  215,
  214,
  49,
  49,
  216,
  51,
  51,
  217,
  218,
  213,
  149,
  137,
  222,
  221,
  224,
  223,
  c,
  [106, 12],
  228,
  227,
  c,
  [120, 13],
  c,
  [158, 3],
  c,
  [14, 10],
  15,
  233,
  c,
  [6, 4],
  234,
  235,
  237,
  236,
  204,
  204,
  240,
  s,
  [204, 4],
  61,
  61,
  241,
  61,
  61,
  s,
  [184, 3],
  242,
  s,
  [179, 5],
  243,
  s,
  [179, 3],
  190,
  190,
  59,
  244,
  15,
  112,
  212,
  c,
  [40, 4],
  110,
  111,
  249,
  246,
  s,
  [105, 3],
  261,
  105,
  254,
  252,
  105,
  258,
  259,
  260,
  264,
  s,
  [105, 5],
  253,
  255,
  256,
  257,
  262,
  263,
  265,
  c,
  [183, 15],
  c,
  [15, 16],
  269,
  190,
  188,
  183,
  c,
  [11, 6],
  231,
  231,
  277,
  231,
  231,
  274,
  s,
  [231, 20],
  s,
  [232, 4],
  278,
  s,
  [232, 4],
  279,
  s,
  [232, 16],
  229,
  229,
  277,
  229,
  229,
  280,
  s,
  [229, 4],
  281,
  s,
  [229, 16],
  227,
  227,
  277,
  227,
  227,
  284,
  s,
  [227, 4],
  285,
  s,
  [227, 16],
  38,
  c,
  [133, 15],
  s,
  [226, 8],
  290,
  s,
  [226, 16],
  230,
  230,
  277,
  s,
  [230, 22],
  s,
  [180, 10],
  292,
  s,
  [180, 16],
  s,
  [174, 19],
  38,
  s,
  [174, 7],
  s,
  [175, 10],
  294,
  s,
  [175, 16],
  s,
  [238, 8],
  295,
  s,
  [238, 16],
  s,
  [237, 8],
  296,
  s,
  [237, 16],
  s,
  [239, 8],
  297,
  s,
  [239, 16],
  302,
  303,
  c,
  [358, 5],
  304,
  c,
  [226, 12],
  307,
  88,
  38,
  119,
  121,
  c,
  [247, 16],
  315,
  s,
  [79, 3],
  316,
  15,
  112,
  216,
  c,
  [554, 6],
  318,
  242,
  38,
  39,
  213,
  149,
  213,
  149,
  322,
  324,
  323,
  c,
  [521, 13],
  c,
  [6, 12],
  329,
  c,
  [6, 4],
  330,
  c,
  [19, 13],
  333,
  c,
  [6, 4],
  334,
  15,
  335,
  c,
  [7, 4],
  336,
  337,
  c,
  [650, 3],
  205,
  205,
  339,
  s,
  [205, 4],
  340,
  c,
  [78, 4],
  120,
  122,
  110,
  111,
  343,
  249,
  344,
  c,
  [500, 16],
  348,
  c,
  [500, 9],
  349,
  350,
  c,
  [28, 15],
  c,
  [438, 4],
  352,
  c,
  [435, 8],
  c,
  [478, 4],
  352,
  c,
  [475, 8],
  c,
  [543, 4],
  352,
  c,
  [529, 11],
  c,
  [525, 7],
  191,
  356,
  190,
  183,
  88,
  46,
  47,
  277,
  191,
  166,
  367,
  c,
  [101, 14],
  c,
  [24, 5],
  371,
  38,
  c,
  [32, 7],
  38,
  277,
  c,
  [9, 9],
  237,
  379,
  s,
  [38, 6],
  277,
  277,
  352,
  c,
  [125, 15],
  38,
  391,
  390,
  392,
  393,
  394,
  396,
  395,
  397,
  c,
  [846, 7],
  213,
  149,
  400,
  137,
  198,
  137,
  202,
  c,
  [240, 13],
  407,
  c,
  [6, 4],
  408,
  15,
  409,
  c,
  [7, 4],
  410,
  411,
  199,
  200,
  15,
  412,
  c,
  [10, 4],
  413,
  414,
  199,
  200,
  415,
  199,
  200,
  416,
  417,
  418,
  c,
  [83, 15],
  108,
  108,
  277,
  108,
  261,
  421,
  108,
  254,
  252,
  108,
  422,
  c,
  [793, 4],
  s,
  [108, 5],
  c,
  [793, 22],
  426,
  213,
  149,
  427,
  429,
  428,
  c,
  [21, 15],
  297,
  233,
  277,
  352,
  285,
  234,
  277,
  352,
  281,
  235,
  290,
  236,
  279,
  295,
  296,
  277,
  352,
  391,
  431,
  432,
  294,
  73,
  433,
  434,
  c,
  [39, 15],
  436,
  277,
  277,
  439,
  440,
  c,
  [20, 15],
  88,
  c,
  [495, 16],
  c,
  [237, 16],
  c,
  [209, 6],
  447,
  448,
  449,
  15,
  450,
  c,
  [9, 4],
  451,
  452,
  199,
  200,
  453,
  199,
  200,
  454,
  455,
  199,
  200,
  456,
  457,
  458,
  191,
  460,
  c,
  [420, 9],
  c,
  [56, 16],
  277,
  465,
  115,
  115,
  277,
  115,
  352,
  115,
  115,
  422,
  s,
  [115, 5],
  c,
  [564, 4],
  468,
  c,
  [5, 4],
  213,
  149,
  277,
  473,
  474,
  475,
  477,
  476,
  15,
  479,
  c,
  [297, 5],
  15,
  482,
  199,
  200,
  483,
  484,
  485,
  111,
  111,
  277,
  111,
  352,
  111,
  111,
  422,
  s,
  [111, 5],
  c,
  [75, 15],
  487,
  204,
  277,
  230,
  240,
  204,
  s,
  [230, 14],
  c,
  [35, 15],
  489,
  490,
  277,
  352,
  422,
  158,
  s,
  [491, 7, 1],
  c,
  [178, 6],
  c,
  [144, 16],
  199,
  200,
  s,
  [501, 4, 1],
  213,
  149,
  c,
  [1129, 31],
  c,
  [15, 29],
  15,
  510,
  c,
  [90, 4],
  s,
  [511, 5, 1],
  113,
  113,
  277,
  113,
  352,
  113,
  113,
  422,
  s,
  [113, 5],
  517,
  516,
  s,
  [518, 4, 1],
  199,
  522,
  523,
  200,
  c,
  [124, 21],
  c,
  [21, 21],
  528,
  c,
  [16, 15],
  530,
  531,
  15,
  532,
  c,
  [39, 4],
  533,
  15,
  534,
  c,
  [7, 4],
  535,
  536,
  c,
  [54, 6],
  199,
  538,
  539,
  c,
  [85, 7],
  199,
  200,
  541,
  c,
  [605, 7],
  543,
  c,
  [6, 4],
  544,
  545,
  15,
  546,
  c,
  [8, 4],
  547,
  c,
  [329, 6],
  199,
  549,
  c,
  [39, 8],
  551,
  552,
  200,
  553,
  15,
  554,
  c,
  [11, 4],
  555,
  556,
  199,
  557,
  c,
  [22, 7],
  559,
  15,
  560,
  c,
  [29, 5],
  561,
  200,
  562
])
}),
defaultActions: bda({
  idx: u([
  5,
  6,
  8,
  s,
  [10, 5, 1],
  18,
  19,
  21,
  22,
  23,
  29,
  30,
  31,
  s,
  [35, 5, 1],
  s,
  [42, 4, 1],
  49,
  50,
  51,
  53,
  61,
  63,
  66,
  67,
  71,
  74,
  76,
  80,
  s,
  [88, 4, 1],
  94,
  95,
  s,
  [98, 7, 1],
  s,
  [106, 4, 1],
  116,
  s,
  [119, 4, 1],
  125,
  143,
  146,
  150,
  151,
  152,
  154,
  158,
  160,
  161,
  162,
  164,
  165,
  169,
  176,
  177,
  178,
  180,
  189,
  s,
  [192, 5, 1],
  s,
  [202, 7, 1],
  214,
  218,
  234,
  235,
  236,
  238,
  246,
  248,
  s,
  [251, 15, 1],
  268,
  276,
  283,
  s,
  [287, 4, 2],
  300,
  301,
  304,
  306,
  307,
  309,
  311,
  312,
  319,
  320,
  321,
  330,
  s,
  [334, 4, 2],
  341,
  s,
  [343, 5, 1],
  355,
  357,
  366,
  367,
  372,
  374,
  375,
  377,
  378,
  s,
  [380, 6, 1],
  390,
  392,
  s,
  [398, 4, 2],
  408,
  410,
  413,
  416,
  417,
  418,
  424,
  428,
  431,
  435,
  436,
  s,
  [439, 5, 1],
  447,
  451,
  454,
  456,
  457,
  459,
  463,
  464,
  467,
  473,
  474,
  478,
  480,
  483,
  484,
  485,
  488,
  s,
  [489, 5, 2],
  503,
  s,
  [517, 5, 1],
  528,
  530,
  536,
  544,
  547,
  548,
  553,
  555,
  559,
  562
]),
  goto: u([
  8,
  22,
  21,
  24,
  25,
  26,
  65,
  66,
  4,
  9,
  6,
  23,
  7,
  11,
  12,
  13,
  19,
  192,
  193,
  184,
  179,
  180,
  181,
  175,
  176,
  2,
  3,
  5,
  195,
  17,
  189,
  70,
  75,
  74,
  1,
  197,
  201,
  169,
  15,
  14,
  16,
  69,
  76,
  62,
  64,
  s,
  [206, 5, 1],
  87,
  97,
  221,
  222,
  73,
  182,
  177,
  183,
  178,
  47,
  56,
  58,
  10,
  187,
  18,
  191,
  63,
  102,
  103,
  104,
  106,
  107,
  116,
  223,
  224,
  225,
  228,
  161,
  240,
  241,
  170,
  171,
  172,
  78,
  81,
  219,
  220,
  237,
  238,
  239,
  46,
  27,
  44,
  45,
  57,
  53,
  82,
  84,
  185,
  s,
  [244, 14, 1],
  114,
  130,
  132,
  134,
  160,
  128,
  173,
  122,
  123,
  167,
  100,
  162,
  164,
  242,
  243,
  48,
  50,
  52,
  40,
  42,
  43,
  59,
  55,
  60,
  68,
  83,
  85,
  86,
  110,
  157,
  126,
  129,
  98,
  139,
  140,
  131,
  146,
  133,
  144,
  137,
  138,
  141,
  142,
  143,
  168,
  163,
  77,
  72,
  199,
  203,
  38,
  39,
  41,
  36,
  54,
  67,
  136,
  125,
  99,
  159,
  117,
  121,
  124,
  101,
  165,
  166,
  71,
  37,
  32,
  34,
  35,
  112,
  145,
  135,
  127,
  119,
  120,
  94,
  20,
  30,
  31,
  33,
  109,
  s,
  [147, 4, 2],
  118,
  29,
  156,
  s,
  [148, 4, 2],
  28,
  88,
  155,
  89,
  95,
  96,
  91,
  90,
  92,
  93
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable && typeof this.trace === 'function') {
        this.trace(str);
        hash.destroy(); // destroy... well, *almost*!
    } else {
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack
    var lstack = new Array(128);        // location stack
    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks
    var yyloc;

    var yylineno;


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 563 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function copy_yylloc(loc) {
        var rv = shallow_copy(loc);
        if (rv && rv.range) {
            rv.range = rv.range.slice(0);
        }
        return rv;
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = shallow_copy(l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        rv = shallow_copy(l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: copy_yylloc(lexer.yylloc),
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function lex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        yyloc = lexer.yylloc;
        lstack[sp] = yyloc;
        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p, this.JisonParserError);
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = copy_yylloc(lexer.yylloc);
                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;


                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;






                




                continue;

            // reduce:
            case 2:
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }

                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = this.parseError(p.errStr, p, this.JisonParserError);
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;


/* lexer generated by jison-lex 0.6.1-203 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... true
//   location assignment: ............. true
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.options.trackPosition) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        var pre = this.match;
        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).' + pos_str,
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      var error_size = loc.last_line - loc.first_line;
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');

      //var show_context = (error_size < 5 || context_loc);
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));

      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');

        if (lno === loc.first_line) {
          var offset = loc.first_column + 2;

          var len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );

          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno === loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, loc.last_column + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno > loc.first_line && lno < loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, line.length + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;

        console.log('clip off: ', {
          start: clip_start,
          end: clip_end,
          len: clip_end - clip_start + 1,
          arr: nonempty_line_indexes,
          rv
        });

        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var pos_str = '';

          if (typeof this.showPosition === 'function') {
            pos_str = this.showPosition();

            if (pos_str && pos_str[0] !== '\n') {
              pos_str = '\n' + pos_str;
            }
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!' + pos_str,
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.' + pos_str,
          this.options.lexerErrorsAreRecoverable
        );

        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time:
          if (!this.match.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.options.pre_lex === 'function') {
        r = this.options.pre_lex.call(this);
      }

      while (!r) {
        r = this.next();
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      flex: true,
      trackPosition: true,
      parseActionsUseYYMERGELOCATIONINFO: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: * */
        /*! Rule::       \s+ */
        return;

        break;

      case 5:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 6:
        /*! Conditions:: INITIAL */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 7:
        /*! Conditions:: INITIAL */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 8:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 38;
        break;

      case 15:
        /*! Conditions:: TAG */
        /*! Rule::       \/> */
        this.popState();

        return 37;
        break;

      case 17:
        /*! Conditions:: TAG */
        /*! Rule::       > */
        this.begin('CHILDREN');

        return 14;
        break;

      case 18:
        /*! Conditions:: TAG */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 38;
        break;

      case 19:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 38;
        break;

      case 20:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 21:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 22:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <\/ */
        this.begin('TAG');

        return 36;
        break;

      case 23:
        /*! Conditions:: CHILDREN */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 54:
        /*! Conditions:: CONTROL */
        /*! Rule::       = */
        this.begin('CONTROL_CHILD');

        return 9;
        break;

      case 57:
        /*! Conditions:: CONTROL */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 58:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 59:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 38;
        break;

      case 60:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 76:
        /*! Conditions:: EXPRESSION */
        /*! Rule::       \}\} */
        this.popState();

        return 39;
        break;

      case 77:
        /*! Conditions:: COMMENT */
        /*! Rule::       (.|\r|\n)*?--> */
        this.popState();

        return;
        break;

      case 108:
        /*! Conditions:: INITIAL */
        /*! Rule::       . */
        console.log('', yy_.yytext);

        /* `flex` lexing mode: the last resort rule! */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       import */
      1: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       from */
      2: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       using */
      3: 'USING',

      /*! Conditions:: INITIAL */
      /*! Rule::       as */
      4: 27,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Constructor} */
      9: 56,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Identifier} */
      10: 55,

      /*! Conditions:: TAG */
      /*! Rule::       true */
      11: 53,

      /*! Conditions:: TAG */
      /*! Rule::       false */
      12: 54,

      /*! Conditions:: TAG */
      /*! Rule::       {Constructor} */
      13: 56,

      /*! Conditions:: TAG */
      /*! Rule::       {Identifier} */
      14: 55,

      /*! Conditions:: TAG */
      /*! Rule::       \/ */
      16: 'NOSE',

      /*! Conditions:: CHILDREN */
      /*! Rule::       [^/<>{%}]+ */
      24: 47,

      /*! Conditions:: CONTROL */
      /*! Rule::       main */
      25: 29,

      /*! Conditions:: CONTROL */
      /*! Rule::       endmain */
      26: 'ENDMAIN',

      /*! Conditions:: CONTROL */
      /*! Rule::       macro */
      27: 'MACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       endmacro */
      28: 'ENDMACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       for */
      29: 40,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfor */
      30: 42,

      /*! Conditions:: CONTROL */
      /*! Rule::       if */
      31: 44,

      /*! Conditions:: CONTROL */
      /*! Rule::       endif */
      32: 46,

      /*! Conditions:: CONTROL */
      /*! Rule::       else */
      33: 45,

      /*! Conditions:: CONTROL */
      /*! Rule::       elseif */
      34: 'ELSEIF',

      /*! Conditions:: CONTROL */
      /*! Rule::       in */
      35: 41,

      /*! Conditions:: CONTROL */
      /*! Rule::       case */
      36: 'CASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       endcase */
      37: 'ENDCASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       export */
      38: 31,

      /*! Conditions:: CONTROL */
      /*! Rule::       from */
      39: 26,

      /*! Conditions:: CONTROL */
      /*! Rule::       view */
      40: 32,

      /*! Conditions:: CONTROL */
      /*! Rule::       using */
      41: 'USING',

      /*! Conditions:: CONTROL */
      /*! Rule::       endview */
      42: 33,

      /*! Conditions:: CONTROL */
      /*! Rule::       match */
      43: 'MATCH',

      /*! Conditions:: CONTROL */
      /*! Rule::       endmatch */
      44: 'ENDMATCH',

      /*! Conditions:: CONTROL */
      /*! Rule::       instanceof */
      45: 63,

      /*! Conditions:: CONTROL */
      /*! Rule::       typeof */
      46: 'TYPEOF',

      /*! Conditions:: CONTROL */
      /*! Rule::       this */
      47: 'THIS',

      /*! Conditions:: CONTROL */
      /*! Rule::       fun */
      48: 34,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfun */
      49: 35,

      /*! Conditions:: CONTROL */
      /*! Rule::       as */
      50: 27,

      /*! Conditions:: CONTROL */
      /*! Rule::       :: */
      51: '::',

      /*! Conditions:: CONTROL */
      /*! Rule::       @ */
      52: 19,

      /*! Conditions:: CONTROL */
      /*! Rule::       \(\) */
      53: '()',

      /*! Conditions:: CONTROL */
      /*! Rule::       {Constructor} */
      55: 56,

      /*! Conditions:: CONTROL */
      /*! Rule::       {Identifier} */
      56: 55,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Constructor} */
      61: 56,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Identifier} */
      62: 55,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \| */
      63: 15,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       => */
      64: 50,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       -> */
      65: '->',

      /*! Conditions:: EXPRESSION */
      /*! Rule::       @ */
      66: 19,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       instanceof */
      67: 63,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       true */
      68: 53,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       false */
      69: 54,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       if */
      70: 44,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       then */
      71: 48,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       else */
      72: 45,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       as */
      73: 27,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Constructor} */
      74: 56,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Identifier} */
      75: 55,

      /*! Conditions:: * */
      /*! Rule::       {NumberLiteral} */
      78: 52,

      /*! Conditions:: * */
      /*! Rule::       {StringLiteral} */
      79: 51,

      /*! Conditions:: * */
      /*! Rule::       > */
      80: 14,

      /*! Conditions:: * */
      /*! Rule::       < */
      81: 13,

      /*! Conditions:: * */
      /*! Rule::       \( */
      82: 7,

      /*! Conditions:: * */
      /*! Rule::       \) */
      83: 8,

      /*! Conditions:: * */
      /*! Rule::       \[ */
      84: 10,

      /*! Conditions:: * */
      /*! Rule::       \] */
      85: 11,

      /*! Conditions:: * */
      /*! Rule::       ; */
      86: 20,

      /*! Conditions:: * */
      /*! Rule::       : */
      87: 12,

      /*! Conditions:: * */
      /*! Rule::       = */
      88: 9,

      /*! Conditions:: * */
      /*! Rule::       == */
      89: 59,

      /*! Conditions:: * */
      /*! Rule::       != */
      90: 60,

      /*! Conditions:: * */
      /*! Rule::       >= */
      91: 57,

      /*! Conditions:: * */
      /*! Rule::       <= */
      92: 58,

      /*! Conditions:: * */
      /*! Rule::       \+ */
      93: 21,

      /*! Conditions:: * */
      /*! Rule::       - */
      94: 23,

      /*! Conditions:: * */
      /*! Rule::       \* */
      95: 3,

      /*! Conditions:: * */
      /*! Rule::       \/ */
      96: 22,

      /*! Conditions:: * */
      /*! Rule::       \\ */
      97: 49,

      /*! Conditions:: * */
      /*! Rule::       && */
      98: 61,

      /*! Conditions:: * */
      /*! Rule::       \|\| */
      99: 62,

      /*! Conditions:: * */
      /*! Rule::       \^ */
      100: 24,

      /*! Conditions:: * */
      /*! Rule::       ! */
      101: 16,

      /*! Conditions:: * */
      /*! Rule::       , */
      102: 6,

      /*! Conditions:: * */
      /*! Rule::       \? */
      103: 18,

      /*! Conditions:: * */
      /*! Rule::       \. */
      104: 17,

      /*! Conditions:: * */
      /*! Rule::       \{ */
      105: 4,

      /*! Conditions:: * */
      /*! Rule::       \} */
      106: 5,

      /*! Conditions:: * */
      /*! Rule::       $ */
      107: 1
    },

    rules: [
      /*   0: */  /^(?:\s+)/,
      /*   1: */  /^(?:import)/,
      /*   2: */  /^(?:from)/,
      /*   3: */  /^(?:using)/,
      /*   4: */  /^(?:as)/,
      /*   5: */  /^(?:\{%)/,
      /*   6: */  /^(?:<!--)/,
      /*   7: */  /^(?:<)/,
      /*   8: */  /^(?:\{\{)/,
      /*   9: */  /^(?:([A-Z][\w$\-]*))/,
      /*  10: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  11: */  /^(?:true)/,
      /*  12: */  /^(?:false)/,
      /*  13: */  /^(?:([A-Z][\w$\-]*))/,
      /*  14: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  15: */  /^(?:\/>)/,
      /*  16: */  /^(?:\/)/,
      /*  17: */  /^(?:>)/,
      /*  18: */  /^(?:\{\{)/,
      /*  19: */  /^(?:\{\{)/,
      /*  20: */  /^(?:\{%)/,
      /*  21: */  /^(?:<!--)/,
      /*  22: */  /^(?:<\/)/,
      /*  23: */  /^(?:<)/,
      /*  24: */  /^(?:[^\/<>{%}]+)/,
      /*  25: */  /^(?:main)/,
      /*  26: */  /^(?:endmain)/,
      /*  27: */  /^(?:macro)/,
      /*  28: */  /^(?:endmacro)/,
      /*  29: */  /^(?:for)/,
      /*  30: */  /^(?:endfor)/,
      /*  31: */  /^(?:if)/,
      /*  32: */  /^(?:endif)/,
      /*  33: */  /^(?:else)/,
      /*  34: */  /^(?:elseif)/,
      /*  35: */  /^(?:in)/,
      /*  36: */  /^(?:case)/,
      /*  37: */  /^(?:endcase)/,
      /*  38: */  /^(?:export)/,
      /*  39: */  /^(?:from)/,
      /*  40: */  /^(?:view)/,
      /*  41: */  /^(?:using)/,
      /*  42: */  /^(?:endview)/,
      /*  43: */  /^(?:match)/,
      /*  44: */  /^(?:endmatch)/,
      /*  45: */  /^(?:instanceof)/,
      /*  46: */  /^(?:typeof)/,
      /*  47: */  /^(?:this)/,
      /*  48: */  /^(?:fun)/,
      /*  49: */  /^(?:endfun)/,
      /*  50: */  /^(?:as)/,
      /*  51: */  /^(?:::)/,
      /*  52: */  /^(?:@)/,
      /*  53: */  /^(?:\(\))/,
      /*  54: */  /^(?:=)/,
      /*  55: */  /^(?:([A-Z][\w$\-]*))/,
      /*  56: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  57: */  /^(?:%\})/,
      /*  58: */  /^(?:<)/,
      /*  59: */  /^(?:\{\{)/,
      /*  60: */  /^(?:%\})/,
      /*  61: */  /^(?:([A-Z][\w$\-]*))/,
      /*  62: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  63: */  /^(?:\|)/,
      /*  64: */  /^(?:=>)/,
      /*  65: */  /^(?:->)/,
      /*  66: */  /^(?:@)/,
      /*  67: */  /^(?:instanceof)/,
      /*  68: */  /^(?:true)/,
      /*  69: */  /^(?:false)/,
      /*  70: */  /^(?:if)/,
      /*  71: */  /^(?:then)/,
      /*  72: */  /^(?:else)/,
      /*  73: */  /^(?:as)/,
      /*  74: */  /^(?:([A-Z][\w$\-]*))/,
      /*  75: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  76: */  /^(?:\}\})/,
      /*  77: */  /^(?:(.|\r|\n)*?-->)/,
      /*  78: */  /^(?:((?:([-]?(?:[-]?([0]|((?:[1-9])(?:\d+)*)))\.(?:\d+)*(?:(?:[Ee])(?:[+-]?\d+))?)|(\.(?:\d+)(?:(?:[Ee])(?:[+-]?\d+))?)|((?:[-]?([0]|((?:[1-9])(?:\d+)*)))(?:(?:[Ee])(?:[+-]?\d+))?))|(?:[0][Xx](?:[\dA-Fa-f])+)|(?:[0](?:[0-7])+)))/,
      /*  79: */  /^(?:(("(?:([^\n\r"\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*")|('(?:([^\n\r'\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*')|(`(?:([^\n\r\\`]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*`)))/,
      /*  80: */  /^(?:>)/,
      /*  81: */  /^(?:<)/,
      /*  82: */  /^(?:\()/,
      /*  83: */  /^(?:\))/,
      /*  84: */  /^(?:\[)/,
      /*  85: */  /^(?:\])/,
      /*  86: */  /^(?:;)/,
      /*  87: */  /^(?::)/,
      /*  88: */  /^(?:=)/,
      /*  89: */  /^(?:==)/,
      /*  90: */  /^(?:!=)/,
      /*  91: */  /^(?:>=)/,
      /*  92: */  /^(?:<=)/,
      /*  93: */  /^(?:\+)/,
      /*  94: */  /^(?:-)/,
      /*  95: */  /^(?:\*)/,
      /*  96: */  /^(?:\/)/,
      /*  97: */  /^(?:\\)/,
      /*  98: */  /^(?:&&)/,
      /*  99: */  /^(?:\|\|)/,
      /* 100: */  /^(?:\^)/,
      /* 101: */  /^(?:!)/,
      /* 102: */  /^(?:,)/,
      /* 103: */  /^(?:\?)/,
      /* 104: */  /^(?:\.)/,
      /* 105: */  /^(?:\{)/,
      /* 106: */  /^(?:\})/,
      /* 107: */  /^(?:$)/,
      /* 108: */  /^(?:.)/
    ],

    conditions: {
      'CHILDREN': {
        rules: [
          0,
          19,
          20,
          21,
          22,
          23,
          24,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'COMMENT': {
        rules: [
          0,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'CONTROL': {
        rules: [
          0,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'EXPRESSION': {
        rules: [
          0,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'CONTROL_CHILD': {
        rules: [
          0,
          58,
          59,
          60,
          61,
          62,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'TAG': {
        rules: [
          0,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107
        ],

        inclusive: false
      },

      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = Parser;
  exports.Parser = Parser.Parser;
  exports.parse = function () {
    return Parser.parse.apply(Parser, arguments);
  };
  
}

},{}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nodes = require("./AST");
var afpl = require("afpl");
var CONTEXT = '___context';
var VIEW = '___view';
var prims = ['String', 'Boolean', 'Number', 'Object', 'Undefined', 'Null', 'Void', 'Never', 'Any'];
/**
 * Types and functions for generating typescript program text.
 */
var _throwNotKnown = function (n) {
    throw new Error("Unsupported AST node " + (typeof n === 'object' ? n.constructor.name : n) + "!");
};
var noop = function () { return "function () {}"; };
/**
 * view template.
 */
exports.view = function (id, typeClasses, params, ctx, tag) {
    return "export class " + id + typeClasses + " extends $wml.AppView<" + ctx + "> {\n\n    constructor(context: " + ctx + (params ? ',' + params : '') + ") {\n\n        super(context);\n\n        this.template = (" + CONTEXT + ":" + ctx + ", " + VIEW + ":$wml.AppView<" + ctx + ">) =>\n          " + (tag ? tag : '<Node>document.createDocumentFragment()') + ";\n\n       }\n\n     }\n";
};
/**
 * code turns an AST into typescript code.
 */
exports.code = function (n, o) { return exports.module2TS(n, o); };
/**
 * module2TS converts a module to a typescript module.
 */
exports.module2TS = function (n, _a) {
    var module = _a.module;
    return "\nimport * as $wml from '" + module + "';\n" + n.imports.map(exports.importStatement2TS).join(';\n') + "\n\n" + n.exports.map(exports.exports2TS).join(';\n') + "\n\n" + (n.main ? exports.main2TS(n.main) : '') + "\n";
};
/**
 * exports2TS converts various exports to typescript.
 */
exports.exports2TS = function (n) {
    if (n instanceof nodes.ExportStatement)
        return exports.exportStatement2TS(n);
    else if (n instanceof nodes.FunStatement)
        return exports.funStatement2TS(n);
    else if (n instanceof nodes.ViewStatement)
        return exports.viewStatement2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * importStatement2TS converts an import statement.
 */
exports.importStatement2TS = function (n) {
    return "import " + exports.importMember2TS(n.member) + " from '" + n.module.value + "'; ";
};
/**
 * importMember2TS converts the members of an import to typescript.
 */
exports.importMember2TS = function (n) {
    if (n instanceof nodes.AggregateMember)
        return exports.aggregateMember2TS(n);
    else if (n instanceof nodes.AliasedMember)
        return exports.aliasedMember2TS(n);
    else if (n instanceof nodes.CompositeMember)
        return exports.compositeMember2TS(n);
    else
        return _throwNotKnown;
};
/**
 * aliasedMember2TS converts a member alias to typescript.
 */
exports.aliasedMember2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.member) + " as " + exports.identifierOrConstructor2TS(n.alias) + " ";
};
/**
 * aggregateMember2TS converts a qualified member to typescript.
 */
exports.aggregateMember2TS = function (n) {
    return "* as " + exports.identifierOrConstructor2TS(n.id) + " ";
};
/**
 * compositeMember2TS coverts to typescript.
 */
exports.compositeMember2TS = function (n) {
    return '{' + (n.members.map(function (m) { return (m instanceof nodes.AliasedMember) ?
        exports.aliasedMember2TS(m) :
        exports.identifierOrConstructor2TS(m); }).join(',')) + '}';
};
/**
 * main2TS converts to typescript.
 */
exports.main2TS = function (n) {
    return (n instanceof nodes.TypedMain) ?
        exports.typedMain2TS(n) :
        exports.untypedMain2TS(n);
};
/**
 * typedMain2TS converts a typed main file to typescript.
 */
exports.typedMain2TS = function (n) {
    return exports.view(n.id ? exports.unqualifiedIdentifier2TS(n.id) : 'Main', exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
/**
 * untypedMain2TS converts an untyped main file to typescript.
 */
exports.untypedMain2TS = function (n) {
    return exports.view('Main', '', '', 'void', exports.tag2TS(n.tag));
};
/**
 * exportStatement2TS converts an export statement to typescript.
 */
exports.exportStatement2TS = function (n) {
    return "export " + exports.compositeMember2TS(n.members) + " from '" + n.module.value + "';\n";
};
/**
 * viewStatement2TS converts a view statement into a typescript class.
 */
exports.viewStatement2TS = function (n) {
    return exports.view(exports.constructor2TS(n.id), exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
var _funContext = function (n) { return "(" + CONTEXT + ":" + exports.type2TS(n) + ")=>"; };
var _funView = function () { return "(" + VIEW + ":$wml.View)=>"; };
/**
 * funStatement2TS converts a function statement to typescript.
 */
exports.funStatement2TS = function (n) {
    return "export const " + exports.unqualifiedIdentifier2TS(n.id) + " = " +
        (exports.typeClasses2TS(n.typeClasses) + "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>") +
        ((n.context != null) ? _funContext(n.context) : '') +
        _funView() +
        ((Array.isArray(n.body) ? exports.children2TS(n.body) : exports.child2TS(n.body)) + ";");
};
/**
 * typeClasses2TS converts a list of typeclasses into the a list of typescript typeclasses.
 */
exports.typeClasses2TS = function (ns) {
    return (ns.length === 0) ? '' : "< " + ns.map(exports.typeClass2TS).join(',') + ">";
};
/**
 * typeClass2TS converts a typeclass into a typescript typeclass.
 */
exports.typeClass2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.id) + " " +
        ((n.constraint ? 'extends ' + exports.type2TS(n.constraint) : '') + " ");
};
var _toPrim = function (typ) {
    return prims.indexOf(typ) > -1 ? typ.toLowerCase() : typ;
};
/**
 * type2TS converts a type hint to a typescript type hint.
 */
exports.type2TS = function (n) {
    return _toPrim(exports.identifierOrConstructor2TS(n.id)) + " " +
        (exports.typeClasses2TS(n.typeClasses) + " " + (n.list ? '[]' : ''));
};
/**
 * parameter2TS converts a parameter to a typescript parameter.
 */
exports.parameter2TS = function (n) {
    return (n instanceof nodes.TypedParameter) ? exports.typedParameter2TS(n) :
        (n instanceof nodes.UntypedParameter) ? exports.untypedParameter2TS(n) :
            _throwNotKnown;
};
/**
 * typedParameter2TS converts a typed parameter into a non-any typescript parameter.
 */
exports.typedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + ":" + exports.type2TS(n.hint) + " ";
};
/**
 * untypedParameter2TS converts an type inferred parameter to a typescript parameter.
 */
exports.untypedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + " ";
};
/**
 * children2TS converts a list of children to typescript.
 */
exports.children2TS = function (list) {
    return (list.length === 0) ? 'document.createDocumentFragment();' :
        (list.length === 1) ? exports.child2TS(list[0]) :
            "$wml.box(" + list.map(function (l) { return exports.child2TS(l); }).join(',') + ") ";
};
/**
 * child2TS converts children to typescript.
 */
exports.child2TS = function (n) {
    if ((n instanceof nodes.Node) || (n instanceof nodes.Widget))
        return exports.tag2TS(n);
    else if (n instanceof nodes.Interpolation)
        return "$wml.domify(" + exports.interpolation2TS(n) + ") ";
    else if (n instanceof nodes.IfStatement)
        return exports.ifStatement2TS(n);
    else if (n instanceof nodes.ForStatement)
        return exports.forStatement2TS(n);
    else if (n instanceof nodes.Characters)
        return exports.characters2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * tag2TS converts a tag (node/widget) to typescript.
 */
exports.tag2TS = function (n) {
    var children = n.children.map(exports.child2TS);
    var attrs = exports.attrs2String(exports.groupAttrs(n.attributes));
    var name = exports.identifierOrConstructor2TS(n.open);
    return (n.type === 'widget') ? "$wml.widget(" + name + ", " + attrs + ", [" + children + "], " + VIEW + ")" :
        "$wml.node('" + name + "', " + attrs + ", [" + children + "], " + VIEW + ") ";
};
/**
 * attrs2String
 */
exports.attrs2String = function (attrs) { return '{' +
    (Object.keys(attrs).map(function (ns) { return ns + " : { " + attrs[ns].join(',') + " } "; })) + '}'; };
/**
 * groupAttrs groups attributes according to their namespace.
 */
exports.groupAttrs = function (ns) { return ns.reduce(function (p, c) {
    return afpl.util.merge(p, (_a = {},
        _a[c.namespace.id || 'html'] = (p[c.namespace.id || 'html'] || []).concat(exports.attribute2TS(c)),
        _a));
    var _a;
}, { html: [], wml: [] }); };
/**
 * attribute2Value
 */
exports.attribute2TS = function (n) {
    return exports.unqualifiedIdentifier2TS(n.name) + " : " + exports.attributeValue2TS(n.value) + " ";
};
/**
 * attributeValue2TS converts an attribute value to typescript.
 */
exports.attributeValue2TS = function (n) {
    return (n instanceof nodes.Interpolation) ? exports.interpolation2TS(n) : exports.literal2TS(n);
};
/**
 * interpolation2TS converts interpolation expressions to typescript.
 */
exports.interpolation2TS = function (n) {
    return n.filters.reduce(function (p, c) { return exports.expression2TS(c) + " (" + p + ")"; }, exports.expression2TS(n.expression));
};
/**
 * forStatement2TS converts a for statement to typescript.
 */
exports.forStatement2TS = function (n) {
    return "$wml.map(" + exports.expression2TS(n.list) + ", function _map" +
        ("(" + [n.variable, n.index, n.all].filter(function (x) { return x; }).map(exports.parameter2TS).join(',') + ") ") +
        ("{ return " + exports.children2TS(n.body) + " }, ") +
        ("function otherwise() { return " + exports.children2TS(n.otherwise) + " }) ");
};
/**
 * ifStatement2TS converts an if statement to typescript.
 */
exports.ifStatement2TS = function (n) {
    return "$wml.ifthen(" + exports.expression2TS(n.condition) + ", " +
        "function then()" +
        ("{ return " + exports.children2TS(n.then) + " }, " + (n.elseClause ? else2TS(n.elseClause) : noop()) + ") ");
};
var else2TS = function (n) {
    return (n instanceof nodes.ElseClause) ? exports.elseClause2TS(n) :
        (n instanceof nodes.ElseIfClause) ? exports.elseIfClause2TS(n) :
            _throwNotKnown(n);
};
/**
 * elseClause2TS converts the else clause of an if statement to typescript.
 */
exports.elseClause2TS = function (n) {
    return "function else_clause() { return " + exports.children2TS(n.children) + " } ";
};
/**
 * elseIfClause2TS converts an else if clause to typescript.
 */
exports.elseIfClause2TS = function (n) {
    return "function elseif()" +
        ("{ return $wml.ifthen(" + exports.expression2TS(n.condition) + ", ") +
        "function then() " +
        ("{ return " + exports.children2TS(n.then) + "; }, ") +
        (else2TS(n.elseClause) + ");}");
};
/**
 * characters2TS converts character text to a typescript string.
 */
exports.characters2TS = function (n) { return "$wml.text(`" + n.value + "`)"; };
/**
 * expression2TS converts a wml expression to a typescript expression.
 */
exports.expression2TS = function (n) {
    if (n instanceof nodes.IfThenExpression)
        return exports.ifThenExpression2TS(n);
    else if (n instanceof nodes.BinaryExpression)
        return exports.binaryExpression2TS(n);
    else if (n instanceof nodes.UnaryExpression)
        return exports.unaryExpression2TS(n);
    else if (n instanceof nodes.ViewConstruction)
        return exports.viewConstruction2TS(n);
    else if (n instanceof nodes.FunApplication)
        return exports.funApplication2TS(n);
    else if (n instanceof nodes.ConstructExpression)
        return exports.constructExpression2TS(n);
    else if (n instanceof nodes.CallExpression)
        return exports.callExpression2TS(n);
    else if (n instanceof nodes.MemberExpression)
        return exports.memberExpression2TS(n);
    else if (n instanceof nodes.ReadExpression)
        return exports.readExpression2TS(n);
    else if (n instanceof nodes.FunctionExpression)
        return exports.functionExpression2TS(n);
    else if (n instanceof nodes.Record)
        return exports.record2TS(n);
    else if (n instanceof nodes.List)
        return exports.list2TS(n);
    else if (n instanceof nodes.BooleanLiteral)
        return exports.boolean2TS(n);
    else if (n instanceof nodes.NumberLiteral)
        return exports.number2TS(n);
    else if (n instanceof nodes.StringLiteral)
        return exports.string2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else if (n instanceof nodes.ContextVariable)
        return exports.contextVariable2TS(n);
    else
        _throwNotKnown(n);
};
/**
 * ifThenExpression2TS converts an if-then-else expression to typescript.
 */
exports.ifThenExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ") ? " + exports.expression2TS(n.iftrue) + " : " + exports.expression2TS(n.iffalse) + " ";
};
/**
 * binaryExpression2TS converts a binary expression to typescript.
 */
exports.binaryExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.left) + " " + exports.convertOperator(n.operator) + " " + exports.expression2TS(n.right) + ") ";
};
/**
 * convertOperator for strictness.
 */
exports.convertOperator = function (op) {
    return (op === '==') ? '===' :
        (op === '!=') ? '!==' :
            op;
};
/**
 * unaryExpression2TS converts a unary expression to typescript.
 */
exports.unaryExpression2TS = function (n) {
    return n.operator + " (" + exports.expression2TS(n.expression) + ")";
};
/**
 * viewConstruction2TS convers a view construction to typescript.
 */
exports.viewConstruction2TS = function (n) {
    return "(new " + exports.constructor2TS(n.cons) + "(" + exports.args2TS(n.context) + ")).render()";
};
var _applyFun = function (context) {
    return (context.length > 0 ? "(" + exports.args2TS(context) + ")" : '') + ("(" + VIEW + ")");
};
/**
 * funApplication2TS converts a fun application to typescript.
 */
exports.funApplication2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " " +
        ("(" + exports.args2TS(n.args) + ")" + _applyFun(n.context));
};
/**
 * constructExpression2TS converts a construct expression to a typescript new expression.
 */
exports.constructExpression2TS = function (n) {
    return "new " + exports.constructor2TS(n.cons) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * callExpression2TS converts a call expression (apply) to a typescript invocation.
 */
exports.callExpression2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * typeArgs2TS converts passed type arguments to typescript
 */
exports.typeArgs2TS = function (ns) {
    return ns.length === 0 ? '' : "< " + ns.map(exports.type2TS).join(',') + ">";
};
/**
 * args2TS converts a list of arguments to a typescript argument tupple.
 */
exports.args2TS = function (ns) {
    return (ns.length === 0) ? '' : ns.map(exports.expression2TS).join(',');
};
/**
 * memberExpression2TS converts a member expression into a typescript member expression.
 */
exports.memberExpression2TS = function (n) {
    return exports.expression2TS(n.target) + "." + exports.identifier2TS(n.member) + " ";
};
/**
 * readExpression2TS converts a read expression to side effect full property look up.
 *
 * NOTE: this part of the language is most likely to change.
 */
exports.readExpression2TS = function (n) {
    return "$wml.read < " + exports.type2TS(n.hint) + ">(" + exports.expression2TS(n.path) + ", " + exports.expression2TS(n.target) + " " +
        ((n.defaults ? ',' + exports.expression2TS(n.defaults) : '') + ")");
};
/**
 * functionExpression2TS converts a function expression to a typescript function expression.
 */
exports.functionExpression2TS = function (n) {
    return "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>" +
        ("" + exports.expression2TS(n.body));
};
/**
 * literal2TS converts literals.
 */
exports.literal2TS = function (n) {
    return (n instanceof nodes.BooleanLiteral) ? exports.boolean2TS(n) :
        (n instanceof nodes.StringLiteral) ? exports.string2TS(n) :
            (n instanceof nodes.NumberLiteral) ? exports.number2TS(n) :
                (n instanceof nodes.Record) ? exports.record2TS(n) :
                    (n instanceof nodes.List) ? exports.list2TS(n) :
                        _throwNotKnown(n);
};
/**
 * boolean2TS converts a boolean literal to a typescript boolean literal.
 */
exports.boolean2TS = function (n) { return n.value + " "; };
/**
 * string2TS converts a string literal to a typescript string literal.
 */
exports.string2TS = function (n) { return "`" + n.value + "`"; };
/**
 * number2TS converts a number literal to a typecript number literal.
 */
exports.number2TS = function (n) { return "" + parseFloat(n.value); };
/**
 * record2TS converts a record to a typescript object literal.
 */
exports.record2TS = function (n) {
    return "{" + n.properties.map(exports.property2TS).join(',') + "}";
};
/**
 * list2TS converts a list to a typescript array literal.
 */
exports.list2TS = function (n) {
    return "[" + n.members.map(exports.expression2TS).join(',') + "]";
};
/**
 * property2TS converts a property of a a record to typescript.
 */
exports.property2TS = function (n) {
    return "'" + exports.key2TS(n.key) + "' : " + exports.expression2TS(n.value);
};
/**
 * key2TS converts a single key on a record.
 */
exports.key2TS = function (n) {
    return (n instanceof nodes.StringLiteral) ? exports.string2TS(n) : exports.identifier2TS(n);
};
/**
 * contextProperty2TS turns property access on the context to regular TS
 * property access.
 */
exports.contextProperty2TS = function (n) {
    return CONTEXT + "." + exports.identifier2TS(n.member);
};
/**
 * contextVariable2TS turns the context variable into the context identifier.
 */
exports.contextVariable2TS = function (_) { return "" + CONTEXT; };
/**
 * identifierOrConstructor2TS
 */
exports.identifierOrConstructor2TS = function (n) {
    if ((n instanceof nodes.UnqualifiedIdentifier) ||
        (n instanceof nodes.QualifiedIdentifier))
        return exports.identifier2TS(n);
    else if ((n instanceof nodes.UnqualifiedConstructor) ||
        (n instanceof nodes.QualifiedConstructor))
        return exports.constructor2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * constructor2TS turns a constructor to a typescript identifier.
 *
 * Remember constructors are proper cased.
 */
exports.constructor2TS = function (n) {
    return (n instanceof nodes.QualifiedConstructor) ? exports.qualifiedConstructor2TS(n) :
        (n instanceof nodes.UnqualifiedConstructor) ? exports.unqualifiedConstructor2TS(n) :
            _throwNotKnown(n);
};
/**
 * unqualifiedConstructor2TS converts an unqualified constructor to typescript
 */
exports.unqualifiedConstructor2TS = function (n) { return "" + n.id; };
/**
 * qualifiedConstructor converts a qualified constructor to typescript.
 */
exports.qualifiedConstructor2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * identifier2TS turns an identifier to a typescript identifier.
 */
exports.identifier2TS = function (n) {
    return (n instanceof nodes.QualifiedIdentifier) ? exports.qualifiedIdentifier2TS(n) :
        (n instanceof nodes.UnqualifiedIdentifier) ? exports.unqualifiedIdentifier2TS(n) :
            _throwNotKnown(n);
};
/**
 * qualifiedIdentifier2TS converts a qualified identifier to typescript
 */
exports.qualifiedIdentifier2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * unqualifiedIdentifier2TS converts an unqualified identifier to typescript
 */
exports.unqualifiedIdentifier2TS = function (n) { return "" + n.id; };

},{"./AST":35,"afpl":41}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property = require("property-seek");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var Compiler_1 = require("./Compiler");
exports.parse = Compiler_1.parse;
exports.compile = Compiler_1.compile;
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 *
 */
var Component = /** @class */ (function () {
    /**
     * attrs is the attributes this Component excepts.
     */
    /**
     * children is an array of content passed to this Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;
/**
 * read a value form an object.
 *
 * This is an alternative to regular property access that will throw exceptions
 * if any of the values in the part are null.
 * @param {string} path - The path to look up on the object.
 * @param {object} o - The object
 * @param {A} [defaultValue] - This value is returned if the value is not set.
 * @private
 */
exports.read = function (path, o, defaultValue) {
    var ret = property.get(path.split(':').join('.'), o);
    return (ret != null) ? ret : defaultValue;
};
/**
 * @private
 */
var adopt = function (child, e) {
    switch (typeof child) {
        case 'string':
        case 'number':
        case 'boolean':
            e.appendChild(document.createTextNode('' + child));
        case 'object':
            e.appendChild(child);
            break;
        default:
            throw new TypeError("Can not adopt child " + child + " of type " + typeof child);
    }
};
/**
 * @private
 */
exports.box = function () {
    var content = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        content[_i] = arguments[_i];
    }
    var frag = document.createDocumentFragment();
    content.forEach(function (c) { return frag.appendChild(c); });
    return frag;
};
/**
 * @private
 */
exports.domify = function (a) {
    if (a instanceof Array) {
        return exports.box.apply(null, a.map(exports.domify));
    }
    else if ((typeof a === 'string') ||
        (typeof a === 'number') ||
        (typeof a === 'boolean')) {
        return exports.text(a);
    }
    else if (a instanceof Node) {
        return a;
    }
    else if (a == null) {
        return document.createDocumentFragment();
    }
    else {
        throw new TypeError("Can not use '" + a + "'(typeof " + typeof a + ") as Content!");
    }
};
/**
 * text creates a new TextNode.
 * @private
 */
exports.text = function (value) {
    return document.createTextNode('' + value);
};
/**
 * node is called to create a regular DOM node
 * @private
 */
exports.node = function (tag, attributes, children, view) {
    var e = document.createElement(tag);
    if (typeof attributes['html'] === 'object')
        Object.keys(attributes['html']).forEach(function (key) {
            var value = attributes['html'][key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, "" + value);
            }
        });
    children.forEach(function (c) { return adopt(c, e); });
    var id = attributes['wml'].id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, e);
    if (group)
        view.registerByGroup(group, e);
    return e;
};
/**
 * widget creates and renders a new wml widget instance.
 * @param {function} Construtor
 * @param {object} attributes
 * @param {array<string|number|Widget>} children
 * @param {View} view
 * @private
 * @return {Widget}
 */
exports.widget = function (Constructor, attributes, children, view) {
    var childs = [];
    var w;
    children.forEach(function (child) { return (child instanceof Array) ?
        childs.push.apply(childs, child) : childs.push(child); });
    w = new Constructor(attributes, childs);
    var id = attributes.wml.id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, w);
    if (group)
        view.registerByGroup(group, w);
    view.registerWidget(w);
    return w.render();
};
/**
 * ifthen provides an if then expression
 * @private
 */
exports.ifthen = function (predicate, positive, negative) {
    return (predicate) ? positive() : negative();
};
/**
 * forE provides a for expression
 * @private
 */
exports.map = function (collection, cb, cb2) {
    var frag = document.createDocumentFragment();
    if (collection instanceof Array) {
        if (collection.length > 0)
            collection.forEach(function (v, k, a) { return frag.appendChild(cb(v, k, a)); });
        else
            frag.appendChild(cb2());
    }
    else if (typeof collection === 'object') {
        var l = Object.keys(collection);
        if (l.length > 0)
            l.forEach(function (k) { return frag.appendChild(cb(collection[k], k, collection)); });
        else
            frag.appendChild(cb2());
    }
    return frag;
};
/**
 * AppView is the concrete implementation of a View.
 *
 * @property {<C>} context - The context the view is rendered in.
 */
var AppView = /** @class */ (function () {
    function AppView(context) {
        this.context = context;
        this.ids = {};
        this.groups = {};
        this.widgets = [];
    }
    AppView.prototype.registerWidget = function (w) {
        this.widgets.push(w);
        return this;
    };
    AppView.prototype.registerById = function (id, w) {
        if (this.ids.hasOwnProperty(id))
            throw new Error("Duplicate id '" + id + "' detected!");
        this.ids[id] = w;
        return this;
    };
    AppView.prototype.registerByGroup = function (group, e) {
        this.groups[group] = this.groups[group] || [];
        this.groups[group].push(e);
        return this;
    };
    AppView.prototype.findById = function (id) {
        return Maybe_1.Maybe.fromAny(this.ids[id]);
    };
    AppView.prototype.findGroupByName = function (name) {
        return Maybe_1.Maybe.fromArray(this.groups.hasOwnProperty(name) ? this.groups[name] : []);
    };
    AppView.prototype.invalidate = function () {
        var childs;
        var realFirstChild;
        var realFirstChildIndex;
        var tree = (this._fragRoot) ? this._fragRoot : this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            throw new ReferenceError('Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new ReferenceError('Attempt to invalidate a view that has not been inserted to DOM!');
        childs = tree.parentNode.children;
        //for some reason the reference stored does not have the correct parent node.
        //we do this to get a 'live' version of the node.
        for (var i = 0; i < childs.length; i++)
            if (childs[i] === tree) {
                realFirstChild = childs[i];
                realFirstChildIndex = i;
            }
        parent.replaceChild(this.render(), realFirstChild);
    };
    AppView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this._fragRoot = null;
        this.tree = this.template(this.context, this);
        this.ids['root'] = (this.ids['root']) ? this.ids['root'] : this.tree;
        if (this.tree.nodeName === (document.createDocumentFragment()).nodeName)
            this._fragRoot = this.tree.firstChild;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return AppView;
}());
exports.AppView = AppView;

},{"./Compiler":36,"afpl/lib/monad/Maybe":46,"property-seek":55}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.f1 = function (f) { return f; };
exports.f2 = function (f) { return function (a) { return function (b) { return f(a, b); }; }; };
exports.f3 = function (f) {
    return function (a) { return function (b) { return function (c) { return f(a, b, c); }; }; };
};
exports.f4 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return f(a, b, c, d); }; }; }; };
};
exports.f5 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return f(a, b, c, d, e); }; }; }; }; };
};
exports.f6 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return function (_f) { return f(a, b, c, d, e, _f); }; }; }; }; }; };
};

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
exports.util = util;
var curry = require("./curry");
exports.curry = curry;
var Identity_1 = require("./monad/Identity");
exports.Identity = Identity_1.Identity;
var Maybe_1 = require("./monad/Maybe");
exports.Maybe = Maybe_1.Maybe;
var Either_1 = require("./monad/Either");
exports.Either = Either_1.Either;
var State_1 = require("./monad/State");
exports.State = State_1.State;
var Free_1 = require("./monad/Free");
exports.Free = Free_1.Free;
var IO_1 = require("./monad/IO");
exports.IO = IO_1.IO;

},{"./curry":40,"./monad/Either":42,"./monad/Free":43,"./monad/IO":44,"./monad/Identity":45,"./monad/Maybe":46,"./monad/State":47,"./util":48}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * left wraps a value on the left side.
 */
exports.left = function (a) { return new Left(a); };
/**
 * right wraps a value on the right side.
 */
exports.right = function (b) { return new Right(b); };
/**
 * fromBoolean constructs an Either using a boolean value.
 */
exports.fromBoolean = function (b) {
    return b ? exports.right(true) : exports.left(false);
};
/**
 * Either monad implementation
 */
var Either = (function () {
    function Either() {
    }
    Either.prototype.of = function (v) {
        return new Right(v);
    };
    Either.left = exports.left;
    Either.right = exports.right;
    Either.fromBoolean = exports.fromBoolean;
    return Either;
}());
exports.Either = Either;
var Left = (function (_super) {
    __extends(Left, _super);
    function Left(l) {
        var _this = _super.call(this) || this;
        _this.l = l;
        return _this;
    }
    Left.prototype.map = function (_) {
        return new Left(this.l);
    };
    Left.prototype.mapLeft = function (f) {
        return new Left(f(this.l));
    };
    Left.prototype.bimap = function (f, _) {
        return exports.left(f(this.l));
    };
    Left.prototype.chain = function (_) {
        return new Left(this.l);
    };
    Left.prototype.orElse = function (f) {
        return f(this.l);
    };
    Left.prototype.orRight = function (f) {
        return new Right(f(this.l));
    };
    Left.prototype.ap = function (_) {
        return new Left(this.l);
    };
    Left.prototype.takeLeft = function () {
        return this.l;
    };
    Left.prototype.takeRight = function () {
        throw new TypeError("Not right!");
    };
    Left.prototype.cata = function (f, _) {
        return f(this.l);
    };
    return Left;
}(Either));
exports.Left = Left;
var Right = (function (_super) {
    __extends(Right, _super);
    function Right(r) {
        var _this = _super.call(this) || this;
        _this.r = r;
        return _this;
    }
    Right.prototype.map = function (f) {
        return new Right(f(this.r));
    };
    Right.prototype.mapLeft = function (_) {
        return new Right(this.r);
    };
    Right.prototype.bimap = function (_, g) {
        return exports.right(g(this.r));
    };
    Right.prototype.chain = function (f) {
        return f(this.r);
    };
    /**
     * orElse returns the result of f if the Either is left.
     */
    Right.prototype.orElse = function (_) {
        return this;
    };
    Right.prototype.orRight = function (_) {
        return this;
    };
    /**
     * ap
     */
    Right.prototype.ap = function (e) {
        var _this = this;
        return e.map(function (f) { return f(_this.r); });
    };
    /**
      * takeLeft extracts the left value of an Either, throwing an error if the Either is right.
      */
    Right.prototype.takeLeft = function () {
        throw new TypeError("Not left!");
    };
    Right.prototype.takeRight = function () {
        return this.r;
    };
    /**
     * cata
     */
    Right.prototype.cata = function (_, g) {
        return g(this.r);
    };
    return Right;
}(Either));
exports.Right = Right;

},{}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var Either_1 = require("./Either");
/**
 * free wraps a value in a free
 */
exports.free = function (a) { return new Return(a); };
/**
 * suspend lifts a function into a Free monad to mimic tail call recursion.
 */
exports.suspend = function (f) { return new Suspend(util_1.compose(exports.free, f)); };
/**
 * liftF lifts a Functor into a Free.
 */
exports.liftF = function (f) { return new Suspend(f.map(exports.free)); };
/**
 * Free is a Free monad that also implements a Free Applicative (almost).
 *
 * Inspired by https://cwmyers.github.io/monet.js/#free
 */
var Free = (function () {
    function Free() {
    }
    /**
     * of
     */
    Free.prototype.of = function (a) {
        return new Return(a);
    };
    /**
     * map
     */
    Free.prototype.map = function (f) {
        return this.chain(function (a) { return exports.free(f(a)); });
    };
    /**
     * chain
     */
    Free.prototype.chain = function (g) {
        if (this instanceof Suspend) {
            var f_1 = this.f;
            return (typeof f_1 === 'function') ?
                new Suspend(function (x) { return f_1(x).chain(g); }) :
                new Suspend(f_1.map(function (free) { return free.chain(g); }));
        }
        else if (this instanceof Return) {
            g(this.a);
        }
    };
    /**
     * resume the next stage of the computation
     */
    Free.prototype.resume = function () {
        if (this instanceof Suspend) {
            return Either_1.left(this.f);
        }
        else if (this instanceof Return) {
            return Either_1.right(this.a);
        }
    };
    /**
     * hoist
    hoist<B>(func: (fb: Functor<B>) => Functor<B>): Free<F, A> {

        if (this instanceof Suspend) {

            return new Suspend((func(this.f))
                .map((fr: Free<F, B>) => fr.hoist<any>(func)))
        } else {

            return this;

        }

    }
    */
    /**
     * cata
     */
    Free.prototype.cata = function (f, g) {
        return this.resume().cata(f, g);
    };
    /**
     * go runs the computation to completion using f to extract each stage.
     * @summmary go :: Free<F<*>, A>   (F<Free<F,A>>   Free<F,A>)   A
     */
    Free.prototype.go = function (f) {
        if (this instanceof Suspend) {
            var r = this.resume();
            while (r instanceof Either_1.Left)
                r = (f(r.takeLeft())).resume();
            return r.takeRight();
        }
        else if (this instanceof Return) {
            return this.a;
        }
    };
    /**
     * run the Free chain to completion
     * @summary run :: Free<A A,A>   A
     */
    Free.prototype.run = function () {
        return this.go(function (next) { return next(); });
    };
    Free.free = exports.free;
    Free.suspend = exports.suspend;
    Free.liftF = exports.liftF;
    return Free;
}());
exports.Free = Free;
var Suspend = (function (_super) {
    __extends(Suspend, _super);
    function Suspend(f) {
        var _this = _super.call(this) || this;
        _this.f = f;
        return _this;
    }
    return Suspend;
}(Free));
exports.Suspend = Suspend;
var Return = (function (_super) {
    __extends(Return, _super);
    function Return(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    return Return;
}(Free));
exports.Return = Return;

},{"../util":48,"./Either":42}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * wrapIO a value in the IO monad
 */
exports.wrapIO = function (a) { return new IO(function () { return a; }); };
/**
 * safeIO accepts a function that has side effects and wrapIOs it in an IO Monad.
 */
exports.safeIO = function (f) { return new IO(f); };
exports.pure = exports.wrapIO;
exports.suspend = exports.safeIO;
/**
 * IO monadic type for containing interactions with the 'real world'.
 */
var IO = (function () {
    function IO(effect) {
        this.effect = effect;
    }
    IO.prototype.of = function (v) {
        return new IO(function () { return v; });
    };
    IO.prototype.map = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()); });
    };
    IO.prototype.mapIn = function (b) {
        return this.map(function () { return b; });
    };
    /**
     * chain
     */
    IO.prototype.chain = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()).run(); });
    };
    IO.prototype.chainIn = function (b) {
        return this.chain(function () { return exports.wrapIO(b); });
    };
    /**
     * run
     */
    IO.prototype.run = function () {
        return this.effect();
    };
    IO.safeIO = exports.safeIO;
    IO.pure = exports.pure;
    IO.suspend = exports.suspend;
    IO.chain = function (f) { return function (m) { return m.chain(f); }; };
    return IO;
}());
exports.IO = IO;

},{}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Identity
 */
var Identity = (function () {
    function Identity(a) {
        this.a = a;
    }
    /**
     * of
     */
    Identity.prototype.of = function (a) {
        return new Identity(a);
    };
    /**
     * map
     */
    Identity.prototype.map = function (f) {
        return new Identity(f(this.get()));
    };
    /**
     * chain
     */
    Identity.prototype.chain = function (f) {
        return f(this.get());
    };
    /**
     * ap
     */
    Identity.prototype.ap = function (i) {
        var _this = this;
        return i.map(function (f) { return f(_this.get()); });
    };
    /**
     * get the value of an Identity
     * @summary get :: Identity<A>   A
     */
    Identity.prototype.get = function () {
        return this.a;
    };
    return Identity;
}());
exports.Identity = Identity;

},{}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("./Either");
/**
 * just wraps a value in a Just
 */
exports.just = function (a) { return new Just(a); };
;
/**
 * nothing constructs nothing
 */
exports.nothing = function () { return new Nothing(); };
/**
 * fromAny constructs a Maybe from a value that may be null.
 */
exports.fromAny = function (a) { return a == null ? exports.nothing() : exports.just(a); };
/**
 * fromArray checks an array to see if it's empty (or full of nulls)
 * and returns a Maybe.
 */
exports.fromArray = function (a) {
    return ((a.length === 0) || (a.reduce(function (c, v) { return (v == null) ? c + 1 : c; }, 0) === a.length)) ?
        exports.nothing() : exports.just(a);
};
/**
 * fromOBject uses Object.keys to turn see if an object has any own properties.
 */
exports.fromObject = function (o) {
    return Object.keys(o).length === 0 ? exports.nothing() : exports.just(o);
};
/**
 * fromString constructs nothing if the string is empty or just otherwise.
 */
exports.fromString = function (s) {
    return (s === '') ? exports.nothing() : exports.just(s);
};
/**
 * fromBoolean constructs nothing if b is false, just otherwise
 */
exports.fromBoolean = function (b) {
    return (b === false) ? exports.nothing() : exports.just(b);
};
/**
 * fromNumber constructs nothing if n is 0 just otherwise.
 */
exports.fromNumber = function (n) {
    return (n === 0) ? exports.nothing() : exports.just(n);
};
/**
 * Maybe
 */
var Maybe = (function () {
    function Maybe() {
    }
    Maybe.prototype.of = function (a) {
        return new Just(a);
    };
    Maybe.just = exports.just;
    Maybe.nothing = exports.nothing;
    Maybe.fromAny = exports.fromAny;
    Maybe.fromObject = exports.fromObject;
    Maybe.fromArray = exports.fromArray;
    Maybe.fromString = exports.fromString;
    Maybe.fromBoolean = exports.fromBoolean;
    Maybe.fromNumber = exports.fromNumber;
    return Maybe;
}());
exports.Maybe = Maybe;
/**
 * Nothing
 */
var Nothing = (function (_super) {
    __extends(Nothing, _super);
    function Nothing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Nothing.prototype.map = function (_) {
        return new Nothing();
    };
    Nothing.prototype.chain = function (_) {
        return new Nothing();
    };
    Nothing.prototype.get = function () {
        throw new TypeError('Cannot get anything from Nothing!');
    };
    Nothing.prototype.orElse = function (f) {
        return f();
    };
    /**
     * orJust will turn Nothing into Just, wrapping the value specified.
     */
    Nothing.prototype.orJust = function (f) {
        return exports.just(f());
    };
    /**
     * cata applies the corresponding function to the Maybe
     */
    Nothing.prototype.cata = function (f, _g) {
        return f();
    };
    Nothing.prototype.toEither = function () {
        return Either_1.left(undefined);
    };
    return Nothing;
}(Maybe));
exports.Nothing = Nothing;
/**
 * Just
 */
var Just = (function (_super) {
    __extends(Just, _super);
    function Just(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    Just.prototype.map = function (f) {
        return new Just(f(this.a));
    };
    Just.prototype.join = function () {
        return this.a;
    };
    Just.prototype.chain = function (f) {
        return f(this.a);
    };
    Just.prototype.get = function () {
        return this.a;
    };
    Just.prototype.orElse = function (_f) {
        return this;
    };
    Just.prototype.orJust = function (_f) {
        return this;
    };
    Just.prototype.cata = function (_f, g) {
        return g(this.a);
    };
    Just.prototype.toEither = function () {
        return Either_1.right(this.a);
    };
    return Just;
}(Maybe));
exports.Just = Just;

},{"./Either":42}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * get the state from the internals of the monad
 */
exports.get = function () { return new State(function (s) { return ([s, s]); }); };
/**
 * put
 */
exports.put = function (s) { return new State(function () { return ([null, s]); }); };
/**
 * modify the state
 * @summary  (S   S)   State<S   {A, S} >
 */
exports.modify = function (f) { return exports.get().chain(function (s) { return exports.put(f(s)); }); };
/**
 * gets applies a function to the state putting using the result
 * as the result of the computation.
 * @summary (S   A)   State<S   {A, S}>
 */
exports.gets = function (f) { return exports.get().chain(function (s) { return exports.state(f(s)); }); };
/**
 * state create a new State monad
 */
exports.state = function (a) { return new State(function (s) { return ([a, s]); }); };
/**
 * State is a monadic class that we use to hold information that changes
 * during computation.
 *
 * This implementation is influenced by:
 * @link https://en.wikipedia.org/wiki/Monad_(functional_programming)#State_monads
 * @property {s   (a, s)} a
 */
var State = (function () {
    function State(f) {
        this.f = f;
    }
    /**
     * of wraps a value in the State monad.
     * @summary A   State<S {A,S}>
     */
    State.prototype.of = function (a) {
        return new State(function (s) { return ([a, s]); });
    };
    /**
     * map
     * @summary State<S  {A,S}>   (A   B)   State<S   {C, S}>
     */
    State.prototype.map = function (f) {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return [f(a), s];
        });
    };
    /**
     * join replaces the outer State with an inner State
     */
    State.prototype.join = function () {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return a.run(s);
        });
    };
    /**
     * chain
     */
    State.prototype.chain = function (f) {
        return this.map(f).join();
    };
    /**
     * evaluate the State returning the final value
     */
    State.prototype.evaluate = function (s) {
        return this.run(s)[0];
    };
    /**
     * execute the State returning the final state.
     */
    State.prototype.execute = function (s) {
        return this.run(s)[1];
    };
    /**
     * run the State yielding the final value and state.
     * @summary State<S {A<S}>   S   {A,S}
     */
    State.prototype.run = function (s) {
        return this.f(s);
    };
    State.get = exports.get;
    State.put = exports.put;
    State.modify = exports.modify;
    State.gets = exports.gets;
    State.state = exports.state;
    return State;
}());
exports.State = State;

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * identity is the famed identity function.
 */
exports.identity = function (a) { return a; };
/**
 * merge two objects easily
 */
exports.merge = function () {
    var o = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        o[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, [{}].concat(o));
};
/**
 * fuse is the deep version of merge
 */
exports.fuse = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.reduce(function (o, c) {
        if (c === void 0) { c = {}; }
        return exports.reduce(c, function (co, cc, k) {
            return Array.isArray(cc) ?
                (Array.isArray(co[k]) ?
                    exports.merge(co, (_a = {}, _a[k] = (co[k]).map(exports.copy).concat(cc.map(exports.copy)), _a)) :
                    exports.merge(co, (_b = {}, _b[k] = cc.map(exports.copy), _b))) :
                typeof cc !== 'object' ?
                    exports.merge(co, (_c = {}, _c[k] = cc, _c)) :
                    exports.merge(co, (_d = {},
                        _d[k] = (typeof co[k] !== 'object') ?
                            exports.merge(co[k], cc) :
                            exports.fuse(co[k], cc),
                        _d));
            var _a, _b, _c, _d;
        }, o);
    }, {});
};
exports.copy = function (o) {
    return (Array.isArray(o)) ?
        o.map(exports.copy) :
        (typeof o === 'object') ?
            exports.reduce(o, function (p, c, k) {
                return exports.merge(p, (_a = {}, _a[k] = exports.copy(c), _a));
                var _a;
            }, {}) : o;
};
/**
 * reduce an object's keys (in no guaranteed order)
 */
exports.reduce = function (o, f, accum) {
    return Object.keys(o).reduce(function (p, k) { return f(p, o[k], k, o); }, accum);
};
/**
 * map over an object (in no guaranteed oreder)
 */
exports.map = function (o, f) {
    return Object.keys(o).map((function (k) { return f(o[k], k, o); }));
};
/**
 * compose two functions into one.
 */
exports.compose = function (f, g) { return function (x) { return f(g(x)); }; };
/**
 * fling removes a key from an object
 * @param {string} key
 * @param {object} object
 * @return {Object}
 * @summary {(string,Object)   Object}
 */
exports.fling = function (s, o) {
    if ((o == null) || (o.constructor !== Object))
        throw new TypeError('fling(): only works with object literals!');
    return Object.keys(o).reduce(function (o2, k) {
        return k === s ? o2 : exports.merge(o2, (_a = {},
            _a[k] = o[k],
            _a));
        var _a;
    }, {});
};
/**
 * head returns the item at index 0 of an array
 * @param {Array} list
 * @return {*}
 * @summary { Array   * }
 */
exports.head = function (list) { return list[0]; };
/**
 * tail returns the last item in an array
 * @param {Array} list
 * @return {*}
 * @summary {Array   *}
 */
exports.tail = function (list) { return list[list.length - 1]; };
/**
 * constant given a value, return a function that always returns this value.
 * @summary constant X   *   X
 *
 */
exports.constant = function (a) { return function () { return a; }; };
/**
 * f1 partial application.
 */
exports.f1 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return f.apply(null, args.concat(a)); };
};
/**
 * f2 partial application
 */
exports.f2 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return f.apply(null, args.concat(a, aa)); }; };
};
/**
 * f3 partial application
 */
exports.f3 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return f.apply(null, args.concat(a, aa, aaa)); }; }; };
};
/**
 * f4 partial application
 */
exports.f4 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa));
    }; }; }; };
};
/**
 * f5 partial application
 */
exports.f5 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) { return function (aaaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa, aaaaa));
    }; }; }; }; };
};
/**
 * except copies an object removing a single key.
 */
exports.except = function (keys, o) {
    return exports.reduce(o, function (p, c, k) {
        return keys.indexOf(k) > -1 ? p : exports.merge(p, (_a = {}, _a[k] = c, _a));
        var _a;
    }, {});
};

},{}],49:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],50:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./Either":49,"dup":46}],51:[function(require,module,exports){
/*
  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
    // the default is js
    var beautify = function(src, config) {
        return js_beautify.js_beautify(src, config);
    };

    // short aliases
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;

    // legacy aliases
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;

    return beautify;
}

if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([
        "./lib/beautify",
        "./lib/beautify-css",
        "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
    });
} else {
    (function(mod) {
        var js_beautify = require('./lib/beautify');
        var css_beautify = require('./lib/beautify-css');
        var html_beautify = require('./lib/beautify-html');

        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

    })(module);
}
},{"./lib/beautify":54,"./lib/beautify-css":52,"./lib/beautify-html":53}],52:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
        http://jsbeautifier.org/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                          indentation size,
        indent_char (space)                      character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {
var legacy_beautify_css =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);
var Output = __webpack_require__(3).Output;


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

function Beautifier(source_text, options) {
    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'css');

    source_text = source_text || '';

    var newlinesFromLastWSEat = 0;
    var indentSize = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    var indentCharacter = options.indent_char || ' ';
    var preserve_newlines = (options.preserve_newlines === undefined) ? false : options.preserve_newlines;
    var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
    var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
    var space_around_combinator = (options.space_around_combinator === undefined) ? false : options.space_around_combinator;
    space_around_combinator = space_around_combinator || ((options.space_around_selector_separator === undefined) ? false : options.space_around_selector_separator);
    var eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indentCharacter = '\t';
        indentSize = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (source_text && lineBreak.test(source_text || '')) {
            eol = source_text.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    source_text = source_text.replace(allLineBreaks, '\n');

    // tokenizer
    var whiteRe = /^\s+$/;

    var pos = -1,
        ch;
    var parenLevel = 0;

    function next() {
        ch = source_text.charAt(++pos);
        return ch || '';
    }

    function peek(skipWhitespace) {
        var result = '';
        var prev_pos = pos;
        if (skipWhitespace) {
            eatWhitespace();
        }
        result = source_text.charAt(pos + 1) || '';
        pos = prev_pos - 1;
        next();
        return result;
    }

    function eatString(endChars) {
        var start = pos;
        while (next()) {
            if (ch === "\\") {
                next();
            } else if (endChars.indexOf(ch) !== -1) {
                break;
            } else if (ch === "\n") {
                break;
            }
        }
        return source_text.substring(start, pos + 1);
    }

    function peekString(endChar) {
        var prev_pos = pos;
        var str = eatString(endChar);
        pos = prev_pos - 1;
        next();
        return str;
    }

    function eatWhitespace(preserve_newlines_local) {
        var result = 0;
        while (whiteRe.test(peek())) {
            next();
            if (ch === '\n' && preserve_newlines_local && preserve_newlines) {
                output.add_new_line(true);
                result++;
            }
        }
        newlinesFromLastWSEat = result;
        return result;
    }

    function skipWhitespace() {
        var result = '';
        if (ch && whiteRe.test(ch)) {
            result = ch;
        }
        while (whiteRe.test(next())) {
            result += ch;
        }
        return result;
    }

    function eatComment() {
        var start = pos;
        var singleLine = peek() === "/";
        next();
        while (next()) {
            if (!singleLine && ch === "*" && peek() === "/") {
                next();
                break;
            } else if (singleLine && ch === "\n") {
                return source_text.substring(start, pos);
            }
        }

        return source_text.substring(start, pos) + ch;
    }


    function lookBack(str) {
        return source_text.substring(pos - str.length, pos).toLowerCase() ===
            str;
    }

    // Nested pseudo-class if we are insideRule
    // and the next special character found opens
    // a new block
    function foundNestedPseudoClass() {
        var openParen = 0;
        for (var i = pos + 1; i < source_text.length; i++) {
            var ch = source_text.charAt(i);
            if (ch === "{") {
                return true;
            } else if (ch === '(') {
                // pseudoclasses can contain ()
                openParen += 1;
            } else if (ch === ')') {
                if (openParen === 0) {
                    return false;
                }
                openParen -= 1;
            } else if (ch === ";" || ch === "}") {
                return false;
            }
        }
        return false;
    }

    // printer
    var baseIndentString = '';
    var preindent_index = 0;
    if (source_text && source_text.length) {
        while ((source_text.charAt(preindent_index) === ' ' ||
                source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = source_text.substring(0, preindent_index);
        js_source_text = source_text.substring(preindent_index);
    }


    var singleIndent = new Array(indentSize + 1).join(indentCharacter);
    var indentLevel;
    var nestedLevel;
    var output;

    function print_string(output_string) {
        if (output.just_added_newline()) {
            output.set_indent(indentLevel);
        }
        output.add_token(output_string);
    }

    function preserveSingleSpace(isAfterSpace) {
        if (isAfterSpace) {
            output.space_before_token = true;
        }
    }

    function indent() {
        indentLevel++;
    }

    function outdent() {
        if (indentLevel > 0) {
            indentLevel--;
        }
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        // reset
        output = new Output(singleIndent, baseIndentString);
        indentLevel = 0;
        nestedLevel = 0;

        pos = -1;
        ch = null;
        parenLevel = 0;

        var insideRule = false;
        var insidePropertyValue = false;
        var enteringConditionalGroup = false;
        var top_ch = '';
        var last_top_ch = '';

        while (true) {
            var whitespace = skipWhitespace();
            var isAfterSpace = whitespace !== '';
            var isAfterNewline = whitespace.indexOf('\n') !== -1;
            last_top_ch = top_ch;
            top_ch = ch;

            if (!ch) {
                break;
            } else if (ch === '/' && peek() === '*') { /* css comment */
                var header = indentLevel === 0;

                if (isAfterNewline || header) {
                    output.add_new_line();
                }

                print_string(eatComment());
                output.add_new_line();
                if (header) {
                    output.add_new_line(true);
                }
            } else if (ch === '/' && peek() === '/') { // single line comment
                if (!isAfterNewline && last_top_ch !== '{') {
                    output.trim(true);
                }
                output.space_before_token = true;
                print_string(eatComment());
                output.add_new_line();
            } else if (ch === '@') {
                preserveSingleSpace(isAfterSpace);

                // deal with less propery mixins @{...}
                if (peek() === '{') {
                    print_string(eatString('}'));
                } else {
                    print_string(ch);

                    // strip trailing space, if present, for hash property checks
                    var variableOrRule = peekString(": ,;{}()[]/='\"");

                    if (variableOrRule.match(/[ :]$/)) {
                        // we have a variable or pseudo-class, add it and insert one space before continuing
                        next();
                        variableOrRule = eatString(": ").replace(/\s$/, '');
                        print_string(variableOrRule);
                        output.space_before_token = true;
                    }

                    variableOrRule = variableOrRule.replace(/\s$/, '');

                    // might be a nesting at-rule
                    if (variableOrRule in this.NESTED_AT_RULE) {
                        nestedLevel += 1;
                        if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                            enteringConditionalGroup = true;
                        }
                    }
                }
            } else if (ch === '#' && peek() === '{') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString('}'));
            } else if (ch === '{') {
                if (peek(true) === '}') {
                    eatWhitespace();
                    next();
                    output.space_before_token = true;
                    print_string("{}");
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                        output.add_new_line(true);
                    }
                } else {
                    indent();
                    output.space_before_token = true;
                    print_string(ch);
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    // when entering conditional groups, only rulesets are allowed
                    if (enteringConditionalGroup) {
                        enteringConditionalGroup = false;
                        insideRule = (indentLevel > nestedLevel);
                    } else {
                        // otherwise, declarations are also allowed
                        insideRule = (indentLevel >= nestedLevel);
                    }
                }
            } else if (ch === '}') {
                outdent();
                output.add_new_line();
                print_string(ch);
                insideRule = false;
                insidePropertyValue = false;
                if (nestedLevel) {
                    nestedLevel--;
                }

                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }

                if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                    output.add_new_line(true);
                }
            } else if (ch === ":") {
                eatWhitespace();
                if ((insideRule || enteringConditionalGroup) &&
                    !(lookBack("&") || foundNestedPseudoClass()) &&
                    !lookBack("(")) {
                    // 'property: value' delimiter
                    // which could be in a conditional group query
                    print_string(':');
                    if (!insidePropertyValue) {
                        insidePropertyValue = true;
                        output.space_before_token = true;
                    }
                } else {
                    // sass/less parent reference don't use a space
                    // sass nested pseudo-class don't use a space

                    // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
                    if (lookBack(" ")) {
                        output.space_before_token = true;
                    }
                    if (peek() === ":") {
                        // pseudo-element
                        next();
                        print_string("::");
                    } else {
                        // pseudo-class
                        print_string(':');
                    }
                }
            } else if (ch === '"' || ch === '\'') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString(ch));
            } else if (ch === ';') {
                insidePropertyValue = false;
                print_string(ch);
                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }
            } else if (ch === '(') { // may be a url
                if (lookBack("url")) {
                    print_string(ch);
                    eatWhitespace();
                    if (next()) {
                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
                            print_string(eatString(')'));
                        } else {
                            pos--;
                        }
                    }
                } else {
                    parenLevel++;
                    preserveSingleSpace(isAfterSpace);
                    print_string(ch);
                    eatWhitespace();
                }
            } else if (ch === ')') {
                print_string(ch);
                parenLevel--;
            } else if (ch === ',') {
                print_string(ch);
                if (!eatWhitespace(true) && selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
                    output.add_new_line();
                } else {
                    output.space_before_token = true;
                }
            } else if ((ch === '>' || ch === '+' || ch === '~') &&
                !insidePropertyValue && parenLevel < 1) {
                //handle combinator spacing
                if (space_around_combinator) {
                    output.space_before_token = true;
                    print_string(ch);
                    output.space_before_token = true;
                } else {
                    print_string(ch);
                    eatWhitespace();
                    // squash extra whitespace
                    if (ch && whiteRe.test(ch)) {
                        ch = '';
                    }
                }
            } else if (ch === ']') {
                print_string(ch);
            } else if (ch === '[') {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            } else if (ch === '=') { // no whitespace before or after
                eatWhitespace();
                print_string('=');
                if (whiteRe.test(ch)) {
                    ch = '';
                }

            } else {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            }
        }

        var sweetCode = output.get_code(end_with_newline, eol);

        return sweetCode;
    };

    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    this.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        // also in CONDITIONAL_GROUP_RULE below
        "@media": true,
        "@supports": true,
        "@document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
}

module.exports = css_beautify;

/***/ })
/******/ ]);
var css_beautify = legacy_beautify_css;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return {
            css_beautify: css_beautify
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    exports.css_beautify = css_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.css_beautify = css_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.css_beautify = css_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],53:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)   indent <head> and <body> sections,
    indent_size (default 4)           indentation size,
    indent_char (default space)       character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to pre tag) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/

(function() {
var legacy_beautify_html =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

// function trim(s) {
//     return s.replace(/^\s+|\s+$/g, '');
// }

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

function rtrim(s) {
    return s.replace(/\s+$/g, '');
}

function Beautifier(html_source, options, js_beautify, css_beautify) {
    //Wrapper function to invoke all the necessary constructors and deal with the output.
    html_source = html_source || '';

    var multi_parser,
        indent_inner_html,
        indent_body_inner_html,
        indent_head_inner_html,
        indent_size,
        indent_character,
        wrap_line_length,
        brace_style,
        unformatted,
        content_unformatted,
        preserve_newlines,
        max_preserve_newlines,
        indent_handlebars,
        wrap_attributes,
        wrap_attributes_indent_size,
        is_wrap_attributes_force,
        is_wrap_attributes_force_expand_multiline,
        is_wrap_attributes_force_aligned,
        end_with_newline,
        extra_liners,
        eol;

    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'html');

    // backwards compatibility to 1.3.4
    if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
        (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
        options.wrap_line_length = options.max_char;
    }

    indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
    indent_body_inner_html = (options.indent_body_inner_html === undefined) ? true : options.indent_body_inner_html;
    indent_head_inner_html = (options.indent_head_inner_html === undefined) ? true : options.indent_head_inner_html;
    indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
    indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
    brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
    wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
    unformatted = options.unformatted || [
        // https://www.w3.org/TR/html5/dom.html#phrasing-content
        'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
        'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
        'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
        'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
        'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
        'video', 'wbr', 'text',
        // prexisting - not sure of full effect of removing, leaving in
        'acronym', 'address', 'big', 'dt', 'ins', 'strike', 'tt',
    ];
    content_unformatted = options.content_unformatted || [
        'pre',
    ];
    preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    max_preserve_newlines = preserve_newlines ?
        (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) :
        0;
    indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
    wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
    wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);
    is_wrap_attributes_force = wrap_attributes.substr(0, 'force'.length) === 'force';
    is_wrap_attributes_force_expand_multiline = (wrap_attributes === 'force-expand-multiline');
    is_wrap_attributes_force_aligned = (wrap_attributes === 'force-aligned');
    end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    extra_liners = (typeof options.extra_liners === 'object') && options.extra_liners ?
        options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
        options.extra_liners.split(',') : 'head,body,/html'.split(',');
    eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indent_character = '\t';
        indent_size = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (html_source && lineBreak.test(html_source || '')) {
            eol = html_source.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    html_source = html_source.replace(allLineBreaks, '\n');

    function Parser() {

        this.pos = 0; //Parser position
        this.token = '';
        this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
        this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
            parent: 'parent1',
            parentcount: 1,
            parent1: ''
        };
        this.tag_type = '';
        this.token_text = this.last_token = this.last_text = this.token_type = '';
        this.newlines = 0;
        this.indent_content = indent_inner_html;
        this.indent_body_inner_html = indent_body_inner_html;
        this.indent_head_inner_html = indent_head_inner_html;

        this.Utils = { //Uilities made available to the various functions
            whitespace: "\n\r\t ".split(''),

            single_token: options.void_elements || [
                // HTLM void elements - aka self-closing tags - aka singletons
                // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
                'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
                'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
                // NOTE: Optional tags - are not understood.
                // https://www.w3.org/TR/html5/syntax.html#optional-tags
                // The rules for optional tags are too complex for a simple list
                // Also, the content of these tags should still be indented in many cases.
                // 'li' is a good exmple.

                // Doctype and xml elements
                '!doctype', '?xml',
                // ?php tag
                '?php',
                // other tags that were in this list, keeping just in case
                'basefont', 'isindex'
            ],
            extra_liners: extra_liners, //for tags that need a line of whitespace before them
            in_array: function(what, arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (what === arr[i]) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Return true if the given text is composed entirely of whitespace.
        this.is_whitespace = function(text) {
            for (var n = 0; n < text.length; n++) {
                if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
                    return false;
                }
            }
            return true;
        };

        this.traverse_whitespace = function() {
            var input_char = '';

            input_char = this.input.charAt(this.pos);
            if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                this.newlines = 0;
                while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
                        this.newlines += 1;
                    }

                    this.pos++;
                    input_char = this.input.charAt(this.pos);
                }
                return true;
            }
            return false;
        };

        // Append a space to the given content (string array) or, if we are
        // at the wrap_line_length, append a newline/indentation.
        // return true if a newline was added, false if a space was added
        this.space_or_wrap = function(content) {
            if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
                this.print_newline(false, content);
                this.print_indentation(content);
                return true;
            } else {
                this.line_char_count++;
                content.push(' ');
                return false;
            }
        };

        this.get_content = function() { //function to capture regular content between tags
            var input_char = '',
                content = [],
                handlebarsStarted = 0;

            while (this.input.charAt(this.pos) !== '<' || handlebarsStarted === 2) {
                if (this.pos >= this.input.length) {
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                if (handlebarsStarted < 2 && this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                    continue;
                }

                input_char = this.input.charAt(this.pos);

                if (indent_handlebars) {
                    if (input_char === '{') {
                        handlebarsStarted += 1;
                    } else if (handlebarsStarted < 2) {
                        handlebarsStarted = 0;
                    }

                    if (input_char === '}' && handlebarsStarted > 0) {
                        if (handlebarsStarted-- === 0) {
                            break;
                        }
                    }
                    // Handlebars parsing is complicated.
                    // {{#foo}} and {{/foo}} are formatted tags.
                    // {{something}} should get treated as content, except:
                    // {{else}} specifically behaves like {{#if}} and {{/if}}
                    var peek3 = this.input.substr(this.pos, 3);
                    if (peek3 === '{{#' || peek3 === '{{/') {
                        // These are tags and not content.
                        break;
                    } else if (peek3 === '{{!') {
                        return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
                    } else if (this.input.substr(this.pos, 2) === '{{') {
                        if (this.get_tag(true) === '{{else}}') {
                            break;
                        }
                    }
                }

                this.pos++;
                this.line_char_count++;
                content.push(input_char); //letter at-a-time (or string) inserted to an array
            }
            return content.length ? content.join('') : '';
        };

        this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
            if (this.pos === this.input.length) {
                return ['', 'TK_EOF'];
            }
            var content = '';
            var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
            reg_match.lastIndex = this.pos;
            var reg_array = reg_match.exec(this.input);
            var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
            if (this.pos < end_script) { //get everything in between the script tags
                content = this.input.substring(this.pos, end_script);
                this.pos = end_script;
            }
            return content;
        };

        this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
            if (this.tags[tag + 'count']) { //check for the existence of this tag type
                this.tags[tag + 'count']++;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            } else { //otherwise initialize this tag type
                this.tags[tag + 'count'] = 1;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            }
            this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
            this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
        };

        this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
            if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
                var temp_parent = this.tags.parent; //check to see if it's a closable tag.
                while (temp_parent) { //till we reach '' (the initial value);
                    if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
                        break;
                    }
                    temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
                }
                if (temp_parent) { //if we caught something
                    this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
                    this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
                }
                delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
                delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
                if (this.tags[tag + 'count'] === 1) {
                    delete this.tags[tag + 'count'];
                } else {
                    this.tags[tag + 'count']--;
                }
            }
        };

        this.indent_to_tag = function(tag) {
            // Match the indentation level to the last use of this tag, but don't remove it.
            if (!this.tags[tag + 'count']) {
                return;
            }
            var temp_parent = this.tags.parent;
            while (temp_parent) {
                if (tag + this.tags[tag + 'count'] === temp_parent) {
                    break;
                }
                temp_parent = this.tags[temp_parent + 'parent'];
            }
            if (temp_parent) {
                this.indent_level = this.tags[tag + this.tags[tag + 'count']];
            }
        };

        this.get_tag = function(peek) { //function to get a full tag and parse its type
            var input_char = '',
                content = [],
                comment = '',
                space = false,
                first_attr = true,
                has_wrapped_attrs = false,
                tag_start, tag_end,
                tag_start_char,
                orig_pos = this.pos,
                orig_line_char_count = this.line_char_count,
                is_tag_closed = false,
                tail;

            peek = peek !== undefined ? peek : false;

            do {
                if (this.pos >= this.input.length) {
                    if (peek) {
                        this.pos = orig_pos;
                        this.line_char_count = orig_line_char_count;
                    }
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
                    space = true;
                    continue;
                }

                if (input_char === "'" || input_char === '"') {
                    input_char += this.get_unformatted(input_char);
                    space = true;
                }

                if (input_char === '=') { //no space before =
                    space = false;
                }
                tail = this.input.substr(this.pos - 1);
                if (is_wrap_attributes_force_expand_multiline && has_wrapped_attrs && !is_tag_closed && (input_char === '>' || input_char === '/')) {
                    if (tail.match(/^\/?\s*>/)) {
                        space = false;
                        is_tag_closed = true;
                        this.print_newline(false, content);
                        this.print_indentation(content);
                    }
                }
                if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
                    //no space after = or before >
                    var wrapped = this.space_or_wrap(content);
                    var indentAttrs = wrapped && input_char !== '/' && !is_wrap_attributes_force;
                    space = false;

                    if (is_wrap_attributes_force && input_char !== '/') {
                        var force_first_attr_wrap = false;
                        if (is_wrap_attributes_force_expand_multiline && first_attr) {
                            var is_only_attribute = tail.match(/^\S*(="([^"]|\\")*")?\s*\/?\s*>/) !== null;
                            force_first_attr_wrap = !is_only_attribute;
                        }
                        if (!first_attr || force_first_attr_wrap) {
                            this.print_newline(false, content);
                            this.print_indentation(content);
                            indentAttrs = true;
                        }
                    }
                    if (indentAttrs) {
                        has_wrapped_attrs = true;

                        //indent attributes an auto, forced, or forced-align line-wrap
                        var alignment_size = wrap_attributes_indent_size;
                        if (is_wrap_attributes_force_aligned) {
                            alignment_size = content.indexOf(' ') + 1;
                        }

                        for (var count = 0; count < alignment_size; count++) {
                            // only ever further indent with spaces since we're trying to align characters
                            content.push(' ');
                        }
                    }
                    if (first_attr) {
                        for (var i = 0; i < content.length; i++) {
                            if (content[i] === ' ') {
                                first_attr = false;
                                break;
                            }
                        }
                    }
                }

                if (indent_handlebars && tag_start_char === '<') {
                    // When inside an angle-bracket tag, put spaces around
                    // handlebars not inside of strings.
                    if ((input_char + this.input.charAt(this.pos)) === '{{') {
                        input_char += this.get_unformatted('}}');
                        if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
                            input_char = ' ' + input_char;
                        }
                        space = true;
                    }
                }

                if (input_char === '<' && !tag_start_char) {
                    tag_start = this.pos - 1;
                    tag_start_char = '<';
                }

                if (indent_handlebars && !tag_start_char) {
                    if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
                        if (input_char === '#' || input_char === '/' || input_char === '!') {
                            tag_start = this.pos - 3;
                        } else {
                            tag_start = this.pos - 2;
                        }
                        tag_start_char = '{';
                    }
                }

                this.line_char_count++;
                content.push(input_char); //inserts character at-a-time (or string)

                if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
                    break;
                }
            } while (input_char !== '>');

            var tag_complete = content.join('');
            var tag_index;
            var tag_offset;

            // must check for space first otherwise the tag could have the first attribute included, and
            // then not un-indent correctly
            if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
                tag_index = tag_complete.indexOf(' ');
            } else if (tag_complete.indexOf('\n') !== -1) { //if there's a line break, thats where the tag name ends
                tag_index = tag_complete.indexOf('\n');
            } else if (tag_complete.charAt(0) === '{') {
                tag_index = tag_complete.indexOf('}');
            } else { //otherwise go with the tag ending
                tag_index = tag_complete.indexOf('>');
            }
            if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
                tag_offset = 1;
            } else {
                tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
            }
            var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
            if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
                this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
                if (!peek) {
                    this.tag_type = 'SINGLE';
                }
            } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
                if (!peek) {
                    this.indent_to_tag('if');
                    this.tag_type = 'HANDLEBARS_ELSE';
                    this.indent_content = true;
                    this.traverse_whitespace();
                }
            } else if (this.is_unformatted(tag_check, unformatted) ||
                this.is_unformatted(tag_check, content_unformatted)) {
                // do not reformat the "unformatted" or "content_unformatted" tags
                comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
                content.push(comment);
                tag_end = this.pos - 1;
                this.tag_type = 'SINGLE';
            } else if (tag_check === 'script' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 &&
                        tag_complete.search(/\b(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'SCRIPT';
                }
            } else if (tag_check === 'style' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'STYLE';
                }
            } else if (tag_check.charAt(0) === '!') { //peek for <! comment
                // for comments content is already correct.
                if (!peek) {
                    this.tag_type = 'SINGLE';
                    this.traverse_whitespace();
                }
            } else if (!peek) {
                if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
                    this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
                    this.tag_type = 'END';
                } else { //otherwise it's a start-tag
                    this.record_tag(tag_check); //push it on the tag stack
                    if (tag_check.toLowerCase() !== 'html') {
                        this.indent_content = true;
                    }
                    this.tag_type = 'START';
                }

                // Allow preserving of newlines after a start or end tag
                if (this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                }

                if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
                    this.print_newline(false, this.output);
                    if (this.output.length && this.output[this.output.length - 2] !== '\n') {
                        this.print_newline(true, this.output);
                    }
                }
            }

            if (peek) {
                this.pos = orig_pos;
                this.line_char_count = orig_line_char_count;
            }

            return content.join(''); //returns fully formatted tag
        };

        this.get_comment = function(start_pos) { //function to return comment content in its entirety
            // this is will have very poor perf, but will work for now.
            var comment = '',
                delimiter = '>',
                matched = false;

            this.pos = start_pos;
            var input_char = this.input.charAt(this.pos);
            this.pos++;

            while (this.pos <= this.input.length) {
                comment += input_char;

                // only need to check for the delimiter if the last chars match
                if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
                    comment.indexOf(delimiter) !== -1) {
                    break;
                }

                // only need to search for custom delimiter for the first few characters
                if (!matched && comment.length < 10) {
                    if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
                        delimiter = '<![endif]>';
                        matched = true;
                    } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
                        delimiter = ']]>';
                        matched = true;
                    } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
                        delimiter = ']>';
                        matched = true;
                    } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
                        delimiter = '-->';
                        matched = true;
                    } else if (comment.indexOf('{{!--') === 0) { // {{!-- handlebars comment
                        delimiter = '--}}';
                        matched = true;
                    } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
                        if (comment.length === 5 && comment.indexOf('{{!--') === -1) {
                            delimiter = '}}';
                            matched = true;
                        }
                    } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
                        delimiter = '?>';
                        matched = true;
                    } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
                        delimiter = '%>';
                        matched = true;
                    }
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;
            }

            return comment;
        };

        function tokenMatcher(delimiter) {
            var token = '';

            var add = function(str) {
                var newToken = token + str.toLowerCase();
                token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);
            };

            var doesNotMatch = function() {
                return token.indexOf(delimiter) === -1;
            };

            return {
                add: add,
                doesNotMatch: doesNotMatch
            };
        }

        this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety
            if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
                return '';
            }
            var input_char = '';
            var content = '';
            var space = true;

            var delimiterMatcher = tokenMatcher(delimiter);

            do {

                if (this.pos >= this.input.length) {
                    return content;
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (!space) {
                        this.line_char_count--;
                        continue;
                    }
                    if (input_char === '\n' || input_char === '\r') {
                        content += '\n';
                        /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            */
                        this.line_char_count = 0;
                        continue;
                    }
                }
                content += input_char;
                delimiterMatcher.add(input_char);
                this.line_char_count++;
                space = true;

                if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
                    // Handlebars expressions in strings should also be unformatted.
                    content += this.get_unformatted('}}');
                    // Don't consider when stopping for delimiters.
                }
            } while (delimiterMatcher.doesNotMatch());

            return content;
        };

        this.get_token = function() { //initial handler for token-retrieval
            var token;

            if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
                var type = this.last_token.substr(7);
                token = this.get_contents_to(type);
                if (typeof token !== 'string') {
                    return token;
                }
                return [token, 'TK_' + type];
            }
            if (this.current_mode === 'CONTENT') {
                token = this.get_content();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    return [token, 'TK_CONTENT'];
                }
            }

            if (this.current_mode === 'TAG') {
                token = this.get_tag();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    var tag_name_type = 'TK_TAG_' + this.tag_type;
                    return [token, tag_name_type];
                }
            }
        };

        this.get_full_indent = function(level) {
            level = this.indent_level + level || 0;
            if (level < 1) {
                return '';
            }

            return Array(level + 1).join(this.indent_string);
        };

        this.is_unformatted = function(tag_check, unformatted) {
            //is this an HTML5 block-level link?
            if (!this.Utils.in_array(tag_check, unformatted)) {
                return false;
            }

            if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
                return true;
            }

            //at this point we have an  tag; is its first child something we want to remain
            //unformatted?
            var next_tag = this.get_tag(true /* peek. */ );

            // test next_tag to see if it is just html tag (no external content)
            var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

            // if next_tag comes back but is not an isolated tag, then
            // let's treat the 'a' tag as having content
            // and respect the unformatted option
            if (!tag || this.Utils.in_array(tag[1], unformatted)) {
                return true;
            } else {
                return false;
            }
        };

        this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

            this.input = js_source || ''; //gets the input for the Parser

            // HACK: newline parsing inconsistent. This brute force normalizes the input.
            this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n');

            this.output = [];
            this.indent_character = indent_character;
            this.indent_string = '';
            this.indent_size = indent_size;
            this.brace_style = brace_style;
            this.indent_level = 0;
            this.wrap_line_length = wrap_line_length;
            this.line_char_count = 0; //count to see if wrap_line_length was exceeded

            for (var i = 0; i < this.indent_size; i++) {
                this.indent_string += this.indent_character;
            }

            this.print_newline = function(force, arr) {
                this.line_char_count = 0;
                if (!arr || !arr.length) {
                    return;
                }
                if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
                    if ((arr[arr.length - 1] !== '\n')) {
                        arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
                    }
                    arr.push('\n');
                }
            };

            this.print_indentation = function(arr) {
                for (var i = 0; i < this.indent_level; i++) {
                    arr.push(this.indent_string);
                    this.line_char_count += this.indent_string.length;
                }
            };

            this.print_token = function(text) {
                // Avoid printing initial whitespace.
                if (this.is_whitespace(text) && !this.output.length) {
                    return;
                }
                if (text || text !== '') {
                    if (this.output.length && this.output[this.output.length - 1] === '\n') {
                        this.print_indentation(this.output);
                        text = ltrim(text);
                    }
                }
                this.print_token_raw(text);
            };

            this.print_token_raw = function(text) {
                // If we are going to print newlines, truncate trailing
                // whitespace, as the newlines will represent the space.
                if (this.newlines > 0) {
                    text = rtrim(text);
                }

                if (text && text !== '') {
                    if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
                        // unformatted tags can grab newlines as their last character
                        this.output.push(text.slice(0, -1));
                        this.print_newline(false, this.output);
                    } else {
                        this.output.push(text);
                    }
                }

                for (var n = 0; n < this.newlines; n++) {
                    this.print_newline(n > 0, this.output);
                }
                this.newlines = 0;
            };

            this.indent = function() {
                this.indent_level++;
            };

            this.unindent = function() {
                if (this.indent_level > 0) {
                    this.indent_level--;
                }
            };
        };
        return this;
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        multi_parser = new Parser(); //wrapping functions Parser
        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values
        while (true) {
            var t = multi_parser.get_token();
            multi_parser.token_text = t[0];
            multi_parser.token_type = t[1];

            if (multi_parser.token_type === 'TK_EOF') {
                break;
            }

            switch (multi_parser.token_type) {
                case 'TK_TAG_START':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) &&
                            (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {

                            multi_parser.indent();
                        }

                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_STYLE':
                case 'TK_TAG_SCRIPT':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_END':
                    //Print new line only if the tag has no content and has child
                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
                        var tag_name = (multi_parser.token_text.match(/\w+/) || [])[0];
                        var tag_extracted_from_last_output = null;
                        if (multi_parser.output.length) {
                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
                        }
                        if (tag_extracted_from_last_output === null ||
                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
                            multi_parser.print_newline(false, multi_parser.output);
                        }
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_SINGLE':
                    // Don't add a newline before elements that should remain unformatted.
                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_ELSE':
                    // Don't add a newline if opening {{#if}} tag is on the current line
                    var foundIfOnCurrentLine = false;
                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
                        if (multi_parser.output[lastCheckedOutput] === '\n') {
                            break;
                        } else {
                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {
                                foundIfOnCurrentLine = true;
                                break;
                            }
                        }
                    }
                    if (!foundIfOnCurrentLine) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_COMMENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_CONTENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_STYLE':
                case 'TK_SCRIPT':
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_newline(false, multi_parser.output);
                        var text = multi_parser.token_text,
                            _beautifier,
                            script_indent_level = 1;
                        if (multi_parser.token_type === 'TK_SCRIPT') {
                            _beautifier = typeof js_beautify === 'function' && js_beautify;
                        } else if (multi_parser.token_type === 'TK_STYLE') {
                            _beautifier = typeof css_beautify === 'function' && css_beautify;
                        }

                        if (options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (options.indent_scripts === "separate") {
                            script_indent_level = -multi_parser.indent_level;
                        }

                        var indentation = multi_parser.get_full_indent(script_indent_level);
                        if (_beautifier) {

                            // call the Beautifier if avaliable
                            var Child_options = function() {
                                this.eol = '\n';
                            };
                            Child_options.prototype = options;
                            var child_options = new Child_options();
                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
                        } else {
                            // simply indent the string otherwise
                            var white = text.match(/^\s*/)[0];
                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
                            text = text.replace(/^\s*/, indentation)
                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
                                .replace(/\s+$/, '');
                        }
                        if (text) {
                            multi_parser.print_token_raw(text);
                            multi_parser.print_newline(true, multi_parser.output);
                        }
                    }
                    multi_parser.current_mode = 'TAG';
                    break;
                default:
                    // We should not be getting here but we don't want to drop input on the floor
                    // Just output the text and move on
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_token(multi_parser.token_text);
                    }
                    break;
            }
            multi_parser.last_token = multi_parser.token_type;
            multi_parser.last_text = multi_parser.token_text;
        }
        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

        // establish end_with_newline
        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function style_html(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
}

module.exports = style_html;

/***/ })
/******/ ]);
var style_html = legacy_beautify_html;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define(["require", "./beautify", "./beautify-css"], function(requireamd) {
        var js_beautify = requireamd("./beautify");
        var css_beautify = requireamd("./beautify-css");

        return {
            html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
            }
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    var js_beautify = require('./beautify.js');
    var css_beautify = require('./beautify-css.js');

    exports.html_beautify = function(html_source, options) {
        return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
    };
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.html_beautify = function(html_source, options) {
        return style_html(html_source, options, window.js_beautify, window.css_beautify);
    };
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.html_beautify = function(html_source, options) {
        return style_html(html_source, options, global.js_beautify, global.css_beautify);
    };
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./beautify-css.js":52,"./beautify.js":54}],54:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/* see js/src/javascript/index.js */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {
var legacy_beautify_js =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var mergeOpts = __webpack_require__(3).mergeOpts;
var acorn = __webpack_require__(0);
var Output = __webpack_require__(4).Output;
var Tokenizer = __webpack_require__(7).Tokenizer;

function remove_redundant_indentation(output, frame) {
    // This implementation is effective but has some issues:
    //     - can cause line wrap to happen too soon due to indent removal
    //           after wrap points are calculated
    // These issues are minor compared to ugly indentation.

    if (frame.multiline_frame ||
        frame.mode === MODE.ForInitializer ||
        frame.mode === MODE.Conditional) {
        return;
    }

    // remove one indent from each line inside this section
    var start_index = frame.start_line_index;

    output.remove_indent(start_index);
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

// function rtrim(s) {
//     return s.replace(/\s+$/g, '');
// }


function generateMapFromStrings(list) {
    var result = {};
    for (var x = 0; x < list.length; x++) {
        // make the mapped names underscored instead of dash
        result[list[x].replace(/-/g, '_')] = list[x];
    }
    return result;
}

function sanitizeOperatorPosition(opPosition) {
    opPosition = opPosition || OPERATOR_POSITION.before_newline;

    if (!in_array(opPosition, validPositionValues)) {
        throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
            validPositionValues +
            "\nYou passed in: '" + opPosition + "'");
    }

    return opPosition;
}

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
    BlockStatement: 'BlockStatement', // 'BLOCK'
    Statement: 'Statement', // 'STATEMENT'
    ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
    ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
    ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
    Conditional: 'Conditional', //'(COND-EXPRESSION)',
    Expression: 'Expression' //'(EXPRESSION)'
};

function Beautifier(js_source_text, options) {
    "use strict";
    var output;
    var tokens = [],
        token_pos;
    var tokenizer;
    var current_token;
    var last_type, last_last_text, indent_string;
    var flags, previous_flags, flag_store;
    var prefix;

    var handlers, opt;
    var baseIndentString = '';

    handlers = {
        'TK_START_EXPR': handle_start_expr,
        'TK_END_EXPR': handle_end_expr,
        'TK_START_BLOCK': handle_start_block,
        'TK_END_BLOCK': handle_end_block,
        'TK_WORD': handle_word,
        'TK_RESERVED': handle_word,
        'TK_SEMICOLON': handle_semicolon,
        'TK_STRING': handle_string,
        'TK_EQUALS': handle_equals,
        'TK_OPERATOR': handle_operator,
        'TK_COMMA': handle_comma,
        'TK_BLOCK_COMMENT': handle_block_comment,
        'TK_COMMENT': handle_comment,
        'TK_DOT': handle_dot,
        'TK_UNKNOWN': handle_unknown,
        'TK_EOF': handle_eof
    };

    function create_flags(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
            next_indent_level = flags_base.indentation_level;
            if (!output.just_added_newline() &&
                flags_base.line_indent_level > next_indent_level) {
                next_indent_level = flags_base.line_indent_level;
            }
        }

        var next_flags = {
            mode: mode,
            parent: flags_base,
            last_text: flags_base ? flags_base.last_text : '', // last token text
            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
            declaration_statement: false,
            declaration_assignment: false,
            multiline_frame: false,
            inline_frame: false,
            if_block: false,
            else_block: false,
            do_block: false,
            do_while: false,
            import_block: false,
            in_case_statement: false, // switch(..){ INSIDE HERE }
            in_case: false, // we're on the exact line with "case 0:"
            case_body: false, // the indented case-action block
            indentation_level: next_indent_level,
            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
            start_line_index: output.get_line_number(),
            ternary_depth: 0
        };
        return next_flags;
    }

    // Some interpreters have unexpected results with foo = baz || bar;
    options = options ? options : {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'js');

    opt = {};

    // compatibility, re
    if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
        options.brace_style = "expand";
    } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
        options.brace_style = "collapse,preserve-inline";
    } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
        options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
    } else if (!options.brace_style) //Nothing exists to set it
    {
        options.brace_style = "collapse";
    }


    var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
    opt.brace_style = brace_style_split[0];
    opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    opt.indent_char = options.indent_char ? options.indent_char : ' ';
    opt.eol = options.eol ? options.eol : 'auto';
    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    opt.unindent_chained_methods = (options.unindent_chained_methods === undefined) ? false : options.unindent_chained_methods;
    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
    opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
    opt.e4x = (options.e4x === undefined) ? false : options.e4x;
    opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
    opt.operator_position = sanitizeOperatorPosition(options.operator_position);

    // For testing of beautify ignore:start directive
    opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

    // force opt.space_after_anon_function to true if opt.jslint_happy
    if (opt.jslint_happy) {
        opt.space_after_anon_function = true;
    }

    if (options.indent_with_tabs) {
        opt.indent_char = '\t';
        opt.indent_size = 1;
    }

    if (opt.eol === 'auto') {
        opt.eol = '\n';
        if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
            opt.eol = js_source_text.match(acorn.lineBreak)[0];
        }
    }

    opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    //----------------------------------
    indent_string = '';
    while (opt.indent_size > 0) {
        indent_string += opt.indent_char;
        opt.indent_size -= 1;
    }

    var preindent_index = 0;
    if (js_source_text && js_source_text.length) {
        while ((js_source_text.charAt(preindent_index) === ' ' ||
                js_source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = js_source_text.substring(0, preindent_index);
        js_source_text = js_source_text.substring(preindent_index);
    }

    last_type = 'TK_START_BLOCK'; // last token type
    last_last_text = ''; // pre-last token text
    output = new Output(indent_string, baseIndentString);

    // If testing the ignore directive, start with output disable set to true
    output.raw = opt.test_output_raw;


    // Stack of parsing/formatting states, including MODE.
    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
    // and formatted output.  This makes the beautifier less accurate than full parsers
    // but also far more tolerant of syntax errors.
    //
    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
    // most full parsers would die, but the beautifier gracefully falls back to
    // MODE.BlockStatement and continues on.
    flag_store = [];
    set_mode(MODE.BlockStatement);

    this.beautify = function() {

        /*jshint onevar:true */
        var sweet_code;
        tokenizer = new Tokenizer(js_source_text, opt, indent_string);
        tokens = tokenizer.tokenize();
        token_pos = 0;

        current_token = get_token();
        while (current_token) {
            handlers[current_token.type]();

            last_last_text = flags.last_text;
            last_type = current_token.type;
            flags.last_text = current_token.text;

            token_pos += 1;
            current_token = get_token();
        }

        sweet_code = output.get_code(opt.end_with_newline, opt.eol);

        return sweet_code;
    };

    function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
        var newlines = local_token.newlines;
        var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
        var temp_token = current_token;

        for (var h = 0; h < local_token.comments_before.length; h++) {
            // The cleanest handling of inline comments is to treat them as though they aren't there.
            // Just continue formatting and the behavior should be logical.
            // Also ignore unknown tokens.  Again, this should result in better behavior.
            current_token = local_token.comments_before[h];
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
            handlers[current_token.type](preserve_statement_flags);
        }
        current_token = temp_token;

        if (keep_whitespace) {
            for (var i = 0; i < newlines; i += 1) {
                print_newline(i > 0, preserve_statement_flags);
            }
        } else {
            if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
                newlines = opt.max_preserve_newlines;
            }

            if (opt.preserve_newlines) {
                if (local_token.newlines > 1) {
                    print_newline(false, preserve_statement_flags);
                    for (var j = 1; j < newlines; j += 1) {
                        print_newline(true, preserve_statement_flags);
                    }
                }
            }
        }

    }

    // we could use just string.split, but
    // IE doesn't like returning empty strings
    function split_linebreaks(s) {
        //return s.split(/\x0d\x0a|\x0a/);

        s = s.replace(acorn.allLineBreaks, '\n');
        var out = [],
            idx = s.indexOf("\n");
        while (idx !== -1) {
            out.push(s.substring(0, idx));
            s = s.substring(idx + 1);
            idx = s.indexOf("\n");
        }
        if (s.length) {
            out.push(s);
        }
        return out;
    }

    var newline_restricted_tokens = ['break', 'continue', 'return', 'throw', 'yield'];

    function allow_wrap_or_preserved_newline(force_linewrap) {
        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

        // Never wrap the first token on a line
        if (output.just_added_newline()) {
            return;
        }

        var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
        var operatorLogicApplies = in_array(flags.last_text, tokenizer.positionable_operators) || in_array(current_token.text, tokenizer.positionable_operators);

        if (operatorLogicApplies) {
            var shouldPrintOperatorNewline = (
                    in_array(flags.last_text, tokenizer.positionable_operators) &&
                    in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
                ) ||
                in_array(current_token.text, tokenizer.positionable_operators);
            shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }

        if (shouldPreserveOrForce) {
            print_newline(false, true);
        } else if (opt.wrap_line_length) {
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
                // These tokens should never have a newline inserted
                // between them and the following expression.
                return;
            }
            var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
                (output.space_before_token ? 1 : 0);
            if (proposed_line_length >= opt.wrap_line_length) {
                print_newline(false, true);
            }
        }
    }

    function print_newline(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                var next_token = get_token(1);
                while (flags.mode === MODE.Statement &&
                    !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
                    !flags.do_block) {
                    restore_mode();
                }
            }
        }

        if (output.add_new_line(force_newline)) {
            flags.multiline_frame = true;
        }
    }

    function print_token_line_indentation() {
        if (output.just_added_newline()) {
            if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
                output.current_line.push(current_token.whitespace_before);
                output.space_before_token = false;
            } else if (output.set_indent(flags.indentation_level)) {
                flags.line_indent_level = flags.indentation_level;
            }
        }
    }

    function print_token(printable_token) {
        if (output.raw) {
            output.add_raw_token(current_token);
            return;
        }

        if (opt.comma_first && last_type === 'TK_COMMA' &&
            output.just_added_newline()) {
            if (output.previous_line.last() === ',') {
                var popped = output.previous_line.pop();
                // if the comma was already at the start of the line,
                // pull back onto that line and reprint the indentation
                if (output.previous_line.is_empty()) {
                    output.previous_line.push(popped);
                    output.trim(true);
                    output.current_line.pop();
                    output.trim();
                }

                // add the comma in front of the next token
                print_token_line_indentation();
                output.add_token(',');
                output.space_before_token = true;
            }
        }

        printable_token = printable_token || current_token.text;
        print_token_line_indentation();
        output.add_token(printable_token);
    }

    function indent() {
        flags.indentation_level += 1;
    }

    function deindent() {
        if (flags.indentation_level > 0 &&
            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
            flags.indentation_level -= 1;

        }
    }

    function set_mode(mode) {
        if (flags) {
            flag_store.push(flags);
            previous_flags = flags;
        } else {
            previous_flags = create_flags(null, mode);
        }

        flags = create_flags(previous_flags, mode);
    }

    function is_array(mode) {
        return mode === MODE.ArrayLiteral;
    }

    function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
    }

    function restore_mode() {
        if (flag_store.length > 0) {
            previous_flags = flags;
            flags = flag_store.pop();
            if (previous_flags.mode === MODE.Statement && !opt.unindent_chained_methods) {
                remove_redundant_indentation(output, previous_flags);
            }
        }
    }

    function start_of_object_property() {
        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
            (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
    }

    function start_of_statement() {
        if (
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens) && !current_token.wanted_newline) ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
                !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
            (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
            (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
                !flags.in_case &&
                !(current_token.text === '--' || current_token.text === '++') &&
                last_last_text !== 'function' &&
                current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
            (flags.mode === MODE.ObjectLiteral && (
                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
        ) {

            set_mode(MODE.Statement);
            if (!opt.unindent_chained_methods) {
                indent();
            }

            handle_whitespace_and_comments(current_token, true);

            // Issue #276:
            // If starting a new statement with [if, for, while, do], push to a new line.
            // if (a) if (b) if(c) d(); else e(); else f();
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline(
                    current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
            }

            return true;
        }
        return false;
    }

    function all_lines_start_with(lines, c) {
        for (var i = 0; i < lines.length; i++) {
            var line = trim(lines[i]);
            if (line.charAt(0) !== c) {
                return false;
            }
        }
        return true;
    }

    function each_line_matches_indent(lines, indent) {
        var i = 0,
            len = lines.length,
            line;
        for (; i < len; i++) {
            line = lines[i];
            // allow empty lines to pass through
            if (line && line.indexOf(indent) !== 0) {
                return false;
            }
        }
        return true;
    }

    function is_special_word(word) {
        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
    }

    function get_token(offset) {
        var index = token_pos + (offset || 0);
        return (index < 0 || index >= tokens.length) ? null : tokens[index];
    }

    function handle_start_expr() {
        // The conditional starts the statement if appropriate.
        if (!start_of_statement()) {
            handle_whitespace_and_comments(current_token);
        }

        var next_mode = MODE.Expression;
        if (current_token.text === '[') {

            if (last_type === 'TK_WORD' || flags.last_text === ')') {
                // this is array index specifier, break immediately
                // a[x], fn()[x]
                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, tokenizer.line_starters)) {
                    output.space_before_token = true;
                }
                set_mode(next_mode);
                print_token();
                indent();
                if (opt.space_in_paren) {
                    output.space_before_token = true;
                }
                return;
            }

            next_mode = MODE.ArrayLiteral;
            if (is_array(flags.mode)) {
                if (flags.last_text === '[' ||
                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                    // ], [ goes to new line
                    // }, [ goes to new line
                    if (!opt.keep_array_indentation) {
                        print_newline();
                    }
                }
            }

        } else {
            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                next_mode = MODE.ForInitializer;
            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                next_mode = MODE.Conditional;
            } else {
                // next_mode = MODE.Expression;
            }
        }

        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
            print_newline();
        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
            allow_wrap_or_preserved_newline(current_token.wanted_newline);
            // do nothing on (( and )( and ][ and ]( and .(
        } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
            output.space_before_token = true;
        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            // function() vs function ()
            // yield*() vs yield* ()
            // function*() vs function* ()
            if (opt.space_after_anon_function) {
                output.space_before_token = true;
            }
        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, tokenizer.line_starters) || flags.last_text === 'catch')) {
            if (opt.space_before_conditional) {
                output.space_before_token = true;
            }
        }

        // Should be a space between await and an IIFE, or async and an arrow function
        if (current_token.text === '(' && last_type === 'TK_RESERVED' && in_array(flags.last_word, ['await', 'async'])) {
            output.space_before_token = true;
        }

        // Support of this kind of newline preservation.
        // a = (b &&
        //     (c || d));
        if (current_token.text === '(') {
            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
        }

        // Support preserving wrapped arrow function expressions
        // a.b('c',
        //     () => d.e
        // )
        if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
            allow_wrap_or_preserved_newline();
        }

        set_mode(next_mode);
        print_token();
        if (opt.space_in_paren) {
            output.space_before_token = true;
        }

        // In all cases, if we newline while inside an expression it should be indented.
        indent();
    }

    function handle_end_expr() {
        // statements inside expressions are not valid syntax, but...
        // statements must all be closed when their container closes
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        handle_whitespace_and_comments(current_token);

        if (flags.multiline_frame) {
            allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
        }

        if (opt.space_in_paren) {
            if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
                // () [] no inner space in empty parens like these, ever, ref #320
                output.trim();
                output.space_before_token = false;
            } else {
                output.space_before_token = true;
            }
        }
        if (current_token.text === ']' && opt.keep_array_indentation) {
            print_token();
            restore_mode();
        } else {
            restore_mode();
            print_token();
        }
        remove_redundant_indentation(output, previous_flags);

        // do {} while () // no statement required after
        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
            previous_flags.mode = MODE.Expression;
            flags.do_block = false;
            flags.do_while = false;

        }
    }

    function handle_start_block() {
        handle_whitespace_and_comments(current_token);

        // Check if this is should be treated as a ObjectLiteral
        var next_token = get_token(1);
        var second_token = get_token(2);
        if (second_token && (
                (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
                (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
            )) {
            // We don't support TypeScript,but we didn't break it for a very long time.
            // We'll try to keep not breaking it.
            if (!in_array(last_last_text, ['class', 'interface'])) {
                set_mode(MODE.ObjectLiteral);
            } else {
                set_mode(MODE.BlockStatement);
            }
        } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
            // arrow function: (param1, paramN) => { statements }
            set_mode(MODE.BlockStatement);
        } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
        ) {
            // Detecting shorthand function syntax is difficult by scanning forward,
            //     so check the surrounding context.
            // If the block is being returned, imported, export default, passed as arg,
            //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
            set_mode(MODE.ObjectLiteral);
        } else {
            set_mode(MODE.BlockStatement);
        }

        var empty_braces = !next_token.comments_before.length && next_token.text === '}';
        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
            last_type === 'TK_END_EXPR';

        if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
        {
            // search forward for a newline wanted inside this block
            var index = 0;
            var check_token = null;
            flags.inline_frame = true;
            do {
                index += 1;
                check_token = get_token(index);
                if (check_token.wanted_newline) {
                    flags.inline_frame = false;
                    break;
                }
            } while (check_token.type !== 'TK_EOF' &&
                !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
        }

        if ((opt.brace_style === "expand" ||
                (opt.brace_style === "none" && current_token.wanted_newline)) &&
            !flags.inline_frame) {
            if (last_type !== 'TK_OPERATOR' &&
                (empty_anonymous_function ||
                    last_type === 'TK_EQUALS' ||
                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                output.space_before_token = true;
            } else {
                print_newline(false, true);
            }
        } else { // collapse || inline_frame
            if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
                if (last_type === 'TK_COMMA' || opt.space_in_paren) {
                    output.space_before_token = true;
                }

                if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
                    allow_wrap_or_preserved_newline();
                    previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
                    flags.multiline_frame = false;
                }
            }
            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
                    print_newline();
                } else {
                    output.space_before_token = true;
                }
            }
        }
        print_token();
        indent();
    }

    function handle_end_block() {
        // statements must all be closed when their container closes
        handle_whitespace_and_comments(current_token);

        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        var empty_braces = last_type === 'TK_START_BLOCK';

        if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
            output.space_before_token = true;
        } else if (opt.brace_style === "expand") {
            if (!empty_braces) {
                print_newline();
            }
        } else {
            // skip {}
            if (!empty_braces) {
                if (is_array(flags.mode) && opt.keep_array_indentation) {
                    // we REALLY need a newline here, but newliner would skip that
                    opt.keep_array_indentation = false;
                    print_newline();
                    opt.keep_array_indentation = true;

                } else {
                    print_newline();
                }
            }
        }
        restore_mode();
        print_token();
    }

    function handle_word() {
        if (current_token.type === 'TK_RESERVED') {
            if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
                current_token.type = 'TK_WORD';
            } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
                current_token.type = 'TK_WORD';
            } else if (flags.mode === MODE.ObjectLiteral) {
                var next_token = get_token(1);
                if (next_token.text === ':') {
                    current_token.type = 'TK_WORD';
                }
            }
        }

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
                flags.declaration_statement = true;
            }
        } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
            last_type !== 'TK_EQUALS' &&
            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
            handle_whitespace_and_comments(current_token);
            print_newline();
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.do_block && !flags.do_while) {
            if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
                // do {} ## while ()
                output.space_before_token = true;
                print_token();
                output.space_before_token = true;
                flags.do_while = true;
                return;
            } else {
                // do {} should always have while as the next word.
                // if we don't see the expected while, recover
                print_newline();
                flags.do_block = false;
            }
        }

        // if may be followed by else, or not
        // Bare/inline ifs are tricky
        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
        if (flags.if_block) {
            if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
                flags.else_block = true;
            } else {
                while (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                flags.if_block = false;
                flags.else_block = false;
            }
        }

        if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
            print_newline();
            if (flags.case_body || opt.jslint_happy) {
                // switch cases following one another
                deindent();
                flags.case_body = false;
            }
            print_token();
            flags.in_case = true;
            flags.in_case_statement = true;
            return;
        }

        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline();
            }
        }

        if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
            if (in_array(flags.last_text, ['}', ';']) ||
                (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
                // make sure there is a nice clean space of at least one blank line
                // before a new function definition
                if (!output.just_added_blankline() && !current_token.comments_before.length) {
                    print_newline();
                    print_newline(true);
                }
            }
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                if (last_type === 'TK_RESERVED' && (
                        in_array(flags.last_text, ['get', 'set', 'new', 'export', 'async']) ||
                        in_array(flags.last_text, newline_restricted_tokens))) {
                    output.space_before_token = true;
                } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
                    output.space_before_token = true;
                } else {
                    print_newline();
                }
            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                // foo = function
                output.space_before_token = true;
            } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
                // (function
            } else {
                print_newline();
            }

            print_token();
            flags.last_word = current_token.text;
            return;
        }

        prefix = 'NONE';

        if (last_type === 'TK_END_BLOCK') {

            if (previous_flags.inline_frame) {
                prefix = 'SPACE';
            } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
                prefix = 'NEWLINE';
            } else {
                if (opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) {
                    prefix = 'NEWLINE';
                } else {
                    prefix = 'SPACE';
                    output.space_before_token = true;
                }
            }
        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
            // TODO: Should this be for STATEMENT as well?
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_STRING') {
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_START_BLOCK') {
            if (flags.inline_frame) {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }
        } else if (last_type === 'TK_END_EXPR') {
            output.space_before_token = true;
            prefix = 'NEWLINE';
        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
            if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }

        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
            if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
                    opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) &&
                !flags.inline_frame) {
                print_newline();
            } else {
                output.trim(true);
                var line = output.current_line;
                // If we trimmed and there's something other than a close block before us
                // put a newline back in.  Handles '} // comment' scenario.
                if (line.last() !== '}') {
                    print_newline();
                }
                output.space_before_token = true;
            }
        } else if (prefix === 'NEWLINE') {
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // no newline between 'return nnn'
                output.space_before_token = true;
            } else if (last_type !== 'TK_END_EXPR') {
                if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                    // no need to force newline on 'var': for (var x = 0...)
                    if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                        // no newline for } else if {
                        output.space_before_token = true;
                    } else {
                        print_newline();
                    }
                }
            } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
                print_newline();
            }
        } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
            print_newline(); // }, in lists get a newline treatment
        } else if (prefix === 'SPACE') {
            output.space_before_token = true;
        }
        print_token();
        flags.last_word = current_token.text;

        if (current_token.type === 'TK_RESERVED') {
            if (current_token.text === 'do') {
                flags.do_block = true;
            } else if (current_token.text === 'if') {
                flags.if_block = true;
            } else if (current_token.text === 'import') {
                flags.import_block = true;
            } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
                flags.import_block = false;
            }
        }
    }

    function handle_semicolon() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // Semicolon can be the start (and end) of a statement
            output.space_before_token = false;
        } else {
            handle_whitespace_and_comments(current_token);
        }

        var next_token = get_token(1);
        while (flags.mode === MODE.Statement &&
            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
            !flags.do_block) {
            restore_mode();
        }

        // hacky but effective for the moment
        if (flags.import_block) {
            flags.import_block = false;
        }
        print_token();
    }

    function handle_string() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // One difference - strings want at least a space before
            output.space_before_token = true;
        } else {
            handle_whitespace_and_comments(current_token);
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
                output.space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
        }
        print_token();
    }

    function handle_equals() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.declaration_statement) {
            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
            flags.declaration_assignment = true;
        }
        output.space_before_token = true;
        print_token();
        output.space_before_token = true;
    }

    function handle_comma() {
        handle_whitespace_and_comments(current_token, true);

        print_token();
        output.space_before_token = true;
        if (flags.declaration_statement) {
            if (is_expression(flags.parent.mode)) {
                // do not break on comma, for(var a = 1, b = 2)
                flags.declaration_assignment = false;
            }

            if (flags.declaration_assignment) {
                flags.declaration_assignment = false;
                print_newline(false, true);
            } else if (opt.comma_first) {
                // for comma-first, we want to allow a newline before the comma
                // to turn into a newline after the comma, which we will fixup later
                allow_wrap_or_preserved_newline();
            }
        } else if (flags.mode === MODE.ObjectLiteral ||
            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
            if (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (!flags.inline_frame) {
                print_newline();
            }
        } else if (opt.comma_first) {
            // EXPR or DO_BLOCK
            // for comma-first, we want to allow a newline before the comma
            // to turn into a newline after the comma, which we will fixup later
            allow_wrap_or_preserved_newline();
        }
    }

    function handle_operator() {
        var isGeneratorAsterisk = current_token.text === '*' &&
            ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
                (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
            );
        var isUnary = in_array(current_token.text, ['-', '+']) && (
            in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
            in_array(flags.last_text, tokenizer.line_starters) ||
            flags.last_text === ','
        );

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            var preserve_statement_flags = !isGeneratorAsterisk;
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            // "return" had a special handling in TK_WORD. Now we need to return the favor
            output.space_before_token = true;
            print_token();
            return;
        }

        // hack for actionscript's import .*;
        if (current_token.text === '*' && last_type === 'TK_DOT') {
            print_token();
            return;
        }

        if (current_token.text === '::') {
            // no spaces around exotic namespacing syntax operator
            print_token();
            return;
        }

        // Allow line wrapping between operators when operator_position is
        //   set to before or preserve
        if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
            allow_wrap_or_preserved_newline();
        }

        if (current_token.text === ':' && flags.in_case) {
            flags.case_body = true;
            indent();
            print_token();
            print_newline();
            flags.in_case = false;
            return;
        }

        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ':') {
            if (flags.ternary_depth === 0) {
                // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                space_before = false;
            } else {
                flags.ternary_depth -= 1;
                in_ternary = true;
            }
        } else if (current_token.text === '?') {
            flags.ternary_depth += 1;
        }

        // let's handle the operator_position option prior to any conflicting logic
        if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, tokenizer.positionable_operators)) {
            var isColon = current_token.text === ':';
            var isTernaryColon = (isColon && in_ternary);
            var isOtherColon = (isColon && !in_ternary);

            switch (opt.operator_position) {
                case OPERATOR_POSITION.before_newline:
                    // if the current token is : and it's not a ternary statement then we set space_before to false
                    output.space_before_token = !isOtherColon;

                    print_token();

                    if (!isColon || isTernaryColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.after_newline:
                    // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
                    //   then print a newline.

                    output.space_before_token = true;

                    if (!isColon || isTernaryColon) {
                        if (get_token(1).wanted_newline) {
                            print_newline(false, true);
                        } else {
                            allow_wrap_or_preserved_newline();
                        }
                    } else {
                        output.space_before_token = false;
                    }

                    print_token();

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.preserve_newline:
                    if (!isOtherColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    // if we just added a newline, or the current token is : and it's not a ternary statement,
                    //   then we set space_before to false
                    space_before = !(output.just_added_newline() || isOtherColon);

                    output.space_before_token = space_before;
                    print_token();
                    output.space_before_token = true;
                    return;
            }
        }

        if (isGeneratorAsterisk) {
            allow_wrap_or_preserved_newline();
            space_before = false;
            var next_token = get_token(1);
            space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
        } else if (current_token.text === '...') {
            allow_wrap_or_preserved_newline();
            space_before = last_type === 'TK_START_BLOCK';
            space_after = false;
        } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
            // unary operators (and binary +/- pretending to be unary) special cases

            space_before = false;
            space_after = false;

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
                print_newline(false, true);
            }

            if (flags.last_text === ';' && is_expression(flags.mode)) {
                // for (;; ++i)
                //        ^^^
                space_before = true;
            }

            if (last_type === 'TK_RESERVED') {
                space_before = true;
            } else if (last_type === 'TK_END_EXPR') {
                space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
            } else if (last_type === 'TK_OPERATOR') {
                // a++ + ++b;
                // a - -b
                space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
                // + and - are not unary when preceeded by -- or ++ operator
                // a-- + b
                // a * +b
                // a - -b
                if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
                    space_after = true;
                }
            }


            if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
                (flags.last_text === '{' || flags.last_text === ';')) {
                // { foo; --i }
                // foo(); --bar;
                print_newline();
            }
        }

        output.space_before_token = output.space_before_token || space_before;
        print_token();
        output.space_before_token = space_after;
    }

    function handle_block_comment(preserve_statement_flags) {
        if (output.raw) {
            output.add_raw_token(current_token);
            if (current_token.directives && current_token.directives.preserve === 'end') {
                // If we're testing the raw output behavior, do not allow a directive to turn it off.
                output.raw = opt.test_output_raw;
            }
            return;
        }

        if (current_token.directives) {
            print_newline(false, preserve_statement_flags);
            print_token();
            if (current_token.directives.preserve === 'start') {
                output.raw = true;
            }
            print_newline(false, true);
            return;
        }

        // inline block
        if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
            return;
        }

        var lines = split_linebreaks(current_token.text);
        var j; // iterator for this case
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;

        // block comment starts with a new line
        print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
            javadoc = all_lines_start_with(lines.slice(1), '*');
            starless = each_line_matches_indent(lines.slice(1), lastIndent);
        }

        // first line always indented
        print_token(lines[0]);
        for (j = 1; j < lines.length; j++) {
            print_newline(false, true);
            if (javadoc) {
                // javadoc: reformat and re-indent
                print_token(' ' + ltrim(lines[j]));
            } else if (starless && lines[j].length > lastIndentLength) {
                // starless: re-indent non-empty content, avoiding trim
                print_token(lines[j].substring(lastIndentLength));
            } else {
                // normal comments output raw
                output.add_token(lines[j]);
            }
        }

        // for comments of more than one line, make sure there's a new line after
        print_newline(false, preserve_statement_flags);
    }

    function handle_comment(preserve_statement_flags) {
        if (current_token.wanted_newline) {
            print_newline(false, preserve_statement_flags);
        } else {
            output.trim(true);
        }

        output.space_before_token = true;
        print_token();
        print_newline(false, preserve_statement_flags);
    }

    function handle_dot() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token, true);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            output.space_before_token = true;
        } else {
            // allow preserved newlines before dots in general
            // force newlines on dots after close paren when break_chained - for bar().baz()
            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
        }

        print_token();
    }

    function handle_unknown(preserve_statement_flags) {
        print_token();

        if (current_token.text[current_token.text.length - 1] === '\n') {
            print_newline(false, preserve_statement_flags);
        }
    }

    function handle_eof() {
        // Unwind any open statements
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }
        handle_whitespace_and_comments(current_token);
    }
}

module.exports.Beautifier = Beautifier;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function InputScanner(input) {
    var _input = input;
    var _input_length = _input.length;
    var _position = 0;

    this.back = function() {
        _position -= 1;
    };

    this.hasNext = function() {
        return _position < _input_length;
    };

    this.next = function() {
        var val = null;
        if (this.hasNext()) {
            val = _input.charAt(_position);
            _position += 1;
        }
        return val;
    };

    this.peek = function(index) {
        var val = null;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charAt(index);
        }
        return val;
    };

    this.peekCharCode = function(index) {
        var val = 0;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charCodeAt(index);
        }
        return val;
    };

    this.test = function(pattern, index) {
        index = index || 0;
        pattern.lastIndex = _position + index;
        return pattern.test(_input);
    };

    this.testChar = function(pattern, index) {
        var val = this.peek(index);
        return val !== null && pattern.test(val);
    };

    this.match = function(pattern) {
        pattern.lastIndex = _position;
        var pattern_match = pattern.exec(_input);
        if (pattern_match && pattern_match.index === _position) {
            _position += pattern_match[0].length;
        } else {
            pattern_match = null;
        }
        return pattern_match;
    };
}


module.exports.InputScanner = InputScanner;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function Token(type, text, newlines, whitespace_before, parent) {
    this.type = type;
    this.text = text;

    // comments_before are
    // comments that have a new line before them
    // and may or may not have a newline after
    // this is a set of comments before
    this.comments_before = /* inline comment*/ [];


    this.comments_after = []; // no new line before and newline after
    this.newlines = newlines || 0;
    this.wanted_newline = newlines > 0;
    this.whitespace_before = whitespace_before || '';
    this.parent = parent || null;
    this.opened = null;
    this.directives = null;
}

module.exports.Token = Token;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(1).Beautifier;

function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
}

module.exports = js_beautify;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var InputScanner = __webpack_require__(2).InputScanner;
var Token = __webpack_require__(5).Token;
var acorn = __webpack_require__(0);

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function Tokenizer(input_string, opts) {

    var whitespace = "\n\r\t ".split('');
    var digit = /[0-9]/;
    var digit_bin = /[01]/;
    var digit_oct = /[01234567]/;
    var digit_hex = /[0123456789abcdefABCDEF]/;

    this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
    var punct = this.positionable_operators.concat(
        // non-positionable operators - these do not follow operator position settings
        '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

    // words which should always start on new line.
    this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
    var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

    //  /* ... */ comment ends with nearest */ or end of file
    var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

    // comment ends just before nearest linefeed or end of file
    var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

    var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
    var directive_pattern = / (\w+)[:](\w+)/g;
    var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

    var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

    var n_newlines, whitespace_before_token, in_html_comment, tokens;
    var input;

    this.tokenize = function() {
        input = new InputScanner(input_string);
        in_html_comment = false;
        tokens = [];

        var next, last;
        var token_values;
        var open = null;
        var open_stack = [];
        var comments = [];

        while (!(last && last.type === 'TK_EOF')) {
            token_values = tokenize_next();
            next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
                if (next.type === 'TK_BLOCK_COMMENT') {
                    next.directives = token_values[2];
                }
                comments.push(next);
                token_values = tokenize_next();
                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            }

            if (comments.length) {
                next.comments_before = comments;
                comments = [];
            }

            if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
                next.parent = last;
                open_stack.push(open);
                open = next;
            } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
                (open && (
                    (next.text === ']' && open.text === '[') ||
                    (next.text === ')' && open.text === '(') ||
                    (next.text === '}' && open.text === '{')))) {
                next.parent = open.parent;
                next.opened = open;

                open = open_stack.pop();
            }

            tokens.push(next);
            last = next;
        }

        return tokens;
    };

    function get_directives(text) {
        if (!text.match(directives_block_pattern)) {
            return null;
        }

        var directives = {};
        directive_pattern.lastIndex = 0;
        var directive_match = directive_pattern.exec(text);

        while (directive_match) {
            directives[directive_match[1]] = directive_match[2];
            directive_match = directive_pattern.exec(text);
        }

        return directives;
    }

    function tokenize_next() {
        var resulting_string;
        var whitespace_on_this_line = [];

        n_newlines = 0;
        whitespace_before_token = '';

        var c = input.next();

        if (c === null) {
            return ['', 'TK_EOF'];
        }

        var last_token;
        if (tokens.length) {
            last_token = tokens[tokens.length - 1];
        } else {
            // For the sake of tokenizing we can pretend that there was on open brace to start
            last_token = new Token('TK_START_BLOCK', '{');
        }

        while (in_array(c, whitespace)) {

            if (acorn.newline.test(c)) {
                if (!(c === '\n' && input.peek(-2) === '\r')) {
                    n_newlines += 1;
                    whitespace_on_this_line = [];
                }
            } else {
                whitespace_on_this_line.push(c);
            }

            c = input.next();

            if (c === null) {
                return ['', 'TK_EOF'];
            }
        }

        if (whitespace_on_this_line.length) {
            whitespace_before_token = whitespace_on_this_line.join('');
        }

        if (digit.test(c) || (c === '.' && input.testChar(digit))) {
            var allow_decimal = true;
            var allow_e = true;
            var local_digit = digit;

            if (c === '0' && input.testChar(/[XxOoBb]/)) {
                // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
                allow_decimal = false;
                allow_e = false;
                if (input.testChar(/[Bb]/)) {
                    local_digit = digit_bin;
                } else if (input.testChar(/[Oo]/)) {
                    local_digit = digit_oct;
                } else {
                    local_digit = digit_hex;
                }
                c += input.next();
            } else if (c === '.') {
                // Already have a decimal for this literal, don't allow another
                allow_decimal = false;
            } else {
                // we know this first loop will run.  It keeps the logic simpler.
                c = '';
                input.back();
            }

            // Add the digits
            while (input.testChar(local_digit)) {
                c += input.next();

                if (allow_decimal && input.peek() === '.') {
                    c += input.next();
                    allow_decimal = false;
                }

                // a = 1.e-7 is valid, so we test for . then e in one loop
                if (allow_e && input.testChar(/[Ee]/)) {
                    c += input.next();

                    if (input.testChar(/[+-]/)) {
                        c += input.next();
                    }

                    allow_e = false;
                    allow_decimal = false;
                }
            }

            return [c, 'TK_WORD'];
        }

        if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
            if (input.hasNext()) {
                while (acorn.isIdentifierChar(input.peekCharCode())) {
                    c += input.next();
                    if (!input.hasNext()) {
                        break;
                    }
                }
            }

            if (!(last_token.type === 'TK_DOT' ||
                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
                in_array(c, reserved_words)) {
                if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
                    return [c, 'TK_OPERATOR'];
                }
                return [c, 'TK_RESERVED'];
            }

            return [c, 'TK_WORD'];
        }

        if (c === '(' || c === '[') {
            return [c, 'TK_START_EXPR'];
        }

        if (c === ')' || c === ']') {
            return [c, 'TK_END_EXPR'];
        }

        if (c === '{') {
            return [c, 'TK_START_BLOCK'];
        }

        if (c === '}') {
            return [c, 'TK_END_BLOCK'];
        }

        if (c === ';') {
            return [c, 'TK_SEMICOLON'];
        }

        if (c === '/') {
            var comment = '';
            var comment_match;
            // peek for comment /* ... */
            if (input.peek() === '*') {
                input.next();
                comment_match = input.match(block_comment_pattern);
                comment = '/*' + comment_match[0];
                var directives = get_directives(comment);
                if (directives && directives.ignore === 'start') {
                    comment_match = input.match(directives_end_ignore_pattern);
                    comment += comment_match[0];
                }
                comment = comment.replace(acorn.allLineBreaks, '\n');
                return [comment, 'TK_BLOCK_COMMENT', directives];
            }
            // peek for comment // ...
            if (input.peek() === '/') {
                input.next();
                comment_match = input.match(comment_pattern);
                comment = '//' + comment_match[0];
                return [comment, 'TK_COMMENT'];
            }

        }

        var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

        if (c === '`' || c === "'" || c === '"' || // string
            (
                (c === '/') || // regexp
                (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
            ) && ( // regex and xml can only appear in specific locations during parsing
                (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
                (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
                    last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
                (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                ]))
            )) {

            var sep = c,
                esc = false,
                has_char_escapes = false;

            resulting_string = c;

            if (sep === '/') {
                //
                // handle regexp
                //
                var in_char_class = false;
                while (input.hasNext() &&
                    ((esc || in_char_class || input.peek() !== sep) &&
                        !input.testChar(acorn.newline))) {
                    resulting_string += input.peek();
                    if (!esc) {
                        esc = input.peek() === '\\';
                        if (input.peek() === '[') {
                            in_char_class = true;
                        } else if (input.peek() === ']') {
                            in_char_class = false;
                        }
                    } else {
                        esc = false;
                    }
                    input.next();
                }
            } else if (opts.e4x && sep === '<') {
                //
                // handle e4x xml literals
                //

                var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
                input.back();
                var xmlStr = '';
                var match = input.match(startXmlRegExp);
                if (match) {
                    // Trim root tag to attempt to
                    var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
                    var isCurlyRoot = rootTag.indexOf('{') === 0;
                    var depth = 0;
                    while (match) {
                        var isEndTag = !!match[1];
                        var tagName = match[2];
                        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                        if (!isSingletonTag &&
                            (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
                            if (isEndTag) {
                                --depth;
                            } else {
                                ++depth;
                            }
                        }
                        xmlStr += match[0];
                        if (depth <= 0) {
                            break;
                        }
                        match = input.match(xmlRegExp);
                    }
                    // if we didn't close correctly, keep unformatted.
                    if (!match) {
                        xmlStr += input.match(/[\s\S]*/g)[0];
                    }
                    xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
                    return [xmlStr, "TK_STRING"];
                }
            } else {
                //
                // handle string
                //
                var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
                    // Template strings can travers lines without escape characters.
                    // Other strings cannot
                    var current_char;
                    while (input.hasNext()) {
                        current_char = input.peek();
                        if (!(esc || (current_char !== delimiter &&
                                (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
                            break;
                        }

                        // Handle \r\n linebreaks after escapes or in template strings
                        if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
                            if (current_char === '\r' && input.peek(1) === '\n') {
                                input.next();
                                current_char = input.peek();
                            }
                            resulting_string += '\n';
                        } else {
                            resulting_string += current_char;
                        }

                        if (esc) {
                            if (current_char === 'x' || current_char === 'u') {
                                has_char_escapes = true;
                            }
                            esc = false;
                        } else {
                            esc = current_char === '\\';
                        }

                        input.next();

                        if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
                            if (delimiter === '`') {
                                parse_string('}', allow_unescaped_newlines, '`');
                            } else {
                                parse_string('`', allow_unescaped_newlines, '${');
                            }

                            if (input.hasNext()) {
                                resulting_string += input.next();
                            }
                        }
                    }
                };

                if (sep === '`') {
                    parse_string('`', true, '${');
                } else {
                    parse_string(sep);
                }
            }

            if (has_char_escapes && opts.unescape_strings) {
                resulting_string = unescape_string(resulting_string);
            }

            if (input.peek() === sep) {
                resulting_string += sep;
                input.next();

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                    while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
                        resulting_string += input.next();
                    }
                }
            }
            return [resulting_string, 'TK_STRING'];
        }

        if (c === '#') {

            if (tokens.length === 0 && input.peek() === '!') {
                // shebang
                resulting_string = c;
                while (input.hasNext() && c !== '\n') {
                    c = input.next();
                    resulting_string += c;
                }
                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
            }



            // Spidermonkey-specific sharp variables for circular references
            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
            var sharp = '#';
            if (input.hasNext() && input.testChar(digit)) {
                do {
                    c = input.next();
                    sharp += c;
                } while (input.hasNext() && c !== '#' && c !== '=');
                if (c === '#') {
                    //
                } else if (input.peek() === '[' && input.peek(1) === ']') {
                    sharp += '[]';
                    input.next();
                    input.next();
                } else if (input.peek() === '{' && input.peek(1) === '}') {
                    sharp += '{}';
                    input.next();
                    input.next();
                }
                return [sharp, 'TK_WORD'];
            }
        }

        if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
            input.back();
            var template_match = input.match(template_pattern);
            if (template_match) {
                c = template_match[0];
                c = c.replace(acorn.allLineBreaks, '\n');
                return [c, 'TK_STRING'];
            }
        }

        if (c === '<' && input.match(/\!--/g)) {
            c = '<!--';
            while (input.hasNext() && !input.testChar(acorn.newline)) {
                c += input.next();
            }
            in_html_comment = true;
            return [c, 'TK_COMMENT'];
        }

        if (c === '-' && in_html_comment && input.match(/->/g)) {
            in_html_comment = false;
            return ['-->', 'TK_COMMENT'];
        }

        if (c === '.') {
            if (input.peek() === '.' && input.peek(1) === '.') {
                c += input.next() + input.next();
                return [c, 'TK_OPERATOR'];
            }
            return [c, 'TK_DOT'];
        }

        if (in_array(c, punct)) {
            while (input.hasNext() && in_array(c + input.peek(), punct)) {
                c += input.next();
                if (!input.hasNext()) {
                    break;
                }
            }

            if (c === ',') {
                return [c, 'TK_COMMA'];
            } else if (c === '=') {
                return [c, 'TK_EQUALS'];
            } else {
                return [c, 'TK_OPERATOR'];
            }
        }

        return [c, 'TK_UNKNOWN'];
    }


    function unescape_string(s) {
        // You think that a regex would work for this
        // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
        //         return String.fromCharCode(parseInt(val, 16));
        //     })
        // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
        var out = '',
            escaped = 0;

        var input_scan = new InputScanner(s);
        var matched = null;

        while (input_scan.hasNext()) {
            // Keep any whitespace, non-slash characters
            // also keep slash pairs.
            matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

            if (matched) {
                out += matched[0];
            }

            if (input_scan.peek() === '\\') {
                input_scan.next();
                if (input_scan.peek() === 'x') {
                    matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
                } else if (input_scan.peek() === 'u') {
                    matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
                } else {
                    out += '\\';
                    if (input_scan.hasNext()) {
                        out += input_scan.next();
                    }
                    continue;
                }

                // If there's some error decoding, return the original string
                if (!matched) {
                    return s;
                }

                escaped = parseInt(matched[1], 16);

                if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
                    // we bail out on \x7f..\xff,
                    // leaving whole string escaped,
                    // as it's probably completely binary
                    return s;
                } else if (escaped >= 0x00 && escaped < 0x20) {
                    // leave 0x00...0x1f escaped
                    out += '\\' + matched[0];
                    continue;
                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                    // single-quote, apostrophe, backslash - escape these
                    out += '\\' + String.fromCharCode(escaped);
                } else {
                    out += String.fromCharCode(escaped);
                }
            }
        }

        return out;
    }
}

module.exports.Tokenizer = Tokenizer;

/***/ })
/******/ ]);
var js_beautify = legacy_beautify_js;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return { js_beautify: js_beautify };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var js_beautify = require("beautify").js_beautify`.
    exports.js_beautify = js_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.js_beautify = js_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.js_beautify = js_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function boundary_to_dot(value) {
    return value.split('][').join('.').split('[').join('.');
}
function strip_braces(value) {
    return value.split('[').join('.').split(']').join('');
}
function escape_dots(value) {
    var val = value.split('\'');
    return (val.length < 3) ? val.join('\'') : val.map(function (seg) {
        if (seg.length < 3)
            return seg;
        if ((seg[0] === '.') || (seg[seg.length - 1] === '.'))
            return seg;
        return seg.split('.').join('&&');
    }).join('');
}
function unescape_dots(value) {
    return value.split('&&').join('.');
}
function partify(value) {
    if (!value)
        return;
    return escape_dots(strip_braces(boundary_to_dot('' + value))).split('.');
}
function canClone(o) {
    return (typeof o.__CLONE__ === 'function');
}
function clone(o) {
    if ((typeof o !== 'object') || (o === null))
        return o;
    if (Array.isArray(o))
        return o.map(clone);
    return (canClone(o)) ?
        o.__CLONE__(clone) : (o.constructor !== Object) ? o :
        Object.keys(o).reduce(function (pre, k) {
            pre[k] = (typeof o[k] === 'object') ?
                clone(o[k]) : o[k];
            return pre;
        }, {});
}
function get(path, o) {
    var parts = partify(path);
    var first;
    if (typeof o === 'object') {
        if (parts.length === 1)
            return o[unescape_dots(parts[0])];
        if (parts.length === 0)
            return;
        first = o[parts.shift()];
        return ((typeof o === 'object') && (o !== null)) ?
            parts.reduce(function (target, prop) {
                if (target == null)
                    return target;
                return target[unescape_dots(prop)];
            }, first) : null;
    }
    else {
        throw new TypeError('get(): expects an object got ' + typeof o);
    }
}
exports.get = get;
;
function set(path, value, obj) {
    var parts = partify(path);
    if ((typeof obj !== 'object') || (obj == null)) {
        return clone(obj);
    }
    else {
        return _set(obj, value, parts);
    }
}
exports.set = set;
;
function _set(obj, value, parts) {
    var o;
    var k;
    if (parts.length === 0)
        return value;
    o = ((typeof obj !== 'object') || (obj === null)) ? {} : clone(obj);
    k = unescape_dots(parts[0]);
    o[k] = _set(o[k], value, parts.slice(1));
    return o;
}
function default_1(k, v, o) {
    if (o == null)
        return get(k, v);
    else
        return set(k, v, o);
}
exports.default = default_1;
;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2J1aWxkL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL2xhbmRpbmcuanMiLCJleGFtcGxlL2J1aWxkL3dtbC9uYXZpZ2F0aW9uLmpzIiwiZXhhbXBsZS9idWlsZC93bWwvdmlld3MvaW5kZXguanMiLCJsaWIvYXBwL2FjdGlvbi1iYXIvQWN0aW9uQmFyLmpzIiwibGliL2FwcC9hY3Rpb24tYmFyL3dtbC9hY3Rpb25fYmFyLmpzIiwibGliL2NvbW1vbi9uYW1lcy5qcyIsImxpYi9jb21tb24vdXRpbC5qcyIsImxpYi9jb250ZW50L0dyb3VwLmpzIiwibGliL2NvbnRyb2wvZGFzaC9EYXNoLmpzIiwibGliL2NvbnRyb2wvZGFzaC93bWwvZGFzaC5qcyIsImxpYi9jb250cm9sL2ljb24tYnV0dG9uL0ljb25CdXR0b24uanMiLCJsaWIvY29udHJvbC9pY29uLWJ1dHRvbi93bWwvaWNvbi1idXR0b24uanMiLCJsaWIvbGF5b3V0L2FzaWRlL0FzaWRlLmpzIiwibGliL2xheW91dC9hc2lkZS93bWwvYXNpZGUuanMiLCJsaWIvbGF5b3V0L2RyYXdlci9EcmF3ZXIuanMiLCJsaWIvbGF5b3V0L2RyYXdlci93bWwvZHJhd2VyLmpzIiwibGliL2xheW91dC9ncmlkL0dyaWQuanMiLCJsaWIvbGF5b3V0L2dyaWQvd21sL2dyaWQuanMiLCJsaWIvbGF5b3V0L21haW4vTWFpbi5qcyIsImxpYi9sYXlvdXQvbWFpbi93bWwvbWFpbi5qcyIsImxpYi9sYXlvdXQvcGFuZWwvUGFuZWwuanMiLCJsaWIvbGF5b3V0L3BhbmVsL3dtbC9wYW5lbC5qcyIsImxpYi9uYXYvbGluay9MaW5rLmpzIiwibGliL25hdi9saW5rL0xpbmtDbGlja2VkRXZlbnQuanMiLCJsaWIvbmF2L2xpbmsvd21sL2xpbmsuanMiLCJsaWIvbmF2L2xpc3QvSXRlbS5qcyIsImxpYi9uYXYvbGlzdC9MaXN0LmpzIiwibGliL25hdi9saXN0L1RleHQuanMiLCJsaWIvbmF2L2xpc3Qvd21sL2l0ZW0uanMiLCJsaWIvbmF2L2xpc3Qvd21sL2xpc3QuanMiLCJsaWIvbmF2L2xpc3Qvd21sL3RleHQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvd21sL2xpYi9BU1QuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvQ29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbGliL1R5cGVTY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvY3VycnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvRWl0aGVyLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbm9kZV9tb2R1bGVzL2FmcGwvbGliL21vbmFkL0ZyZWUuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSU8uanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvTWF5YmUuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvU3RhdGUuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9ub2RlX21vZHVsZXMvYWZwbC9saWIvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wZXJ0eS1zZWVrL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2dTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMzJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3B3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFuZGluZyA9IHJlcXVpcmUoXCIuL3dtbC9sYW5kaW5nXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3ZpZXdzXCIpO1xudmFyIGFwcF8xID0gcmVxdWlyZShcIi4vd21sL2FwcFwiKTtcbnZhciBuYXZpZ2F0aW9uXzEgPSByZXF1aXJlKFwiLi93bWwvbmF2aWdhdGlvblwiKTtcbnZhciBBcHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogcGFnZSBjdXJyZW50bHkgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWdlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2aWV3cyB0byBzaG93IHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3cyA9IHtcbiAgICAgICAgICAgIHBhbmVsczogbmV3IHZpZXdzLlBhbmVsU2NyZWVuKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYXZpZ2F0aW9uIHZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBuYXZpZ2F0aW9uXzEuTmF2aWdhdGlvbih0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyB1c2VkIHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgbGF5b3V0OiAnbGF5b3V0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogdmlldyBpcyB0aGUgY3VycmVudCBhcHBsaWNhdGlvbiB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IGFwcF8xLk1haW4odGhpcyk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG5ldyBsYW5kaW5nLk1haW4odGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2dnbGVEcmF3ZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9nZ2xlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZChfdGhpcy52YWx1ZXMuaWQubGF5b3V0KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudG9nZ2xlRHJhd2VyKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpcy5wYWdlID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy52aWV3cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZW50ID0gX3RoaXMudmlld3NbbmFtZV07XG4gICAgICAgICAgICBfdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpb24uaW52YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIEFwcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKTtcbiAgICAgICAgd2hpbGUgKHJvb3QubGFzdENoaWxkKVxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChyb290Lmxhc3RDaGlsZCk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodGhpcy52aWV3LnJlbmRlcigpKTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubGF5b3V0KTtcbiAgICB9O1xuICAgIEFwcC5tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFwcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcDtcbn0oKSk7XG5leHBvcnRzLkFwcCA9IEFwcDtcbnZhciB3ID0gd2luZG93O1xudy5hcHAgPSBBcHAubWFpbigpO1xudy5hcHAucnVuKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgRHJhd2VyXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZHJhd2VyL0RyYXdlclwiKTtcbjtcbnZhciBBY3Rpb25CYXJfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2FwcC9hY3Rpb24tYmFyL0FjdGlvbkJhclwiKTtcbjtcbjtcbnZhciBJY29uQnV0dG9uXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2ljb24tYnV0dG9uL0ljb25CdXR0b25cIik7XG47XG52YXIgRGFzaF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9kYXNoL0Rhc2hcIik7XG47XG52YXIgTWFpbl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L21haW4vTWFpblwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC53aWRnZXQoRHJhd2VyXzEuRHJhd2VyLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBfX19jb250ZXh0LnZhbHVlcy5pZC5sYXlvdXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdlcjogX19fY29udGV4dC5uYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KEFjdGlvbkJhcl8xLkFjdGlvbkJhciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFskd21sLndpZGdldChJY29uQnV0dG9uXzEuSWNvbkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBfX19jb250ZXh0LnRvZ2dsZURyYXdlclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoRGFzaF8xLkRhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksICR3bWwud2lkZ2V0KERhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCAkd21sLndpZGdldChEYXNoXzEuRGFzaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksICR3bWwud2lkZ2V0KE1haW5fMS5NYWluLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgWyR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY29udGVudC5yZW5kZXIoKSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBQYW5lbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L3BhbmVsL1BhbmVsXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFskd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogNFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoUGFuZWxfMS5QYW5lbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFskd21sLndpZGdldChQYW5lbF8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFskd21sLnRleHQoXCJGdW5kaW5nXCIpXSwgX19fdmlldyksICR3bWwud2lkZ2V0KFBhbmVsXzEuQm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFskd21sLnRleHQoXCIkNzQyLjAwXCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCAkd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KFBhbmVsXzEuUGFuZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoUGFuZWxfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbJHdtbC50ZXh0KFwiQ2xpZW50c1wiKV0sIF9fX3ZpZXcpLCAkd21sLndpZGdldChQYW5lbF8xLkJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbJHdtbC50ZXh0KFwiM1wiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KCR3bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmRpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG52YXIgTGlzdF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L2xpc3QvTGlzdFwiKTtcbjtcbnZhciBJdGVtXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9uYXYvbGlzdC9JdGVtXCIpO1xuO1xudmFyIExpbmtfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL25hdi9saW5rL0xpbmtcIik7XG47XG52YXIgVGV4dF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L2xpc3QvVGV4dFwiKTtcbnZhciBOYXZpZ2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hdmlnYXRpb24oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC53aWRnZXQoTGlzdF8xLkxpc3QsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoTGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAoX19fY29udGV4dC5wYWdlID09PSBcImhvbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJob21lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkhvbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgJHdtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoVGV4dF8xLlRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJMYXlvdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksICR3bWwud2lkZ2V0KExpc3RfMS5MaXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KEl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KExpbmtfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGFuZWxzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAoX19fY29udGV4dC5wYWdlID09PSBcInBhbmVsc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiUGFuZWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgJHdtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbJHdtbC53aWRnZXQoTGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0YWJsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJ0YWJsZXNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJUYWJsZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOYXZpZ2F0aW9uO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIFBhbmVsU2NyZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbFNjcmVlbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbFNjcmVlbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyR3bWwudGV4dChcIlBhbmVsXCIpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsU2NyZWVuO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuUGFuZWxTY3JlZW4gPSBQYW5lbFNjcmVlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIEdyb3VwXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250ZW50L0dyb3VwXCIpO1xudmFyIGFjdGlvbl9iYXJfMSA9IHJlcXVpcmUoXCIuL3dtbC9hY3Rpb25fYmFyXCIpO1xuLyoqXG4gKiBBY3Rpb25CYXIgcHJvdmlkZXMgYSBiYXIgYWNyb3NzIHRoZSBzY3JlZW4gdGhhdCBjYW4gYmVcbiAqIHVzZWQgYXMgYSB0b29sYmFyLCBuYXZpZ2F0aW9uIG1lbnUgb3Igc29tZXRoaW5nIHNpbWlsbGFyLlxuICovXG52YXIgQWN0aW9uQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpb25CYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aW9uQmFyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBhY3Rpb25fYmFyXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2NvbnRlbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsLmNvbWJpbmUoW25hbWVzLkFDVElPTl9CQVIsIG5hbWVzLkZJWEVEX1BVU0hBQkxFXSksXG4gICAgICAgICAgICAgICAgY29udGVudDogbmFtZXMuQUNUSU9OX0JBUl9DT05URU5UXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjdGlvbkJhcjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5BY3Rpb25CYXIgPSBBY3Rpb25CYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb25CYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuICR3bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFskd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX19fY29udGV4dC52YWx1ZXMuaWQuY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgWyR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oJHdtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aW9uX2Jhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSElEREVOIGluZGljYXRlcyBhbiBlbGVtZW50IHNob3VsZCBiZSBoaWRkZW4gZnJvbSBzaWdodC5cbiAqL1xuZXhwb3J0cy5ISURERU4gPSAnLWhpZGRlbic7XG4vKipcbiAqIERJU0FCTEVEIGluZGljYXRlcyBhbiBlbGVtZW50IHNob3VsZCBhcHBlYXIgdG8gYmUgaW5hY2Nlc2libGVcbiAqL1xuZXhwb3J0cy5ESVNBQkxFRCA9ICctZGlzYWJsZWQnO1xuLyoqXG4gKiBPTiBpbmRpY2F0ZXMgYW4gJ29uJyBzdGF0ZS5cbiAqL1xuZXhwb3J0cy5PTiA9ICctb24nO1xuLyoqXG4gKiBPRkYgaW5kaWNhdGVzIGFuICdvZmYnIHN0YXRlLlxuICovXG5leHBvcnRzLk9GRiA9ICctb2ZmJztcbi8qKlxuICogb3BlbiBpbmRpY2F0ZXMgYW4gb3BlbiBzdGF0ZSBpbiBjb2xsYXBzYWJsZSB3aWRnZXRzXG4gKi9cbmV4cG9ydHMuT1BFTiA9ICctb3Blbic7XG4vKipcbiAqIFBVU0hBQkxFIGlzIHVzZWQgYnkgb3RoZXIgc3R5bGVzIHRvIG1vdmUgYW4gZWxlbWVudCBhcm91bmQuXG4gKi9cbmV4cG9ydHMuUFVTSEFCTEUgPSAnLXB1c2hhYmxlJztcbi8qKlxuICogRklYRURfUFVTSEFCTEUgaXMgbGlrZSBQVVNIQUJMRSBidXQgdXNlZCBmb3IgZml4ZWQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuRklYRURfUFVTSEFCTEUgPSAnLWZpeGVkLXB1c2hhYmxlJztcbi8qKlxuICogTk9fSE9WRVIgaW5kaWNhdGVzIGhvdmVyIGVmZmVjdHMgc2hvdWxkIGJlIGRpc2FibGVkLlxuICovXG5leHBvcnRzLk5PX0hPVkVSID0gJy1uby1ob3Zlcic7XG5leHBvcnRzLlNQQUNFRCA9ICctc3BhY2VkJztcbmV4cG9ydHMuREVGQVVMVCA9ICctZGVmYXVsdCc7XG5leHBvcnRzLlBSSU1BUlkgPSAnLXByaW1hcnknO1xuZXhwb3J0cy5TVUNDRVNTID0gJy1zdWNjZXNzJztcbmV4cG9ydHMuSU5GTyA9ICctaW5mbyc7XG5leHBvcnRzLldBUk5JTkcgPSAnLXdhcm5pbmcnO1xuZXhwb3J0cy5EQU5HRVIgPSAnLWRhbmdlcic7XG5leHBvcnRzLkxBUkdFID0gJy1sYXJnZSc7XG5leHBvcnRzLlNNQUxMID0gJy1zbWFsbCc7XG5leHBvcnRzLkVYVFJBX1NNQUxMID0gJy1leHRyYS1zbWFsbCc7XG5leHBvcnRzLkFDVElWRSA9ICdhY3RpdmUnOyAvL0B0b2RvOiByZWZhY3RvciB0byBmbGFnIHN5bnRheFxuZXhwb3J0cy5EUkFXRVIgPSAnd3ctZHJhd2VyLWxheW91dCc7XG5leHBvcnRzLkFTSURFID0gJ3d3LWRyYXdlcic7XG5leHBvcnRzLkFTSURFX0NPTlRFTlQgPSAnd3ctZHJhd2VyX19jb250ZW50JztcbmV4cG9ydHMuQVNJREVfUFVTSEFCTEUgPSAnLWRyYXdlci1wdXNoYWJsZSc7XG5leHBvcnRzLkFTSURFX1BVU0hBQkxFX0ZJWEVEID0gJy1kcmF3ZXItcHVzaGFibGUtZml4ZWQnO1xuLyoqXG4gKiBBQ1RJT05fQkFSIGNsYXNzZXMgZm9yIHRoZSBBY3Rpb25CYXIgcm9vdC5cbiAqL1xuZXhwb3J0cy5BQ1RJT05fQkFSID0gJ3d3LWFjdGlvbi1iYXInO1xuLyoqXG4gKiBBQ1RJT05fQkFSX0NPTlRFTlQgY2xhc3Nlc1xuICovXG5leHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVCA9ICd3dy1hY3Rpb24tYmFyX19jb250ZW50Jztcbi8qKlxuICogQlVUVE9OX01FTlUgY2xhc3Nlc1xuICovXG5leHBvcnRzLkJVVFRPTl9NRU5VID0gJ3d3LWJ1dHRvbi1tZW51Jztcbi8qKlxuICogQlVUVE9OX01FTlVfQlVUVE9OIGNsYXNzZXNcbiAqL1xuZXhwb3J0cy5CVVRUT05fTUVOVV9CVVRUT04gPSBleHBvcnRzLkJVVFRPTl9NRU5VICsgXCJfX2J1dHRvblwiO1xuLyoqXG4gKiBCVVRUT05fTUVOVV9NRU5VIGNsYXNzZXNcbiAqL1xuZXhwb3J0cy5CVVRUT05fTUVOVV9NRU5VID0gZXhwb3J0cy5CVVRUT05fTUVOVV9CVVRUT04gKyBcIl9fbWVudVwiO1xuZXhwb3J0cy5NQUlOX1ZJRVcgPSAnd3ctbWFpbi12aWV3Jztcbi8qKlxuICogTUVOVSBjbGFzc2VzXG4gKi9cbmV4cG9ydHMuTUVOVSA9ICd3dy1tZW51Jztcbi8qKlxuICogTUVOVV9CVVRUT04gY2xhc2VzcyBmb3IgdGhlIE1lbnVCdXR0b24uXG4gKi9cbmV4cG9ydHMuTUVOVV9CVVRUT04gPSAnd3ctbWVudS1idXR0b24nO1xuLyoqXG4gKiBEQVNIIGNsYXNzZXNcbiAqL1xuZXhwb3J0cy5EQVNIID0gJ3d3LWRhc2gnO1xuLyoqXG4gKiBOQVYgY2xhc3Nlc1xuICovXG5leHBvcnRzLk5BViA9ICd3dy1uYXYnO1xuLyoqXG4gKiBOQVZfTElOSyBjbGFzc2VzXG4gKi9cbmV4cG9ydHMuTkFWX0xJTksgPSAnd3ctbmF2LWxpbmsnO1xuLyoqXG4gKiBOQVZfTElTVCBjbGFzc2VzXG4gKi9cbmV4cG9ydHMuTkFWX0xJU1QgPSAnd3ctbmF2LWxpc3QnO1xuLyoqXG4gKiBOQVZfTElTVF9JVEVNIGNsYXNzZXNcbiAqL1xuZXhwb3J0cy5OQVZfTElTVF9JVEVNID0gJ3d3LW5hdi1saXN0X19pdGVtJztcbi8qKlxuICogTkFWX0xJU1RfSVRFTV9URVhUIGNsYXNzZXNcbiAqL1xuZXhwb3J0cy5OQVZfTElTVF9JVEVNX1RFWFQgPSAnd3ctbmF2LWxpc3RfX2l0ZW1fX3RleHQnO1xuZXhwb3J0cy5CVVRUT04gPSAnd3ctYnV0dG9uJztcbmV4cG9ydHMuQlVUVE9OX0dST1VQID0gJ3d3LWJ1dHRvbi1ncm91cCc7XG4vL0B0b2RvOiByZWZhY3RvciB0aGlzIHRvIGJlIGlubGluZSB3aXRoIG90aGVyIGNsYXNzIG5hbWVzXG5leHBvcnRzLkdSSUQgPSAnY29udGFpbmVyLWZsdWlkJztcbmV4cG9ydHMuR1JJRF9DT0wgPSAnJztcbmV4cG9ydHMuR1JJRF9ST1cgPSAncm93JztcbmV4cG9ydHMuUEFORUwgPSAnd3ctcGFuZWwnO1xuZXhwb3J0cy5QQU5FTF9IRUFERVIgPSAnd3ctcGFuZWxfX2hlYWRlcic7XG5leHBvcnRzLlBBTkVMX0JPRFkgPSAnd3ctcGFuZWxfX2JvZHknO1xuZXhwb3J0cy5QQU5FTF9GT09URVIgPSAnd3ctcGFuZWxfX2Zvb3Rlcic7XG5leHBvcnRzLk1PREFMID0gJ3d3LW1vZGFsJztcbmV4cG9ydHMuTU9EQUxfRElBTE9HID0gJ3d3LW1vZGFsX19kaWFsb2cnO1xuZXhwb3J0cy5NT0RBTF9DT05URU5UID0gJ3d3LW1vZGFsX19jb250ZW50JztcbmV4cG9ydHMuTU9EQUxfSEVBREVSID0gJ3d3LW1vZGFsX19oZWFkZXInO1xuZXhwb3J0cy5NT0RBTF9CT0RZID0gJ3d3LW1vZGFsX19ib2R5JztcbmV4cG9ydHMuTU9EQUxfRk9PVEVSID0gJ3d3LW1vYWRsX19mb290ZXInO1xuZXhwb3J0cy5GT1JNX0dST1VQID0gJ2Zvcm0tZ3JvdXAnO1xuZXhwb3J0cy5DT05UUk9MX0xBQkVMID0gJ2NvbnRyb2wtbGFiZWwnO1xuZXhwb3J0cy5JTlBVVCA9ICdmb3JtLWNvbnRyb2wnO1xuZXhwb3J0cy5URVhUQVJFQSA9ICdmb3JtLWNvbnRyb2wnO1xuZXhwb3J0cy5TRUxFQ1QgPSAnZm9ybS1jb250cm9sJztcbmV4cG9ydHMuVEFCUyA9ICduYXYgbmF2LXRhYnMnOyAvL0B0b2RvIHVuLWJvb3RzdHJhcFxuZXhwb3J0cy5TV0lUQ0ggPSAnd3ctc3dpdGNoJztcbmV4cG9ydHMuU1dJVENIX1NMSURFUiA9ICd3dy1zd2l0Y2hfX3NsaWRlcic7XG5leHBvcnRzLlRBQkxFID0gJ3RhYmxlJzsgLy9AdG9kbyB1bi1ib290c3RyYXBcbmV4cG9ydHMuVFJFRV9OQVYgPSAndHJlZS1uYXYnO1xuZXhwb3J0cy5UUkVFX05BVl9MSVNUID0gJ3RyZWUtbmF2X19saXN0JztcbmV4cG9ydHMuVFJFRV9OQVZfTElTVF9JVEVNID0gJ3RyZWUtbmF2X19pdGVtJztcbmV4cG9ydHMuQlJFQURfQ1JVTUJTID0gJ2JyZWFkY3J1bWInOyAvL0B0b2RvIHVuLWJvb3RzdHJhcFxuZXhwb3J0cy5CUkVBRF9DUlVNQlNfQ1JVTUIgPSBleHBvcnRzLkJSRUFEX0NSVU1CUyArIFwiX19jcnVtYlwiO1xuZXhwb3J0cy5MSVNUID0gJ3d3LWxpc3QnO1xuZXhwb3J0cy5MSVNUX0lURU0gPSAnd3ctbGlzdF9faXRlbSc7XG5leHBvcnRzLlNFQVJDSF9JTlBVVCA9ICd3dy1zZWFyY2hfX2lucHV0JztcbmV4cG9ydHMuRklOREVSID0gJ3d3LWZpbmRlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogY29tYmluZSB0aGUgbWVtYmVycyBvZiBhbiBhcnJheSBpbnRvIG9uZSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuY29tYmluZSA9IGZ1bmN0aW9uIChzdHIsIGpvaW5lcikge1xuICAgIGlmIChqb2luZXIgPT09IHZvaWQgMCkgeyBqb2luZXIgPSAnICc7IH1cbiAgICByZXR1cm4gc3RyLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gKChzICE9IG51bGwpIHx8IHMgIT0gJycpOyB9KS5qb2luKGpvaW5lcik7XG59O1xuLyoqXG4gKiBjb25jYXQgam9pbnMgdmFyaW91cyBzdHJpbmdzIHRvZ2V0aGVyIHRvIGZvcm0gYW4gaHRtbCBjbGFzcyBhdHRyaWJ1dGUgdmFsdWUuXG4gKlxuICogUmVtb3ZlcyBlbXB0eSBzdHJpbmdzLCBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzLlxuICovXG5leHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RyID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBzdHIuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoKHMgIT0gbnVsbCkgfHwgcyAhPSAnJyk7IH0pLmpvaW4oJyAnKTtcbn07XG4vKipcbiAqIG5vb3BcbiAqL1xuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLyoqXG4gKiByZXBsYWNlQ29udGVudFxuICovXG5leHBvcnRzLnJlcGxhY2VDb250ZW50ID0gZnVuY3Rpb24gKHIsIG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpXG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoci5yZW5kZXIoKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbC1ydW50aW1lXCIpO1xuLyoqXG4gKiBHcm91cCBpcyBhbiBhYnN0cmFjdCBjbGFzcyBwcm92aWRpbmcgYW4gYXBpIGZvclxuICogd2lkZ2V0cyB3aG9zZSBwcmltYXJ5IHB1cnBvc2UgaXMgZGlzcGxheWluZyBjb250ZW50LlxuICovXG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldENvbnRlbnQgY2hhbmdlcyB0aGUgY29udGVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBHcm91cC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlQ29udGVudCByZW1vdmVzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICovXG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwO1xufSh3bWxfcnVudGltZV8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB3bWxfcnVudGltZV8xID0gcmVxdWlyZShcIkBxdWVuay93bWwtcnVudGltZVwiKTtcbnZhciBkYXNoXzEgPSByZXF1aXJlKFwiLi93bWwvZGFzaFwiKTtcbi8qKlxuICogRGFzaCBhcmUgbGl0ZXJhbCBob3Jpem9udGFsIGRhc2hlcy5cbiAqXG4gKiBUaGVzZSBjYW4gYmUgdXNlZCB3aXRoIGFwcC9tZW51L0J1dHRvbiB0byBjcmVhdGUgJ2hhbWJ1cmdlcicgbWVudXMuXG4gKi9cbnZhciBEYXNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhc2goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGRhc2hfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5EQVNIXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERhc2g7XG59KHdtbF9ydW50aW1lXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkRhc2ggPSBEYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGFzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyICR3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgd21sX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sLXJ1bnRpbWVcIik7XG52YXIgaWNvbl9idXR0b25fMSA9IHJlcXVpcmUoXCIuL3dtbC9pY29uLWJ1dHRvblwiKTtcbi8qKlxuICogSWNvbkJ1dHRvbiBwcm92aWRlcyBhICdoYW1idXJnZXInIG1lbnUgYnV0dG9uLlxuICovXG52YXIgSWNvbkJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWNvbkJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJY29uQnV0dG9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBpY29uX2J1dHRvbl8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLk1FTlVfQlVUVE9OXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEljb25CdXR0b247XG59KHdtbF9ydW50aW1lXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkljb25CdXR0b24gPSBJY29uQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbkJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyICR3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC5ub2RlKCdidXR0b24nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogJHdtbC5yZWFkKFwid3c6b25DbGlja1wiLCBfX19jb250ZXh0LmF0dHJzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KCR3bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tYnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgYXNpZGVfMSA9IHJlcXVpcmUoXCIuL3dtbC9hc2lkZVwiKTtcbi8qKlxuICogQXNpZGUgcHJvdmlkZXMgYSB3aWRnZXQgZm9yIGRpc3BsYXlpbmcgbmF2aWdhdGlvbiBhbmQgb3RoZXIgc2lkZWJhciBjb250ZW50LlxuICpcbiAqIEl0J3MgYXBpIGFsbG93cyBmb3IgdG9nZ2xpbmcgYmV0d2VlbiBoaWRkZW4gYW5kIHNob3duIHN0YXRlcyBhcyB3ZWxsIGFzIHF1ZXJ5aW5nIHRoZVxuICogY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBUaGlzIHdpZGdldCdzIHN0eWxlIGludGVudGlvbmFsbHkgZ2l2ZXMgaXQgYSBoaWdoIHotaW5kZXggc28gdGhhdCBpdCBhcHBlYXJzIGluLWZyb250XG4gKiBvZiBvdGhlciBjb250ZW50LiBBZGp1c3QgdGhlIHJlc3BlY3RpdmUgc3R5bGUgdmFyaWFibGVzIHRvIGNoYW5nZS5cbiAqL1xudmFyIEFzaWRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc2lkZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2lkZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgaXMgYSBoYXNoIG9mIHZhbHVlcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAnYXNpZGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuQVNJREUsXG4gICAgICAgICAgICAgICAgY29udGVudDogbmFtZXMuQVNJREVfQ09OVEVOVFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3d3OmNvbnRlbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgYXNpZGVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBc2lkZS5wcm90b3R5cGUuX2dldERyYXdlckRPTSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdCkuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHZpc2libGUgcXVlcmllcyB3aGV0aGVyIHRoZSBEcmF3ZXIgaXMgdmlzaWJsZSBvciBub3QuXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLnZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lcy5ISURERU4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGRyYXdlci5cbiAgICAgKi9cbiAgICBBc2lkZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSgpKVxuICAgICAgICAgICAgdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC5hZGQobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzaG93RHJhd2VyIHNob3dzIHRoZSBkcmF3ZXJcbiAgICAgKi9cbiAgICBBc2lkZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSlcbiAgICAgICAgICAgIHRoaXMuX2dldERyYXdlckRPTShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkhJRERFTik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoaXMgRHJhd2VyXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0RHJhd2VyRE9NKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNsYXNzTGlzdC50b2dnbGUobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXNpZGU7XG59KEdyb3VwXzEuR3JvdXApKTtcbmV4cG9ydHMuQXNpZGUgPSBBc2lkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzaWRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IF9fX2NvbnRleHQudmFsdWVzLmlkLnJvb3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbJHdtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbJHdtbC5pZnRoZW4oJHdtbC5yZWFkKFwid3c6Y29udGVudFwiLCBfX19jb250ZXh0LmF0dHJzKSwgZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkd21sLmRvbWlmeSgkd21sLnJlYWQoXCJ3dzpjb250ZW50XCIsIF9fX2NvbnRleHQuYXR0cnMpLnJlbmRlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gZWxzZV9jbGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oJHdtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNpZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBHcm91cF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udGVudC9Hcm91cFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciBkcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL3dtbC9kcmF3ZXJcIik7XG47XG4vKipcbiAqIERyYXdlciBwcm92aWRlcyBhIDIgY29sdW1uIGFwcGxpY2F0aW9uIGxheW91dCB3aXRoIHRoZSBmaXJzdCB0eXBpY2FsbHkgdXNlZCBhcyBuYXZhaWdhdGlvblxuICogYW5kIHRoZSBzZWNvbmQgbWFpbiBhcHBsaWNhdGlvbiBjb250ZW50LlxuICpcbiAqIGBgYHdtbFxuICpcbiAqICA8RHJhd2VyXG4gKiAgIHdtbDppZD1cImxheW91dFwiXG4gKiAgIGNvbnRlbnQ9e3t0aGlzLmdldENvbnRlbnQoKX19IC8+XG4gKlxuICogYGBgXG4gKi9cbnZhciBEcmF3ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYXdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcmF3ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGRyYXdlcl8xLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzIGlzIGEgaGFzaCBvZiB2YWx1ZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICBkcmF3ZXI6ICdkcmF3ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5EUkFXRVIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBEUkFXRVI6ICd3dzpkcmF3ZXInLFxuICAgICAgICAgICAgICAgIENPTlRFTlQ6ICd3dzpjb250ZW50J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdlci5wcm90b3R5cGUuX2dldEFzaWRlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5kcmF3ZXIpLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgZik7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLl9jb21iaW5lID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZHJhd2VyVmlzaWJsZSBxdWVyaWVzIHdoZXRoZXIgdGhlIEFzaWRlIGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUuZHJhd2VyVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFzaWRlKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2libGUoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoaWRlRHJhd2VyIGhpZGVzIHRoZSBkcmF3ZXIuXG4gICAgICovXG4gICAgRHJhd2VyLnByb3RvdHlwZS5oaWRlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuaGlkZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNob3dEcmF3ZXIgc2hvd3MgdGhlIGRyYXdlclxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUuc2hvd0RyYXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFzaWRlKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnNob3coKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEFzaWRlLlxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUudG9nZ2xlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudG9nZ2xlKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERyYXdlcjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5EcmF3ZXIgPSBEcmF3ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmF3ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgQXNpZGVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9hc2lkZS9Bc2lkZVwiKTtcbjtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBfX19jb250ZXh0LnZhbHVlcy5pZC5yb290XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgWyR3bWwud2lkZ2V0KEFzaWRlXzEuQXNpZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IF9fX2NvbnRleHQudmFsdWVzLmlkLmRyYXdlclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJHdtbC5yZWFkKFwid3c6ZHJhd2VyXCIsIF9fX2NvbnRleHQuYXR0cnMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksICR3bWwuaWZ0aGVuKF9fX2NvbnRleHQuY29udGVudCwgZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gZWxzZWlmKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHdtbC5pZnRoZW4oJHdtbC5yZWFkKFwid3c6Y29udGVudFwiLCBfX19jb250ZXh0LmF0dHJzKSwgZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkd21sLmRvbWlmeShfX19jb250ZXh0LmF0dHJzLnd3LmNvbnRlbnQucmVuZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBlbHNlX2NsYXVzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oJHdtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhd2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZ3JpZFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuO1xuLyoqXG4gKiBHcmlkXG4gKi9cbnZhciBHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyaWQoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLkdSSURcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JpZDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkdyaWQgPSBHcmlkO1xudmFyIFJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuUm93KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5HUklEX1JPV1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3c7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Sb3cgPSBSb3c7XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2x1bW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sdW1uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Db2x1bW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IF90aGlzLmF0dHJzLnd3ID8gdXRpbF8xLmNvbmNhdChfdGhpcy5hdHRycy53dy5zaXplID9cbiAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtXCIgKyBfdGhpcy5hdHRycy53dy5zaXplIDogJ2NvbC1tZC0xMicsIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA6ICdjb2wtbWQtMTInXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciAkd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JpZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmlkKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuICR3bWwubm9kZSgnc2VjdGlvbicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JpZDtcbn0oJHdtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkdyaWQgPSBHcmlkO1xuO1xudmFyIFJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm93O1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuUm93ID0gUm93O1xuO1xudmFyIENvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sdW1uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbHVtbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29sdW1uO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuQ29sdW1uID0gQ29sdW1uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL21haW5cIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgR3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG4vKipcbiAqIE1haW4gcHJvdmlkZXMgYSBjb250YWluZXIgZm9yIHRoZSBtYWluIGNvbnRlbnQgb2YgYW4gYXBwbGljYXRpb24uXG4gKi9cbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTUFJTl9WSUVXLCBuYW1lcy5QVVNIQUJMRSwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShHcm91cF8xLkdyb3VwKSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyICR3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJHdtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KCR3bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9wYW5lbFwiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuUGFuZWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuUEFORUwsIF90aGlzLmF0dHJzLnd3ID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc3R5bGUgOiBuYW1lcy5ERUZBVUxUKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlBhbmVsID0gUGFuZWw7XG52YXIgSGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5IZWFkZXIoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLlBBTkVMX0hFQURFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5IZWFkZXIgPSBIZWFkZXI7XG52YXIgQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb2R5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Cb2R5KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5QQU5FTF9CT0RZXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJvZHk7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Cb2R5ID0gQm9keTtcbnZhciBGb290ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvb3RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb290ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkZvb3RlcihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuUEFORUxfRk9PVEVSXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZvb3Rlcjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkZvb3RlciA9IEZvb3Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbChjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWw7XG59KCR3bWwuQXBwVmlldykpO1xuZXhwb3J0cy5QYW5lbCA9IFBhbmVsO1xuO1xudmFyIEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlcihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVyO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuO1xudmFyIEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQm9keShjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQm9keTtcbn0oJHdtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkJvZHkgPSBCb2R5O1xuO1xudmFyIEZvb3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9vdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvb3Rlcihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbJHdtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRm9vdGVyO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuRm9vdGVyID0gRm9vdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9saW5rXCIpO1xudmFyIExpbmtDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xpbmtDbGlja2VkRXZlbnRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIExpbmsgZ2VuZXJhdGVzIGFuIDxhPiBlbGVtZW50LlxuICovXG52YXIgTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hbWUgYXNzaWduZWQgdG8gdGhpcyBMaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubmFtZSA9IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5uYW1lKSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5uYW1lIDogJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aXRsZSBhc3NpZ25lZCB0byB0aGlzIExpbmsuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50aXRsZSA9IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGl0bGUgOiAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhyZWYgYXNzaWduZWQgdG8gdGhpcyBsaW5rXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5ocmVmID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhyZWYpID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmhyZWYgOiAnJztcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTkFWX0xJTkssIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJywgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5BQ1RJVkUgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50aXRsZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cubmFtZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgaHJlZjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhyZWYpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcjJyxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYWN0aXZlIDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5hdHRycy53dywgbmFtZV8xID0gX2EubmFtZSwgaHJlZiA9IF9hLmhyZWYsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgICAgICAgICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKG5ldyBMaW5rQ2xpY2tlZEV2ZW50XzEuTGlua0NsaWNrZWRFdmVudChuYW1lXzEsIGhyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBJdGVtLlxuICAgICAgKi9cbiAgICBMaW5rLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB3LmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LmFkZChuYW1lcy5BQ1RJVkUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGluYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBpdGVtLlxuICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmluYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkFDVElWRSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTGluayA9IExpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMaW5rQ2xpY2tlZEV2ZW50IGluZGljYXRlcyBhIGxpbmsgaGFzIGJlZW4gY2xpY2tlZC5cbiAqL1xudmFyIExpbmtDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua0NsaWNrZWRFdmVudChuYW1lLCBocmVmKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBMaW5rQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuTGlua0NsaWNrZWRFdmVudCA9IExpbmtDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogX19fY29udGV4dC52YWx1ZXMuYS5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX19jb250ZXh0LnZhbHVlcy5hLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfX19jb250ZXh0LnZhbHVlcy5hLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfX19jb250ZXh0LmNsaWNrZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFskd21sLmlmdGhlbigkd21sLnJlYWQoXCJ3dzp0ZXh0XCIsIF9fX2NvbnRleHQuYXR0cnMpLCBmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHdtbC5kb21pZnkoJHdtbC5yZWFkKFwid3c6dGV4dFwiLCBfX19jb250ZXh0LmF0dHJzKSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gZWxzZV9jbGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaXRlbVwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogSXRlbSB3cmFwcyBjb250ZW50IGluIGEgbmF2aWdhdGlvbiBsaXN0LlxuICpcbiAqIEl0ZW1zIHNob3VsZCBub3QgaGF2ZSBhbnkgc2libGluZ3MgdGhhdCBhcmUgbm90IG90aGVyIEl0ZW1zLlxuICovXG52YXIgSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTkFWX0xJU1RfSVRFTSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgPyBuYW1lcy5BQ1RJVkUgOiBudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFjdGl2YXRlIHRoaXMgbmF2IGxpc3QgSXRlbS5cbiAgICAgKi9cbiAgICBJdGVtLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB3LmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LmFkZChuYW1lcy5BQ1RJVkUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGluYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBpdGVtLlxuICAgICAqL1xuICAgIEl0ZW0ucHJvdG90eXBlLmluYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkFDVElWRSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEl0ZW07XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuSXRlbSA9IEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpc3RcIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIExpc3Qgb2YgbmF2aWdhdGlvbiBsaW5rcy5cbiAqL1xudmFyIExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbC5jb25jYXQobmFtZXMuTkFWX0xJU1QsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdDtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5MaXN0ID0gTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90ZXh0XCIpO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBUZXh0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgbm9uLWNsaWNrYWJsZSBoZWFkaW5nIHRleHQgaW4gYSBuYXYgbGlzdC5cbiAqL1xudmFyIFRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5OQVZfTElTVF9JVEVNX1RFWFQsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRleHQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHQ7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFskd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFskd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufSgkd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgJHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAkd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyR3bWwuaWZ0aGVuKF9fX2NvbnRleHQudmFsdWVzLnRleHQsIGZ1bmN0aW9uIHRoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy50ZXh0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBlbHNlX2NsYXVzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR3bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KCR3bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJvcGVydHkgPSByZXF1aXJlKFwicHJvcGVydHktc2Vla1wiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xuO1xuLyoqXG4gKiBDb21wb25lbnQgaXMgYW4gYWJzdHJhY3QgV2lkZ2V0IGltcGxlbWVudGF0aW9uXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgbWFudWFsbHkgaW1wbGVtZW50aW5nIHRoZSB3aG9sZSBpbnRlcmZhY2UuXG4gKlxuICovXG52YXIgQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBhdHRycyBpcyB0aGUgYXR0cmlidXRlcyB0aGlzIENvbXBvbmVudCBleGNlcHRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGNoaWxkcmVuIGlzIGFuIGFycmF5IG9mIGNvbnRlbnQgcGFzc2VkIHRvIHRoaXMgQ29tcG9uZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudChhdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3LnJlbmRlcigpOyB9O1xuICAgIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG47XG4vKipcbiAqIHJlYWQgYSB2YWx1ZSBmb3JtIGFuIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIHJlZ3VsYXIgcHJvcGVydHkgYWNjZXNzIHRoYXQgd2lsbCB0aHJvdyBleGNlcHRpb25zXG4gKiBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgcGFydCBhcmUgbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gbG9vayB1cCBvbiB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtvYmplY3R9IG8gLSBUaGUgb2JqZWN0XG4gKiBAcGFyYW0ge0F9IFtkZWZhdWx0VmFsdWVdIC0gVGhpcyB2YWx1ZSBpcyByZXR1cm5lZCBpZiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChwYXRoLCBvLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gcHJvcGVydHkuZ2V0KHBhdGguc3BsaXQoJzonKS5qb2luKCcuJyksIG8pO1xuICAgIHJldHVybiAocmV0ICE9IG51bGwpID8gcmV0IDogZGVmYXVsdFZhbHVlO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkb3B0ID0gZnVuY3Rpb24gKGNoaWxkLCBlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgY2hpbGQpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgY2hpbGQpKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBhZG9wdCBjaGlsZCBcIiArIGNoaWxkICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBjaGlsZCk7XG4gICAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5ib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb250ZW50W19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZnJhZy5hcHBlbmRDaGlsZChjKTsgfSk7XG4gICAgcmV0dXJuIGZyYWc7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRvbWlmeSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5ib3guYXBwbHkobnVsbCwgYS5tYXAoZXhwb3J0cy5kb21pZnkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGVvZiBhID09PSAnc3RyaW5nJykgfHxcbiAgICAgICAgKHR5cGVvZiBhID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgKHR5cGVvZiBhID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnRleHQoYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHVzZSAnXCIgKyBhICsgXCInKHR5cGVvZiBcIiArIHR5cGVvZiBhICsgXCIpIGFzIENvbnRlbnQhXCIpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfZW1wdHkgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZW1wdHk7IH07XG4vKipcbiAqIHRleHQgY3JlYXRlcyBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIHZhbHVlKTtcbn07XG4vKipcbiAqIG5vZGUgaXMgY2FsbGVkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgRE9NIG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubm9kZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCB2aWV3KSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzWydodG1sJ10gPT09ICdvYmplY3QnKVxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzWydodG1sJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1snaHRtbCddW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYWRvcHQoYywgZSk7IH0pO1xuICAgIHZhciBpZCA9IGF0dHJpYnV0ZXNbJ3dtbCddLmlkO1xuICAgIHZhciBncm91cCA9IGF0dHJpYnV0ZXMud21sLmdyb3VwO1xuICAgIGlmIChpZClcbiAgICAgICAgdmlldy5yZWdpc3RlcihpZCwgZSk7XG4gICAgaWYgKGdyb3VwKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyR3JvdXAoZ3JvdXAsIGUpO1xuICAgIHJldHVybiBlO1xufTtcbi8qKlxuICogd2lkZ2V0IGNyZWF0ZXMgYW5kIHJlbmRlcnMgYSBuZXcgd21sIHdpZGdldCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbnN0cnV0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZ3xudW1iZXJ8V2lkZ2V0Pn0gY2hpbGRyZW5cbiAqIEBwYXJhbSB7Vmlld30gdmlld1xuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1dpZGdldH1cbiAqL1xuZXhwb3J0cy53aWRnZXQgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCB2aWV3KSB7XG4gICAgdmFyIGNoaWxkcyA9IFtdO1xuICAgIHZhciB3O1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAoY2hpbGQgaW5zdGFuY2VvZiBBcnJheSkgP1xuICAgICAgICBjaGlsZHMucHVzaC5hcHBseShjaGlsZHMsIGNoaWxkKSA6IGNoaWxkcy5wdXNoKGNoaWxkKTsgfSk7XG4gICAgdyA9IG5ldyBDb25zdHJ1Y3RvcihhdHRyaWJ1dGVzLCBjaGlsZHMpO1xuICAgIHZhciBpZCA9IGF0dHJpYnV0ZXMud21sLmlkO1xuICAgIHZhciBncm91cCA9IGF0dHJpYnV0ZXMud21sLmdyb3VwO1xuICAgIGlmIChpZClcbiAgICAgICAgdmlldy5yZWdpc3RlcihpZCwgdyk7XG4gICAgaWYgKGdyb3VwKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyR3JvdXAoZ3JvdXAsIHcpO1xuICAgIHZpZXcud2lkZ2V0cy5wdXNoKHcpO1xuICAgIHJldHVybiB3LnJlbmRlcigpO1xufTtcbi8qKlxuICogaWZFIHByb3ZpZGVzIGFuIGlmIHRoZW4gZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pZkUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBwb3NpdGl2ZSwgbmVnYXRpdmUpIHtcbiAgICByZXR1cm4gKHByZWRpY2F0ZSkgPyBwb3NpdGl2ZSgpIDogbmVnYXRpdmUoKTtcbn07XG4vKipcbiAqIGZvckUgcHJvdmlkZXMgYSBmb3IgZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5mb3JFID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNiLCBjYjIpIHtcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHYsIGssIGEpIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoY2IodiwgaywgYSkpOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjYjIoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbCA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAobC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGNiKGNvbGxlY3Rpb25ba10sIGssIGNvbGxlY3Rpb24pKTsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2IyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbn07XG4vKipcbiAqIHN3aXRjaEUgc2ltdWxhdGVzIGEgc3dpdGNoIHN0YXRlbWVudFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gY2FzZXNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuc3dpdGNoRSA9IGZ1bmN0aW9uICh2YWx1ZSwgY2FzZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FzZXNbdmFsdWVdO1xuICAgIHZhciBkZWZhdWwgPSBjYXNlc1snZGVmYXVsdCddO1xuICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGRlZmF1bClcbiAgICAgICAgcmV0dXJuIGRlZmF1bDtcbn07XG4vKipcbiAqIEFwcFZpZXcgaXMgdGhlIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgVmlldy5cbiAqXG4gKiBAcHJvcGVydHkgezxDPn0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRoZSB2aWV3IGlzIHJlbmRlcmVkIGluLlxuICovXG52YXIgQXBwVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwVmlldyhjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgIH1cbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChpZCwgdykge1xuICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGlkICdcIiArIGlkICsgXCInIGRldGVjdGVkIVwiKTtcbiAgICAgICAgdGhpcy5pZHNbaWRdID0gdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3Rlckdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUuZnJvbUFueSh0aGlzLmlkc1tpZF0pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZmluZEdyb3VwQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUuZnJvbUFycmF5KHRoaXMuZ3JvdXBzW25hbWVdKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHM7XG4gICAgICAgIHZhciByZWFsRmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHJlYWxGaXJzdENoaWxkSW5kZXg7XG4gICAgICAgIHZhciB0cmVlID0gKHRoaXMuX2ZyYWdSb290KSA/IHRoaXMuX2ZyYWdSb290IDogdGhpcy50cmVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdHJlZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodHJlZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdDYW5ub3QgaW52YWxpZGF0ZSBhIHZpZXcgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQhJyk7XG4gICAgICAgIGlmICh0cmVlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0ZW1wdCB0byBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiBpbnNlcnRlZCB0byBET00hJyk7XG4gICAgICAgIGNoaWxkcyA9IHRyZWUucGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgLy9mb3Igc29tZSByZWFzb24gdGhlIHJlZmVyZW5jZSBzdG9yZWQgZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBwYXJlbnQgbm9kZS5cbiAgICAgICAgLy93ZSBkbyB0aGlzIHRvIGdldCBhICdsaXZlJyB2ZXJzaW9uIG9mIHRoZSBub2RlLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGlsZHNbaV0gPT09IHRyZWUpIHtcbiAgICAgICAgICAgICAgICByZWFsRmlyc3RDaGlsZCA9IGNoaWxkc1tpXTtcbiAgICAgICAgICAgICAgICByZWFsRmlyc3RDaGlsZEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCByZWFsRmlyc3RDaGlsZCk7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbW92ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLl9mcmFnUm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJlZSA9IHRoaXMudGVtcGxhdGUodGhpcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKSA/IHRoaXMuaWRzWydyb290J10gOiB0aGlzLnRyZWU7XG4gICAgICAgIGlmICh0aGlzLnRyZWUubm9kZU5hbWUgPT09IChkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpLm5vZGVOYW1lKVxuICAgICAgICAgICAgdGhpcy5fZnJhZ1Jvb3QgPSB0aGlzLnRyZWUuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVuZGVyZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gQXBwVmlldztcbn0oKSk7XG5leHBvcnRzLkFwcFZpZXcgPSBBcHBWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFdNTCBBU1QuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbjtcbi8qKlxuICogTW9kdWxlIGlzIHdoYXQgYSB3bWwgZmlsZSBjb21waWxlcyB0by5cbiAqXG4gKiBBIG1vZHVsZSBjb250YWlucyBhIGxpc3Qgb2YgaW1wb3J0cyBhbmQgZXhwb3J0ZWQgc3ltYm9scy5cbiAqIEFsbCBkZWNsYXJhdGlvbnMgaW4gd21sIGFyZSBleHBvcnRlZC4gVGhlcmUgaXMgbm8gc3VjaCB0aGluZ1xuICogYXMgcHJpdmF0ZSBoZXJlLlxuICovXG52YXIgTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZHVsZShpbXBvcnRzLCBleHBvcnRzLCBtYWluLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmltcG9ydHMgPSBpbXBvcnRzO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBleHBvcnRzO1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdtb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gTW9kdWxlO1xufSgpKTtcbmV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xuLyoqXG4gKiBJbXBvcnRTdGF0ZW1lbnRcbiAqL1xudmFyIEltcG9ydFN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRTdGF0ZW1lbnQobWVtYmVyLCBtb2R1bGUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1wb3J0LXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJbXBvcnRTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5JbXBvcnRTdGF0ZW1lbnQgPSBJbXBvcnRTdGF0ZW1lbnQ7XG4vKipcbiAqIEFsaWFzZWRNZW1iZXJcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gYWxpYXMgLSBUaGUgaWRlbnRpZmllciBpbnRyb2R1Y2VkIHRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBtZW1iZXIgLSBUaGUgaWRlbnRpZmllciB0aGF0IGlzIGFsaWFzZWQuXG4gKi9cbnZhciBBbGlhc2VkTWVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsaWFzZWRNZW1iZXIobWVtYmVyLCBhbGlhcywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYWxpYXNlZC1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQWxpYXNlZE1lbWJlcjtcbn0oKSk7XG5leHBvcnRzLkFsaWFzZWRNZW1iZXIgPSBBbGlhc2VkTWVtYmVyO1xuLyoqXG4gKiBBZ2dyZWdhdGVNZW1iZXJcbiAqL1xudmFyIEFnZ3JlZ2F0ZU1lbWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZ2dyZWdhdGVNZW1iZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVhbGlmaWVkLW1lbWJlcic7XG4gICAgfVxuICAgIHJldHVybiBBZ2dyZWdhdGVNZW1iZXI7XG59KCkpO1xuZXhwb3J0cy5BZ2dyZWdhdGVNZW1iZXIgPSBBZ2dyZWdhdGVNZW1iZXI7XG4vKipcbiAqIENvbXBvc2l0ZU1lbWJlclxuICogQHByb3BlcnR5IHsuLi5JZGVudGlmaWVyfEFsaWFzZWRfTWVtYmVyfSBtZW1iZXJzXG4gKi9cbnZhciBDb21wb3NpdGVNZW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9zaXRlTWVtYmVyKG1lbWJlcnMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbXBvc2l0ZS1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9zaXRlTWVtYmVyO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9zaXRlTWVtYmVyID0gQ29tcG9zaXRlTWVtYmVyO1xudmFyIFR5cGVkTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlZE1haW4oaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtbWFpbic7XG4gICAgfVxuICAgIHJldHVybiBUeXBlZE1haW47XG59KCkpO1xuZXhwb3J0cy5UeXBlZE1haW4gPSBUeXBlZE1haW47XG52YXIgVW50eXBlZE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW50eXBlZE1haW4odGFnLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1tYWluJztcbiAgICB9XG4gICAgcmV0dXJuIFVudHlwZWRNYWluO1xufSgpKTtcbmV4cG9ydHMuVW50eXBlZE1haW4gPSBVbnR5cGVkTWFpbjtcbnZhciBFeHBvcnRTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0U3RhdGVtZW50KG1lbWJlcnMsIG1vZHVsZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4cG9ydC1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRXhwb3J0U3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRXhwb3J0U3RhdGVtZW50ID0gRXhwb3J0U3RhdGVtZW50O1xuLyoqXG4gKiBWaWV3U3RhdGVtZW50XG4gKi9cbnZhciBWaWV3U3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdTdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndmlldy1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gVmlld1N0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLlZpZXdTdGF0ZW1lbnQgPSBWaWV3U3RhdGVtZW50O1xudmFyIEZ1blN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5TdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCBib2R5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBGdW5TdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5GdW5TdGF0ZW1lbnQgPSBGdW5TdGF0ZW1lbnQ7XG4vKipcbiAqIFR5cGVDbGFzc1xuICovXG52YXIgVHlwZUNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVDbGFzcyhpZCwgY29uc3RyYWludCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlLWNsYXNzJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVDbGFzcztcbn0oKSk7XG5leHBvcnRzLlR5cGVDbGFzcyA9IFR5cGVDbGFzcztcbnZhciBUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGUoaWQsIHR5cGVDbGFzc2VzLCBsaXN0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZSc7XG4gICAgfVxuICAgIHJldHVybiBUeXBlO1xufSgpKTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG52YXIgVHlwZWRQYXJhbWV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZWRQYXJhbWV0ZXIoaWQsIGhpbnQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5oaW50ID0gaGludDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtcGFyYW1ldGVyJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVkUGFyYW1ldGVyO1xufSgpKTtcbmV4cG9ydHMuVHlwZWRQYXJhbWV0ZXIgPSBUeXBlZFBhcmFtZXRlcjtcbnZhciBVbnR5cGVkUGFyYW1ldGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVudHlwZWRQYXJhbWV0ZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1wYXJhbWV0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gVW50eXBlZFBhcmFtZXRlcjtcbn0oKSk7XG5leHBvcnRzLlVudHlwZWRQYXJhbWV0ZXIgPSBVbnR5cGVkUGFyYW1ldGVyO1xudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShvcGVuLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICB9XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KG9wZW4sIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBjbG9zZSkge1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3dpZGdldCc7XG4gICAgfVxuICAgIHJldHVybiBXaWRnZXQ7XG59KCkpO1xuZXhwb3J0cy5XaWRnZXQgPSBXaWRnZXQ7XG52YXIgQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lc3BhY2UsIG5hbWUsIHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdhdHRyaWJ1dGUnO1xuICAgIH1cbiAgICByZXR1cm4gQXR0cmlidXRlO1xufSgpKTtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xudmFyIEludGVycG9sYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihleHByZXNzaW9uLCBmaWx0ZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbnRlcnBvbGF0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KCkpO1xuZXhwb3J0cy5JbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGlvbjtcbnZhciBGb3JTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KHZhcmlhYmxlLCBpbmRleCwgYWxsLCBsaXN0LCBib2R5LCBvdGhlcndpc2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmFsbCA9IGFsbDtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Zvci1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xudmFyIElmU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJZlN0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG52YXIgRWxzZUNsYXVzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbHNlQ2xhdXNlKGNoaWxkcmVuLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VDbGF1c2U7XG59KCkpO1xuZXhwb3J0cy5FbHNlQ2xhdXNlID0gRWxzZUNsYXVzZTtcbnZhciBFbHNlSWZDbGF1c2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxzZUlmQ2xhdXNlKGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtaWYtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VJZkNsYXVzZTtcbn0oKSk7XG5leHBvcnRzLkVsc2VJZkNsYXVzZSA9IEVsc2VJZkNsYXVzZTtcbnZhciBDaGFyYWN0ZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJhY3RlcnModmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2hhcmFjdGVycyc7XG4gICAgfVxuICAgIHJldHVybiBDaGFyYWN0ZXJzO1xufSgpKTtcbmV4cG9ydHMuQ2hhcmFjdGVycyA9IENoYXJhY3RlcnM7XG52YXIgSWZUaGVuRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZlRoZW5FeHByZXNzaW9uKGNvbmRpdGlvbiwgaWZ0cnVlLCBpZmZhbHNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5pZnRydWUgPSBpZnRydWU7XG4gICAgICAgIHRoaXMuaWZmYWxzZSA9IGlmZmFsc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXRoZW4tZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBJZlRoZW5FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuSWZUaGVuRXhwcmVzc2lvbiA9IElmVGhlbkV4cHJlc3Npb247XG52YXIgQmluYXJ5RXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeS1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbnZhciBVbmFyeUV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VuYXJ5LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xudmFyIFZpZXdDb25zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0NvbnN0cnVjdGlvbihjb25zLCBjb250ZXh0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbnMgPSBjb25zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd2aWV3LWNvbnN0cnVjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29uc3RydWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuVmlld0NvbnN0cnVjdGlvbiA9IFZpZXdDb25zdHJ1Y3Rpb247XG52YXIgRnVuQXBwbGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuQXBwbGljYXRpb24odGFyZ2V0LCB0eXBlQXJncywgY29udGV4dCwgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudHlwZUFyZ3MgPSB0eXBlQXJncztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLWFwcGxpY2F0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEZ1bkFwcGxpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuQXBwbGljYXRpb24gPSBGdW5BcHBsaWNhdGlvbjtcbnZhciBDb25zdHJ1Y3RFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0cnVjdEV4cHJlc3Npb24oY29ucywgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25zID0gY29ucztcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29uc3RydWN0LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gQ29uc3RydWN0RXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNvbnN0cnVjdEV4cHJlc3Npb24gPSBDb25zdHJ1Y3RFeHByZXNzaW9uO1xudmFyIENhbGxFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKHRhcmdldCwgdHlwZUFyZ3MsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnR5cGVBcmdzID0gdHlwZUFyZ3M7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NhbGwtZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG4vKipcbiAqIE1lbWJlckV4cHJlc3Npb25cbiAqL1xudmFyIE1lbWJlckV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtYmVyRXhwcmVzc2lvbih0YXJnZXQsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIHJldHVybiBNZW1iZXJFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuTWVtYmVyRXhwcmVzc2lvbiA9IE1lbWJlckV4cHJlc3Npb247XG52YXIgUmVhZEV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVhZEV4cHJlc3Npb24odGFyZ2V0LCBwYXRoLCBoaW50LCBkZWZhdWx0cywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVhZC1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuUmVhZEV4cHJlc3Npb24gPSBSZWFkRXhwcmVzc2lvbjtcbnZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtZXRlcnMsIGJvZHksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uLWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xudmFyIExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdChtZW1iZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdsaXN0JztcbiAgICB9XG4gICAgcmV0dXJuIExpc3Q7XG59KCkpO1xuZXhwb3J0cy5MaXN0ID0gTGlzdDtcbnZhciBSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb3JkKHByb3BlcnRpZXMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlY29yZCc7XG4gICAgfVxuICAgIHJldHVybiBSZWNvcmQ7XG59KCkpO1xuZXhwb3J0cy5SZWNvcmQgPSBSZWNvcmQ7XG52YXIgUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvcGVydHkoa2V5LCB2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gUHJvcGVydHk7XG59KCkpO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xudmFyIFN0cmluZ0xpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHJpbmcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nTGl0ZXJhbDtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBTdHJpbmdMaXRlcmFsO1xudmFyIE51bWJlckxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdudW1iZXItbGl0ZXJhbCc7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJMaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IE51bWJlckxpdGVyYWw7XG52YXIgQm9vbGVhbkxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwodmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm9vbGVhbi1saXRlcmFsJztcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW5MaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbnZhciBDb250ZXh0UHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dFByb3BlcnR5KG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbnRleHQtcHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gQ29udGV4dFByb3BlcnR5O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dFByb3BlcnR5ID0gQ29udGV4dFByb3BlcnR5O1xudmFyIENvbnRleHRWYXJpYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0VmFyaWFibGUobG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29udGV4dC12YXJpYWJsZSc7XG4gICAgfVxuICAgIHJldHVybiBDb250ZXh0VmFyaWFibGU7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0VmFyaWFibGUgPSBDb250ZXh0VmFyaWFibGU7XG52YXIgVW5xdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZENvbnN0cnVjdG9yKGlkLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VucXVhbGlmaWVkLWNvbnN0cnVjdG9yJztcbiAgICB9XG4gICAgcmV0dXJuIFVucXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZENvbnN0cnVjdG9yID0gVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjtcbnZhciBRdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWFsaWZpZWRDb25zdHJ1Y3RvcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtY29uc3RydWN0b3InO1xuICAgIH1cbiAgICByZXR1cm4gUXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5RdWFsaWZpZWRDb25zdHJ1Y3RvciA9IFF1YWxpZmllZENvbnN0cnVjdG9yO1xudmFyIFVucXVhbGlmaWVkSWRlbnRpZmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZElkZW50aWZpZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW5xdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBVbnF1YWxpZmllZElkZW50aWZpZXI7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZElkZW50aWZpZXIgPSBVbnF1YWxpZmllZElkZW50aWZpZXI7XG4vKipcbiAqIFF1YWxpZmllZElkZW50aWZpZXJcbiAqL1xudmFyIFF1YWxpZmllZElkZW50aWZpZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVhbGlmaWVkSWRlbnRpZmllcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBRdWFsaWZpZWRJZGVudGlmaWVyO1xufSgpKTtcbmV4cG9ydHMuUXVhbGlmaWVkSWRlbnRpZmllciA9IFF1YWxpZmllZElkZW50aWZpZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BU1QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPSdQYXJzZXIuZC50cycgLz5cbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XG52YXIgbm9kZXMgPSByZXF1aXJlKFwiLi9BU1RcIik7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGpzZm10ID0gcmVxdWlyZShcImpzLWJlYXV0aWZ5XCIpO1xudmFyIFR5cGVTY3JpcHQgPSByZXF1aXJlKFwiLi9UeXBlU2NyaXB0XCIpO1xudmFyIGFmcGxfMSA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBtYWluOiAnTWFpbicsXG4gICAgbW9kdWxlOiAnQHF1ZW5rL3dtbCcsXG59O1xuLyoqXG4gKiBwYXJzZSBhIHN0cmluZyBhcyBXTUwgcmV0dXJuaW5nIGVpdGhlciBhbiBlcnJvciBvciBhbiBBU1QuXG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBhc3QpIHtcbiAgICBpZiAoYXN0ID09PSB2b2lkIDApIHsgYXN0ID0gbm9kZXM7IH1cbiAgICBQYXJzZXIucGFyc2VyLnl5ID0geyBhc3Q6IGFzdCB9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLnJpZ2h0KFBhcnNlci5wYXJzZXIucGFyc2Uoc3RyKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLmxlZnQoZSk7XG4gICAgfVxufTtcbi8qKlxuICogcHJldHR5IHVwIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24gKGRvaXQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIGRvaXQgPyBqc2ZtdChzLCB7fSkgOiBzO1xufTsgfTtcbi8qKlxuICogY29tcGlsZSBhIHN0cmluZyBvZiBXTUwgdHVybmluZyBpdCBpbnRvIHR5cGVzY3JpcHQgY29kZS5cbiAqL1xuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9wdHMgPSBhZnBsLnV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBleHBvcnRzLnBhcnNlKHNyYylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gVHlwZVNjcmlwdC5jb2RlKG0sIG9wdHMpOyB9KVxuICAgICAgICAubWFwKGV4cG9ydHMucHJldHR5KG9wdGlvbnMucHJldHR5KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcGlsZXIuanMubWFwIiwiXG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNi4xLTIwMyAqL1xuXG4vKlxuICogUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIFBhcnNlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRlcml2YXRpdmUvY29weSBvZiB0aGlzIG9uZSxcbiAqICAgICAgICAgICAgICAgbm90IGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqICB9XG4gKlxuICogIFBhcnNlci5wcm90b3R5cGU6IHtcbiAqICAgIHl5OiB7fSxcbiAqICAgIEVPRjogMSxcbiAqICAgIFRFUlJPUjogMixcbiAqXG4gKiAgICB0cmFjZTogZnVuY3Rpb24oZXJyb3JNZXNzYWdlLCAuLi4pLFxuICpcbiAqICAgIEppc29uUGFyc2VyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKlxuICogICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlXG4gKiAgICAgICAgICAgICAgIHF1b3RlcyBhcm91bmQgbGl0ZXJhbCBJRHMgaW4gYSBkZXNjcmlwdGlvbiBzdHJpbmcuXG4gKlxuICogICAgb3JpZ2luYWxRdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgcXVvdGVOYW1lIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcXVvdGVOYW1lKClgIHRvIHJlZmVyZW5jZSB0aGlzIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYC5cbiAqXG4gKiAgICBkZXNjcmliZVN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSxcbiAqICAgICAgICAgICAgICAgUmV0dXJuIGEgbW9yZS1vci1sZXNzIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBzeW1ib2wsIHdoZW5cbiAqICAgICAgICAgICAgICAgYXZhaWxhYmxlLCBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2tcbiAqICAgICAgICAgICAgICAgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbiAqXG4gKiAgICAgICAgICAgICAgIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG4gKlxuICogICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICogICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gKiAgICBub250ZXJtaW5hbHM6IHthc3NvY2lhdGl2ZSBsaXN0OiBydWxlLW5hbWUgPT0+IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IHJ1bGUtYWx0fX0sXG4gKiAgICB0ZXJtaW5hbF9kZXNjcmlwdGlvbnNfOiAoaWYgdGhlcmUgYXJlIGFueSkge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gZGVzY3JpcHRpb259LFxuICogICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX3BlcmZvcm1BY3Rpb24oeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eWxvYywgeXlzdGF0ZSwgeXlzcCwgeXl2c3RhY2ssIHl5bHN0YWNrLCB5eXN0YWNrLCB5eXNzdGFjayksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYHl5dmFsYCBpbnRlcm5hbCBvYmplY3QsIHdoaWNoIGhhcyBtZW1iZXJzIChgJGAgYW5kIGBfJGApXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RvcmUvcmVmZXJlbmNlIHRoZSBydWxlIHZhbHVlIGAkJGAgYW5kIGxvY2F0aW9uIGluZm8gYEAkYC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgT25lIGltcG9ydGFudCB0aGluZyB0byBub3RlIGFib3V0IGB0aGlzYCBhLmsuYS4gYHl5dmFsYDogZXZlcnkgKnJlZHVjZSogYWN0aW9uIGdldHNcbiAqICAgICAgICAgICAgICAgICB0byBzZWUgdGhlIHNhbWUgb2JqZWN0IHZpYSB0aGUgYHRoaXNgIHJlZmVyZW5jZSwgaS5lLiBpZiB5b3Ugd2lzaCB0byBjYXJyeSBjdXN0b21cbiAqICAgICAgICAgICAgICAgICBkYXRhIGZyb20gb25lIHJlZHVjZSBhY3Rpb24gdGhyb3VnaCB0byB0aGUgbmV4dCB3aXRoaW4gYSBzaW5nbGUgcGFyc2UgcnVuLCB0aGVuIHlvdVxuICogICAgICAgICAgICAgICAgIG1heSBnZXQgbmFzdHkgYW5kIHVzZSBgeXl2YWxgIGEuay5hLiBgdGhpc2AgZm9yIHN0b3JpbmcgeW91IG93biBzZW1pLXBlcm1hbmVudCBkYXRhLlxuICpcbiAqICAgICAgICAgICAgICAgICBgdGhpcy55eWAgaXMgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIHNoYXJlZCBzdGF0ZSBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICAgIGAlcGFyc2UtcGFyYW1gLXNwZWNpZmllZCBhZGRpdGlvbmFsIGBwYXJzZSgpYCBhcmd1bWVudHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgYHl5YFxuICogICAgICAgICAgICAgICAgIG9iamVjdCBhdCBgcGFyc2UoKWAgc3RhcnQgYW5kIGFyZSB0aGVyZWZvcmUgYXZhaWxhYmxlIHRvIHRoZSBhY3Rpb24gY29kZSB2aWEgdGhlXG4gKiAgICAgICAgICAgICAgICAgc2FtZSBuYW1lZCBgeXkueHh4eGAgYXR0cmlidXRlcyAod2hlcmUgYHh4eHhgIHJlcHJlc2VudHMgYSBpZGVudGlmaWVyIG5hbWUgZnJvbVxuICogICAgICAgICAgICAgICAgIHRoZSAlcGFyc2UtcGFyYW1gIGxpc3QuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXRleHRgICA6IHJlZmVyZW5jZSB0byB0aGUgbGV4ZXIgdmFsdWUgd2hpY2ggYmVsb25ncyB0byB0aGUgbGFzdCBsZXhlciB0b2tlbiB1c2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gbWF0Y2ggdGhpcyBydWxlLiBUaGlzIGlzICpub3QqIHRoZSBsb29rLWFoZWFkIHRva2VuLCBidXQgdGhlIGxhc3QgdG9rZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0J3MgYWN0dWFsbHkgcGFydCBvZiB0aGlzIHJ1bGUuXG4gKlxuICogICAgICAgICAgICAgICAgIEZvcm11bGF0ZWQgYW5vdGhlciB3YXksIGB5eXRleHRgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW1tZWRpYXRlbHkgcHJlY2VlZGluZ1xuICogICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGxvb2stYWhlYWQgdG9rZW4uXG4gKiAgICAgICAgICAgICAgICAgQ2F2ZWF0cyBhcHBseSBmb3IgcnVsZXMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBsb29rLWFoZWFkLCBzdWNoIGFzIGVwc2lsb24gcnVsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxlbmdgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGVuZyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGluZW5vYDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsaW5lbm8gdmFsdWUuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxvY2AgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGxvYyBsZXhlciB0b2tlbiBsb2NhdGlvbiBpbmZvLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdBUk5JTkc6IHNpbmNlIGppc29uIDAuNC4xOC0xODYgdGhpcyBlbnRyeSBtYXkgYmUgTlVMTC9VTkRFRklORUQgaW5zdGVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYW4gZW1wdHkgb2JqZWN0IHdoZW4gbm8gc3VpdGFibGUgbG9jYXRpb24gaW5mbyBjYW4gYmUgcHJvdmlkZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YXRlYCA6IHRoZSBjdXJyZW50IHBhcnNlciBzdGF0ZSBudW1iZXIsIHVzZWQgaW50ZXJuYWxseSBmb3IgZGlzcGF0Y2hpbmcgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpbmcgdGhlIGFjdGlvbiBjb2RlIGNodW5rIG1hdGNoaW5nIHRoZSBydWxlIGN1cnJlbnRseSBiZWluZyByZWR1Y2VkLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzcGAgICAgOiB0aGUgY3VycmVudCBzdGF0ZSBzdGFjayBwb3NpdGlvbiAoYS5rLmEuICdzdGFjayBwb2ludGVyJylcbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAgIEFsc28gbm90ZSB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoaXMgYW5kIG90aGVyIHN0YWNrIGluZGV4IHZhbHVlcyB1c2luZyB0aGUgbmV3IGRvdWJsZS1oYXNoXG4gKiAgICAgICAgICAgICAgICAgc3ludGF4LCBpLmUuIGAjIyQgPT09ICMjMCA9PT0geXlzcGAsIHdoaWxlIGAjIzFgIGlzIHRoZSBzdGFjayBpbmRleCBmb3IgYWxsIHRoaW5nc1xuICogICAgICAgICAgICAgICAgIHJlbGF0ZWQgdG8gdGhlIGZpcnN0IHJ1bGUgdGVybSwganVzdCBsaWtlIHlvdSBoYXZlIGAkMWAsIGBAMWAgYW5kIGAjMWAuXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBpcyBtYWRlIGF2YWlsYWJsZSB0byB3cml0ZSB2ZXJ5IGFkdmFuY2VkIGdyYW1tYXIgYWN0aW9uIHJ1bGVzLCBlLmcuIHdoZW4geW91IHdhbnRcbiAqICAgICAgICAgICAgICAgICB0byBpbnZlc3RpZ2F0ZSB0aGUgcGFyc2Ugc3RhdGUgc3RhY2sgaW4geW91ciBhY3Rpb24gY29kZSwgd2hpY2ggd291bGQsIGZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgIGJlIHJlbGV2YW50IHdoZW4geW91IHdpc2ggdG8gaW1wbGVtZW50IGVycm9yIGRpYWdub3N0aWNzIGFuZCByZXBvcnRpbmcgc2NoZW1lcyBzaW1pbGFyXG4gKiAgICAgICAgICAgICAgICAgdG8gdGhlIHdvcmsgZGVzY3JpYmVkIGhlcmU6XG4gKlxuICogICAgICAgICAgICAgICAgICsgUG90dGllciwgRi4sIDIwMTYuIFJlYWNoYWJpbGl0eSBhbmQgZXJyb3IgZGlhZ25vc2lzIGluIExSKDEpIGF1dG9tYXRhLlxuICogICAgICAgICAgICAgICAgICAgSW4gSm91cm7DqWVzIEZyYW5jb3Bob25lcyBkZXMgTGFuZ3VhZ2VzIEFwcGxpY2F0aWZzLlxuICpcbiAqICAgICAgICAgICAgICAgICArIEplZmZlcnksIEMuTC4sIDIwMDMuIEdlbmVyYXRpbmcgTFIgc3ludGF4IGVycm9yIG1lc3NhZ2VzIGZyb20gZXhhbXBsZXMuXG4gKiAgICAgICAgICAgICAgICAgICBBQ00gVHJhbnNhY3Rpb25zIG9uIFByb2dyYW1taW5nIExhbmd1YWdlcyBhbmQgU3lzdGVtcyAoVE9QTEFTKSwgMjUoNSksIHBwLjYzMeKAkzY0MC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZWxlbmd0aGA6IHRoZSBjdXJyZW50IHJ1bGUncyB0ZXJtIGNvdW50LCBpLmUuIHRoZSBudW1iZXIgb2YgZW50cmllcyBvY2N1cGllZCBvbiB0aGUgc3RhY2suXG4gKlxuICogICAgICAgICAgICAgICAgIFRoaXMgb25lIGNvbWVzIGluIGhhbmR5IHdoZW4geW91IGFyZSBnb2luZyB0byBkbyBhZHZhbmNlZCB0aGluZ3MgdG8gdGhlIHBhcnNlclxuICogICAgICAgICAgICAgICAgIHN0YWNrcywgYWxsIG9mIHdoaWNoIGFyZSBhY2Nlc3NpYmxlIGZyb20geW91ciBhY3Rpb24gY29kZSAoc2VlIHRoZSBuZXh0IGVudHJpZXMgYmVsb3cpLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXl2c3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciB2YWx1ZSBzdGFjay4gQWxzbyBhY2Nlc3NlZCB2aWEgdGhlIGAkMWAgZXRjLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdHMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGxvY2F0aW9uIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgQDFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGFycmF5IE1BWSBjb250YWluIHNsb3RzIHdoaWNoIGFyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVOREVGSU5FRCByYXRoZXIgdGhhbiBhbiBlbXB0eSAobG9jYXRpb24pIG9iamVjdCwgd2hlbiB0aGUgbGV4ZXIvcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uIGNvZGUgZGlkIG5vdCBwcm92aWRlIGEgc3VpdGFibGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hlbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90IHdhcyBmaWxsZWQhXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YWNrYCA6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGlkIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIzFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZTogdGhpcyBpcyBhIGJpdCBvZiBhICoqd2hpdGUgbGllKiogYXMgd2UgY2FuIHN0YXRpY2FsbHkgZGVjb2RlIGFueSBgI25gIHJlZmVyZW5jZSB0b1xuICogICAgICAgICAgICAgICAgIGl0cyBudW1lcmljIHRva2VuIGlkIHZhbHVlLCBoZW5jZSB0aGF0IGNvZGUgd291bGRuJ3QgbmVlZCB0aGUgYHl5c3RhY2tgIGJ1dCAqeW91KiBtaWdodFxuICogICAgICAgICAgICAgICAgIHdhbnQgYWNjZXNzIHRoaXMgYXJyYXkgZm9yIHlvdXIgb3duIHB1cnBvc2VzLCBzdWNoIGFzIGVycm9yIGFuYWx5c2lzIGFzIG1lbnRpb25lZCBhYm92ZSFcbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoaXMgc3RhY2sgc3RvcmVzIHRoZSBjdXJyZW50IHN0YWNrIG9mICp0b2tlbnMqLCB0aGF0IGlzIHRoZSBzZXF1ZW5jZSBvZlxuICogICAgICAgICAgICAgICAgIGFscmVhZHkgcGFyc2VkPXJlZHVjZWQgKm5vbnRlcm1pbmFscyogKHRva2VucyByZXByZXNlbnRpbmcgcnVsZXMpIGFuZCAqdGVybWluYWxzKlxuICogICAgICAgICAgICAgICAgIChsZXhlciB0b2tlbnMgKnNoaWZ0ZWQqIG9udG8gdGhlIHN0YWNrIHVudGlsIHRoZSBydWxlIHRoZXkgYmVsb25nIHRvIGlzIGZvdW5kIGFuZFxuICogICAgICAgICAgICAgICAgICpyZWR1Y2VkKi5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3N0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgc3RhdGUgc3RhY2suIFRoaXMgb25lIGNhcnJpZXMgdGhlIGludGVybmFsIHBhcnNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICpzdGF0ZXMqIHN1Y2ggYXMgdGhlIG9uZSBpbiBgeXlzdGF0ZWAsIHdoaWNoIGFyZSB1c2VkIHRvIHJlcHJlc2VudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpbiB0aGUgKnBhcnNlIHRhYmxlKi4gKlZlcnkqICppbnRlcm5hbCogc3R1ZmYsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hhdCBjYW4gSSBzYXk/IElmIHlvdSBhY2Nlc3MgdGhpcyBvbmUsIHlvdSdyZSBjbGVhcmx5IGRvaW5nIHdpY2tlZCB0aGluZ3NcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYC4uLmAgICAgIDogdGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXIgZGVmaW5pdGlvbiBmaWxlLlxuICpcbiAqICAgIHRhYmxlOiBbLi4uXSxcbiAqICAgICAgICAgICAgICAgU3RhdGUgdHJhbnNpdGlvbiB0YWJsZVxuICogICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogICAgICAgICAgICAgICBpbmRleCBsZXZlbHMgYXJlOlxuICogICAgICAgICAgICAgICAtIGBzdGF0ZWAgIC0tPiBoYXNoIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0gYHN5bWJvbGAgLS0+IGFjdGlvbiAobnVtYmVyIG9yIGFycmF5KVxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYW4gYXJyYXksIHRoZXNlIGFyZSB0aGUgZWxlbWVudHMnIG1lYW5pbmc6XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMF06IDEgPSBzaGlmdCwgMiA9IHJlZHVjZSwgMyA9IGFjY2VwdFxuICogICAgICAgICAgICAgICAgIC0gaW5kZXggWzFdOiBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICAgICAgICAgICAgICAgSWYgdGhlIGBhY3Rpb25gIGlzIGEgbnVtYmVyLCBpdCBpcyB0aGUgR09UTyBgc3RhdGVgXG4gKlxuICogICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgeXlFcnJvcjogZnVuY3Rpb24oc3RyLCAuLi4pLFxuICogICAgeXlSZWNvdmVyaW5nOiBmdW5jdGlvbigpLFxuICogICAgeXlFcnJPazogZnVuY3Rpb24oKSxcbiAqICAgIHl5Q2xlYXJJbjogZnVuY3Rpb24oKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgZXhjZXB0aW9uX29iamVjdCwgZXhwZWN0ZWRfdG9rZW5fc2V0LCBpc19yZWNvdmVyYWJsZSksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIHBhcnNlciBrZXJuZWwgaW4gbWFueSBwbGFjZXM7IGV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgdmFyIGluZm9PYmogPSBwYXJzZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgbnVsbCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSksIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHBhcnNlci5wYXJzZUVycm9yKGluZm9PYmouZXJyU3RyLCBpbmZvT2JqLCBwYXJzZXIuSmlzb25QYXJzZXJFcnJvcik7XG4gKlxuICogICAgb3JpZ2luYWxQYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICAgICAgICAgVGhlIGJhc2ljIGBwYXJzZUVycm9yYCBoYW5kbGVyIHByb3ZpZGVkIGJ5IEpJU09OLlxuICogICAgICAgICAgICAgICBgY2xlYW51cEFmdGVyUGFyc2UoKWAgd2lsbCBjbGVhbiB1cCBhbmQgcmVzZXQgYHBhcnNlRXJyb3IoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIG9wdGlvbnM6IHsgLi4uIHBhcnNlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXRbLCBhcmdzLi4uXSksXG4gKiAgICAgICAgICAgICAgIFBhcnNlIHRoZSBnaXZlbiBgaW5wdXRgIGFuZCByZXR1cm4gdGhlIHBhcnNlZCB2YWx1ZSAob3IgYHRydWVgIHdoZW4gbm9uZSB3YXMgcHJvdmlkZWQgYnlcbiAqICAgICAgICAgICAgICAgdGhlIHJvb3QgYWN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwYXJzZXIgaXMgYWN0aW5nIGFzIGEgKm1hdGNoZXIqKS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhpcyBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIFBhcnNlcidzIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgKHZpYSBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSBqaXNvbiBydW4tdGltZTtcbiAqICAgICAgICAgICAgICAgd2hlbiBzdWNoIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gdG8gcHJldmVudCB0aGUgZ2VuZXJhdGVkIHJ1bi10aW1lXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uIVxuICpcbiAqICAgICAgICAgICAgICAgVGhlIGxleGVyIE1BWSBhZGQgaXRzIG93biBzZXQgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzICh2aWEgdGhlIGAlcGFyc2UtcGFyYW1gIGxpbmUgaW5cbiAqICAgICAgICAgICAgICAgdGhlIGxleGVyIHNlY3Rpb24gb2YgdGhlIGdyYW1tYXIgc3BlYyk6IHRoZXNlIHdpbGwgYmUgaW5zZXJ0ZWQgaW4gdGhlIGB5eWAgc2hhcmVkIHN0YXRlXG4gKiAgICAgICAgICAgICAgIG9iamVjdCBhbmQgYW55IGNvbGxpc2lvbiB3aXRoIHRob3NlIHdpbGwgYmUgcmVwb3J0ZWQgYnkgdGhlIGxleGVyIHZpYSBhIHRocm93biBleGNlcHRpb24uXG4gKlxuICogICAgY2xlYW51cEFmdGVyUGFyc2U6IGZ1bmN0aW9uKHJlc3VsdFZhbHVlLCBpbnZva2VfcG9zdF9tZXRob2RzLCBkb19ub3RfbnVrZV9lcnJvcmluZm9zKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYCBjYWxsLCB1bmxlc3MgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd25cbiAqICAgICAgICAgICAgICAgYW5kIGAlb3B0aW9ucyBuby10cnktY2F0Y2hgIGhhcyBiZWVuIGRlZmluZWQgZm9yIHRoaXMgZ3JhbW1hcjogaW4gdGhhdCBjYXNlIHRoaXMgaGVscGVyIE1BWVxuICogICAgICAgICAgICAgICBiZSBpbnZva2VkIGJ5IGNhbGxpbmcgdXNlciBjb2RlIHRvIGVuc3VyZSB0aGUgYHBvc3RfcGFyc2VgIGNhbGxiYWNrcyBhcmUgaW52b2tlZCBhbmRcbiAqICAgICAgICAgICAgICAgdGhlIGludGVybmFsIHBhcnNlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkIHVuZGVyIHRoZXNlIHBhcnRpY3VsYXIgY2lyY3Vtc3RhbmNlcy5cbiAqXG4gKiAgICB5eU1lcmdlTG9jYXRpb25JbmZvOiBmdW5jdGlvbihmaXJzdF9pbmRleCwgbGFzdF9pbmRleCwgZmlyc3RfeXlsbG9jLCBsYXN0X3l5bGxvYywgZG9udF9sb29rX2JhY2spLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGNhbiBiZSBpbnZva2VkIHRvIGNhbGN1bGF0ZSBhIHNwYW5uaW5nIGB5eWxsb2NgIGxvY2F0aW9uIGluZm8gb2JqZWN0LlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZTogJWVwc2lsb24gcnVsZXMgTUFZIHNwZWNpZnkgbm8gYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AsIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gb2J0YWluIGEgc3VpdGFibGUgbG9jYXRpb24gbWFya2VyIGJ5IGluc3BlY3RpbmcgdGhlIGxvY2F0aW9uIHN0YWNrXG4gKiAgICAgICAgICAgICAgIGJhY2t3YXJkcy5cbiAqXG4gKiAgICAgICAgICAgICAgIEZvciBtb3JlIGluZm8gc2VlIHRoZSBkb2N1bWVudGF0aW9uIGNvbW1lbnQgZnVydGhlciBiZWxvdywgaW1tZWRpYXRlbHkgYWJvdmUgdGhpcyBmdW5jdGlvbidzXG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqICAgIGxleGVyOiB7XG4gKiAgICAgICAgeXk6IHsuLi59LCAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHNvLWNhbGxlZCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgb25jZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkIHZpYSBhIGNhbGwgdG8gdGhlIGAuc2V0SW5wdXQoaW5wdXQsIHl5KWAgbGV4ZXIgQVBJLlxuICogICAgICAgIEVPRjogMSxcbiAqICAgICAgICBFUlJPUjogMixcbiAqICAgICAgICBKaXNvbkxleGVyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAqICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICogICAgICAgIHJlamVjdDogZnVuY3Rpb24oKSxcbiAqICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCwgLi4uKSxcbiAqICAgICAgICBuZXh0OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGxleDogZnVuY3Rpb24oLi4uKSxcbiAqICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqICAgICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKClcbiAqXG4gKiAgICAgICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJULCAuLi4pLFxuICogICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAqICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICAgIH1cbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gKiAgICBmaXJzdF9saW5lOiBuLFxuICogICAgbGFzdF9saW5lOiBuLFxuICogICAgZmlyc3RfY29sdW1uOiBuLFxuICogICAgbGFzdF9jb2x1bW46IG4sXG4gKiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl1cbiAqICAgICAgICAgICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgemVyby1iYXNlZClcbiAqICB9XG4gKlxuICogLS0tXG4gKlxuICogVGhlIGBwYXJzZUVycm9yYCBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmRcbiAqIHBhcnNlciBlcnJvcnM6XG4gKlxuICogIHtcbiAqICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICogICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAqICAgIHRva2VuX2lkOiAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuIG51bWVyaWMgSUQsIGlmIGFueSlcbiAqICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gKiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAqICB9XG4gKlxuICogcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgYWRkaXRpb25hbCBtZW1iZXJzOlxuICpcbiAqICB7XG4gKiAgICBleHBlY3RlZDogICAgKGFycmF5IGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnM7XG4gKiAgICAgICAgICAgICAgICAgIG1heSBiZSBVTkRFRklORUQgd2hlbiB3ZSBjYW5ub3QgZWFzaWx5IHByb2R1Y2Ugc3VjaCBhIHNldClcbiAqICAgIHN0YXRlOiAgICAgICAoaW50ZWdlciAob3IgYXJyYXkgd2hlbiB0aGUgdGFibGUgaW5jbHVkZXMgZ3JhbW1hciBjb2xsaXNpb25zKTtcbiAqICAgICAgICAgICAgICAgICAgcmVwcmVzZW50cyB0aGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgcGFyc2VyIGtlcm5lbC5cbiAqICAgICAgICAgICAgICAgICAgY2FuLCBmb3IgZXhhbXBsZSwgYmUgdXNlZCB0byBwYXNzIHRvIHRoZSBgY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoKWBcbiAqICAgICAgICAgICAgICAgICAgQVBJIHRvIG9idGFpbiB0aGUgZXhwZWN0ZWQgdG9rZW4gc2V0KVxuICogICAgYWN0aW9uOiAgICAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIGFjdGlvbiB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkKVxuICogICAgbmV3X3N0YXRlOiAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBuZXh0L3BsYW5uZWQgaW50ZXJuYWwgc3RhdGUsIG9uY2UgdGhlIGN1cnJlbnRcbiAqICAgICAgICAgICAgICAgICAgYWN0aW9uIGhhcyBleGVjdXRlZClcbiAqICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgTUFZIGhhdmUgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZVxuICogICAgICAgICAgICAgICAgICBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAqICAgIHN0YXRlX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIHN0YXRlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgdmFsdWVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgYCQkYCB2YWx1ZSBzdGFjazsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxvY2F0aW9uX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIGxvY2F0aW9uIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICAgIHBhcnNlcjogICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZSlcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBsZXhlciwgYHRoaXNgIHdpbGwgc3RpbGwgcmVmZXJlbmNlIHRoZSByZWxhdGVkICpwYXJzZXIqXG4gKiBpbnN0YW5jZSwgd2hpbGUgdGhlc2UgYWRkaXRpb25hbCBgaGFzaGAgZmllbGRzIHdpbGwgYWxzbyBiZSBwcm92aWRlZDpcbiAqXG4gKiAge1xuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2Ugd2hpY2ggcmVwb3J0ZWQgdGhlIGVycm9yKVxuICogIH1cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgZHVlIHRvIGEgKipKYXZhU2NyaXB0IGV4Y2VwdGlvbioqIGJlaW5nIGZpcmVkXG4gKiBmcm9tIGVpdGhlciB0aGUgcGFyc2VyIG9yIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBleGNlcHRpb246ICAgKHJlZmVyZW5jZSB0byB0aGUgZXhjZXB0aW9uIHRocm93bilcbiAqICB9XG4gKlxuICogUGxlYXNlIGRvIG5vdGUgdGhhdCBpbiB0aGUgbGF0dGVyIHNpdHVhdGlvbiwgdGhlIGBleHBlY3RlZGAgZmllbGQgd2lsbCBiZSBvbWl0dGVkIGFzXG4gKiB0aGlzIHR5cGUgb2YgZmFpbHVyZSBpcyBhc3N1bWVkIG5vdCB0byBiZSBkdWUgdG8gKnBhcnNlIGVycm9ycyogYnV0IHJhdGhlciBkdWUgdG8gdXNlclxuICogYWN0aW9uIGNvZGUgaW4gZWl0aGVyIHBhcnNlciBvciBsZXhlciBmYWlsaW5nIHVuZXhwZWN0ZWRseS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgcGFyc2VyIG9wdGlvbnMgYnkgc2V0dGluZyAvIG1vZGlmeWluZyB0aGUgYC55eWAgb2JqZWN0IG9mIHlvdXIgUGFyc2VyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICMjIyBvcHRpb25zIHdoaWNoIGFyZSBnbG9iYWwgZm9yIGFsbCBwYXJzZXIgaW5zdGFuY2VzXG4gKlxuICogIFBhcnNlci5wcmVfcGFyc2U6IGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwcmVfcGFyc2UoKSBmdW5jdGlvbiBpbiB0aGUgY2h1bmsgZm9sbG93aW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdyYW1tYXIsIGkuZS4gYWZ0ZXIgdGhlIGxhc3QgYCUlYC5cbiAqICBQYXJzZXIucG9zdF9wYXJzZTogZnVuY3Rpb24oeXksIHJldHZhbCwgcGFyc2VJbmZvKSB7IHJldHVybiByZXR2YWw7IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogeW91IGNhbiBzcGVjaWZ5IGEgcG9zdF9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLiBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgYHJldHZhbGAuXG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHNldCB1cCBwZXIgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogIHl5OiB7XG4gKiAgICAgIHByZV9wYXJzZTogIGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIGJlZm9yZSB0aGUgcGFyc2UgY3ljbGUgc3RhcnRzIChhbmQgYmVmb3JlIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2YgYGxleCgpYCkgYnV0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgYHBhcnNlci5wcmVfcGFyc2UoKWApLlxuICogICAgICBwb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIHBhcnNlIHRlcm1pbmF0ZXMgZHVlIHRvIHN1Y2Nlc3MgKCdhY2NlcHQnKVxuICogICAgICAgICAgICAgICAgIG9yIGZhaWx1cmUgKGV2ZW4gd2hlbiBleGNlcHRpb25zIGFyZSB0aHJvd24pLlxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgIGNvbnRhaW5zIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgcHJvZHVjZWQgYnkgYFBhcnNlci5wYXJzZSgpYDtcbiAqICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIGNhbiBvdmVycmlkZSB0aGUgcmV0dXJuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSwgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWxcbiAqICAgICAgICAgICAgICAgICBgcmV0dmFsYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGBwYXJzZXIucG9zdF9wYXJzZSgpYC5cbiAqXG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgICAgIHF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIHBhcnNlci5sZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiAgICAgIHJhbmdlczogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyLlxuICogICAgICBmbGV4OiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWRcbiAqICAgICAgICAgICAgICAgICBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaC5cbiAqICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgaW52b2tlZDtcbiAqICAgICAgICAgICAgICAgICB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlLlxuICogICAgICB4cmVnZXhwOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcnVsZSByZWdleGVzIGFyZSBcImV4dGVuZGVkIHJlZ2V4IGZvcm1hdFwiIHJlcXVpcmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICBgWFJlZ0V4cGAgbGlicmFyeS4gV2hlbiB0aGlzIGAlb3B0aW9uYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG4gICAgICAgIFxuICAgIFxuICAgICAgICAgICAgdmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG5cbi8vIFNlZSBhbHNvOlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHQvIzM1ODgxNTA4XG4vLyBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuLy8gd2l0aCB1c2VybGFuZCBjb2RlIHdoaWNoIG1pZ2h0IGFjY2VzcyB0aGUgZGVyaXZlZCBjbGFzcyBpbiBhICdjbGFzc2ljJyB3YXkuXG5mdW5jdGlvbiBKaXNvblBhcnNlckVycm9yKG1zZywgaGFzaCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6ICdKaXNvblBhcnNlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKSBtc2cgPSAnPz8/JztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbXNnXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc2ggPSBoYXNoO1xuXG4gICAgdmFyIHN0YWNrdHJhY2U7XG4gICAgaWYgKGhhc2ggJiYgaGFzaC5leGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgZXgyID0gaGFzaC5leGNlcHRpb247XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgICAgc3RhY2t0cmFjZSA9IGV4Mi5zdGFjaztcbiAgICB9XG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgeyAgICAgICAgLy8gVjgvQ2hyb21lIGVuZ2luZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFja3RyYWNlID0gKG5ldyBFcnJvcihtc2cpKS5zdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2t0cmFjZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogc3RhY2t0cmFjZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xufSBlbHNlIHtcbiAgICBKaXNvblBhcnNlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbn1cbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25QYXJzZXJFcnJvcjtcbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25QYXJzZXJFcnJvcic7XG5cblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlIHByb2R1Y3Rpb25zW10gdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYnAocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICB2YXIgcCA9IHMucG9wO1xuICAgICAgICAgICAgdmFyIHIgPSBzLnJ1bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcnYucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgZGVmYXVsdEFjdGlvbnNbXSB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBiZGEocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgICAgICB2YXIgZCA9IHMuaWR4O1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBkW2ldO1xuICAgICAgICAgICAgICAgIHJ2W2pdID0gZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgJ2dvdG8nIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJ0KHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgdmFyIGQgPSBzLmxlbjtcbiAgICAgICAgICAgIHZhciB5ID0gcy5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgdCA9IHMudHlwZTtcbiAgICAgICAgICAgIHZhciBhID0gcy5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBtID0gcy5tb2RlO1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBxID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSA9PT0gMTogYWNjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnYucHVzaChxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiBydW5sZW5ndGggZW5jb2Rpbmcgd2l0aCBpbmNyZW1lbnQgc3RlcDogY29kZSwgbGVuZ3RoOiBzdGVwIChkZWZhdWx0IHN0ZXAgPSAwKVxuICAgICAgICAvLyBgdGhpc2AgcmVmZXJlbmNlcyBhbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBzKGMsIGwsIGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBjICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXI6IGR1cGxpY2F0ZSBzZXF1ZW5jZSBmcm9tICpyZWxhdGl2ZSogb2Zmc2V0IGFuZCBsZW5ndGguXG4gICAgICAgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGFuIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIGMoaSwgbCkge1xuICAgICAgICAgICAgaSA9IHRoaXMubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVscGVyOiB1bnBhY2sgYW4gYXJyYXkgdXNpbmcgaGVscGVycyBhbmQgZGF0YSwgYWxsIHBhc3NlZCBpbiBhbiBhcnJheSBhcmd1bWVudCAnYScuXG4gICAgICAgIGZ1bmN0aW9uIHUoYSkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhW2ldO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgZW50cnkgYSBoZWxwZXIgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBseShydiwgYVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnYucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxudmFyIHBhcnNlciA9IHtcbiAgICAvLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIE9wdGlvbnM6XG4gICAgLy9cbiAgICAvLyAgIGRlZmF1bHQgYWN0aW9uIG1vZGU6IC4uLi4uLi4uLi4uLi4gY2xhc3NpYyxtZXJnZVxuICAgIC8vICAgbm8gdHJ5Li5jYXRjaDogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbm8gZGVmYXVsdCByZXNvbHZlIG9uIGNvbmZsaWN0OiAgICBmYWxzZVxuICAgIC8vICAgb24tZGVtYW5kIGxvb2stYWhlYWQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXJyb3IgcmVjb3ZlcnkgdG9rZW4gc2tpcCBtYXhpbXVtOiAzXG4gICAgLy8gICB5eWVycm9yIGluIHBhcnNlIGFjdGlvbnMgaXM6IC4uLi4uIE5PVCByZWNvdmVyYWJsZSxcbiAgICAvLyAgIHl5ZXJyb3IgaW4gbGV4ZXIgYWN0aW9ucyBhbmQgb3RoZXIgbm9uLWZhdGFsIGxleGVyIGFyZTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgZGVidWcgZ3JhbW1hci9vdXRwdXQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIHBhcnRpYWwgTFIgY29uZmxpY3QgdXBncmFkZTogICB0cnVlXG4gICAgLy8gICBydWRpbWVudGFyeSB0b2tlbi1zdGFjayBzdXBwb3J0OiAgIGZhbHNlXG4gICAgLy8gICBwYXJzZXIgdGFibGUgY29tcHJlc3Npb24gbW9kZTogLi4uIDJcbiAgICAvLyAgIGV4cG9ydCBkZWJ1ZyB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGV4cG9ydCAqYWxsKiB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIG1vZHVsZSB0eXBlOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gY29tbW9uanNcbiAgICAvLyAgIHBhcnNlciBlbmdpbmUgdHlwZTogLi4uLi4uLi4uLi4uLi4gbGFsclxuICAgIC8vICAgb3V0cHV0IG1haW4oKSBpbiB0aGUgbW9kdWxlOiAuLi4uLiB0cnVlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgbWFpbigpOiAuLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgcmVxdWlyZSgpL2ltcG9ydCBtb2R1bGVzIGZvciBtYWluKCk6IFxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbnVtYmVyIG9mIGV4cGVjdGVkIGNvbmZsaWN0czogLi4uLiAwXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFBhcnNlciBBbmFseXNpcyBmbGFnczpcbiAgICAvL1xuICAgIC8vICAgbm8gc2lnbmlmaWNhbnQgYWN0aW9ucyAocGFyc2VyIGlzIGEgbGFuZ3VhZ2UgbWF0Y2hlciBvbmx5KTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgUGFyc2VFcnJvciBBUEk6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPUjogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlSRUNPVkVSSU5HOiAuLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPSzogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlDTEVBUklOOiAuLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHRyYWNrcyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgYXNzaWducyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIGxvY2F0aW9uIHRyYWNraW5nOiAuLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIGFzc2lnbnMgbG9jYXRpb246IC4uLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgdXNlcyB5eXN0YWNrOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNzdGFjazogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNwOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIHl5cnVsZWxlbmd0aDogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5TWVyZ2VMb2NhdGlvbkluZm8gQVBJOiAuLi4uIHRydWVcbiAgICAvLyAgIGhhcyBlcnJvciByZWNvdmVyeTogLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGhhcyBlcnJvciByZXBvcnRpbmc6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLSBFTkQgT0YgUkVQT1JUIC0tLS0tLS0tLS0tXG5cbnRyYWNlOiBmdW5jdGlvbiBub19vcF90cmFjZSgpIHt9LFxuSmlzb25QYXJzZXJFcnJvcjogSmlzb25QYXJzZXJFcnJvcixcbnl5OiB7fSxcbm9wdGlvbnM6IHtcbiAgdHlwZTogXCJsYWxyXCIsXG4gIGhhc1BhcnRpYWxMclVwZ3JhZGVPbkNvbmZsaWN0OiB0cnVlLFxuICBlcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQ6IDMsXG4gIGVibmY6IHRydWVcbn0sXG5zeW1ib2xzXzoge1xuICBcIiFcIjogMTYsXG4gIFwiIT1cIjogNjAsXG4gIFwiJGFjY2VwdFwiOiAwLFxuICBcIiRlbmRcIjogMSxcbiAgXCIlfVwiOiAzMCxcbiAgXCImJlwiOiA2MSxcbiAgXCIoXCI6IDcsXG4gIFwiKVwiOiA4LFxuICBcIipcIjogMyxcbiAgXCIrXCI6IDIxLFxuICBcIixcIjogNixcbiAgXCItXCI6IDIzLFxuICBcIi5cIjogMTcsXG4gIFwiL1wiOiAyMixcbiAgXCIvPlwiOiAzNyxcbiAgXCI6XCI6IDEyLFxuICBcIjtcIjogMjAsXG4gIFwiPFwiOiAxMyxcbiAgXCI8L1wiOiAzNixcbiAgXCI8PVwiOiA1OCxcbiAgXCI9XCI6IDksXG4gIFwiPT1cIjogNTksXG4gIFwiPT5cIjogNTAsXG4gIFwiPlwiOiAxNCxcbiAgXCI+PVwiOiA1NyxcbiAgXCI/XCI6IDE4LFxuICBcIkBcIjogMTksXG4gIFwiQVNcIjogMjcsXG4gIFwiQ0hBUkFDVEVSU1wiOiA0NyxcbiAgXCJDT05TVFJVQ1RPUlwiOiA1NixcbiAgXCJFTFNFXCI6IDQ1LFxuICBcIkVOREZPUlwiOiA0MixcbiAgXCJFTkRGVU5cIjogMzUsXG4gIFwiRU5ESUZcIjogNDYsXG4gIFwiRU5EVklFV1wiOiAzMyxcbiAgXCJFT0ZcIjogMSxcbiAgXCJFWFBPUlRcIjogMzEsXG4gIFwiRkFMU0VcIjogNTQsXG4gIFwiRk9SXCI6IDQwLFxuICBcIkZST01cIjogMjYsXG4gIFwiRlVOXCI6IDM0LFxuICBcIklERU5USUZJRVJcIjogNTUsXG4gIFwiSUZcIjogNDQsXG4gIFwiSU1QT1JUXCI6IDI1LFxuICBcIklOXCI6IDQxLFxuICBcIklOU1RBTkNFT0ZcIjogNjMsXG4gIFwiTUFJTlwiOiAyOSxcbiAgXCJOVU1CRVJfTElURVJBTFwiOiA1MixcbiAgXCJPVEhFUldJU0VcIjogNDMsXG4gIFwiU1RSSU5HX0xJVEVSQUxcIjogNTEsXG4gIFwiVEhFTlwiOiA0OCxcbiAgXCJUUlVFXCI6IDUzLFxuICBcIlZJRVdcIjogMzIsXG4gIFwiW1wiOiAxMCxcbiAgXCJcXFxcXFxcXFwiOiA0OSxcbiAgXCJdXCI6IDExLFxuICBcIl5cIjogMjQsXG4gIFwiYWdncmVnYXRlX21lbWJlclwiOiA2OSxcbiAgXCJhbGlhc2VkX21lbWJlclwiOiA2OCxcbiAgXCJhcmd1bWVudF9saXN0XCI6IDEwNCxcbiAgXCJhcmd1bWVudHNcIjogMTAzLFxuICBcImF0dHJpYnV0ZVwiOiA5MyxcbiAgXCJhdHRyaWJ1dGVfdmFsdWVcIjogOTQsXG4gIFwiYXR0cmlidXRlX3ZhbHVlX2dyb3VwXCI6IDE1MyxcbiAgXCJhdHRyaWJ1dGVzXCI6IDkyLFxuICBcImJpbmFyeV9leHByZXNzaW9uXCI6IDEwNyxcbiAgXCJiaW5hcnlfb3BlcmF0b3JcIjogMTM3LFxuICBcImJpbmFyeV9vcGVyYXRvcl9ncm91cFwiOiAxNTksXG4gIFwiYm9vbGVhbl9saXRlcmFsXCI6IDEyOCxcbiAgXCJjYWxsX2V4cHJlc3Npb25cIjogMTE2LFxuICBcImNoYXJhY3RlcnNcIjogMTAyLFxuICBcImNoaWxkXCI6IDg4LFxuICBcImNoaWxkX2dyb3VwXCI6IDE0OCxcbiAgXCJjaGlsZHJlblwiOiA4NyxcbiAgXCJjb21wb3NpdGVfbWVtYmVyXCI6IDcwLFxuICBcImNvbnNcIjogMTMxLFxuICBcImNvbnN0cnVjdF9leHByZXNzaW9uXCI6IDExNSxcbiAgXCJjb250ZXh0X3Byb3BlcnR5XCI6IDEyOSxcbiAgXCJjb250ZXh0X3R5cGVcIjogNzksXG4gIFwiY29udGV4dF92YXJpYWJsZVwiOiAxMzAsXG4gIFwiY29udHJvbFwiOiA5OCxcbiAgXCJjb250cm9sX2dyb3VwXCI6IDE1NCxcbiAgXCJlbHNlX2NsYXVzZVwiOiAxMDEsXG4gIFwiZXJyb3JcIjogMixcbiAgXCJleHBvcnRcIjogNzUsXG4gIFwiZXhwb3J0X3N0YXRlbWVudFwiOiA3NixcbiAgXCJleHBvcnRzXCI6IDc0LFxuICBcImV4cHJlc3Npb25cIjogMTA1LFxuICBcImZpbHRlclwiOiA5NyxcbiAgXCJmaWx0ZXJzXCI6IDk2LFxuICBcImZvcl9zdGF0ZW1lbnRcIjogOTksXG4gIFwiZnVuX2FwcGxpY2F0aW9uXCI6IDExMSxcbiAgXCJmdW5fc3RhdGVtZW50XCI6IDc4LFxuICBcImZ1bl90YXJnZXRcIjogMTEyLFxuICBcImZ1bmN0aW9uX2V4cHJlc3Npb25cIjogMTIwLFxuICBcImlkZW50aWZpZXJcIjogMTM0LFxuICBcImlmX2V4cHJlc3Npb25cIjogMTA2LFxuICBcImlmX3N0YXRlbWVudFwiOiAxMDAsXG4gIFwiaW1wb3J0X21lbWJlclwiOiA2NyxcbiAgXCJpbXBvcnRfc3RhdGVtZW50XCI6IDY2LFxuICBcImltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uXCI6IDEzOCxcbiAgXCJpbXBvcnRzXCI6IDY1LFxuICBcImludGVycG9sYXRpb25cIjogOTUsXG4gIFwibGlzdFwiOiAxMjUsXG4gIFwibGl0ZXJhbFwiOiAxMjEsXG4gIFwibGl0ZXJhbF9ncm91cFwiOiAxNTcsXG4gIFwibWFpblwiOiA3MyxcbiAgXCJtYWluX29wdGlvblwiOiAxNDIsXG4gIFwibWFpbl9vcHRpb24yXCI6IDE0MyxcbiAgXCJtYWluX29wdGlvbjNcIjogMTQ0LFxuICBcIm1lbWJlclwiOiA3MixcbiAgXCJtZW1iZXJfZXhwcmVzc2lvblwiOiAxMTcsXG4gIFwibWVtYmVyX2dyb3VwXCI6IDE0MSxcbiAgXCJtZW1iZXJfbGlzdFwiOiA3MSxcbiAgXCJtZW1iZXJfbGlzdF9ncm91cFwiOiAxMzksXG4gIFwibWVtYmVyX2xpc3RfZ3JvdXAyXCI6IDE0MCxcbiAgXCJtb2R1bGVcIjogNjQsXG4gIFwibm9kZVwiOiA5MCxcbiAgXCJub2RlX29wdGlvblwiOiAxNDksXG4gIFwibm9kZV9vcHRpb24yXCI6IDE1MCxcbiAgXCJudW1iZXJfbGl0ZXJhbFwiOiAxMjcsXG4gIFwicGFyYW1ldGVyXCI6IDg2LFxuICBcInBhcmFtZXRlcl9saXN0XCI6IDg1LFxuICBcInBhcmFtZXRlcnNcIjogODQsXG4gIFwicHJvcGVydGllc1wiOiAxMjMsXG4gIFwicHJvcGVydHlcIjogMTI0LFxuICBcInByb3BlcnR5X2dyb3VwXCI6IDE1OCxcbiAgXCJxdWFsaWZpZWRfY29uc3RydWN0b3JcIjogMTMyLFxuICBcInF1YWxpZmllZF9pZGVudGlmaWVyXCI6IDEzNSxcbiAgXCJyZWFkX2V4cHJlc3Npb25cIjogMTE4LFxuICBcInJlYWRhYmxlX2V4cHJlc3Npb25cIjogMTE5LFxuICBcInJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXBcIjogMTU2LFxuICBcInJlY29yZFwiOiAxMjIsXG4gIFwic2ltcGxlX2V4cHJlc3Npb25cIjogMTA5LFxuICBcInNpbXBsZV9leHByZXNzaW9uX2dyb3VwXCI6IDE1NSxcbiAgXCJzdHJpbmdfbGl0ZXJhbFwiOiAxMjYsXG4gIFwidGFnXCI6IDg5LFxuICBcInR5cGVcIjogODMsXG4gIFwidHlwZV9hcmdfbGlzdFwiOiAxMTQsXG4gIFwidHlwZV9hcmd1bWVudHNcIjogMTEzLFxuICBcInR5cGVfY2xhc3NcIjogODIsXG4gIFwidHlwZV9jbGFzc19saXN0XCI6IDgxLFxuICBcInR5cGVfY2xhc3Nlc1wiOiA4MCxcbiAgXCJ0eXBlX29wdGlvblwiOiAxNDcsXG4gIFwidW5hcnlfZXhwcmVzc2lvblwiOiAxMDgsXG4gIFwidW5xdWFsaWZpZWRfY29uc3RydWN0b3JcIjogMTMzLFxuICBcInVucXVhbGlmaWVkX2lkZW50aWZpZXJcIjogMTM2LFxuICBcInZpZXdfY29uc3RydWN0aW9uXCI6IDExMCxcbiAgXCJ2aWV3X3N0YXRlbWVudFwiOiA3NyxcbiAgXCJ2aWV3X3N0YXRlbWVudF9vcHRpb25cIjogMTQ1LFxuICBcInZpZXdfc3RhdGVtZW50X29wdGlvbjJcIjogMTQ2LFxuICBcIndpZGdldFwiOiA5MSxcbiAgXCJ3aWRnZXRfb3B0aW9uXCI6IDE1MSxcbiAgXCJ3aWRnZXRfb3B0aW9uMlwiOiAxNTIsXG4gIFwie1wiOiA0LFxuICBcInslXCI6IDI4LFxuICBcInt7XCI6IDM4LFxuICBcInxcIjogMTUsXG4gIFwifHxcIjogNjIsXG4gIFwifVwiOiA1LFxuICBcIn19XCI6IDM5XG59LFxudGVybWluYWxzXzoge1xuICAxOiBcIkVPRlwiLFxuICAyOiBcImVycm9yXCIsXG4gIDM6IFwiKlwiLFxuICA0OiBcIntcIixcbiAgNTogXCJ9XCIsXG4gIDY6IFwiLFwiLFxuICA3OiBcIihcIixcbiAgODogXCIpXCIsXG4gIDk6IFwiPVwiLFxuICAxMDogXCJbXCIsXG4gIDExOiBcIl1cIixcbiAgMTI6IFwiOlwiLFxuICAxMzogXCI8XCIsXG4gIDE0OiBcIj5cIixcbiAgMTU6IFwifFwiLFxuICAxNjogXCIhXCIsXG4gIDE3OiBcIi5cIixcbiAgMTg6IFwiP1wiLFxuICAxOTogXCJAXCIsXG4gIDIwOiBcIjtcIixcbiAgMjE6IFwiK1wiLFxuICAyMjogXCIvXCIsXG4gIDIzOiBcIi1cIixcbiAgMjQ6IFwiXlwiLFxuICAyNTogXCJJTVBPUlRcIixcbiAgMjY6IFwiRlJPTVwiLFxuICAyNzogXCJBU1wiLFxuICAyODogXCJ7JVwiLFxuICAyOTogXCJNQUlOXCIsXG4gIDMwOiBcIiV9XCIsXG4gIDMxOiBcIkVYUE9SVFwiLFxuICAzMjogXCJWSUVXXCIsXG4gIDMzOiBcIkVORFZJRVdcIixcbiAgMzQ6IFwiRlVOXCIsXG4gIDM1OiBcIkVOREZVTlwiLFxuICAzNjogXCI8L1wiLFxuICAzNzogXCIvPlwiLFxuICAzODogXCJ7e1wiLFxuICAzOTogXCJ9fVwiLFxuICA0MDogXCJGT1JcIixcbiAgNDE6IFwiSU5cIixcbiAgNDI6IFwiRU5ERk9SXCIsXG4gIDQzOiBcIk9USEVSV0lTRVwiLFxuICA0NDogXCJJRlwiLFxuICA0NTogXCJFTFNFXCIsXG4gIDQ2OiBcIkVORElGXCIsXG4gIDQ3OiBcIkNIQVJBQ1RFUlNcIixcbiAgNDg6IFwiVEhFTlwiLFxuICA0OTogXCJcXFxcXFxcXFwiLFxuICA1MDogXCI9PlwiLFxuICA1MTogXCJTVFJJTkdfTElURVJBTFwiLFxuICA1MjogXCJOVU1CRVJfTElURVJBTFwiLFxuICA1MzogXCJUUlVFXCIsXG4gIDU0OiBcIkZBTFNFXCIsXG4gIDU1OiBcIklERU5USUZJRVJcIixcbiAgNTY6IFwiQ09OU1RSVUNUT1JcIixcbiAgNTc6IFwiPj1cIixcbiAgNTg6IFwiPD1cIixcbiAgNTk6IFwiPT1cIixcbiAgNjA6IFwiIT1cIixcbiAgNjE6IFwiJiZcIixcbiAgNjI6IFwifHxcIixcbiAgNjM6IFwiSU5TVEFOQ0VPRlwiXG59LFxuVEVSUk9SOiAyLFxuRU9GOiAxLFxuXG4vLyBpbnRlcm5hbHM6IGRlZmluZWQgaGVyZSBzbyB0aGUgb2JqZWN0ICpzdHJ1Y3R1cmUqIGRvZXNuJ3QgZ2V0IG1vZGlmaWVkIGJ5IHBhcnNlKCkgZXQgYWwsXG4vLyB0aHVzIGhlbHBpbmcgSklUIGNvbXBpbGVycyBsaWtlIENocm9tZSBWOC5cbm9yaWdpbmFsUXVvdGVOYW1lOiBudWxsLFxub3JpZ2luYWxQYXJzZUVycm9yOiBudWxsLFxuY2xlYW51cEFmdGVyUGFyc2U6IG51bGwsXG5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogbnVsbCxcbnl5TWVyZ2VMb2NhdGlvbkluZm86IG51bGwsXG5cbl9fcmVlbnRyYW50X2NhbGxfZGVwdGg6IDAsIC8vIElOVEVSTkFMIFVTRSBPTkxZXG5fX2Vycm9yX2luZm9zOiBbXSwgLy8gSU5URVJOQUwgVVNFIE9OTFk6IHRoZSBzZXQgb2YgcGFyc2VFcnJvckluZm8gb2JqZWN0cyBjcmVhdGVkIHNpbmNlIHRoZSBsYXN0IGNsZWFudXBcbl9fZXJyb3JfcmVjb3ZlcnlfaW5mb3M6IFtdLCAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuXG4vLyBBUElzIHdoaWNoIHdpbGwgYmUgc2V0IHVwIGRlcGVuZGluZyBvbiB1c2VyIGFjdGlvbiBjb2RlIGFuYWx5c2lzOlxuLy95eVJlY292ZXJpbmc6IDAsXG4vL3l5RXJyT2s6IDAsXG4vL3l5Q2xlYXJJbjogMCxcblxuLy8gSGVscGVyIEFQSXNcbi8vIC0tLS0tLS0tLS0tXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2VyIGNvZGUgbGF0ZXIgb246IHB1dCBzdWl0YWJsZSBxdW90ZXMgYXJvdW5kXG4vLyBsaXRlcmFsIElEcyBpbiBhIGRlc2NyaXB0aW9uIHN0cmluZy5cbnF1b3RlTmFtZTogZnVuY3Rpb24gcGFyc2VyX3F1b3RlTmFtZShpZF9zdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIGlkX3N0ciArICdcIic7XG59LFxuXG4vLyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGdpdmVuIHN5bWJvbCAodGVybWluYWwgb3Igbm9uLXRlcm1pbmFsKSBhcyBhIHN0cmluZywgd2hlbiBhdmFpbGFibGUuXG4vL1xuLy8gUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbmdldFN5bWJvbE5hbWU6IGZ1bmN0aW9uIHBhcnNlcl9nZXRTeW1ib2xOYW1lKHN5bWJvbCkge1xuICAgIGlmICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF07XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLi4uIHRoaXMgbWlnaHQgcmVmZXIgdG8gYSBSVUxFIHRva2VuIGkuZS4gYSBub24tdGVybWluYWw6IHNlZSBpZiB3ZSBjYW4gZGlnIHRoYXQgb25lIHVwLlxuICAgIC8vXG4gICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIG1heSBiZSB3aGVyZSBhIHJ1bGUncyBhY3Rpb24gY29kZSBjb250YWlucyBhIGNhbGwgbGlrZSB0aGlzOlxuICAgIC8vXG4gICAgLy8gICAgICBwYXJzZXIuZ2V0U3ltYm9sTmFtZSgjJClcbiAgICAvL1xuICAgIC8vIHRvIG9idGFpbiBhIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGN1cnJlbnQgZ3JhbW1hciBydWxlLlxuICAgIHZhciBzID0gdGhpcy5zeW1ib2xzXztcbiAgICBmb3IgKHZhciBrZXkgaW4gcykge1xuICAgICAgICBpZiAoc1trZXldID09PSBzeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59LFxuXG4vLyBSZXR1cm4gYSBtb3JlLW9yLWxlc3MgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGdpdmVuIHN5bWJvbCwgd2hlbiBhdmFpbGFibGUsXG4vLyBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbi8vXG4vLyBSZXR1cm4gTlVMTCB3aGVuIHRoZSBzeW1ib2wgaXMgdW5rbm93biB0byB0aGUgcGFyc2VyLlxuZGVzY3JpYmVTeW1ib2w6IGZ1bmN0aW9uIHBhcnNlcl9kZXNjcmliZVN5bWJvbChzeW1ib2wpIHtcbiAgICBpZiAoc3ltYm9sICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc18gJiYgdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybWluYWxfZGVzY3JpcHRpb25zX1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAoc3ltYm9sID09PSB0aGlzLkVPRikge1xuICAgICAgICByZXR1cm4gJ2VuZCBvZiBpbnB1dCc7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgIGlmIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdW90ZU5hbWUoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0sXG5cbi8vIFByb2R1Y2UgYSAobW9yZSBvciBsZXNzKSBodW1hbi1yZWFkYWJsZSBsaXN0IG9mIGV4cGVjdGVkIHRva2VucyBhdCB0aGUgcG9pbnQgb2YgZmFpbHVyZS5cbi8vXG4vLyBUaGUgcHJvZHVjZWQgbGlzdCBtYXkgY29udGFpbiB0b2tlbiBvciB0b2tlbiBzZXQgZGVzY3JpcHRpb25zIGluc3RlYWQgb2YgdGhlIHRva2Vuc1xuLy8gdGhlbXNlbHZlcyB0byBoZWxwIHR1cm5pbmcgdGhpcyBvdXRwdXQgaW50byBzb21ldGhpbmcgdGhhdCBlYXNpZXIgdG8gcmVhZCBieSBodW1hbnNcbi8vIHVubGVzcyBgZG9fbm90X2Rlc2NyaWJlYCBwYXJhbWV0ZXIgaXMgc2V0LCBpbiB3aGljaCBjYXNlIGEgbGlzdCBvZiB0aGUgcmF3LCAqbnVtZXJpYyosXG4vLyBleHBlY3RlZCB0ZXJtaW5hbHMgYW5kIG5vbnRlcm1pbmFscyBpcyBwcm9kdWNlZC5cbi8vXG4vLyBUaGUgcmV0dXJuZWQgbGlzdCAoYXJyYXkpIHdpbGwgbm90IGNvbnRhaW4gYW55IGR1cGxpY2F0ZSBlbnRyaWVzLlxuY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQ6IGZ1bmN0aW9uIHBhcnNlcl9jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSwgZG9fbm90X2Rlc2NyaWJlKSB7XG4gICAgdmFyIFRFUlJPUiA9IHRoaXMuVEVSUk9SO1xuICAgIHZhciB0b2tlbnNldCA9IFtdO1xuICAgIHZhciBjaGVjayA9IHt9O1xuICAgIC8vIEhhcyB0aGlzIChlcnJvcj8pIHN0YXRlIGJlZW4gb3V0Zml0dGVkIHdpdGggYSBjdXN0b20gZXhwZWN0YXRpb25zIGRlc2NyaXB0aW9uIHRleHQgZm9yIGh1bWFuIGNvbnN1bXB0aW9uP1xuICAgIC8vIElmIHNvLCB1c2UgdGhhdCBvbmUgaW5zdGVhZCBvZiB0aGUgbGVzcyBwYWxhdGFibGUgdG9rZW4gc2V0LlxuICAgIGlmICghZG9fbm90X2Rlc2NyaWJlICYmIHRoaXMuc3RhdGVfZGVzY3JpcHRpb25zXyAmJiB0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc19bc3RhdGVdKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfW3N0YXRlXV07XG4gICAgfVxuICAgIGZvciAodmFyIHAgaW4gdGhpcy50YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgcCA9ICtwO1xuICAgICAgICBpZiAocCAhPT0gVEVSUk9SKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGRvX25vdF9kZXNjcmliZSA/IHAgOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHApO1xuICAgICAgICAgICAgaWYgKGQgJiYgIWNoZWNrW2RdKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zZXQucHVzaChkKTtcbiAgICAgICAgICAgICAgICBjaGVja1tkXSA9IHRydWU7IC8vIE1hcmsgdGhpcyB0b2tlbiBkZXNjcmlwdGlvbiBhcyBhbHJlYWR5IG1lbnRpb25lZCB0byBwcmV2ZW50IG91dHB1dHRpbmcgZHVwbGljYXRlIGVudHJpZXMuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vuc2V0O1xufSxcbnByb2R1Y3Rpb25zXzogYnAoe1xuICBwb3A6IHUoW1xuICBzLFxuICBbNjQsIDddLFxuICA2NSxcbiAgNjUsXG4gIDY2LFxuICBzLFxuICBbNjcsIDNdLFxuICBzLFxuICBbNjgsIDQsIDFdLFxuICA3MSxcbiAgNzIsXG4gIDczLFxuICA3MyxcbiAgNzQsXG4gIDc0LFxuICBzLFxuICBbNzUsIDNdLFxuICA3NixcbiAgNzcsXG4gIHMsXG4gIFs3OCwgMTZdLFxuICA3OSxcbiAgODAsXG4gIDgxLFxuICA4MSxcbiAgcyxcbiAgWzgyLCA0XSxcbiAgcyxcbiAgWzgzLCAzXSxcbiAgODQsXG4gIDg0LFxuICA4NSxcbiAgODUsXG4gIDg2LFxuICA4NixcbiAgODcsXG4gIDg3LFxuICA4OCxcbiAgODksXG4gIDg5LFxuICBzLFxuICBbOTAsIDRdLFxuICBzLFxuICBbOTEsIDRdLFxuICA5MixcbiAgOTIsXG4gIHMsXG4gIFs5MywgNF0sXG4gIDk0LFxuICA5NSxcbiAgOTUsXG4gIDk2LFxuICBzLFxuICBbOTYsIDQsIDFdLFxuICBzLFxuICBbOTksIDVdLFxuICAxMDAsXG4gIDEwMSxcbiAgMTAxLFxuICAxMDIsXG4gIDEwMyxcbiAgMTAzLFxuICAxMDQsXG4gIDEwNCxcbiAgcyxcbiAgWzEwNSwgN10sXG4gIDEwNixcbiAgcyxcbiAgWzEwNywgNF0sXG4gIDEwOCxcbiAgcyxcbiAgWzEwOCwgNCwgMV0sXG4gIHMsXG4gIFsxMTEsIDNdLFxuICBzLFxuICBbMTEyLCAzXSxcbiAgMTEzLFxuICAxMTQsXG4gIDExNCxcbiAgMTE1LFxuICBzLFxuICBbMTE2LCA4XSxcbiAgcyxcbiAgWzExNywgMTBdLFxuICBzLFxuICBbMTE4LCAxMF0sXG4gIDExOSxcbiAgMTE5LFxuICAxMjAsXG4gIDEyMCxcbiAgMTIxLFxuICAxMjIsXG4gIDEyMixcbiAgMTIzLFxuICAxMjMsXG4gIDEyNCxcbiAgMTI1LFxuICBzLFxuICBbMTI1LCA0LCAxXSxcbiAgcyxcbiAgWzEyOCwgNCwgMV0sXG4gIDEzMSxcbiAgMTMyLFxuICAxMzIsXG4gIDEzMyxcbiAgMTM0LFxuICAxMzQsXG4gIDEzNSxcbiAgcyxcbiAgWzEzNSwgNCwgMV0sXG4gIDEzOCxcbiAgMTM5LFxuICAxMzksXG4gIDE0MCxcbiAgMTQwLFxuICAxNDEsXG4gIDE0MSxcbiAgMTQyLFxuICAxNDIsXG4gIDE0MyxcbiAgMTQzLFxuICAxNDQsXG4gIDE0NCxcbiAgMTQ1LFxuICAxNDUsXG4gIDE0NixcbiAgMTQ2LFxuICAxNDcsXG4gIDE0NyxcbiAgcyxcbiAgWzE0OCwgNV0sXG4gIDE0OSxcbiAgMTQ5LFxuICAxNTAsXG4gIDE1MCxcbiAgMTUxLFxuICAxNTEsXG4gIDE1MixcbiAgMTUyLFxuICAxNTMsXG4gIDE1MyxcbiAgMTU0LFxuICAxNTQsXG4gIHMsXG4gIFsxNTUsIDEwXSxcbiAgcyxcbiAgWzE1NiwgNF0sXG4gIHMsXG4gIFsxNTcsIDVdLFxuICAxNTgsXG4gIDE1OCxcbiAgcyxcbiAgWzE1OSwgMTRdXG5dKSxcbiAgcnVsZTogdShbXG4gIDQsXG4gIDMsXG4gIDMsXG4gIDIsXG4gIDMsXG4gIDIsXG4gIDIsXG4gIDEsXG4gIDIsXG4gIDUsXG4gIHMsXG4gIFsxLCAzXSxcbiAgcyxcbiAgWzMsIDNdLFxuICAxLFxuICAzLFxuICAxLFxuICAxMCxcbiAgMSxcbiAgMSxcbiAgMixcbiAgcyxcbiAgWzEsIDNdLFxuICA2LFxuICAxMyxcbiAgMTEsXG4gIDEwLFxuICAxMCxcbiAgOSxcbiAgMTAsXG4gIDksXG4gIDksXG4gIDgsXG4gIDksXG4gIDgsXG4gIDgsXG4gIDcsXG4gIDgsXG4gIDcsXG4gIDcsXG4gIDYsXG4gIGMsXG4gIFszMCwgNV0sXG4gIGMsXG4gIFs0LCAzXSxcbiAgMixcbiAgNCxcbiAgYyxcbiAgWzUyLCAzXSxcbiAgYyxcbiAgWzQ1LCAzXSxcbiAgYyxcbiAgWzQwLCA2XSxcbiAgOCxcbiAgNyxcbiAgNCxcbiAgMyxcbiAgYyxcbiAgWzQsIDRdLFxuICBjLFxuICBbNjcsIDNdLFxuICBjLFxuICBbMTksIDRdLFxuICAzLFxuICA0LFxuICAxLFxuICBjLFxuICBbNzksIDNdLFxuICAxMCxcbiAgMTIsXG4gIDE0LFxuICAxNCxcbiAgMTYsXG4gIDE4LFxuICA2LFxuICA3LFxuICA3LFxuICAxLFxuICBjLFxuICBbNDIsIDRdLFxuICBzLFxuICBbMSwgNl0sXG4gIDMsXG4gIDYsXG4gIDMsXG4gIDUsXG4gIDUsXG4gIDcsXG4gIDIsXG4gIDQsXG4gIDEsXG4gIDQsXG4gIDYsXG4gIDUsXG4gIDUsXG4gIDQsXG4gIGMsXG4gIFsxMTAsIDRdLFxuICBjLFxuICBbNzUsIDNdLFxuICBjLFxuICBbMTI2LCA0XSxcbiAgMyxcbiAgMixcbiAgNSxcbiAgYyxcbiAgWzEzNSwgM10sXG4gIHMsXG4gIFszLCA2XSxcbiAgNSxcbiAgMyxcbiAgNixcbiAgOCxcbiAgNixcbiAgOCxcbiAgYyxcbiAgWzQsIDRdLFxuICAxMCxcbiAgOCxcbiAgYyxcbiAgWzc2LCAzXSxcbiAgYyxcbiAgWzE1MywgM10sXG4gIGMsXG4gIFsxMDYsIDRdLFxuICBjLFxuICBbNSwgM10sXG4gIHMsXG4gIFsxLCAzXSxcbiAgYyxcbiAgWzExMCwgNF0sXG4gIGMsXG4gIFs5OSwgNF0sXG4gIGMsXG4gIFs1LCA1XSxcbiAgMCxcbiAgcyxcbiAgWzEsIDddLFxuICAwLFxuICBjLFxuICBbMTAsIDNdLFxuICBjLFxuICBbNCwgOF0sXG4gIGMsXG4gIFsxNywgMTNdLFxuICBzLFxuICBbMSwgMzldXG5dKVxufSksXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX1BlcmZvcm1BY3Rpb24oeXlsb2MsIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCB5eXNwLCB5eXZzdGFjaywgeXlsc3RhY2spIHtcblxuICAgICAgICAgIC8qIHRoaXMgPT0geXl2YWwgKi9cblxuICAgICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgaXRzZWxmIGNhbiBnbyBhbmQgcmVtb3ZlIHRoZXNlIHN0YXRlbWVudHMgd2hlbiBgeXlgIHR1cm5zIG91dCB0byBiZSB1bnVzZWQgaW4gYW55IGFjdGlvbiBjb2RlIVxuICAgICAgICAgIHZhciB5eSA9IHRoaXMueXk7XG4gICAgICAgICAgdmFyIHl5cGFyc2VyID0geXkucGFyc2VyO1xuICAgICAgICAgIHZhciB5eWxleGVyID0geXkubGV4ZXI7XG5cbiAgICAgICAgICBcblxuICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgJGFjY2VwdCA6IG1vZHVsZSAkZW5kICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3AgLSAxXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSlcbiAgICBicmVhaztcblxuY2FzZSAxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBleHBvcnRzIG1haW4gRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgZXhwb3J0cyBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgbnVsbCwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBpbXBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIG51bGwsIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBleHBvcnRzIG1haW4gRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogZXhwb3J0cyBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydHMgOiBpbXBvcnRfc3RhdGVtZW50ICovXG5jYXNlIDg0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZmlsdGVycyA6IGZpbHRlciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gIFt5eXZzdGFja1t5eXNwXV07XG4gICAgYnJlYWs7XG5cbmNhc2UgOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydHMgOiBpbXBvcnRzIGltcG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgMjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnRzIDogZXhwb3J0cyBleHBvcnQgKi9cbmNhc2UgNjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZHJlbiA6IGNoaWxkcmVuIGNoaWxkICovXG5jYXNlIDc2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlcyA6IGF0dHJpYnV0ZXMgYXR0cmlidXRlICovXG5jYXNlIDg1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZmlsdGVycyA6IGZpbHRlcnMgZmlsdGVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV0uY29uY2F0KHl5dnN0YWNrW3l5c3BdKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnQgOiBJTVBPUlQgaW1wb3J0X21lbWJlciBGUk9NIHN0cmluZ19saXRlcmFsIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSW1wb3J0U3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9tZW1iZXIgOiBhZ2dyZWdhdGVfbWVtYmVyICovXG5jYXNlIDEyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGFsaWFzZWRfbWVtYmVyICovXG5jYXNlIDEzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGNvbXBvc2l0ZV9tZW1iZXIgKi9cbmNhc2UgMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXIgOiBtZW1iZXJfZ3JvdXAgKi9cbmNhc2UgMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiBleHBvcnRfc3RhdGVtZW50ICovXG5jYXNlIDI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwb3J0IDogdmlld19zdGF0ZW1lbnQgKi9cbmNhc2UgMTYxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbCA6IGxpdGVyYWxfZ3JvdXAgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3BdO1xuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSlcbiAgICBicmVhaztcblxuY2FzZSAxNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFsaWFzZWRfbWVtYmVyIDogbWVtYmVyIEFTIG1lbWJlciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkFsaWFzZWRNZW1iZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhZ2dyZWdhdGVfbWVtYmVyIDogXCIqXCIgQVMgbWVtYmVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQWdncmVnYXRlTWVtYmVyKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbXBvc2l0ZV9tZW1iZXIgOiBcIntcIiBtZW1iZXJfbGlzdCBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbXBvc2l0ZU1lbWJlcih5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3QgOiBtZW1iZXJfbGlzdF9ncm91cCAqL1xuY2FzZSAyMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydHMgOiBleHBvcnQgKi9cbmNhc2UgNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzX2xpc3QgOiB0eXBlX2NsYXNzICovXG5jYXNlIDU4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyX2xpc3QgOiBwYXJhbWV0ZXIgKi9cbmNhc2UgNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZHJlbiA6IGNoaWxkICovXG5jYXNlIDc1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlcyA6IGF0dHJpYnV0ZSAqL1xuY2FzZSAxMDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudF9saXN0IDogZXhwcmVzc2lvbiAqL1xuY2FzZSAxMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2FyZ19saXN0IDogdHlwZSAqL1xuY2FzZSAxNjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0aWVzIDogcHJvcGVydHkgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IFt5eXZzdGFja1t5eXNwXV07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdCA6IG1lbWJlcl9saXN0IFwiLFwiIG1lbWJlcl9saXN0X2dyb3VwMiAqL1xuY2FzZSA0ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3NfbGlzdCA6IHR5cGVfY2xhc3NfbGlzdCBcIixcIiB0eXBlX2NsYXNzICovXG5jYXNlIDU5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyX2xpc3QgOiBwYXJhbWV0ZXJfbGlzdCBcIixcIiBwYXJhbWV0ZXIgKi9cbmNhc2UgMTAxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXJndW1lbnRfbGlzdCA6IGFyZ3VtZW50X2xpc3QgXCIsXCIgZXhwcmVzc2lvbiAqL1xuY2FzZSAxMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2FyZ19saXN0IDogdHlwZV9hcmdfbGlzdCBcIixcIiB0eXBlICovXG5jYXNlIDE2NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnRpZXMgOiBwcm9wZXJ0aWVzIFwiLFwiIHByb3BlcnR5ICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMl0uY29uY2F0KHl5dnN0YWNrW3l5c3BdKTtcbiAgICBicmVhaztcblxuY2FzZSAyMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW4gOiBcInslXCIgTUFJTiBtYWluX29wdGlvbiBtYWluX29wdGlvbjIgXCIoXCIgdHlwZSBcIilcIiBtYWluX29wdGlvbjMgXCIlfVwiIHRhZyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGVkTWFpbih5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA2XXx8W10sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDJdfHxbXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbiA6IHRhZyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVudHlwZWRNYWluKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAyNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydCA6IGZ1bl9zdGF0ZW1lbnQgKi9cbmNhc2UgNjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZCA6IGNoaWxkX2dyb3VwICovXG5jYXNlIDY1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdGFnIDogbm9kZSAqL1xuY2FzZSA2NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHRhZyA6IHdpZGdldCAqL1xuY2FzZSA4MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZV92YWx1ZSA6IGF0dHJpYnV0ZV92YWx1ZV9ncm91cCAqL1xuY2FzZSA4NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRyb2wgOiBjb250cm9sX2dyb3VwICovXG5jYXNlIDEwMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiBpZl9leHByZXNzaW9uICovXG5jYXNlIDEwMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiBiaW5hcnlfZXhwcmVzc2lvbiAqL1xuY2FzZSAxMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogc2ltcGxlX2V4cHJlc3Npb24gKi9cbmNhc2UgMTA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IHJlYWRfZXhwcmVzc2lvbiAqL1xuY2FzZSAxMDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogZnVuY3Rpb25fZXhwcmVzc2lvbiAqL1xuY2FzZSAxMTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uX2dyb3VwICovXG5jYXNlIDEyMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl90YXJnZXQgOiBpZGVudGlmaWVyICovXG5jYXNlIDEyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl90YXJnZXQgOiBjb250ZXh0X3Byb3BlcnR5ICovXG5jYXNlIDE1NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb24gOiByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwICovXG5jYXNlIDE3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnMgOiBxdWFsaWZpZWRfY29uc3RydWN0b3IgKi9cbmNhc2UgMTc2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29ucyA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE4MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGlkZW50aWZpZXIgOiBxdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxODE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZGVudGlmaWVyIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxODU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3IgOiBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgKi9cbmNhc2UgMTg3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X3N0YXRlbWVudF9vcHRpb24gOiBcIjtcIiAqL1xuY2FzZSAxODg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cCA6IG1lbWJlciAqL1xuY2FzZSAxODk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cCA6IGFsaWFzZWRfbWVtYmVyICovXG5jYXNlIDE5MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9saXN0X2dyb3VwMiA6IG1lbWJlciAqL1xuY2FzZSAxOTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cDIgOiBhbGlhc2VkX21lbWJlciAqL1xuY2FzZSAxOTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZ3JvdXAgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE5MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9ncm91cCA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE5NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uIDogdW5xdWFsaWZpZWRfY29uc3RydWN0b3IgKi9cbmNhc2UgMTk3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24yIDogdHlwZV9jbGFzc2VzICovXG5jYXNlIDE5OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uMyA6IHBhcmFtZXRlcnMgKi9cbmNhc2UgMjAxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnRfb3B0aW9uIDogdHlwZV9jbGFzc2VzICovXG5jYXNlIDIwMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfc3RhdGVtZW50X29wdGlvbjIgOiBwYXJhbWV0ZXJzICovXG5jYXNlIDIwNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfb3B0aW9uIDogdHlwZV9jbGFzc2VzICovXG5jYXNlIDIwNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogdGFnICovXG5jYXNlIDIwNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogaW50ZXJwb2xhdGlvbiAqL1xuY2FzZSAyMDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGNvbnRyb2wgKi9cbmNhc2UgMjA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiBjaGFyYWN0ZXJzICovXG5jYXNlIDIxMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogaWRlbnRpZmllciAqL1xuY2FzZSAyMTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbiA6IGNoaWxkcmVuICovXG5jYXNlIDIxNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGVfb3B0aW9uMiA6IGNoaWxkcmVuICovXG5jYXNlIDIxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldF9vcHRpb24gOiBjaGlsZHJlbiAqL1xuY2FzZSAyMTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uMiA6IGNoaWxkcmVuICovXG5jYXNlIDIxOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZV92YWx1ZV9ncm91cCA6IGludGVycG9sYXRpb24gKi9cbmNhc2UgMjIwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlX3ZhbHVlX2dyb3VwIDogbGl0ZXJhbCAqL1xuY2FzZSAyMjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250cm9sX2dyb3VwIDogZm9yX3N0YXRlbWVudCAqL1xuY2FzZSAyMjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250cm9sX2dyb3VwIDogaWZfc3RhdGVtZW50ICovXG5jYXNlIDIyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogdmlld19jb25zdHJ1Y3Rpb24gKi9cbmNhc2UgMjI0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBmdW5fYXBwbGljYXRpb24gKi9cbmNhc2UgMjI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb25zdHJ1Y3RfZXhwcmVzc2lvbiAqL1xuY2FzZSAyMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGNhbGxfZXhwcmVzc2lvbiAqL1xuY2FzZSAyMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IG1lbWJlcl9leHByZXNzaW9uICovXG5jYXNlIDIyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogbGl0ZXJhbCAqL1xuY2FzZSAyMjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnRleHRfcHJvcGVydHkgKi9cbmNhc2UgMjMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb25zICovXG5jYXNlIDIzMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogaWRlbnRpZmllciAqL1xuY2FzZSAyMzI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnRleHRfdmFyaWFibGUgKi9cbmNhc2UgMjMzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IHN0cmluZ19saXRlcmFsICovXG5jYXNlIDIzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXAgOiBtZW1iZXJfZXhwcmVzc2lvbiAqL1xuY2FzZSAyMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwIDogY29udGV4dF9wcm9wZXJ0eSAqL1xuY2FzZSAyMzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwIDogY2FsbF9leHByZXNzaW9uICovXG5jYXNlIDIzNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiByZWNvcmQgKi9cbmNhc2UgMjM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IGxpc3QgKi9cbmNhc2UgMjM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IHN0cmluZ19saXRlcmFsICovXG5jYXNlIDI0MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBudW1iZXJfbGl0ZXJhbCAqL1xuY2FzZSAyNDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogYm9vbGVhbl9saXRlcmFsICovXG5jYXNlIDI0MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnR5X2dyb3VwIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAyNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0eV9ncm91cCA6IHN0cmluZ19saXRlcmFsICovXG5jYXNlIDI0NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPlwiICovXG5jYXNlIDI0NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPj1cIiAqL1xuY2FzZSAyNDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIjxcIiAqL1xuY2FzZSAyNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIjw9XCIgKi9cbmNhc2UgMjQ4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI9PVwiICovXG5jYXNlIDI0OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiIT1cIiAqL1xuY2FzZSAyNTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIitcIiAqL1xuY2FzZSAyNTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIi9cIiAqL1xuY2FzZSAyNTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIi1cIiAqL1xuY2FzZSAyNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj1cIiAqL1xuY2FzZSAyNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIiYmXCIgKi9cbmNhc2UgMjU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCJ8fFwiICovXG5jYXNlIDI1NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiXlwiICovXG5jYXNlIDI1NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IElOU1RBTkNFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3BdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDI3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwb3J0X3N0YXRlbWVudCA6IFwieyVcIiBFWFBPUlQgY29tcG9zaXRlX21lbWJlciBGUk9NIHN0cmluZ19saXRlcmFsIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkV4cG9ydFN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudCA6IFwieyVcIiBWSUVXIHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yIHZpZXdfc3RhdGVtZW50X29wdGlvbiBcIihcIiB0eXBlIFwiKVwiIHZpZXdfc3RhdGVtZW50X29wdGlvbjIgXCIlfVwiIHRhZyBcInslXCIgRU5EVklFVyBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVmlld1N0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTBdLCB5eXZzdGFja1t5eXNwIC0gOV18fFtdLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XXx8W10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBjb250ZXh0X3R5cGUgcGFyYW1ldGVycyBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEwLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA4XSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIGNvbnRleHRfdHlwZSBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDksIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBwYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA2XSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCBudWxsLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgW10sIHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBjb250ZXh0X3R5cGUgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSwgW10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHBhcmFtZXRlcnMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSxbXSxudWxsLHl5dnN0YWNrW3l5c3AgLSA1XSx5eXZzdGFja1t5eXNwIC0gM10sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNV0sW10sbnVsbCxbXSx5eXZzdGFja1t5eXNwIC0gM10sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBjb250ZXh0X3R5cGUgcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDgsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDRdLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gM10sIG51bGwsIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBjb250ZXh0X3R5cGUgcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGNvbnRleHRfdHlwZSBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDRdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgcGFyYW1ldGVycyBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDRdLFtdLG51bGwseXl2c3RhY2tbeXlzcCAtIDNdLHl5dnN0YWNrW3l5c3AgLSAxXSx0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSxbXSxudWxsLFtdLHl5dnN0YWNrW3l5c3AgLSAxXSx0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfdHlwZSA6IFwiKFwiIHR5cGUgXCIpXCIgKi9cbmNhc2UgNDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzZXMgOiBcIltcIiB0eXBlX2NsYXNzX2xpc3QgXCJdXCIgKi9cbmNhc2UgNTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJzIDogXCIoXCIgcGFyYW1ldGVyX2xpc3QgXCIpXCIgKi9cbmNhc2UgOTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudHMgOiBcIihcIiBhcmd1bWVudF9saXN0IFwiKVwiICovXG5jYXNlIDEwODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5jYXNlIDEyNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl90YXJnZXQgOiBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5jYXNlIDEyNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJndW1lbnRzIDogXCJbXCIgdHlwZV9hcmdfbGlzdCBcIl1cIiAqL1xuY2FzZSAxNTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcCAtIDFdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzcyA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgNTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfY29uc3RydWN0b3IgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlQ2xhc3MoeXl2c3RhY2tbeXlzcF0sIG51bGwsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDUwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzcyA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI6XCIgdHlwZSAqL1xuY2FzZSA1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3MgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciBcIjpcIiB0eXBlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZUNsYXNzKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZSA6IGNvbnMgdHlwZV9vcHRpb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlKHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF18fFtdLCBmYWxzZSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlIDogY29ucyB0eXBlX2NsYXNzZXMgXCJbXCIgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB0cnVlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGUgOiBjb25zIFwiW1wiIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZSh5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB0cnVlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHBhcmFtZXRlcnMgOiBcIihcIiBcIilcIiAqL1xuY2FzZSA5ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFyZ3VtZW50cyA6IFwiKFwiIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBbXTtcbiAgICBicmVhaztcblxuY2FzZSA2MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHBhcmFtZXRlciA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI6XCIgdHlwZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGVkUGFyYW1ldGVyKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDYxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVudHlwZWRQYXJhbWV0ZXIoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDY3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZSA6IFwiPFwiIGlkZW50aWZpZXIgYXR0cmlidXRlcyBcIj5cIiBub2RlX29wdGlvbiBcIjwvXCIgaWRlbnRpZmllciBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk5vZGUoeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBcIj5cIiBub2RlX29wdGlvbjIgXCI8L1wiIGlkZW50aWZpZXIgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Ob2RlKHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBhdHRyaWJ1dGVzIFwiLz5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk5vZGUoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDcwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZSA6IFwiPFwiIGlkZW50aWZpZXIgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gMV0sIFtdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldCA6IFwiPFwiIGNvbnMgYXR0cmlidXRlcyBcIj5cIiB3aWRnZXRfb3B0aW9uIFwiPC9cIiBjb25zIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM118fFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0IDogXCI8XCIgY29ucyBcIj5cIiB3aWRnZXRfb3B0aW9uMiBcIjwvXCIgY29ucyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LldpZGdldCh5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM118fFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDczOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0IDogXCI8XCIgY29ucyBhdHRyaWJ1dGVzIFwiLz5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LldpZGdldCh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIFwiLz5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LldpZGdldCh5eXZzdGFja1t5eXNwIC0gMV0sIFtdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZSA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI6XCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIj1cIiBhdHRyaWJ1dGVfdmFsdWUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5BdHRyaWJ1dGUoeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZSA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI9XCIgYXR0cmlidXRlX3ZhbHVlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5BdHRyaWJ1dGUobmV3IHl5LmFzdC5VbnF1YWxpZmllZElkZW50aWZpZXIoJ2h0bWwnLCB0aGlzLl8kKSxcbiAgICB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZSA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgXCI6XCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkF0dHJpYnV0ZSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKHRydWUsIHRoaXMuXyQpLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA4MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZSA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5BdHRyaWJ1dGUoXG4gICAgbmV3IHl5LmFzdC5VbnF1YWxpZmllZElkZW50aWZpZXIoJ2h0bWwnLCB0aGlzLl8kKSxcbiAgICB5eXZzdGFja1t5eXNwXSwgbmV3IHl5LmFzdC5Cb29sZWFuTGl0ZXJhbCh0cnVlLCB0aGlzLl8kKSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbnRlcnBvbGF0aW9uIDogXCJ7e1wiIGV4cHJlc3Npb24gXCJ9fVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSW50ZXJwb2xhdGlvbih5eXZzdGFja1t5eXNwIC0gMV0sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGludGVycG9sYXRpb24gOiBcInt7XCIgZXhwcmVzc2lvbiBmaWx0ZXJzIFwifX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkludGVycG9sYXRpb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDg2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZmlsdGVyIDogXCJ8XCIgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcF1cbiAgICBicmVhaztcblxuY2FzZSA4ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gN10sIG51bGwsIG51bGwsIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTFdLCB5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgT1RIRVJXSVNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDExXSwgbnVsbCwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBPVEhFUldJU0UgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTNdLCB5eXZzdGFja1t5eXNwIC0gMTFdLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBPVEhFUldJU0UgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZvclN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gMTVdLCB5eXZzdGFja1t5eXNwIC0gMTNdLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gMTFdLCB5eXZzdGFja1t5eXNwIC0gOV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZl9zdGF0ZW1lbnQgOiBcInslXCIgSUYgZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gZWxzZV9jbGF1c2UgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JZlN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZWxzZV9jbGF1c2UgOiBcInslXCIgRUxTRSBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVORElGIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkVsc2VDbGF1c2UoeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGVsc2VfY2xhdXNlIDogXCJ7JVwiIEVMU0UgSUYgZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gZWxzZV9jbGF1c2UgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDYsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5FbHNlSWZDbGF1c2UoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoYXJhY3RlcnMgOiBDSEFSQUNURVJTICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ2hhcmFjdGVycyh5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTA0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IHVuYXJ5X2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9eXl2c3RhY2tbeXlzcF07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaWZfZXhwcmVzc2lvbiA6IElGIGV4cHJlc3Npb24gVEhFTiBleHByZXNzaW9uIEVMU0UgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LklmVGhlbkV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uIGJpbmFyeV9vcGVyYXRvciBzaW1wbGVfZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJpbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uIGJpbmFyeV9vcGVyYXRvciBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgYmluYXJ5X29wZXJhdG9yIHNpbXBsZV9leHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBiaW5hcnlfb3BlcmF0b3IgXCIoXCIgZXhwcmVzc2lvbiBcIilcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJpbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5hcnlfZXhwcmVzc2lvbiA6IFwiIVwiIHNpbXBsZV9leHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVuYXJ5X2V4cHJlc3Npb24gOiBcIiFcIiBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X2NvbnN0cnVjdGlvbiA6IFwiPFwiIGNvbnMgYXJndW1lbnRzIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVmlld0NvbnN0cnVjdGlvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX2FwcGxpY2F0aW9uIDogXCI8XCIgZnVuX3RhcmdldCB0eXBlX2FyZ3VtZW50cyBhcmd1bWVudHMgYXJndW1lbnRzIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuQXBwbGljYXRpb24oeXl2c3RhY2tbeXlzcCAtIDRdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IGFyZ3VtZW50cyBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5BcHBsaWNhdGlvbih5eXZzdGFja1t5eXNwIC0gM10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX2FwcGxpY2F0aW9uIDogXCI8XCIgZnVuX3RhcmdldCBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5BcHBsaWNhdGlvbih5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb25zdHJ1Y3RfZXhwcmVzc2lvbiA6IGNvbnMgYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29uc3RydWN0RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuY2FzZSAxMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuY2FzZSAxMzM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiB0eXBlX2FyZ3VtZW50cyBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DYWxsRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgYXJndW1lbnRzICovXG5jYXNlIDEzMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgYXJndW1lbnRzICovXG5jYXNlIDEzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTM2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DYWxsRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTM3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBxdWFsaWZpZWRfaWRlbnRpZmllciBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDEzODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogcXVhbGlmaWVkX2NvbnN0cnVjdG9yIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjb250ZXh0X3ZhcmlhYmxlIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBsaXN0IFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiByZWNvcmQgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHN0cmluZ19saXRlcmFsIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTQ0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBjYWxsX2V4cHJlc3Npb24gXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5NZW1iZXJFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE0NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTWVtYmVyRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNDk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3ZhcmlhYmxlIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuY2FzZSAxNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWFkRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBpZGVudGlmaWVyIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5jYXNlIDE1MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiP1wiIGV4cHJlc3Npb24gXCJdXCIgKi9cbmNhc2UgMTUyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogY29udGV4dF9wcm9wZXJ0eSBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuY2FzZSAxNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBtZW1iZXJfZXhwcmVzc2lvbiBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIltcIiBleHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBcIltcIiBleHByZXNzaW9uIEFTIHR5cGUgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWFkRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBudWxsLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5jdGlvbl9leHByZXNzaW9uIDogXCJcXFxcXCIgcGFyYW1ldGVyX2xpc3QgXCI9PlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5jdGlvbkV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTYwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuY3Rpb25fZXhwcmVzc2lvbiA6IFwiPT5cIiBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuY3Rpb25FeHByZXNzaW9uKFtdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTYyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVjb3JkIDogXCJ7XCIgXCJ9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWNvcmQoW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlY29yZCA6IFwie1wiIHByb3BlcnRpZXMgXCJ9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5SZWNvcmQoeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0eSA6IHByb3BlcnR5X2dyb3VwIFwiOlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Qcm9wZXJ0eSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXN0IDogXCJbXCIgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5MaXN0KFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXN0IDogXCJbXCIgYXJndW1lbnRfbGlzdCBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lkxpc3QoeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzdHJpbmdfbGl0ZXJhbCA6IFNUUklOR19MSVRFUkFMICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuU3RyaW5nTGl0ZXJhbCh5eXZzdGFja1t5eXNwXS5zbGljZSgxLCB5eXZzdGFja1t5eXNwXS5sZW5ndGggLSAxLCB0aGlzLl8kKSk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTcwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbnVtYmVyX2xpdGVyYWwgOiBOVU1CRVJfTElURVJBTCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk51bWJlckxpdGVyYWwoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJvb2xlYW5fbGl0ZXJhbCA6IFRSVUUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Cb29sZWFuTGl0ZXJhbCh0cnVlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBib29sZWFuX2xpdGVyYWwgOiBGQUxTRSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKGZhbHNlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3Byb3BlcnR5IDogXCJAXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbnRleHRQcm9wZXJ0eSh5eXZzdGFja1t5eXNwXSwgdGhpcy5fJClcbiAgICBicmVhaztcblxuY2FzZSAxNzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3ZhcmlhYmxlIDogXCJAXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Db250ZXh0VmFyaWFibGUodGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTc3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcXVhbGlmaWVkX2NvbnN0cnVjdG9yIDogSURFTlRJRklFUiBcIi5cIiBDT05TVFJVQ1RPUiAqL1xuY2FzZSAxNzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfY29uc3RydWN0b3IgOiBDT05TVFJVQ1RPUiBcIi5cIiBDT05TVFJVQ1RPUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlF1YWxpZmllZENvbnN0cnVjdG9yKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yIDogQ09OU1RSVUNUT1IgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbnF1YWxpZmllZENvbnN0cnVjdG9yKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfaWRlbnRpZmllciA6IElERU5USUZJRVIgXCIuXCIgSURFTlRJRklFUiAqL1xuY2FzZSAxODM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfaWRlbnRpZmllciA6IENPTlNUUlVDVE9SIFwiLlwiIElERU5USUZJRVIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5RdWFsaWZpZWRJZGVudGlmaWVyKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgOiBJREVOVElGSUVSICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW5xdWFsaWZpZWRJZGVudGlmaWVyKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxODY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfc3RhdGVtZW50X29wdGlvbiA6ICVlcHNpbG9uICovXG5jYXNlIDE5NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMTk2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24yIDogJWVwc2lsb24gKi9cbmNhc2UgMTk4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24zIDogJWVwc2lsb24gKi9cbmNhc2UgMjAwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjAyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnRfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5jYXNlIDIwNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZV9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMjE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0X29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHRydWUpO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB1bmRlZmluZWQ7XG4gICAgYnJlYWs7XG5cbn1cbn0sXG50YWJsZTogYnQoe1xuICBsZW46IHUoW1xuICAxNSxcbiAgMSxcbiAgMTQsXG4gIDExLFxuICAxLFxuICAwLFxuICAwLFxuICA0LFxuICAwLFxuICAxMixcbiAgcyxcbiAgWzAsIDVdLFxuICA4LFxuICBjLFxuICBbMTMsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIDAsXG4gIDUsXG4gIHMsXG4gIFsyLCAzXSxcbiAgYyxcbiAgWzgsIDRdLFxuICAxLFxuICAxLFxuICA5LFxuICBzLFxuICBbMCwgNV0sXG4gIDYsXG4gIDYsXG4gIHMsXG4gIFswLCA0XSxcbiAgMjksXG4gIDI5LFxuICBjLFxuICBbMjAsIDRdLFxuICA0LFxuICAwLFxuICAxLFxuICA0LFxuICA3LFxuICAyLFxuICA2LFxuICA2LFxuICAyLFxuICAwLFxuICAzLFxuICAwLFxuICA1LFxuICAyMyxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgYyxcbiAgWzUsIDNdLFxuICAyLFxuICAyLFxuICBjLFxuICBbNTUsIDNdLFxuICA2LFxuICBjLFxuICBbNTEsIDNdLFxuICA1LFxuICA0LFxuICAyLFxuICAyMSxcbiAgMjAsXG4gIDEwLFxuICBjLFxuICBbNDYsIDVdLFxuICA4LFxuICBjLFxuICBbMjgsIDNdLFxuICAxLFxuICAyMSxcbiAgcyxcbiAgWzAsIDddLFxuICA0MyxcbiAgcyxcbiAgWzAsIDRdLFxuICAxMCxcbiAgMSxcbiAgMixcbiAgMixcbiAgMTcsXG4gIDIzLFxuICBjLFxuICBbMjEsIDddLFxuICBjLFxuICBbNjQsIDRdLFxuICAzLFxuICAxLFxuICA2LFxuICBjLFxuICBbNDgsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIDUsXG4gIDIxLFxuICAyMCxcbiAgMjAsXG4gIDEsXG4gIDEsXG4gIDAsXG4gIDIsXG4gIDksXG4gIGMsXG4gIFs2NiwgM10sXG4gIGMsXG4gIFsxMTUsIDRdLFxuICAzLFxuICBjLFxuICBbMzgsIDNdLFxuICA1LFxuICBjLFxuICBbMTA3LCAzXSxcbiAgMCxcbiAgMCxcbiAgMjYsXG4gIGMsXG4gIFs2MSwgM10sXG4gIDQzLFxuICAzMyxcbiAgMCxcbiAgMjgsXG4gIDI2LFxuICAyOSxcbiAgMjksXG4gIDQsXG4gIGMsXG4gIFs3MCwgNF0sXG4gIDI1LFxuICAwLFxuICAyNixcbiAgMjcsXG4gIDI4LFxuICAyNyxcbiAgcyxcbiAgWzI1LCAzXSxcbiAgMTIsXG4gIDAsXG4gIDQ1LFxuICA4LFxuICBzLFxuICBbMCwgNV0sXG4gIDEsXG4gIDEsXG4gIDMsXG4gIDQzLFxuICBjLFxuICBbNDIsIDRdLFxuICBjLFxuICBbMTIsIDVdLFxuICAyMSxcbiAgNSxcbiAgYyxcbiAgWzcxLCAzXSxcbiAgNSxcbiAgYyxcbiAgWzE3NiwgM10sXG4gIDEsXG4gIGMsXG4gIFs4NiwgM10sXG4gIGMsXG4gIFs4NSwgNF0sXG4gIGMsXG4gIFs0LCA0XSxcbiAgMjAsXG4gIDEsXG4gIDMsXG4gIGMsXG4gIFs4NCwgNV0sXG4gIDcsXG4gIDcsXG4gIDYsXG4gIDEsXG4gIDEsXG4gIDUsXG4gIDEsXG4gIGMsXG4gIFsxMCwgM10sXG4gIGMsXG4gIFs4MiwgM10sXG4gIHMsXG4gIFswLCAxNF0sXG4gIGMsXG4gIFs1NCwgM10sXG4gIDQzLFxuICAxNSxcbiAgMTUsXG4gIDE0LFxuICAxMSxcbiAgMjQsXG4gIDIsXG4gIDAsXG4gIDQ1LFxuICAyMCxcbiAgMixcbiAgMjQsXG4gIGMsXG4gIFsyMDksIDNdLFxuICBjLFxuICBbNCwgNF0sXG4gIDIsXG4gIDAsXG4gIGMsXG4gIFs0LCA1XSxcbiAgcyxcbiAgWzIsIDRdLFxuICBjLFxuICBbOTgsIDNdLFxuICA0MyxcbiAgYyxcbiAgWzEzLCA0XSxcbiAgYyxcbiAgWzMsIDNdLFxuICBjLFxuICBbMjYyLCAzXSxcbiAgMixcbiAgMSxcbiAgMTcsXG4gIDUsXG4gIDEsXG4gIGMsXG4gIFsxMTcsIDRdLFxuICA0LFxuICBjLFxuICBbOTYsIDhdLFxuICBjLFxuICBbNCwgNF0sXG4gIGMsXG4gIFsxODIsIDNdLFxuICBjLFxuICBbMjksIDRdLFxuICBjLFxuICBbMjk0LCA0XSxcbiAgYyxcbiAgWzQ2LCAzXSxcbiAgMzEsXG4gIDQzLFxuICAxLFxuICA3LFxuICAxLFxuICAyLFxuICBjLFxuICBbMjUxLCAzXSxcbiAgYyxcbiAgWzMwMSwgNF0sXG4gIHMsXG4gIFsxLCAzXSxcbiAgYyxcbiAgWzQ3LCAzXSxcbiAgYyxcbiAgWzcsIDRdLFxuICBjLFxuICBbMzQsIDddLFxuICBjLFxuICBbMjc0LCA1XSxcbiAgYyxcbiAgWzEwLCAzXSxcbiAgMixcbiAgMyxcbiAgYyxcbiAgWzEyMiwgM10sXG4gIDAsXG4gIDYsXG4gIDQzLFxuICA0MyxcbiAgMyxcbiAgMjEsXG4gIGMsXG4gIFs2MiwgNV0sXG4gIDEsXG4gIGMsXG4gIFs3NCwgOF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgYyxcbiAgWzM4NywgNV0sXG4gIDMzLFxuICA0NSxcbiAgYyxcbiAgWzM1MCwgNF0sXG4gIDE1LFxuICA2LFxuICAwLFxuICA2LFxuICBjLFxuICBbMzU1LCAzXSxcbiAgYyxcbiAgWzM5MywgNF0sXG4gIGMsXG4gIFs0OSwgM10sXG4gIGMsXG4gIFs1OCwgNl0sXG4gIDIxLFxuICAwLFxuICA0LFxuICA0LFxuICBjLFxuICBbMzgsIDVdLFxuICBjLFxuICBbMTcsIDNdLFxuICAxNSxcbiAgMCxcbiAgNDMsXG4gIDEsXG4gIDIyLFxuICBjLFxuICBbMTYzLCA1XSxcbiAgNixcbiAgYyxcbiAgWzQ0NCwgNl0sXG4gIDIxLFxuICA0MyxcbiAgYyxcbiAgWzcwLCA1XSxcbiAgYyxcbiAgWzY3LCA1XSxcbiAgYyxcbiAgWzUzLCAzXSxcbiAgNDMsXG4gIGMsXG4gIFsxMDEsIDNdLFxuICBjLFxuICBbNCwgNF0sXG4gIGMsXG4gIFszNTgsIDNdLFxuICBjLFxuICBbMzAsIDNdLFxuICAxNSxcbiAgYyxcbiAgWzEzNywgNF0sXG4gIDEsXG4gIDQsXG4gIDIxLFxuICA0MyxcbiAgMjEsXG4gIDQzLFxuICAxLFxuICBjLFxuICBbMTM3LCA2XSxcbiAgMSxcbiAgYyxcbiAgWzE5NywgM10sXG4gIDIwLFxuICBjLFxuICBbNzQsIDRdLFxuICAyMSxcbiAgNCxcbiAgMjEsXG4gIGMsXG4gIFsxMzgsIDNdLFxuICBjLFxuICBbMzksIDNdLFxuICBjLFxuICBbMzE1LCAzXSxcbiAgMyxcbiAgYyxcbiAgWzE0LCAzXSxcbiAgYyxcbiAgWzI3LCAzXSxcbiAgYyxcbiAgWzQxMCwgNF0sXG4gIGMsXG4gIFsxMSwgM10sXG4gIDEsXG4gIDIwLFxuICBjLFxuICBbMTIzLCA0XVxuXSksXG4gIHN5bWJvbDogdShbXG4gIDEzLFxuICAyNSxcbiAgMjgsXG4gIDY0LFxuICA2NSxcbiAgNjYsXG4gIHMsXG4gIFs3MywgNiwgMV0sXG4gIDg5LFxuICA5MCxcbiAgOTEsXG4gIDEsXG4gIDEsXG4gIGMsXG4gIFsxNywgM10sXG4gIGMsXG4gIFsxNSwgMTFdLFxuICAxMyxcbiAgMjgsXG4gIDczLFxuICBjLFxuICBbMTEsIDhdLFxuICAyOSxcbiAgMzEsXG4gIDMyLFxuICAzNCxcbiAgMyxcbiAgNCxcbiAgNTUsXG4gIDU2LFxuICBzLFxuICBbNjcsIDQsIDFdLFxuICA3MixcbiAgMTMzLFxuICAxMzYsXG4gIDE0MSxcbiAgNTUsXG4gIDU2LFxuICBzLFxuICBbMTMxLCA2LCAxXSxcbiAgYyxcbiAgWzM2LCAxMl0sXG4gIDEsXG4gIDcsXG4gIDEwLFxuICA1NixcbiAgMTMzLFxuICAxNDIsXG4gIDQsXG4gIDcwLFxuICA1NixcbiAgMTMzLFxuICA1NSxcbiAgMTM2LFxuICAyNixcbiAgMjcsXG4gIDI3LFxuICA1NSxcbiAgNTYsXG4gIDY4LFxuICA3MSxcbiAgYyxcbiAgWzQzLCAzXSxcbiAgMTM5LFxuICAxNDEsXG4gIDE0LFxuICAzNyxcbiAgNTUsXG4gIDkyLFxuICA5MyxcbiAgMTM2LFxuICBjLFxuICBbNiwgNl0sXG4gIHMsXG4gIFs1LCA3LCAxXSxcbiAgMTMsXG4gIDE0LFxuICAxNSxcbiAgMTcsXG4gIHMsXG4gIFsyMSwgNCwgMV0sXG4gIDI3LFxuICAzMCxcbiAgMzcsXG4gIDM5LFxuICA0NSxcbiAgNDgsXG4gIDU1LFxuICBzLFxuICBbNTcsIDcsIDFdLFxuICBjLFxuICBbMjksIDI5XSxcbiAgYyxcbiAgWzk0LCAzXSxcbiAgODAsXG4gIDE0MyxcbiAgMjYsXG4gIGMsXG4gIFs1LCAzXSxcbiAgMTQ1LFxuICA3LFxuICA5LFxuICAxMCxcbiAgMzAsXG4gIDc5LFxuICA4MCxcbiAgODQsXG4gIDUxLFxuICAxMjYsXG4gIDU1LFxuICA1NixcbiAgYyxcbiAgWzEzOSwgNl0sXG4gIGMsXG4gIFs2LCA0XSxcbiAgNSxcbiAgNixcbiAgNSxcbiAgNixcbiAgMjcsXG4gIGMsXG4gIFsxMDAsIDNdLFxuICA5MyxcbiAgMTM2LFxuICAxMyxcbiAgMjgsXG4gIDM2LFxuICAzOCxcbiAgNDcsXG4gIDU1LFxuICA1NixcbiAgcyxcbiAgWzg3LCA1LCAxXSxcbiAgOTUsXG4gIDk4LFxuICA5OSxcbiAgMTAwLFxuICAxMDIsXG4gIGMsXG4gIFsxNjcsIDNdLFxuICAxNDgsXG4gIDE1MCxcbiAgMTU0LFxuICA5LFxuICAxMixcbiAgYyxcbiAgWzMwLCAzXSxcbiAgYyxcbiAgWzMzLCAyNl0sXG4gIDE1MixcbiAgMTU0LFxuICA1NSxcbiAgNTYsXG4gIDU1LFxuICA1NixcbiAgNyxcbiAgNTUsXG4gIDU2LFxuICA4MSxcbiAgODIsXG4gIDEzMyxcbiAgMTM2LFxuICA1MSxcbiAgMTI2LFxuICA3LFxuICA3LFxuICA5LFxuICAzMCxcbiAgNzksXG4gIDg0LFxuICBjLFxuICBbNSwgM10sXG4gIDg0LFxuICA5LFxuICAzMCxcbiAgMTMsXG4gIDI4LFxuICBjLFxuICBbNDcsIDE4XSxcbiAgMTU0LFxuICBjLFxuICBbMjEsIDZdLFxuICBjLFxuICBbMjAsIDE0XSxcbiAgOCxcbiAgNTUsXG4gIDU2LFxuICA4MyxcbiAgODUsXG4gIDg2LFxuICBjLFxuICBbMjgxLCAzXSxcbiAgYyxcbiAgWzI3OSwgM10sXG4gIDIwLFxuICAyNSxcbiAgMjgsXG4gIDEzOCxcbiAgYyxcbiAgWzI1OCwgM10sXG4gIGMsXG4gIFsxNTUsIDNdLFxuICAxNDAsXG4gIDE0MSxcbiAgYyxcbiAgWzExMywgMjFdLFxuICAxNDksXG4gIDE1NCxcbiAgMzYsXG4gIGMsXG4gIFsyNCwgN10sXG4gIGMsXG4gIFs2OSwgMTRdLFxuICBzLFxuICBbNCwgNiwgM10sXG4gIDQ0LFxuICBzLFxuICBbNDksIDgsIDFdLFxuICBzLFxuICBbMTA1LCA3LCAxXSxcbiAgcyxcbiAgWzExNSwgNCwgMV0sXG4gIDEyMCxcbiAgMTIxLFxuICAxMjIsXG4gIHMsXG4gIFsxMjUsIDEyLCAxXSxcbiAgMTU1LFxuICAxNTcsXG4gIDEzLFxuICAxNCxcbiAgMTcsXG4gIDI4LFxuICAzMCxcbiAgYyxcbiAgWzY3LCA1XSxcbiAgMTcsXG4gIDQwLFxuICA0NCxcbiAgNTUsXG4gIDEzNixcbiAgNCxcbiAgMTAsXG4gIDM4LFxuICBjLFxuICBbNTIsIDRdLFxuICA5NCxcbiAgOTUsXG4gIGMsXG4gIFs0MCwgNl0sXG4gIDE1MyxcbiAgMTU3LFxuICBjLFxuICBbMTIwLCAyMV0sXG4gIDE1MSxcbiAgYyxcbiAgWzEyMCwgMjNdLFxuICBjLFxuICBbMTg4LCAzXSxcbiAgYyxcbiAgWzg4LCAzXSxcbiAgNixcbiAgMTEsXG4gIDYsXG4gIDExLFxuICAxMixcbiAgYyxcbiAgWzMsIDNdLFxuICAzMCxcbiAgYyxcbiAgWzE1LCA2XSxcbiAgYyxcbiAgWzI1NywgNDddLFxuICBjLFxuICBbMzAwLCA0NV0sXG4gIDg1LFxuICA4NixcbiAgYyxcbiAgWzM5NCwgM10sXG4gIGMsXG4gIFs0NiwgMzldLFxuICBjLFxuICBbMjAsIDIwXSxcbiAgMzAsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDEwLFxuICAxMSxcbiAgMTgsXG4gIDQxLFxuICA1MCxcbiAgODAsXG4gIDE0NyxcbiAgNixcbiAgOCxcbiAgMTIsXG4gIDQxLFxuICA1MCxcbiAgYyxcbiAgWzUsIDNdLFxuICAxNyxcbiAgYyxcbiAgWzE4LCA0XSxcbiAgMTQsXG4gIDE3LFxuICBjLFxuICBbMjAsIDNdLFxuICBjLFxuICBbNTI3LCAzXSxcbiAgYyxcbiAgWzIzMywgMjRdLFxuICBjLFxuICBbNywgM10sXG4gIDE1LFxuICAzOSxcbiAgOTYsXG4gIDk3LFxuICA1LFxuICA2LFxuICA4LFxuICA5LFxuICBjLFxuICBbNjIxLCA0XSxcbiAgYyxcbiAgWzYyMCwgNl0sXG4gIGMsXG4gIFs2MTksIDNdLFxuICBjLFxuICBbNjE4LCA3XSxcbiAgMTM3LFxuICAxNTksXG4gIGMsXG4gIFszODgsIDQzXSxcbiAgYyxcbiAgWzQzLCA0N10sXG4gIDE5LFxuICBjLFxuICBbMzksIDZdLFxuICBjLFxuICBbMzUsIDZdLFxuICBjLFxuICBbMzMsIDE2XSxcbiAgYyxcbiAgWzc2OCwgMTBdLFxuICBjLFxuICBbMTQ3LCAxNl0sXG4gIDEwMyxcbiAgMTEzLFxuICBjLFxuICBbMTczLCA0XSxcbiAgYyxcbiAgWzc5NSwgMTJdLFxuICBjLFxuICBbMjgsIDEwXSxcbiAgYyxcbiAgWzgyMiwgMTddLFxuICBjLFxuICBbNTUsIDE0XSxcbiAgYyxcbiAgWzI5LCAyN10sXG4gIGMsXG4gIFszODcsIDRdLFxuICBjLFxuICBbMTkyLCA0M10sXG4gIGMsXG4gIFszMDQsIDhdLFxuICBjLFxuICBbMTMwLCAyMl0sXG4gIGMsXG4gIFsxODMsIDIxXSxcbiAgYyxcbiAgWzEyNywgMjddLFxuICBjLFxuICBbMjA5LCAxOV0sXG4gIGMsXG4gIFsxMDAzLCA4XSxcbiAgYyxcbiAgWzEwNjIsIDE4XSxcbiAgYyxcbiAgWzU1LCAxNF0sXG4gIGMsXG4gIFsyNSwgNzFdLFxuICA3LFxuICAxOSxcbiAgNTUsXG4gIDU2LFxuICAxMTIsXG4gIDEyOSxcbiAgYyxcbiAgWzIyMiwgNl0sXG4gIGMsXG4gIFsyNjMsIDNdLFxuICAxMSxcbiAgYyxcbiAgWzI2NCwgMTJdLFxuICBzLFxuICBbMTA0LCA4LCAxXSxcbiAgYyxcbiAgWzI2NSwgMjJdLFxuICA1MSxcbiAgNTUsXG4gIDEyMyxcbiAgMTI0LFxuICAxMjYsXG4gIDEzNixcbiAgMTU4LFxuICBzLFxuICBbNTUsIDNdLFxuICBjLFxuICBbMzIxLCA0NV0sXG4gIDksXG4gIGMsXG4gIFsxMTUxLCAzXSxcbiAgYyxcbiAgWzY2MCwgMjRdLFxuICBjLFxuICBbMzYsIDNdLFxuICA4LFxuICAxNyxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTE0OSwgM10sXG4gIGMsXG4gIFs4OTAsIDZdLFxuICBjLFxuICBbNiwgNl0sXG4gIDgsXG4gIGMsXG4gIFs4NTAsIDQzXSxcbiAgYyxcbiAgWzg0NSwgNjJdLFxuICBjLFxuICBbNjIsIDY4XSxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDM1LFxuICBjLFxuICBbMTE3MywgM10sXG4gIDg2LFxuICAxMzYsXG4gIGMsXG4gIFs5MzEsIDddLFxuICAxMSxcbiAgYyxcbiAgWzEzNzAsIDZdLFxuICBjLFxuICBbMjE1LCA2XSxcbiAgNTYsXG4gIGMsXG4gIFsxMzg3LCAzXSxcbiAgYyxcbiAgWzM2LCAzXSxcbiAgMTQsXG4gIDE1LFxuICAzOSxcbiAgOTcsXG4gIGMsXG4gIFs4MzIsIDc2XSxcbiAgOCxcbiAgNDgsXG4gIGMsXG4gIFs3MTgsIDQ1XSxcbiAgNyxcbiAgYyxcbiAgWzE1NCwgM10sXG4gIDE1LFxuICAxNyxcbiAgYyxcbiAgWzUzMCwgNV0sXG4gIGMsXG4gIFs4MDksIDZdLFxuICBjLFxuICBbMTUsIDE4XSxcbiAgYyxcbiAgWzE0LCA5XSxcbiAgOCxcbiAgYyxcbiAgWzI3LCA4XSxcbiAgYyxcbiAgWzk4LCAzXSxcbiAgMTksXG4gIDUxLFxuICBjLFxuICBbMTk4LCAzXSxcbiAgMTE0LFxuICAxMTYsXG4gIDExNyxcbiAgMTE5LFxuICBjLFxuICBbODIsIDNdLFxuICBjLFxuICBbODAsIDhdLFxuICAxNTYsXG4gIDcsXG4gIDEwMyxcbiAgNCxcbiAgYyxcbiAgWzUwLCAzXSxcbiAgYyxcbiAgWzU3OSwgNDFdLFxuICBjLFxuICBbNzEsIDddLFxuICBjLFxuICBbNjksIDhdLFxuICAxMzIsXG4gIGMsXG4gIFs2NywgNF0sXG4gIGMsXG4gIFsxNDc0LCAzXSxcbiAgYyxcbiAgWzkzLCAyM10sXG4gIDU1LFxuICAxMzYsXG4gIGMsXG4gIFs5NSwgNF0sXG4gIGMsXG4gIFsyOCwgMjZdLFxuICA2LFxuICA1MCxcbiAgNTUsXG4gIDEzNixcbiAgNTUsXG4gIDEzNixcbiAgYyxcbiAgWzQsIDhdLFxuICA3LFxuICAxMDMsXG4gIDcsXG4gIDEwLFxuICAxMDMsXG4gIDExMyxcbiAgYyxcbiAgWzI2NywgNDNdLFxuICA1NSxcbiAgMTM2LFxuICA2LFxuICAxMSxcbiAgNSxcbiAgNixcbiAgMTIsXG4gIDYsXG4gIDQxLFxuICAzMCxcbiAgYyxcbiAgWzE2MDMsIDE3XSxcbiAgYyxcbiAgWzY2NSwgNV0sXG4gIDE0LFxuICA3LFxuICAzMCxcbiAgODQsXG4gIDE0NCxcbiAgYyxcbiAgWzQsIDNdLFxuICAxNDYsXG4gIGMsXG4gIFs1NDksIDg2XSxcbiAgYyxcbiAgWzI0LCAyNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgMzAsXG4gIDExLFxuICAxNCxcbiAgYyxcbiAgWzQ2NywgNDddLFxuICBjLFxuICBbMTI2MSwgMjVdLFxuICBjLFxuICBbMTQ5NCwgNDVdLFxuICBjLFxuICBbMTk5NCwgNF0sXG4gIDExNCxcbiAgYyxcbiAgWzEzLCAzXSxcbiAgMjcsXG4gIDYsXG4gIDExLFxuICBjLFxuICBbNTQsIDQzXSxcbiAgMTcsXG4gIDI3LFxuICA3LFxuICAxMCxcbiAgMTcsXG4gIDI3LFxuICAxMDMsXG4gIDExMyxcbiAgYyxcbiAgWzYsIDZdLFxuICAxNyxcbiAgMjcsXG4gIHMsXG4gIFsxNywgM10sXG4gIGMsXG4gIFszOTQsIDRdLFxuICA2LFxuICA4LFxuICBjLFxuICBbMTAsIDNdLFxuICAyNyxcbiAgMjcsXG4gIGMsXG4gIFs3MywgNDNdLFxuICAxNCxcbiAgYyxcbiAgWzQ1MSwgM10sXG4gIDE0LFxuICAxMDMsXG4gIDgsXG4gIGMsXG4gIFs1MCwgNDNdLFxuICA1MSxcbiAgNTUsXG4gIGMsXG4gIFsxMTY5LCA0XSxcbiAgYyxcbiAgWzE3MjAsIDg2XSxcbiAgYyxcbiAgWzk2NSwgM10sXG4gIGMsXG4gIFs1MDUsIDIxXSxcbiAgMTQsXG4gIDMwLFxuICBjLFxuICBbNDY3LCAyNV0sXG4gIGMsXG4gIFs0NDMsIDRdLFxuICBjLFxuICBbNCwgNF0sXG4gIDMwLFxuICBjLFxuICBbMTk2LCA1XSxcbiAgYyxcbiAgWzk0OSwgMjldLFxuICBjLFxuICBbMTM3LCAxNV0sXG4gIDgzLFxuICBjLFxuICBbMTM4LCA3XSxcbiAgcyxcbiAgWzExNCwgNSwgMV0sXG4gIGMsXG4gIFs2ODIsIDE5XSxcbiAgNyxcbiAgMTAzLFxuICA0NSxcbiAgYyxcbiAgWzkzOSwgMTVdLFxuICBjLFxuICBbMTMyOCwgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzIyNDMsIDddLFxuICAxNCxcbiAgMTAzLFxuICAxNCxcbiAgMzAsXG4gIDYsXG4gIDQxLFxuICBjLFxuICBbMTcwLCAxNF0sXG4gIDEwMSxcbiAgYyxcbiAgWzY3OSwgN10sXG4gIGMsXG4gIFsxNSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzE3MSwgNV0sXG4gIDMwLFxuICBjLFxuICBbODgsIDE1XSxcbiAgYyxcbiAgWzI5MCwgNDNdLFxuICAyNyxcbiAgNixcbiAgYyxcbiAgWzI3MDgsIDNdLFxuICBjLFxuICBbNjMyLCAzXSxcbiAgYyxcbiAgWzYzMCwgNV0sXG4gIGMsXG4gIFs2MjYsIDddLFxuICA4MCxcbiAgMTAzLFxuICAxNDcsXG4gIGMsXG4gIFs2NiwgNDNdLFxuICAxMSxcbiAgMTgsXG4gIGMsXG4gIFs1NjUsIDZdLFxuICAxMSxcbiAgMTgsXG4gIDExLFxuICAxOCxcbiAgMTEsXG4gIDE4LFxuICAxNCxcbiAgYyxcbiAgWzM2OCwgMjFdLFxuICBjLFxuICBbNDM1LCA0Nl0sXG4gIDQwLFxuICA0NCxcbiAgNDUsXG4gIDI4LFxuICAzMCxcbiAgYyxcbiAgWzI3MiwgN10sXG4gIGMsXG4gIFsyMjU2LCA5MF0sXG4gIGMsXG4gIFs0MywgODJdLFxuICBjLFxuICBbNTk1LCAyMV0sXG4gIDQxLFxuICAzMCxcbiAgNDQsXG4gIDMzLFxuICBjLFxuICBbNDE1LCAxNV0sXG4gIGMsXG4gIFsyOTYsIDNdLFxuICBzLFxuICBbMTEsIDNdLFxuICA0MCxcbiAgNDIsXG4gIDQzLFxuICBjLFxuICBbMTA4OCwgN10sXG4gIGMsXG4gIFszMDEsIDU4XSxcbiAgYyxcbiAgWzY0LCA2NF0sXG4gIDMwLFxuICBjLFxuICBbNDQsIDQ0XSxcbiAgYyxcbiAgWzgxOSwgMjJdLFxuICBjLFxuICBbMjEsIDIxXSxcbiAgMTEsXG4gIGMsXG4gIFsxNTMsIDIxXSxcbiAgYyxcbiAgWzI0MiwgMjVdLFxuICA0MCxcbiAgNDQsXG4gIDQ2LFxuICBjLFxuICBbMTQ0MCwgNDFdLFxuICBjLFxuICBbMTM1LCAzN10sXG4gIGMsXG4gIFs4MDUsIDddLFxuICA0MCxcbiAgNDIsXG4gIGMsXG4gIFsxMTIsIDIzXSxcbiAgYyxcbiAgWzEzNywgM10sXG4gIGMsXG4gIFs3MSwgMjJdLFxuICAzMCxcbiAgYyxcbiAgWzUxLCAyNF0sXG4gIGMsXG4gIFs0NywgMjFdLFxuICBjLFxuICBbNDUsIDNdLFxuICAzMFxuXSksXG4gIHR5cGU6IHUoW1xuICBzLFxuICBbMiwgM10sXG4gIHMsXG4gIFswLCAxMl0sXG4gIDEsXG4gIHMsXG4gIFsyLCA0XSxcbiAgcyxcbiAgWzAsIDEwXSxcbiAgYyxcbiAgWzEzLCAxMV0sXG4gIHMsXG4gIFsyLCA5XSxcbiAgYyxcbiAgWzE3LCAxMF0sXG4gIGMsXG4gIFszNiwgMjJdLFxuICBjLFxuICBbNywgM10sXG4gIDAsXG4gIDIsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzQ1LCAxMV0sXG4gIGMsXG4gIFsxMCwgNl0sXG4gIGMsXG4gIFs2LCA5XSxcbiAgcyxcbiAgWzIsIDU4XSxcbiAgYyxcbiAgWzY5LCA3XSxcbiAgYyxcbiAgWzkxLCA3XSxcbiAgYyxcbiAgWzEwMSwgNF0sXG4gIGMsXG4gIFsxMzksIDEwXSxcbiAgYyxcbiAgWzM2LCAxM10sXG4gIGMsXG4gIFsyMDAsIDE0XSxcbiAgYyxcbiAgWzE5NSwgMTRdLFxuICBjLFxuICBbMzMsIDMyXSxcbiAgYyxcbiAgWzExLCA1XSxcbiAgYyxcbiAgWzEwMCwgN10sXG4gIGMsXG4gIFs1LCA0XSxcbiAgYyxcbiAgWzI1MCwgMTZdLFxuICBjLFxuICBbNDYsIDEzXSxcbiAgYyxcbiAgWzIwLCAxN10sXG4gIGMsXG4gIFsyNjgsIDEzXSxcbiAgYyxcbiAgWzI5MywgMTFdLFxuICBjLFxuICBbMTQ2LCAzMF0sXG4gIGMsXG4gIFsyMiwgMjBdLFxuICBjLFxuICBbNTMsIDIzXSxcbiAgYyxcbiAgWzQzLCAyNl0sXG4gIGMsXG4gIFsxMDMsIDE4XSxcbiAgYyxcbiAgWzEyMCwgNDddLFxuICBjLFxuICBbODMsIDE1XSxcbiAgYyxcbiAgWzIxMCwgOF0sXG4gIGMsXG4gIFsyNTcsIDQ2XSxcbiAgYyxcbiAgWzQzLCA0Ml0sXG4gIGMsXG4gIFsyNSwgMjNdLFxuICBjLFxuICBbODksIDI3XSxcbiAgYyxcbiAgWzI1NCwgMjVdLFxuICBjLFxuICBbNjAwLCAzMV0sXG4gIGMsXG4gIFsxMjIsIDIxXSxcbiAgYyxcbiAgWzUyLCAyNl0sXG4gIGMsXG4gIFszODgsIDU5XSxcbiAgYyxcbiAgWzQzLCA0MF0sXG4gIGMsXG4gIFs3NiwgMzddLFxuICBjLFxuICBbMjI1LCA0Ml0sXG4gIGMsXG4gIFs1NSwgNTNdLFxuICBjLFxuICBbNzQzLCA0XSxcbiAgYyxcbiAgWzIzNSwgNjBdLFxuICBjLFxuICBbMTI4LCAzNl0sXG4gIGMsXG4gIFsxMDAwLCA1NV0sXG4gIHMsXG4gIFsyLCAxMDZdLFxuICBjLFxuICBbMjIwLCAyNF0sXG4gIHMsXG4gIFswLCAyOV0sXG4gIGMsXG4gIFszMiwgOF0sXG4gIGMsXG4gIFs1NTYsIDYwXSxcbiAgYyxcbiAgWzc4MiwgMjNdLFxuICBjLFxuICBbOTA1LCAxMV0sXG4gIGMsXG4gIFsxNDAwLCAyMV0sXG4gIGMsXG4gIFs4MDQsIDQ3XSxcbiAgYyxcbiAgWzg0NSwgNDhdLFxuICBjLFxuICBbNjIsIDc2XSxcbiAgYyxcbiAgWzY0MiwgMTddLFxuICBjLFxuICBbMjE1LCAxNF0sXG4gIGMsXG4gIFsxMTE4LCAxNV0sXG4gIGMsXG4gIFs4MzIsIDg1XSxcbiAgYyxcbiAgWzcxOCwgNDFdLFxuICBjLFxuICBbMTUsIDI5XSxcbiAgYyxcbiAgWzc2MiwgMjBdLFxuICBjLFxuICBbNzksIDE4XSxcbiAgYyxcbiAgWzU3OSwgNDldLFxuICBjLFxuICBbMzYsIDE3XSxcbiAgYyxcbiAgWzE0NzQsIDE5XSxcbiAgYyxcbiAgWzI2LCAxMF0sXG4gIGMsXG4gIFsyOCwgMzJdLFxuICBjLFxuICBbMTkxMiwgOF0sXG4gIGMsXG4gIFsxNiwgN10sXG4gIGMsXG4gIFs2NjQsIDQ2XSxcbiAgYyxcbiAgWzQ1LCAyNl0sXG4gIGMsXG4gIFsxOTc5LCAxMF0sXG4gIGMsXG4gIFs4NCwgMTBdLFxuICBjLFxuICBbNTQ5LCA4MV0sXG4gIGMsXG4gIFsxNzk4LCAzNF0sXG4gIGMsXG4gIFsxMTg1LCA2NV0sXG4gIGMsXG4gIFsxNDUxLCA1MF0sXG4gIGMsXG4gIFs4MiwgMjNdLFxuICBjLFxuICBbMTI4LCAzNF0sXG4gIGMsXG4gIFs3MzUsIDhdLFxuICBjLFxuICBbMTQxMiwgMzFdLFxuICBjLFxuICBbNzMsIDMwXSxcbiAgYyxcbiAgWzMsIDZdLFxuICBjLFxuICBbNTAsIDQ1XSxcbiAgYyxcbiAgWzE0ODUsIDYxXSxcbiAgYyxcbiAgWzU0MywgMzBdLFxuICBjLFxuICBbNTA1LCAyOF0sXG4gIGMsXG4gIFs0NDMsIDY0XSxcbiAgYyxcbiAgWzgyMiwgNDRdLFxuICBjLFxuICBbNzc3LCAxMl0sXG4gIGMsXG4gIFszNTEsIDExXSxcbiAgYyxcbiAgWzI1NywgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzMzMiwgOV0sXG4gIGMsXG4gIFsxMzUxLCAyNF0sXG4gIGMsXG4gIFs0LCA4XSxcbiAgYyxcbiAgWzIwNTMsIDc4XSxcbiAgYyxcbiAgWzQ4LCA4XSxcbiAgYyxcbiAgWzU3MSwgNTVdLFxuICBjLFxuICBbMTUyNSwgMzBdLFxuICBjLFxuICBbNDM1LCA0Nl0sXG4gIGMsXG4gIFs1MzYsIDkzXSxcbiAgYyxcbiAgWzQzLCA5MV0sXG4gIGMsXG4gIFszNTIsIDMyXSxcbiAgYyxcbiAgWzE5NzAsIDMzXSxcbiAgYyxcbiAgWzExNCwgNjNdLFxuICBjLFxuICBbNTEwLCA2MF0sXG4gIGMsXG4gIFs0NCwgMzZdLFxuICBjLFxuICBbMTMwNywgNDNdLFxuICBjLFxuICBbMTEwLCAyNV0sXG4gIGMsXG4gIFs5MTEsIDM4XSxcbiAgYyxcbiAgWzI5ODUsIDQzXSxcbiAgYyxcbiAgWzg4LCA1Ml0sXG4gIGMsXG4gIFsyOTY5LCAzMl0sXG4gIGMsXG4gIFsyMzIsIDM4XVxuXSksXG4gIHN0YXRlOiB1KFtcbiAgMSxcbiAgMixcbiAgNSxcbiAgNCxcbiAgMyxcbiAgNixcbiAgMTAsXG4gIDExLFxuICAxMixcbiAgOCxcbiAgMTMsXG4gIDE0LFxuICAxOSxcbiAgMTcsXG4gIDE2LFxuICBjLFxuICBbMTAsIDddLFxuICAyMCxcbiAgMjIsXG4gIGMsXG4gIFs4LCA2XSxcbiAgMjgsXG4gIDMwLFxuICAyOSxcbiAgMzEsXG4gIDMzLFxuICAzNyxcbiAgMzYsXG4gIDM1LFxuICA0MSxcbiAgNDQsXG4gIDQ1LFxuICA0MCxcbiAgNDIsXG4gIDQzLFxuICA0OCxcbiAgYyxcbiAgWzIyLCA3XSxcbiAgNTMsXG4gIDUyLFxuICA1NCxcbiAgNTUsXG4gIDU2LFxuICA2MyxcbiAgNjAsXG4gIDYyLFxuICAzNyxcbiAgMzYsXG4gIDYxLFxuICAzNSxcbiAgNjQsXG4gIDY3LFxuICA2OCxcbiAgNjksXG4gIDY3LFxuICA2OCxcbiAgNzYsXG4gIDc1LFxuICA4MCxcbiAgNzksXG4gIDgyLFxuICA4MSxcbiAgODMsXG4gIDg3LFxuICA4OSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgOTAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgOTUsXG4gIDY4LFxuICA5NyxcbiAgOTgsXG4gIDEwMCxcbiAgMTMsXG4gIDE0LFxuICAxMDEsXG4gIDEwMixcbiAgMTA4LFxuICAxMDksXG4gIDEwMyxcbiAgMTA0LFxuICA0MixcbiAgNDMsXG4gIDk5LFxuICA5NixcbiAgMTA2LFxuICA5NSxcbiAgNjgsXG4gIDExOCxcbiAgYyxcbiAgWzE4LCAxM10sXG4gIDExNyxcbiAgMTA2LFxuICAxMjQsXG4gIDEyNSxcbiAgMTI3LFxuICAxMjYsXG4gIDEyOCxcbiAgMTMwLFxuICAxMzEsXG4gIDEzNCxcbiAgMTQwLFxuICBjLFxuICBbMjQsIDEzXSxcbiAgMTA2LFxuICAxNDEsXG4gIGMsXG4gIFsxNCwgMTNdLFxuICAxNDIsXG4gIDE0NCxcbiAgMTQ2LFxuICAxNDUsXG4gIDQ0LFxuICA0NSxcbiAgMTQ3LFxuICAxNTAsXG4gIDE1NCxcbiAgMTUzLFxuICAzNyxcbiAgMzYsXG4gIDE1MixcbiAgMzUsXG4gIDE1NixcbiAgYyxcbiAgWzQzLCAxM10sXG4gIDE1NSxcbiAgMTA2LFxuICAxNTgsXG4gIGMsXG4gIFs0NCwgMTNdLFxuICBzLFxuICBbMTU5LCA1LCAxXSxcbiAgcyxcbiAgWzE3NiwgNCwgMV0sXG4gIDE3MyxcbiAgMTY0LFxuICAxNjUsXG4gIDE4MCxcbiAgMTg2LFxuICAxODUsXG4gIDE4NyxcbiAgMTkyLFxuICAxOTMsXG4gIDE3MixcbiAgMTcxLFxuICAxODEsXG4gIDE4NCxcbiAgNDUsXG4gIDE3MCxcbiAgMTgyLFxuICA0MyxcbiAgMTY5LFxuICAxODksXG4gIDIwMSxcbiAgMjAyLFxuICBzLFxuICBbMjA0LCA1LCAxXSxcbiAgMTkyLFxuICAxOTMsXG4gIDIwMyxcbiAgMTg5LFxuICAyMTAsXG4gIGMsXG4gIFs2OSwgMTNdLFxuICAyMDksXG4gIGMsXG4gIFs2OSwgMTVdLFxuICAyMTIsXG4gIGMsXG4gIFsxMTEsIDNdLFxuICAyMTksXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjIwLFxuICAyMjUsXG4gIGMsXG4gIFsxNTEsIDE0XSxcbiAgMjI2LFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMjI5LFxuICBjLFxuICBbMjksIDE0XSxcbiAgMjMwLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMTQ0LFxuICAxNDYsXG4gIDE0NyxcbiAgMjMxLFxuICBjLFxuICBbMzIsIDE0XSxcbiAgMjMyLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgYyxcbiAgWzExMywgMTRdLFxuICAyMzksXG4gIDIzOCxcbiAgYyxcbiAgWzE2LCAxNF0sXG4gIDI0NSxcbiAgNDIsXG4gIDQzLFxuICAyNDcsXG4gIDI0OCxcbiAgMjUwLFxuICAyNTEsXG4gIDI2NixcbiAgYyxcbiAgWzIwNSwgMjddLFxuICAyNjcsXG4gIGMsXG4gIFsyOCwgMjddLFxuICAyNjgsXG4gIGMsXG4gIFsyNCwgNF0sXG4gIDI3MCxcbiAgYyxcbiAgWzIyLCA2XSxcbiAgMjcxLFxuICAyNzMsXG4gIGMsXG4gIFsyMiwgM10sXG4gIDI3MixcbiAgYyxcbiAgWzIyLCA0XSxcbiAgMjc2LFxuICAyNzUsXG4gIDI4MyxcbiAgMjgyLFxuICAyODcsXG4gIDI4NixcbiAgMjg4LFxuICAxNDYsXG4gIDE0NyxcbiAgMjg5LFxuICBjLFxuICBbNTksIDI3XSxcbiAgMjkxLFxuICAyOTMsXG4gIDI5OSxcbiAgMzAxLFxuICAyOTgsXG4gIDQ0LFxuICA0NSxcbiAgMzAwLFxuICA0MixcbiAgNDMsXG4gIDMwNSxcbiAgMzA2LFxuICBjLFxuICBbMzksIDI3XSxcbiAgMzA4LFxuICAzMDksXG4gIDMxMixcbiAgMzExLFxuICAzMTAsXG4gIDMxMyxcbiAgMTQ3LFxuICAzMTQsXG4gIGMsXG4gIFszNSwgMjddLFxuICBjLFxuICBbMjEwLCAxNF0sXG4gIDMxNyxcbiAgNDQsXG4gIDQ1LFxuICAzMTksXG4gIDEyNyxcbiAgMTI2LFxuICAzMjAsXG4gIGMsXG4gIFszNDEsIDNdLFxuICAzMjEsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMzI1LFxuICBjLFxuICBbMjgzLCAxNF0sXG4gIDMyNixcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDMyNyxcbiAgYyxcbiAgWzI5LCAxNF0sXG4gIDMyOCxcbiAgYyxcbiAgWzMxMiwgMjddLFxuICAzMzEsXG4gIGMsXG4gIFs0MywgMTRdLFxuICAzMzIsXG4gIGMsXG4gIFs0MywgMjddLFxuICBjLFxuICBbMTQsIDE0XSxcbiAgMzM4LFxuICAxNDcsXG4gIGMsXG4gIFs2MzQsIDRdLFxuICAzNDEsXG4gIGMsXG4gIFsxMzksIDNdLFxuICAzNDIsXG4gIDQyLFxuICA0MyxcbiAgMzQ1LFxuICAzNDYsXG4gIGMsXG4gIFsxOTksIDI3XSxcbiAgMzQ3LFxuICBjLFxuICBbMzMyLCAyMV0sXG4gIDM1MSxcbiAgYyxcbiAgWzUwLCAyN10sXG4gIDI4NyxcbiAgMjg2LFxuICAyODMsXG4gIDI4MixcbiAgMjc2LFxuICAyNzUsXG4gIDM1NyxcbiAgMzU0LFxuICAzNjEsXG4gIDM1OSxcbiAgMzUzLFxuICAzNjQsXG4gIDM2MyxcbiAgMzU4LFxuICAzNjAsXG4gIDM2MixcbiAgMTQ1LFxuICAxODQsXG4gIDQ1LFxuICAzNjUsXG4gIDE4MixcbiAgNDMsXG4gIDM1NSxcbiAgMzY2LFxuICAzNjgsXG4gIGMsXG4gIFszMzcsIDI4XSxcbiAgMzYxLFxuICAzNTksXG4gIDM2OSxcbiAgYyxcbiAgWzQ1LCA1XSxcbiAgMzcwLFxuICBjLFxuICBbNDMsIDRdLFxuICAzNzIsXG4gIGMsXG4gIFs2MSwgNF0sXG4gIDM3MyxcbiAgYyxcbiAgWzYxLCAxMl0sXG4gIDM3NCxcbiAgMzc1LFxuICBjLFxuICBbMTksIDRdLFxuICAzNzYsXG4gIGMsXG4gIFsxOSwgMTJdLFxuICAzNzcsXG4gIDM3OCxcbiAgcyxcbiAgWzM4MCwgNywgMV0sXG4gIDM4OCxcbiAgMzg3LFxuICAzODksXG4gIGMsXG4gIFs4OSwgMjddLFxuICAyOTMsXG4gIDM5OCxcbiAgYyxcbiAgWzc1NywgOV0sXG4gIDM5OSxcbiAgNDQsXG4gIDQ1LFxuICA0MDIsXG4gIDQwMSxcbiAgNDA0LFxuICA0MDMsXG4gIDQwNSxcbiAgYyxcbiAgWzMwOSwgMTRdLFxuICA0MDYsXG4gIGMsXG4gIFszMDksIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDQxOSxcbiAgYyxcbiAgWzExNywgMjddLFxuICA0MjQsXG4gIDQyMyxcbiAgNDIwLFxuICAyNTEsXG4gIDQyNSxcbiAgYyxcbiAgWzMyLCAyN10sXG4gIDM1NyxcbiAgMzU0LFxuICBjLFxuICBbMzc4LCAzXSxcbiAgNDMwLFxuICBjLFxuICBbMzI0LCAzM10sXG4gIDQzNSxcbiAgYyxcbiAgWzM0LCAyN10sXG4gIDQzNyxcbiAgNDM4LFxuICA0NDEsXG4gIGMsXG4gIFszMCwgMjddLFxuICA0NDIsXG4gIGMsXG4gIFs2NzEsIDNdLFxuICA0NDMsXG4gIGMsXG4gIFszMiwgMjddLFxuICA0NDQsXG4gIGMsXG4gIFsyOCwgMjddLFxuICA0NDUsXG4gIDE0NyxcbiAgNDQ2LFxuICBjLFxuICBbMjkwLCAxNF0sXG4gIGMsXG4gIFsyNDgsIDE0XSxcbiAgNDU5LFxuICBjLFxuICBbNTI5LCAyMV0sXG4gIDM1NyxcbiAgNDYxLFxuICBjLFxuICBbODIsIDZdLFxuICAzNTQsXG4gIGMsXG4gIFs4MywgMTNdLFxuICA0NjIsXG4gIGMsXG4gIFs4MywgN10sXG4gIDQ2MyxcbiAgNDY0LFxuICA0MjQsXG4gIDQyMyxcbiAgNDY2LFxuICBjLFxuICBbMjQzLCAzXSxcbiAgNDY3LFxuICBjLFxuICBbNCwgM10sXG4gIDQ2OSxcbiAgYyxcbiAgWzQsIDNdLFxuICA0NzAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgNDcxLFxuICBjLFxuICBbNCwgM10sXG4gIDQ3MixcbiAgYyxcbiAgWzkxLCA4XSxcbiAgNDc4LFxuICBjLFxuICBbOTIsIDZdLFxuICA0ODAsXG4gIDEzLFxuICAxNCxcbiAgNDgxLFxuICAxMyxcbiAgMTQsXG4gIDQyNCxcbiAgNDIzLFxuICA0ODYsXG4gIGMsXG4gIFsxNTksIDI3XSxcbiAgMjM5LFxuICAyOTEsXG4gIDIzOCxcbiAgNDg4LFxuICBjLFxuICBbMzc5LCAyOV0sXG4gIDQ5OCxcbiAgYyxcbiAgWzE5MCwgMTRdLFxuICA0OTksXG4gIGMsXG4gIFs0NSwgMjddLFxuICA1MDAsXG4gIDE0NyxcbiAgNTA1LFxuICBjLFxuICBbMTM0LCAzXSxcbiAgNTA2LFxuICBjLFxuICBbMzQsIDI3XSxcbiAgNTA3LFxuICBjLFxuICBbMjgsIDI3XSxcbiAgNTA4LFxuICBjLFxuICBbMjgsIDI3XSxcbiAgNTA5LFxuICBjLFxuICBbMTA1MCwgNDFdLFxuICA0MjQsXG4gIDQyMyxcbiAgNTI0LFxuICBjLFxuICBbMTc3LCAxNF0sXG4gIDUyNSxcbiAgYyxcbiAgWzU5LCAyN10sXG4gIDUyNixcbiAgYyxcbiAgWzQzLCAxNF0sXG4gIDUyNyxcbiAgYyxcbiAgWzQzLCAyN10sXG4gIDUyOSxcbiAgYyxcbiAgWzEzMCwgNDFdLFxuICBjLFxuICBbMTQsIDE0XSxcbiAgNTM3LFxuICBjLFxuICBbOTksIDE0XSxcbiAgNTQwLFxuICBjLFxuICBbMTUsIDE0XSxcbiAgNTQyLFxuICBjLFxuICBbNTM5LCAyOF0sXG4gIGMsXG4gIFsxNCwgMjJdLFxuICA1NDgsXG4gIGMsXG4gIFsxNSwgNl0sXG4gIDU1MCxcbiAgYyxcbiAgWzU4LCAyOF0sXG4gIDU1OCxcbiAgYyxcbiAgWzI5LCAyOF1cbl0pLFxuICBtb2RlOiB1KFtcbiAgcyxcbiAgWzEsIDI2XSxcbiAgMixcbiAgMixcbiAgYyxcbiAgWzE3LCAxN10sXG4gIHMsXG4gIFsyLCA4XSxcbiAgYyxcbiAgWzExLCAxMV0sXG4gIHMsXG4gIFsyLCAxOF0sXG4gIGMsXG4gIFsyOSwgMTldLFxuICAxLFxuICBjLFxuICBbNzUsIDNdLFxuICBjLFxuICBbNzgsIDEzXSxcbiAgYyxcbiAgWzkyLCA4XSxcbiAgYyxcbiAgWzcsIDhdLFxuICBjLFxuICBbMTYsIDddLFxuICBjLFxuICBbMTE0LCAxNl0sXG4gIGMsXG4gIFsxNTIsIDI0XSxcbiAgYyxcbiAgWzQ3LCA2XSxcbiAgYyxcbiAgWzQ2LCA4XSxcbiAgYyxcbiAgWzU0LCAyMF0sXG4gIGMsXG4gIFsxMzUsIDEwXSxcbiAgYyxcbiAgWzIzLCAxNF0sXG4gIGMsXG4gIFs1MSwgMTZdLFxuICBjLFxuICBbNzcsIDldLFxuICBzLFxuICBbMSwgNTVdLFxuICBjLFxuICBbMTA0LCA5XSxcbiAgYyxcbiAgWzcsIDZdLFxuICBjLFxuICBbNiwgMTNdLFxuICBjLFxuICBbMTA0LCAxNF0sXG4gIGMsXG4gIFsyNjEsIDEwXSxcbiAgYyxcbiAgWzE1MSwgMThdLFxuICBjLFxuICBbMjQ2LCA0MV0sXG4gIGMsXG4gIFszNzIsIDI5XSxcbiAgYyxcbiAgWzM3NywgMjFdLFxuICBjLFxuICBbMjcsIDUwXSxcbiAgYyxcbiAgWzEyMiwgMThdLFxuICBjLFxuICBbNDcyLCAyN10sXG4gIHMsXG4gIFsyLCAzMV0sXG4gIGMsXG4gIFszMywgMzNdLFxuICBjLFxuICBbMzYsIDIxXSxcbiAgYyxcbiAgWzIzMSwgMzBdLFxuICBjLFxuICBbMjUsIDYyXSxcbiAgYyxcbiAgWzM3MCwgNDRdLFxuICBjLFxuICBbNDUsIDRdLFxuICBjLFxuICBbNTQxLCA2MF0sXG4gIGMsXG4gIFs1NjAsIDI2XSxcbiAgYyxcbiAgWzYyLCA1OV0sXG4gIGMsXG4gIFs3MzEsIDEyXSxcbiAgYyxcbiAgWzEzLCAxN10sXG4gIGMsXG4gIFsyNDksIDE2XSxcbiAgcyxcbiAgWzEsIDk2XSxcbiAgYyxcbiAgWzcyNSwgNV0sXG4gIGMsXG4gIFsyNzAsIDYyXSxcbiAgYyxcbiAgWzM1NSwgNV0sXG4gIGMsXG4gIFsxMDIzLCA3XSxcbiAgYyxcbiAgWzE3OSwgNDhdLFxuICBjLFxuICBbNDE3LCA4XSxcbiAgYyxcbiAgWzEzNSwgNjNdLFxuICBjLFxuICBbNDgzLCA4Ml0sXG4gIGMsXG4gIFs0MDgsIDldLFxuICBjLFxuICBbNDQsIDYwXSxcbiAgYyxcbiAgWzQ2NywgMTZdLFxuICBjLFxuICBbNzksIDIzXSxcbiAgYyxcbiAgWzI1MSwgMTA5XSxcbiAgYyxcbiAgWzIyMSwgNDRdLFxuICBzLFxuICBbMSwgMTQyXVxuXSksXG4gIGdvdG86IHUoW1xuICAxNSxcbiAgOSxcbiAgNyxcbiAgMTgsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjEsXG4gIDE1LFxuICA3LFxuICBzLFxuICBbMjMsIDUsIDFdLFxuICAzMixcbiAgMzQsXG4gIDM4LFxuICAzOSxcbiAgNDYsXG4gIDQ3LFxuICA0OSxcbiAgMTUsXG4gIDcsXG4gIDUwLFxuICA1MSxcbiAgMTk0LFxuICAxOTQsXG4gIDM5LFxuICAzNCxcbiAgMzksXG4gIDM4LFxuICA1NyxcbiAgNTgsXG4gIDU5LFxuICAzOCxcbiAgMzksXG4gIDY1LFxuICA2NixcbiAgMzgsXG4gIDcwLFxuICA3MSxcbiAgMzgsXG4gIHMsXG4gIFsxODQsIDEwXSxcbiAgNzIsXG4gIHMsXG4gIFsxODQsIDE4XSxcbiAgcyxcbiAgWzE3OSwgMTBdLFxuICA3MyxcbiAgcyxcbiAgWzE3OSwgMThdLFxuICA3NCxcbiAgMTk2LFxuICA3NyxcbiAgNzgsXG4gIDIwMCxcbiAgNzcsXG4gIDg2LFxuICA4NSxcbiAgNzcsXG4gIDg0LFxuICA4OCxcbiAgMzgsXG4gIDM5LFxuICAzOCxcbiAgMzksXG4gIDkxLFxuICA5MixcbiAgMTg4LFxuICAxODgsXG4gIDU5LFxuICA5MyxcbiAgOTQsXG4gIDM4LFxuICAxNSxcbiAgMTEyLFxuICAyMTMsXG4gIDEwNSxcbiAgMTA3LFxuICAxMTAsXG4gIDExMSxcbiAgMTE0LFxuICAxMTMsXG4gIHMsXG4gIFs4MCwgM10sXG4gIDExNSxcbiAgMTE2LFxuICBjLFxuICBbMTUsIDNdLFxuICAyMTcsXG4gIGMsXG4gIFsxNSwgNF0sXG4gIHMsXG4gIFsxMTksIDUsIDFdLFxuICAzOCxcbiAgMzksXG4gIDg4LFxuICAxMjksXG4gIDg2LFxuICAxMzMsXG4gIDEzMixcbiAgMTM3LFxuICAxMzYsXG4gIDEzNSxcbiAgMTM5LFxuICAxMzgsXG4gIDE1LFxuICAxMTIsXG4gIGMsXG4gIFsyMywgNF0sXG4gIGMsXG4gIFs2LCA2XSxcbiAgMTQzLFxuICAxNDgsXG4gIDE0OSxcbiAgMTg2LFxuICAxODYsXG4gIDE1MSxcbiAgMTg2LFxuICAxODYsXG4gIDM4LFxuICAzOSxcbiAgMTUsXG4gIDExMixcbiAgMjExLFxuICBjLFxuICBbMTcsIDRdLFxuICAxNTcsXG4gIDE1LFxuICAxMTIsXG4gIDIxNCxcbiAgYyxcbiAgWzgsIDRdLFxuICAxOTEsXG4gIDE2NixcbiAgMTkwLFxuICAxODgsXG4gIDE2OCxcbiAgMTgzLFxuICAxNjcsXG4gIDE3NCxcbiAgMTc1LFxuICA4OCxcbiAgMTk0LFxuICAxOTUsXG4gIDE5NixcbiAgNDYsXG4gIDQ3LFxuICAxODQsXG4gIDE4NCxcbiAgMTk3LFxuICBzLFxuICBbMTg0LCA3XSxcbiAgMTk4LFxuICAxOTksXG4gIDIwMCxcbiAgMzgsXG4gIDE5MSxcbiAgMTkwLFxuICAxMDUsXG4gIGMsXG4gIFsyMywgNF0sXG4gIDE1LFxuICAxMTIsXG4gIDIxNSxcbiAgYyxcbiAgWzQzLCA0XSxcbiAgMjExLFxuICAxNSxcbiAgMTEyLFxuICAyMTgsXG4gIGMsXG4gIFs4LCA0XSxcbiAgMjEzLFxuICAxNDksXG4gIDIxNSxcbiAgMjE0LFxuICA0OSxcbiAgNDksXG4gIDIxNixcbiAgNTEsXG4gIDUxLFxuICAyMTcsXG4gIDIxOCxcbiAgMjEzLFxuICAxNDksXG4gIDEzNyxcbiAgMjIyLFxuICAyMjEsXG4gIDIyNCxcbiAgMjIzLFxuICBjLFxuICBbMTA2LCAxMl0sXG4gIDIyOCxcbiAgMjI3LFxuICBjLFxuICBbMTIwLCAxM10sXG4gIGMsXG4gIFsxNTgsIDNdLFxuICBjLFxuICBbMTQsIDEwXSxcbiAgMTUsXG4gIDIzMyxcbiAgYyxcbiAgWzYsIDRdLFxuICAyMzQsXG4gIDIzNSxcbiAgMjM3LFxuICAyMzYsXG4gIDIwNCxcbiAgMjA0LFxuICAyNDAsXG4gIHMsXG4gIFsyMDQsIDRdLFxuICA2MSxcbiAgNjEsXG4gIDI0MSxcbiAgNjEsXG4gIDYxLFxuICBzLFxuICBbMTg0LCAzXSxcbiAgMjQyLFxuICBzLFxuICBbMTc5LCA1XSxcbiAgMjQzLFxuICBzLFxuICBbMTc5LCAzXSxcbiAgMTkwLFxuICAxOTAsXG4gIDU5LFxuICAyNDQsXG4gIDE1LFxuICAxMTIsXG4gIDIxMixcbiAgYyxcbiAgWzQwLCA0XSxcbiAgMTEwLFxuICAxMTEsXG4gIDI0OSxcbiAgMjQ2LFxuICBzLFxuICBbMTA1LCAzXSxcbiAgMjYxLFxuICAxMDUsXG4gIDI1NCxcbiAgMjUyLFxuICAxMDUsXG4gIDI1OCxcbiAgMjU5LFxuICAyNjAsXG4gIDI2NCxcbiAgcyxcbiAgWzEwNSwgNV0sXG4gIDI1MyxcbiAgMjU1LFxuICAyNTYsXG4gIDI1NyxcbiAgMjYyLFxuICAyNjMsXG4gIDI2NSxcbiAgYyxcbiAgWzE4MywgMTVdLFxuICBjLFxuICBbMTUsIDE2XSxcbiAgMjY5LFxuICAxOTAsXG4gIDE4OCxcbiAgMTgzLFxuICBjLFxuICBbMTEsIDZdLFxuICAyMzEsXG4gIDIzMSxcbiAgMjc3LFxuICAyMzEsXG4gIDIzMSxcbiAgMjc0LFxuICBzLFxuICBbMjMxLCAyMF0sXG4gIHMsXG4gIFsyMzIsIDRdLFxuICAyNzgsXG4gIHMsXG4gIFsyMzIsIDRdLFxuICAyNzksXG4gIHMsXG4gIFsyMzIsIDE2XSxcbiAgMjI5LFxuICAyMjksXG4gIDI3NyxcbiAgMjI5LFxuICAyMjksXG4gIDI4MCxcbiAgcyxcbiAgWzIyOSwgNF0sXG4gIDI4MSxcbiAgcyxcbiAgWzIyOSwgMTZdLFxuICAyMjcsXG4gIDIyNyxcbiAgMjc3LFxuICAyMjcsXG4gIDIyNyxcbiAgMjg0LFxuICBzLFxuICBbMjI3LCA0XSxcbiAgMjg1LFxuICBzLFxuICBbMjI3LCAxNl0sXG4gIDM4LFxuICBjLFxuICBbMTMzLCAxNV0sXG4gIHMsXG4gIFsyMjYsIDhdLFxuICAyOTAsXG4gIHMsXG4gIFsyMjYsIDE2XSxcbiAgMjMwLFxuICAyMzAsXG4gIDI3NyxcbiAgcyxcbiAgWzIzMCwgMjJdLFxuICBzLFxuICBbMTgwLCAxMF0sXG4gIDI5MixcbiAgcyxcbiAgWzE4MCwgMTZdLFxuICBzLFxuICBbMTc0LCAxOV0sXG4gIDM4LFxuICBzLFxuICBbMTc0LCA3XSxcbiAgcyxcbiAgWzE3NSwgMTBdLFxuICAyOTQsXG4gIHMsXG4gIFsxNzUsIDE2XSxcbiAgcyxcbiAgWzIzOCwgOF0sXG4gIDI5NSxcbiAgcyxcbiAgWzIzOCwgMTZdLFxuICBzLFxuICBbMjM3LCA4XSxcbiAgMjk2LFxuICBzLFxuICBbMjM3LCAxNl0sXG4gIHMsXG4gIFsyMzksIDhdLFxuICAyOTcsXG4gIHMsXG4gIFsyMzksIDE2XSxcbiAgMzAyLFxuICAzMDMsXG4gIGMsXG4gIFszNTgsIDVdLFxuICAzMDQsXG4gIGMsXG4gIFsyMjYsIDEyXSxcbiAgMzA3LFxuICA4OCxcbiAgMzgsXG4gIDExOSxcbiAgMTIxLFxuICBjLFxuICBbMjQ3LCAxNl0sXG4gIDMxNSxcbiAgcyxcbiAgWzc5LCAzXSxcbiAgMzE2LFxuICAxNSxcbiAgMTEyLFxuICAyMTYsXG4gIGMsXG4gIFs1NTQsIDZdLFxuICAzMTgsXG4gIDI0MixcbiAgMzgsXG4gIDM5LFxuICAyMTMsXG4gIDE0OSxcbiAgMjEzLFxuICAxNDksXG4gIDMyMixcbiAgMzI0LFxuICAzMjMsXG4gIGMsXG4gIFs1MjEsIDEzXSxcbiAgYyxcbiAgWzYsIDEyXSxcbiAgMzI5LFxuICBjLFxuICBbNiwgNF0sXG4gIDMzMCxcbiAgYyxcbiAgWzE5LCAxM10sXG4gIDMzMyxcbiAgYyxcbiAgWzYsIDRdLFxuICAzMzQsXG4gIDE1LFxuICAzMzUsXG4gIGMsXG4gIFs3LCA0XSxcbiAgMzM2LFxuICAzMzcsXG4gIGMsXG4gIFs2NTAsIDNdLFxuICAyMDUsXG4gIDIwNSxcbiAgMzM5LFxuICBzLFxuICBbMjA1LCA0XSxcbiAgMzQwLFxuICBjLFxuICBbNzgsIDRdLFxuICAxMjAsXG4gIDEyMixcbiAgMTEwLFxuICAxMTEsXG4gIDM0MyxcbiAgMjQ5LFxuICAzNDQsXG4gIGMsXG4gIFs1MDAsIDE2XSxcbiAgMzQ4LFxuICBjLFxuICBbNTAwLCA5XSxcbiAgMzQ5LFxuICAzNTAsXG4gIGMsXG4gIFsyOCwgMTVdLFxuICBjLFxuICBbNDM4LCA0XSxcbiAgMzUyLFxuICBjLFxuICBbNDM1LCA4XSxcbiAgYyxcbiAgWzQ3OCwgNF0sXG4gIDM1MixcbiAgYyxcbiAgWzQ3NSwgOF0sXG4gIGMsXG4gIFs1NDMsIDRdLFxuICAzNTIsXG4gIGMsXG4gIFs1MjksIDExXSxcbiAgYyxcbiAgWzUyNSwgN10sXG4gIDE5MSxcbiAgMzU2LFxuICAxOTAsXG4gIDE4MyxcbiAgODgsXG4gIDQ2LFxuICA0NyxcbiAgMjc3LFxuICAxOTEsXG4gIDE2NixcbiAgMzY3LFxuICBjLFxuICBbMTAxLCAxNF0sXG4gIGMsXG4gIFsyNCwgNV0sXG4gIDM3MSxcbiAgMzgsXG4gIGMsXG4gIFszMiwgN10sXG4gIDM4LFxuICAyNzcsXG4gIGMsXG4gIFs5LCA5XSxcbiAgMjM3LFxuICAzNzksXG4gIHMsXG4gIFszOCwgNl0sXG4gIDI3NyxcbiAgMjc3LFxuICAzNTIsXG4gIGMsXG4gIFsxMjUsIDE1XSxcbiAgMzgsXG4gIDM5MSxcbiAgMzkwLFxuICAzOTIsXG4gIDM5MyxcbiAgMzk0LFxuICAzOTYsXG4gIDM5NSxcbiAgMzk3LFxuICBjLFxuICBbODQ2LCA3XSxcbiAgMjEzLFxuICAxNDksXG4gIDQwMCxcbiAgMTM3LFxuICAxOTgsXG4gIDEzNyxcbiAgMjAyLFxuICBjLFxuICBbMjQwLCAxM10sXG4gIDQwNyxcbiAgYyxcbiAgWzYsIDRdLFxuICA0MDgsXG4gIDE1LFxuICA0MDksXG4gIGMsXG4gIFs3LCA0XSxcbiAgNDEwLFxuICA0MTEsXG4gIDE5OSxcbiAgMjAwLFxuICAxNSxcbiAgNDEyLFxuICBjLFxuICBbMTAsIDRdLFxuICA0MTMsXG4gIDQxNCxcbiAgMTk5LFxuICAyMDAsXG4gIDQxNSxcbiAgMTk5LFxuICAyMDAsXG4gIDQxNixcbiAgNDE3LFxuICA0MTgsXG4gIGMsXG4gIFs4MywgMTVdLFxuICAxMDgsXG4gIDEwOCxcbiAgMjc3LFxuICAxMDgsXG4gIDI2MSxcbiAgNDIxLFxuICAxMDgsXG4gIDI1NCxcbiAgMjUyLFxuICAxMDgsXG4gIDQyMixcbiAgYyxcbiAgWzc5MywgNF0sXG4gIHMsXG4gIFsxMDgsIDVdLFxuICBjLFxuICBbNzkzLCAyMl0sXG4gIDQyNixcbiAgMjEzLFxuICAxNDksXG4gIDQyNyxcbiAgNDI5LFxuICA0MjgsXG4gIGMsXG4gIFsyMSwgMTVdLFxuICAyOTcsXG4gIDIzMyxcbiAgMjc3LFxuICAzNTIsXG4gIDI4NSxcbiAgMjM0LFxuICAyNzcsXG4gIDM1MixcbiAgMjgxLFxuICAyMzUsXG4gIDI5MCxcbiAgMjM2LFxuICAyNzksXG4gIDI5NSxcbiAgMjk2LFxuICAyNzcsXG4gIDM1MixcbiAgMzkxLFxuICA0MzEsXG4gIDQzMixcbiAgMjk0LFxuICA3MyxcbiAgNDMzLFxuICA0MzQsXG4gIGMsXG4gIFszOSwgMTVdLFxuICA0MzYsXG4gIDI3NyxcbiAgMjc3LFxuICA0MzksXG4gIDQ0MCxcbiAgYyxcbiAgWzIwLCAxNV0sXG4gIDg4LFxuICBjLFxuICBbNDk1LCAxNl0sXG4gIGMsXG4gIFsyMzcsIDE2XSxcbiAgYyxcbiAgWzIwOSwgNl0sXG4gIDQ0NyxcbiAgNDQ4LFxuICA0NDksXG4gIDE1LFxuICA0NTAsXG4gIGMsXG4gIFs5LCA0XSxcbiAgNDUxLFxuICA0NTIsXG4gIDE5OSxcbiAgMjAwLFxuICA0NTMsXG4gIDE5OSxcbiAgMjAwLFxuICA0NTQsXG4gIDQ1NSxcbiAgMTk5LFxuICAyMDAsXG4gIDQ1NixcbiAgNDU3LFxuICA0NTgsXG4gIDE5MSxcbiAgNDYwLFxuICBjLFxuICBbNDIwLCA5XSxcbiAgYyxcbiAgWzU2LCAxNl0sXG4gIDI3NyxcbiAgNDY1LFxuICAxMTUsXG4gIDExNSxcbiAgMjc3LFxuICAxMTUsXG4gIDM1MixcbiAgMTE1LFxuICAxMTUsXG4gIDQyMixcbiAgcyxcbiAgWzExNSwgNV0sXG4gIGMsXG4gIFs1NjQsIDRdLFxuICA0NjgsXG4gIGMsXG4gIFs1LCA0XSxcbiAgMjEzLFxuICAxNDksXG4gIDI3NyxcbiAgNDczLFxuICA0NzQsXG4gIDQ3NSxcbiAgNDc3LFxuICA0NzYsXG4gIDE1LFxuICA0NzksXG4gIGMsXG4gIFsyOTcsIDVdLFxuICAxNSxcbiAgNDgyLFxuICAxOTksXG4gIDIwMCxcbiAgNDgzLFxuICA0ODQsXG4gIDQ4NSxcbiAgMTExLFxuICAxMTEsXG4gIDI3NyxcbiAgMTExLFxuICAzNTIsXG4gIDExMSxcbiAgMTExLFxuICA0MjIsXG4gIHMsXG4gIFsxMTEsIDVdLFxuICBjLFxuICBbNzUsIDE1XSxcbiAgNDg3LFxuICAyMDQsXG4gIDI3NyxcbiAgMjMwLFxuICAyNDAsXG4gIDIwNCxcbiAgcyxcbiAgWzIzMCwgMTRdLFxuICBjLFxuICBbMzUsIDE1XSxcbiAgNDg5LFxuICA0OTAsXG4gIDI3NyxcbiAgMzUyLFxuICA0MjIsXG4gIDE1OCxcbiAgcyxcbiAgWzQ5MSwgNywgMV0sXG4gIGMsXG4gIFsxNzgsIDZdLFxuICBjLFxuICBbMTQ0LCAxNl0sXG4gIDE5OSxcbiAgMjAwLFxuICBzLFxuICBbNTAxLCA0LCAxXSxcbiAgMjEzLFxuICAxNDksXG4gIGMsXG4gIFsxMTI5LCAzMV0sXG4gIGMsXG4gIFsxNSwgMjldLFxuICAxNSxcbiAgNTEwLFxuICBjLFxuICBbOTAsIDRdLFxuICBzLFxuICBbNTExLCA1LCAxXSxcbiAgMTEzLFxuICAxMTMsXG4gIDI3NyxcbiAgMTEzLFxuICAzNTIsXG4gIDExMyxcbiAgMTEzLFxuICA0MjIsXG4gIHMsXG4gIFsxMTMsIDVdLFxuICA1MTcsXG4gIDUxNixcbiAgcyxcbiAgWzUxOCwgNCwgMV0sXG4gIDE5OSxcbiAgNTIyLFxuICA1MjMsXG4gIDIwMCxcbiAgYyxcbiAgWzEyNCwgMjFdLFxuICBjLFxuICBbMjEsIDIxXSxcbiAgNTI4LFxuICBjLFxuICBbMTYsIDE1XSxcbiAgNTMwLFxuICA1MzEsXG4gIDE1LFxuICA1MzIsXG4gIGMsXG4gIFszOSwgNF0sXG4gIDUzMyxcbiAgMTUsXG4gIDUzNCxcbiAgYyxcbiAgWzcsIDRdLFxuICA1MzUsXG4gIDUzNixcbiAgYyxcbiAgWzU0LCA2XSxcbiAgMTk5LFxuICA1MzgsXG4gIDUzOSxcbiAgYyxcbiAgWzg1LCA3XSxcbiAgMTk5LFxuICAyMDAsXG4gIDU0MSxcbiAgYyxcbiAgWzYwNSwgN10sXG4gIDU0MyxcbiAgYyxcbiAgWzYsIDRdLFxuICA1NDQsXG4gIDU0NSxcbiAgMTUsXG4gIDU0NixcbiAgYyxcbiAgWzgsIDRdLFxuICA1NDcsXG4gIGMsXG4gIFszMjksIDZdLFxuICAxOTksXG4gIDU0OSxcbiAgYyxcbiAgWzM5LCA4XSxcbiAgNTUxLFxuICA1NTIsXG4gIDIwMCxcbiAgNTUzLFxuICAxNSxcbiAgNTU0LFxuICBjLFxuICBbMTEsIDRdLFxuICA1NTUsXG4gIDU1NixcbiAgMTk5LFxuICA1NTcsXG4gIGMsXG4gIFsyMiwgN10sXG4gIDU1OSxcbiAgMTUsXG4gIDU2MCxcbiAgYyxcbiAgWzI5LCA1XSxcbiAgNTYxLFxuICAyMDAsXG4gIDU2MlxuXSlcbn0pLFxuZGVmYXVsdEFjdGlvbnM6IGJkYSh7XG4gIGlkeDogdShbXG4gIDUsXG4gIDYsXG4gIDgsXG4gIHMsXG4gIFsxMCwgNSwgMV0sXG4gIDE4LFxuICAxOSxcbiAgMjEsXG4gIDIyLFxuICAyMyxcbiAgMjksXG4gIDMwLFxuICAzMSxcbiAgcyxcbiAgWzM1LCA1LCAxXSxcbiAgcyxcbiAgWzQyLCA0LCAxXSxcbiAgNDksXG4gIDUwLFxuICA1MSxcbiAgNTMsXG4gIDYxLFxuICA2MyxcbiAgNjYsXG4gIDY3LFxuICA3MSxcbiAgNzQsXG4gIDc2LFxuICA4MCxcbiAgcyxcbiAgWzg4LCA0LCAxXSxcbiAgOTQsXG4gIDk1LFxuICBzLFxuICBbOTgsIDcsIDFdLFxuICBzLFxuICBbMTA2LCA0LCAxXSxcbiAgMTE2LFxuICBzLFxuICBbMTE5LCA0LCAxXSxcbiAgMTI1LFxuICAxNDMsXG4gIDE0NixcbiAgMTUwLFxuICAxNTEsXG4gIDE1MixcbiAgMTU0LFxuICAxNTgsXG4gIDE2MCxcbiAgMTYxLFxuICAxNjIsXG4gIDE2NCxcbiAgMTY1LFxuICAxNjksXG4gIDE3NixcbiAgMTc3LFxuICAxNzgsXG4gIDE4MCxcbiAgMTg5LFxuICBzLFxuICBbMTkyLCA1LCAxXSxcbiAgcyxcbiAgWzIwMiwgNywgMV0sXG4gIDIxNCxcbiAgMjE4LFxuICAyMzQsXG4gIDIzNSxcbiAgMjM2LFxuICAyMzgsXG4gIDI0NixcbiAgMjQ4LFxuICBzLFxuICBbMjUxLCAxNSwgMV0sXG4gIDI2OCxcbiAgMjc2LFxuICAyODMsXG4gIHMsXG4gIFsyODcsIDQsIDJdLFxuICAzMDAsXG4gIDMwMSxcbiAgMzA0LFxuICAzMDYsXG4gIDMwNyxcbiAgMzA5LFxuICAzMTEsXG4gIDMxMixcbiAgMzE5LFxuICAzMjAsXG4gIDMyMSxcbiAgMzMwLFxuICBzLFxuICBbMzM0LCA0LCAyXSxcbiAgMzQxLFxuICBzLFxuICBbMzQzLCA1LCAxXSxcbiAgMzU1LFxuICAzNTcsXG4gIDM2NixcbiAgMzY3LFxuICAzNzIsXG4gIDM3NCxcbiAgMzc1LFxuICAzNzcsXG4gIDM3OCxcbiAgcyxcbiAgWzM4MCwgNiwgMV0sXG4gIDM5MCxcbiAgMzkyLFxuICBzLFxuICBbMzk4LCA0LCAyXSxcbiAgNDA4LFxuICA0MTAsXG4gIDQxMyxcbiAgNDE2LFxuICA0MTcsXG4gIDQxOCxcbiAgNDI0LFxuICA0MjgsXG4gIDQzMSxcbiAgNDM1LFxuICA0MzYsXG4gIHMsXG4gIFs0MzksIDUsIDFdLFxuICA0NDcsXG4gIDQ1MSxcbiAgNDU0LFxuICA0NTYsXG4gIDQ1NyxcbiAgNDU5LFxuICA0NjMsXG4gIDQ2NCxcbiAgNDY3LFxuICA0NzMsXG4gIDQ3NCxcbiAgNDc4LFxuICA0ODAsXG4gIDQ4MyxcbiAgNDg0LFxuICA0ODUsXG4gIDQ4OCxcbiAgcyxcbiAgWzQ4OSwgNSwgMl0sXG4gIDUwMyxcbiAgcyxcbiAgWzUxNywgNSwgMV0sXG4gIDUyOCxcbiAgNTMwLFxuICA1MzYsXG4gIDU0NCxcbiAgNTQ3LFxuICA1NDgsXG4gIDU1MyxcbiAgNTU1LFxuICA1NTksXG4gIDU2MlxuXSksXG4gIGdvdG86IHUoW1xuICA4LFxuICAyMixcbiAgMjEsXG4gIDI0LFxuICAyNSxcbiAgMjYsXG4gIDY1LFxuICA2NixcbiAgNCxcbiAgOSxcbiAgNixcbiAgMjMsXG4gIDcsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE5LFxuICAxOTIsXG4gIDE5MyxcbiAgMTg0LFxuICAxNzksXG4gIDE4MCxcbiAgMTgxLFxuICAxNzUsXG4gIDE3NixcbiAgMixcbiAgMyxcbiAgNSxcbiAgMTk1LFxuICAxNyxcbiAgMTg5LFxuICA3MCxcbiAgNzUsXG4gIDc0LFxuICAxLFxuICAxOTcsXG4gIDIwMSxcbiAgMTY5LFxuICAxNSxcbiAgMTQsXG4gIDE2LFxuICA2OSxcbiAgNzYsXG4gIDYyLFxuICA2NCxcbiAgcyxcbiAgWzIwNiwgNSwgMV0sXG4gIDg3LFxuICA5NyxcbiAgMjIxLFxuICAyMjIsXG4gIDczLFxuICAxODIsXG4gIDE3NyxcbiAgMTgzLFxuICAxNzgsXG4gIDQ3LFxuICA1NixcbiAgNTgsXG4gIDEwLFxuICAxODcsXG4gIDE4LFxuICAxOTEsXG4gIDYzLFxuICAxMDIsXG4gIDEwMyxcbiAgMTA0LFxuICAxMDYsXG4gIDEwNyxcbiAgMTE2LFxuICAyMjMsXG4gIDIyNCxcbiAgMjI1LFxuICAyMjgsXG4gIDE2MSxcbiAgMjQwLFxuICAyNDEsXG4gIDE3MCxcbiAgMTcxLFxuICAxNzIsXG4gIDc4LFxuICA4MSxcbiAgMjE5LFxuICAyMjAsXG4gIDIzNyxcbiAgMjM4LFxuICAyMzksXG4gIDQ2LFxuICAyNyxcbiAgNDQsXG4gIDQ1LFxuICA1NyxcbiAgNTMsXG4gIDgyLFxuICA4NCxcbiAgMTg1LFxuICBzLFxuICBbMjQ0LCAxNCwgMV0sXG4gIDExNCxcbiAgMTMwLFxuICAxMzIsXG4gIDEzNCxcbiAgMTYwLFxuICAxMjgsXG4gIDE3MyxcbiAgMTIyLFxuICAxMjMsXG4gIDE2NyxcbiAgMTAwLFxuICAxNjIsXG4gIDE2NCxcbiAgMjQyLFxuICAyNDMsXG4gIDQ4LFxuICA1MCxcbiAgNTIsXG4gIDQwLFxuICA0MixcbiAgNDMsXG4gIDU5LFxuICA1NSxcbiAgNjAsXG4gIDY4LFxuICA4MyxcbiAgODUsXG4gIDg2LFxuICAxMTAsXG4gIDE1NyxcbiAgMTI2LFxuICAxMjksXG4gIDk4LFxuICAxMzksXG4gIDE0MCxcbiAgMTMxLFxuICAxNDYsXG4gIDEzMyxcbiAgMTQ0LFxuICAxMzcsXG4gIDEzOCxcbiAgMTQxLFxuICAxNDIsXG4gIDE0MyxcbiAgMTY4LFxuICAxNjMsXG4gIDc3LFxuICA3MixcbiAgMTk5LFxuICAyMDMsXG4gIDM4LFxuICAzOSxcbiAgNDEsXG4gIDM2LFxuICA1NCxcbiAgNjcsXG4gIDEzNixcbiAgMTI1LFxuICA5OSxcbiAgMTU5LFxuICAxMTcsXG4gIDEyMSxcbiAgMTI0LFxuICAxMDEsXG4gIDE2NSxcbiAgMTY2LFxuICA3MSxcbiAgMzcsXG4gIDMyLFxuICAzNCxcbiAgMzUsXG4gIDExMixcbiAgMTQ1LFxuICAxMzUsXG4gIDEyNyxcbiAgMTE5LFxuICAxMjAsXG4gIDk0LFxuICAyMCxcbiAgMzAsXG4gIDMxLFxuICAzMyxcbiAgMTA5LFxuICBzLFxuICBbMTQ3LCA0LCAyXSxcbiAgMTE4LFxuICAyOSxcbiAgMTU2LFxuICBzLFxuICBbMTQ4LCA0LCAyXSxcbiAgMjgsXG4gIDg4LFxuICAxNTUsXG4gIDg5LFxuICA5NSxcbiAgOTYsXG4gIDkxLFxuICA5MCxcbiAgOTIsXG4gIDkzXG5dKVxufSksXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSAmJiB0eXBlb2YgdGhpcy50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgICAgIGhhc2guZGVzdHJveSgpOyAvLyBkZXN0cm95Li4uIHdlbGwsICphbG1vc3QqIVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvblBhcnNlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25DbGFzcyhzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YWNrID0gbmV3IEFycmF5KDEyOCk7ICAgICAgICAgLy8gdG9rZW4gc3RhY2s6IHN0b3JlcyB0b2tlbiB3aGljaCBsZWFkcyB0byBzdGF0ZSBhdCB0aGUgc2FtZSBpbmRleCAoY29sdW1uIHN0b3JhZ2UpXG4gICAgdmFyIHNzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gc3RhdGUgc3RhY2s6IHN0b3JlcyBzdGF0ZXMgKGNvbHVtbiBzdG9yYWdlKVxuXG4gICAgdmFyIHZzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gc2VtYW50aWMgdmFsdWUgc3RhY2tcbiAgICB2YXIgbHN0YWNrID0gbmV3IEFycmF5KDEyOCk7ICAgICAgICAvLyBsb2NhdGlvbiBzdGFja1xuICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGU7XG4gICAgdmFyIHNwID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3N0YWNrIHBvaW50ZXInOiBpbmRleCBpbnRvIHRoZSBzdGFja3NcbiAgICB2YXIgeXlsb2M7XG5cbiAgICB2YXIgeXlsaW5lbm87XG5cblxuICAgIHZhciBzeW1ib2wgPSAwO1xuXG5cblxuICAgIHZhciBURVJST1IgPSB0aGlzLlRFUlJPUjtcbiAgICB2YXIgRU9GID0gdGhpcy5FT0Y7XG4gICAgdmFyIEVSUk9SX1JFQ09WRVJZX1RPS0VOX0RJU0NBUkRfQ09VTlQgPSAodGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnlUb2tlbkRpc2NhcmRDb3VudCB8IDApIHx8IDM7XG4gICAgdmFyIE5PX0FDVElPTiA9IFswLCA1NjMgLyogPT09IHRhYmxlLmxlbmd0aCA6OiBlbnN1cmVzIHRoYXQgYW55b25lIHVzaW5nIHRoaXMgbmV3IHN0YXRlIHdpbGwgZmFpbCBkcmFtYXRpY2FsbHkhICovXTtcblxuICAgIHZhciBsZXhlcjtcbiAgICBpZiAodGhpcy5fX2xleGVyX18pIHtcbiAgICAgICAgbGV4ZXIgPSB0aGlzLl9fbGV4ZXJfXztcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXhlciA9IHRoaXMuX19sZXhlcl9fID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcmVkU3RhdGVfeXkgPSB7XG4gICAgICAgIHBhcnNlRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgcXVvdGVOYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGxleGVyOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcnNlcjogdW5kZWZpbmVkLFxuICAgICAgICBwcmVfcGFyc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zdF9wYXJzZTogdW5kZWZpbmVkLFxuICAgICAgICBwcmVfbGV4OiB1bmRlZmluZWQsXG4gICAgICAgIHBvc3RfbGV4OiB1bmRlZmluZWQgICAgICAvLyBXQVJOSU5HOiBtdXN0IGJlIHdyaXR0ZW4gdGhpcyB3YXkgZm9yIHRoZSBjb2RlIGV4cGFuZGVycyB0byB3b3JrIGNvcnJlY3RseSBpbiBib3RoIEVTNSBhbmQgRVM2IG1vZGVzIVxuICAgIH07XG5cbiAgICB2YXIgQVNTRVJUO1xuICAgIGlmICh0eXBlb2YgYXNzZXJ0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEFTU0VSVCA9IGZ1bmN0aW9uIEppc29uQXNzZXJ0KGNvbmQsIG1zZykge1xuICAgICAgICAgICAgaWYgKCFjb25kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnRpb24gZmFpbGVkOiAnICsgKG1zZyB8fCAnKioqJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEFTU0VSVCA9IGFzc2VydDtcbiAgICB9XG5cbiAgICB0aGlzLnl5R2V0U2hhcmVkU3RhdGUgPSBmdW5jdGlvbiB5eUdldFNoYXJlZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXk7XG4gICAgfTtcblxuXG4gICAgLy8gc2hhbGxvdyBjbG9uZSBvYmplY3RzLCBzdHJhaWdodCBjb3B5IG9mIHNpbXBsZSBgc3JjYCB2YWx1ZXNcbiAgICAvLyBlLmcuIGBsZXhlci55eXRleHRgIE1BWSBiZSBhIGNvbXBsZXggdmFsdWUgb2JqZWN0LFxuICAgIC8vIHJhdGhlciB0aGFuIGEgc2ltcGxlIHN0cmluZy92YWx1ZS5cbiAgICBmdW5jdGlvbiBzaGFsbG93X2NvcHkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGRzdCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZHN0W2tdID0gc3JjW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd19jb3B5X25vY2xvYmJlcihkc3QsIHNyYykge1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkc3Rba10gPT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIGspKSB7XG4gICAgICAgICAgICAgICAgZHN0W2tdID0gc3JjW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlfeXlsbG9jKGxvYykge1xuICAgICAgICB2YXIgcnYgPSBzaGFsbG93X2NvcHkobG9jKTtcbiAgICAgICAgaWYgKHJ2ICYmIHJ2LnJhbmdlKSB7XG4gICAgICAgICAgICBydi5yYW5nZSA9IHJ2LnJhbmdlLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHN0YXRlXG4gICAgc2hhbGxvd19jb3B5X25vY2xvYmJlcihzaGFyZWRTdGF0ZV95eSwgdGhpcy55eSk7XG5cbiAgICBzaGFyZWRTdGF0ZV95eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlX3l5LnBhcnNlciA9IHRoaXM7XG5cblxuXG5cblxuXG4gICAgLy8gRG9lcyB0aGUgc2hhcmVkIHN0YXRlIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCB0aGF0IGFscmVhZHkgY29tZXMgd2l0aCB0aGlzIGluc3RhbmNlP1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGVfeXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBmdW5jdGlvbiBwYXJzZUVycm9yQWx0KHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25QYXJzZXJFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFyZWRTdGF0ZV95eS5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy5vcmlnaW5hbFBhcnNlRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gRG9lcyB0aGUgc2hhcmVkIHN0YXRlIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBxdW90ZU5hbWVgIHRoYXQgYWxyZWFkeSBjb21lcyB3aXRoIHRoaXMgaW5zdGFuY2U/XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZV95eS5xdW90ZU5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSBmdW5jdGlvbiBxdW90ZU5hbWVBbHQoaWRfc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXkucXVvdGVOYW1lLmNhbGwodGhpcywgaWRfc3RyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1b3RlTmFtZSA9IHRoaXMub3JpZ2luYWxRdW90ZU5hbWU7XG4gICAgfVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjbGVhbnVwIGZ1bmN0aW9uOyBtYWtlIGl0IGFuIEFQSSBzbyB0aGF0IGV4dGVybmFsIGNvZGUgY2FuIHJlLXVzZSB0aGlzIG9uZSBpbiBjYXNlIG9mXG4gICAgLy8gY2FsYW1pdGllcyBvciB3aGVuIHRoZSBgJW9wdGlvbnMgbm8tdHJ5LWNhdGNoYCBvcHRpb24gaGFzIGJlZW4gc3BlY2lmaWVkIGZvciB0aGUgZ3JhbW1hciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHRoaXMgcGFyc2UoKSBBUEkgbWV0aG9kIGRvZXNuJ3QgY29tZSB3aXRoIGEgYGZpbmFsbHkgeyAuLi4gfWAgYmxvY2sgYW55IG1vcmUhXG4gICAgLy9cbiAgICAvLyBOT1RFOiBhcyB0aGlzIEFQSSB1c2VzIHBhcnNlKCkgYXMgYSBjbG9zdXJlLCBpdCBNVVNUIGJlIHNldCBhZ2FpbiBvbiBldmVyeSBwYXJzZSgpIGludm9jYXRpb24sXG4gICAgLy8gICAgICAgb3IgZWxzZSB5b3VyIGBzaGFyZWRTdGF0ZWAsIGV0Yy4gcmVmZXJlbmNlcyB3aWxsIGJlICp3cm9uZyohXG4gICAgdGhpcy5jbGVhbnVwQWZ0ZXJQYXJzZSA9IGZ1bmN0aW9uIHBhcnNlcl9jbGVhbnVwQWZ0ZXJQYXJzZShyZXN1bHRWYWx1ZSwgaW52b2tlX3Bvc3RfbWV0aG9kcywgZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICB2YXIgcnY7XG5cbiAgICAgICAgaWYgKGludm9rZV9wb3N0X21ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBoYXNoO1xuXG4gICAgICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZSB8fCB0aGlzLnBvc3RfcGFyc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlOiB3ZSByZS11c2UgdGhpcyBBUEkgaW4gYSAqKm5vbi1lcnJvciBzaXR1YXRpb24qKlxuICAgICAgICAgICAgICAgIC8vIGFzIHRoaXMgb25lIGRlbGl2ZXJzIGFsbCBwYXJzZXIgaW50ZXJuYWxzIHJlYWR5IGZvciBhY2Nlc3MgYnkgdXNlcmxhbmQgY29kZS5cbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhudWxsIC8qIG5vIGVycm9yISAqLywgbnVsbCAvKiBubyBleGNlcHRpb24hICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eS5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgcnYgPSBzaGFyZWRTdGF0ZV95eS5wb3N0X3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXksIHJlc3VsdFZhbHVlLCBoYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAndW5kZWZpbmVkJykgcmVzdWx0VmFsdWUgPSBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvc3RfcGFyc2UpIHtcbiAgICAgICAgICAgICAgICBydiA9IHRoaXMucG9zdF9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5LCByZXN1bHRWYWx1ZSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFZhbHVlID0gcnY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFudXA6XG4gICAgICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBoYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGggPiAxKSByZXR1cm4gcmVzdWx0VmFsdWU7ICAgICAgICAvLyBkbyBub3QgKHlldCkga2lsbCB0aGUgc2hhcmVkU3RhdGUgd2hlbiB0aGlzIGlzIGEgcmVlbnRyYW50IHJ1bi5cblxuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgbGluZ2VyaW5nIGxleGVyIHN0cnVjdHVyZXMgYXMgd2VsbDpcbiAgICAgICAgaWYgKGxleGVyLmNsZWFudXBBZnRlckxleCkge1xuICAgICAgICAgICAgbGV4ZXIuY2xlYW51cEFmdGVyTGV4KGRvX25vdF9udWtlX2Vycm9yaW5mb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCBsaW5nZXJpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBmcm9tIGNhdXNpbmcgbWVtb3J5IGxlYWtzOlxuICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LmxleGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2hhcmVkU3RhdGVfeXkucGFyc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGxleGVyLnl5ID09PSBzaGFyZWRTdGF0ZV95eSkge1xuICAgICAgICAgICAgICAgIGxleGVyLnl5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYXJlZFN0YXRlX3l5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0aGlzLm9yaWdpbmFsUGFyc2VFcnJvcjtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSB0aGlzLm9yaWdpbmFsUXVvdGVOYW1lO1xuXG4gICAgICAgIC8vIG51a2UgdGhlIHZzdGFja1tdIGFycmF5IGF0IGxlYXN0IGFzIHRoYXQgb25lIHdpbGwgc3RpbGwgcmVmZXJlbmNlIG9ic29sZXRlZCB1c2VyIHZhbHVlcy5cbiAgICAgICAgLy8gVG8gYmUgc2FmZSwgd2UgbnVrZSB0aGUgb3RoZXIgaW50ZXJuYWwgc3RhY2sgY29sdW1ucyBhcyB3ZWxsLi4uXG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgLy8gZmFzdGVzdCB3YXkgdG8gbnVrZSBhbiBhcnJheSB3aXRob3V0IG92ZXJseSBib3RoZXJpbmcgdGhlIEdDXG4gICAgICAgIHNzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHNwID0gMDtcblxuICAgICAgICAvLyBudWtlIHRoZSBlcnJvciBoYXNoIGluZm8gaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcnVuLlxuICAgICAgICAvLyBVc2VybGFuZCBjb2RlIG11c3QgQ09QWSBhbnkgZGF0YS9yZWZlcmVuY2VzXG4gICAgICAgIC8vIGluIHRoZSBlcnJvciBoYXNoIGluc3RhbmNlKHMpIGl0IGlzIG1vcmUgcGVybWFuZW50bHkgaW50ZXJlc3RlZCBpbi5cbiAgICAgICAgaWYgKCFkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fX2Vycm9yX2luZm9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fX2Vycm9yX2luZm9zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlbC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLmxlbmd0aCA9IDA7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBtZXJnZSB5eWxsb2MgaW5mbyBpbnRvIGEgbmV3IHl5bGxvYyBpbnN0YW5jZS5cbiAgICAvL1xuICAgIC8vIGBmaXJzdF9pbmRleGAgYW5kIGBsYXN0X2luZGV4YCBNQVkgYmUgVU5ERUZJTkVEL05VTEwgb3IgdGhlc2UgYXJlIGluZGV4ZXMgaW50byB0aGUgYGxzdGFja1tdYCBsb2NhdGlvbiBzdGFjayBhcnJheS5cbiAgICAvL1xuICAgIC8vIGBmaXJzdF95eWxsb2NgIGFuZCBgbGFzdF95eWxsb2NgIE1BWSBiZSBVTkRFRklORUQvTlVMTCBvciBleHBsaWNpdCAoY3VzdG9tIG9yIHJlZ3VsYXIpIGB5eWxsb2NgIGluc3RhbmNlcywgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHRoZXNlIG92ZXJyaWRlIHRoZSBjb3JyZXNwb25kaW5nIGZpcnN0L2xhc3QgaW5kZXhlcy5cbiAgICAvL1xuICAgIC8vIGBkb250X2xvb2tfYmFja2AgaXMgYW4gb3B0aW9uYWwgZmxhZyAoZGVmYXVsdDogRkFMU0UpLCB3aGljaCBpbnN0cnVjdHMgdGhpcyBtZXJnZSBvcGVyYXRpb24gTk9UIHRvIHNlYXJjaFxuICAgIC8vIHRocm91Z2ggdGhlIHBhcnNlIGxvY2F0aW9uIHN0YWNrIGZvciBhIGxvY2F0aW9uLCB3aGljaCB3b3VsZCBvdGhlcndpc2UgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIG5ldyAoZXBzaWxvbiEpXG4gICAgLy8geXlsbG9jIGluZm8uXG4gICAgLy9cbiAgICAvLyBOb3RlOiBlcHNpbG9uIHJ1bGUncyB5eWxsb2Mgc2l0dWF0aW9uIGlzIGRldGVjdGVkIGJ5IHBhc3NpbmcgYm90aCBgZmlyc3RfaW5kZXhgIGFuZCBgZmlyc3RfeXlsbG9jYCBhcyBVTkRFRklORUQvTlVMTC5cbiAgICB0aGlzLnl5TWVyZ2VMb2NhdGlvbkluZm8gPSBmdW5jdGlvbiBwYXJzZXJfeXlNZXJnZUxvY2F0aW9uSW5mbyhmaXJzdF9pbmRleCwgbGFzdF9pbmRleCwgZmlyc3RfeXlsbG9jLCBsYXN0X3l5bGxvYywgZG9udF9sb29rX2JhY2spIHtcbiAgICAgICAgdmFyIGkxID0gZmlyc3RfaW5kZXggfCAwLFxuICAgICAgICAgICAgaTIgPSBsYXN0X2luZGV4IHwgMDtcbiAgICAgICAgdmFyIGwxID0gZmlyc3RfeXlsbG9jLFxuICAgICAgICAgICAgbDIgPSBsYXN0X3l5bGxvYztcbiAgICAgICAgdmFyIHJ2O1xuXG4gICAgICAgIC8vIHJ1bGVzOlxuICAgICAgICAvLyAtIGZpcnN0L2xhc3QgeXlsbG9jIGVudHJpZXMgb3ZlcnJpZGUgZmlyc3QvbGFzdCBpbmRleGVzXG5cbiAgICAgICAgaWYgKCFsMSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaTE7IGkgPD0gaTI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsMSA9IGxzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbDIpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaTI7IGkgPj0gaTE7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsMiA9IGxzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0gZGV0ZWN0IGlmIGFuIGVwc2lsb24gcnVsZSBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIGFjdCBhY2NvcmRpbmdseTpcbiAgICAgICAgaWYgKCFsMSAmJiBmaXJzdF9pbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlcHNpbG9uIHJ1bGUgc3BhbiBtZXJnZXIuIFdpdGggb3B0aW9uYWwgbG9vay1haGVhZCBpbiBsMi5cbiAgICAgICAgICAgIGlmICghZG9udF9sb29rX2JhY2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKGkxIHx8IHNwKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGwxID0gbHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsMSkge1xuICAgICAgICAgICAgICAgIGlmICghbDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSBzdGlsbCBkb24ndCBoYXZlIGFueSB2YWxpZCB5eWxsb2MgaW5mbywgd2UncmUgbG9va2luZyBhdCBhbiBlcHNpbG9uIHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBsb29rLWFoZWFkIGFuZCBubyBwcmVjZWRpbmcgdGVybXMgYW5kL29yIGBkb250X2xvb2tfYmFja2Agc2V0OlxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2EgZG8gbm90aGluZyBidXQgcmV0dXJuIE5VTEwvVU5ERUZJTkVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYWxsb3ctY29weSBMMjogYWZ0ZXIgYWxsLCB3ZSBNQVkgYmUgbG9va2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhdCB1bmNvbnZlbnRpb25hbCB5eWxsb2MgaW5mbyBvYmplY3RzLi4uXG4gICAgICAgICAgICAgICAgICAgIHJ2ID0gc2hhbGxvd19jb3B5KGwyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ2LnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93IGNvcHkgdGhlIHl5bGxvYyByYW5nZXMgaW5mbyB0byBwcmV2ZW50IHVzIGZyb20gbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMnIGVudHJpZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICBydi5yYW5nZSA9IHJ2LnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNoYWxsb3ctY29weSBMMSwgdGhlbiBhZGp1c3QgZmlyc3QgY29sL3JvdyAxIGNvbHVtbiBwYXN0IHRoZSBlbmQuXG4gICAgICAgICAgICAgICAgcnYgPSBzaGFsbG93X2NvcHkobDEpO1xuICAgICAgICAgICAgICAgIHJ2LmZpcnN0X2xpbmUgPSBydi5sYXN0X2xpbmU7XG4gICAgICAgICAgICAgICAgcnYuZmlyc3RfY29sdW1uID0gcnYubGFzdF9jb2x1bW47XG4gICAgICAgICAgICAgICAgaWYgKHJ2LnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYWxsb3cgY29weSB0aGUgeXlsbG9jIHJhbmdlcyBpbmZvIHRvIHByZXZlbnQgdXMgZnJvbSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cycgZW50cmllczpcbiAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2VbMF0gPSBydi5yYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdy1taXhpbiBMMiwgdGhlbiBhZGp1c3QgbGFzdCBjb2wvcm93IGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgICAgICAgICBzaGFsbG93X2NvcHlfbm9jbG9iYmVyKHJ2LCBsMik7XG4gICAgICAgICAgICAgICAgICAgIHJ2Lmxhc3RfbGluZSA9IGwyLmxhc3RfbGluZTtcbiAgICAgICAgICAgICAgICAgICAgcnYubGFzdF9jb2x1bW4gPSBsMi5sYXN0X2NvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ2LnJhbmdlICYmIGwyLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydi5yYW5nZVsxXSA9IGwyLnJhbmdlWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgIGwxID0gbDI7XG4gICAgICAgICAgICBsMiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNoYWxsb3ctY29weSBMMXxMMiwgYmVmb3JlIHdlIHRyeSB0byBhZGp1c3QgdGhlIHl5bGxvYyB2YWx1ZXM6IGFmdGVyIGFsbCwgd2UgTUFZIGJlIGxvb2tpbmdcbiAgICAgICAgLy8gYXQgdW5jb252ZW50aW9uYWwgeXlsbG9jIGluZm8gb2JqZWN0cy4uLlxuICAgICAgICBydiA9IHNoYWxsb3dfY29weShsMSk7XG5cbiAgICAgICAgLy8gZmlyc3RfbGluZTogLi4uLFxuICAgICAgICAvLyBmaXJzdF9jb2x1bW46IC4uLixcbiAgICAgICAgLy8gbGFzdF9saW5lOiAuLi4sXG4gICAgICAgIC8vIGxhc3RfY29sdW1uOiAuLi4sXG4gICAgICAgIGlmIChydi5yYW5nZSkge1xuICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHRoZSB5eWxsb2MgcmFuZ2VzIGluZm8gdG8gcHJldmVudCB1cyBmcm9tIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzJyBlbnRyaWVzOlxuICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsMikge1xuICAgICAgICAgICAgc2hhbGxvd19jb3B5X25vY2xvYmJlcihydiwgbDIpO1xuICAgICAgICAgICAgcnYubGFzdF9saW5lID0gbDIubGFzdF9saW5lO1xuICAgICAgICAgICAgcnYubGFzdF9jb2x1bW4gPSBsMi5sYXN0X2NvbHVtbjtcbiAgICAgICAgICAgIGlmIChydi5yYW5nZSAmJiBsMi5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHJ2LnJhbmdlWzFdID0gbDIucmFuZ2VbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfTtcblxuICAgIC8vIE5PVEU6IGFzIHRoaXMgQVBJIHVzZXMgcGFyc2UoKSBhcyBhIGNsb3N1cmUsIGl0IE1VU1QgYmUgc2V0IGFnYWluIG9uIGV2ZXJ5IHBhcnNlKCkgaW52b2NhdGlvbixcbiAgICAvLyAgICAgICBvciBlbHNlIHlvdXIgYGxleGVyYCwgYHNoYXJlZFN0YXRlYCwgZXRjLiByZWZlcmVuY2VzIHdpbGwgYmUgKndyb25nKiFcbiAgICB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvID0gZnVuY3Rpb24gcGFyc2VyX2NvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKG1zZywgZXgsIGV4cGVjdGVkLCByZWNvdmVyYWJsZSkge1xuICAgICAgICB2YXIgcGVpID0ge1xuICAgICAgICAgICAgZXJyU3RyOiBtc2csXG4gICAgICAgICAgICBleGNlcHRpb246IGV4LFxuICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICB2YWx1ZTogbGV4ZXIueXl0ZXh0LFxuICAgICAgICAgICAgdG9rZW46IHRoaXMuZGVzY3JpYmVTeW1ib2woc3ltYm9sKSB8fCBzeW1ib2wsXG4gICAgICAgICAgICB0b2tlbl9pZDogc3ltYm9sLFxuICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICBsb2M6IGNvcHlfeXlsbG9jKGxleGVyLnl5bGxvYyksXG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICByZWNvdmVyYWJsZTogcmVjb3ZlcmFibGUsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIG5ld19zdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICBzeW1ib2xfc3RhY2s6IHN0YWNrLFxuICAgICAgICAgICAgc3RhdGVfc3RhY2s6IHNzdGFjayxcbiAgICAgICAgICAgIHZhbHVlX3N0YWNrOiB2c3RhY2ssXG4gICAgICAgICAgICBsb2NhdGlvbl9zdGFjazogbHN0YWNrLFxuICAgICAgICAgICAgc3RhY2tfcG9pbnRlcjogc3AsXG4gICAgICAgICAgICB5eTogc2hhcmVkU3RhdGVfeXksXG4gICAgICAgICAgICBsZXhlcjogbGV4ZXIsXG4gICAgICAgICAgICBwYXJzZXI6IHRoaXMsXG5cbiAgICAgICAgICAgIC8vIGFuZCBtYWtlIHN1cmUgdGhlIGVycm9yIGluZm8gZG9lc24ndCBzdGF5IGR1ZSB0byBwb3RlbnRpYWxcbiAgICAgICAgICAgIC8vIHJlZiBjeWNsZSB2aWEgdXNlcmxhbmQgY29kZSBtYW5pcHVsYXRpb25zLlxuICAgICAgICAgICAgLy8gVGhlc2Ugd291bGQgb3RoZXJ3aXNlIGFsbCBiZSBtZW1vcnkgbGVhayBvcHBvcnR1bml0aWVzIVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbmx5IGFycmF5IGFuZCBvYmplY3QgcmVmZXJlbmNlcyBhcmUgbnVrZWQgYXMgdGhvc2VcbiAgICAgICAgICAgIC8vIGNvbnN0aXR1dGUgdGhlIHNldCBvZiBlbGVtZW50cyB3aGljaCBjYW4gcHJvZHVjZSBhIGN5Y2xpYyByZWYuXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbWVtYmVycyBpcyBrZXB0IGludGFjdCBhcyB0aGV5IGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3RydWN0UGFyc2VFcnJvckluZm8oKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGN5Y2xpYyByZWZlcmVuY2VzIGFkZGVkIHRvIGVycm9yIGluZm86XG4gICAgICAgICAgICAgICAgLy8gaW5mby55eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gaW5mby5sZXhlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gaW5mby52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gaW5mby52YWx1ZV9zdGFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gLi4uXG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9ICEhdGhpcy5yZWNvdmVyYWJsZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyYWJsZSA9IHJlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHJhY2sgdGhpcyBpbnN0YW5jZSBzbyB3ZSBjYW4gYGRlc3Ryb3koKWAgaXQgb25jZSB3ZSBkZWVtIGl0IHN1cGVyZmx1b3VzIGFuZCByZWFkeSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIVxuICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MucHVzaChwZWkpO1xuICAgICAgICByZXR1cm4gcGVpO1xuICAgIH07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICBmdW5jdGlvbiBnZXROb25UZXJtaW5hbEZyb21Db2RlKHN5bWJvbCkge1xuICAgICAgICB2YXIgdG9rZW5OYW1lID0gc2VsZi5nZXRTeW1ib2xOYW1lKHN5bWJvbCk7XG4gICAgICAgIGlmICghdG9rZW5OYW1lKSB7XG4gICAgICAgICAgICB0b2tlbk5hbWUgPSBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuTmFtZTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4ZXIubGV4KCk7XG4gICAgICAgIC8vIGlmIHRva2VuIGlzbid0IGl0cyBudW1lcmljIHZhbHVlLCBjb252ZXJ0XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IEVPRjtcbiAgICB9XG5cblxuICAgIHZhciBzdGF0ZSwgYWN0aW9uLCByLCB0O1xuICAgIHZhciB5eXZhbCA9IHtcbiAgICAgICAgJDogdHJ1ZSxcbiAgICAgICAgXyQ6IHVuZGVmaW5lZCxcbiAgICAgICAgeXk6IHNoYXJlZFN0YXRlX3l5XG4gICAgfTtcbiAgICB2YXIgcDtcbiAgICB2YXIgeXlydWxlbGVuO1xuICAgIHZhciB0aGlzX3Byb2R1Y3Rpb247XG4gICAgdmFyIG5ld1N0YXRlO1xuICAgIHZhciByZXR2YWwgPSBmYWxzZTtcblxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoKys7XG5cbiAgICAgICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlX3l5KTtcblxuICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgbHN0YWNrW3NwXSA9IHl5bG9jO1xuICAgICAgICB2c3RhY2tbc3BdID0gbnVsbDtcbiAgICAgICAgc3N0YWNrW3NwXSA9IDA7XG4gICAgICAgIHN0YWNrW3NwXSA9IDA7XG4gICAgICAgICsrc3A7XG5cblxuXG5cblxuICAgICAgICBpZiAodGhpcy5wcmVfcGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJlX3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eS5wcmVfcGFyc2UpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LnByZV9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1N0YXRlID0gc3N0YWNrW3NwIC0gMV07XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTsgICAgICAgICAgICAgICAvLyBzc3RhY2tbc3AgLSAxXTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHQgYWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IDI7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpbmdsZSBgPT1gIGNvbmRpdGlvbiBiZWxvdyBjb3ZlcnMgYm90aCB0aGVzZSBgPT09YCBjb21wYXJpc29ucyBpbiBhIHNpbmdsZVxuICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT09ICd1bmRlZmluZWQnKSAuLi5cbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhZCBhY3Rpb24gZm9yIGN1cnJlbnQgc3RhdGUgYW5kIGZpcnN0IGlucHV0XG4gICAgICAgICAgICAgICAgdCA9ICh0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF0pIHx8IE5PX0FDVElPTjtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRbMV07XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gdFswXTtcblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHBhcnNlIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN0cjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN5bWJvbERlc2NyID0gKHRoaXMuZGVzY3JpYmVTeW1ib2woc3ltYm9sKSB8fCBzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSB0aGlzLmNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXhlci55eWxpbmVubyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAobGV4ZXIueXlsaW5lbm8gKyAxKSArICc6ICc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3I6ICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXhlci5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnXFxuJyArIGxleGVyLnNob3dQb3NpdGlvbig3OSAtIDEwLCAxMCkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ0V4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCB1bmV4cGVjdGVkICcgKyBlcnJTeW1ib2xEZXNjcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnVW5leHBlY3RlZCAnICsgZXJyU3ltYm9sRGVzY3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlY292ZXIgZnJvbSB0aGUgZXJyb3IhXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKGVyclN0ciwgbnVsbCwgZXhwZWN0ZWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfVxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgLy8gY2F0Y2ggbWlzYy4gcGFyc2UgZmFpbHVyZXM6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgdW5sZXNzIHJlc29sdmUgZGVmYXVsdHMgYXJlIG9mZlxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sLCBudWxsLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFub3RoZXIgY2FzZSBvZiBiZXR0ZXIgc2FmZSB0aGFuIHNvcnJ5OiBpbiBjYXNlIHN0YXRlIHRyYW5zaXRpb25zIGNvbWUgb3V0IG9mIGFub3RoZXIgZXJyb3IgcmVjb3ZlcnkgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIG9yIGEgYnVnZ3kgTFVUIChMb29rVXAgVGFibGUpOlxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdQYXJzaW5nIGhhbHRlZC4gTm8gdmlhYmxlIGVycm9yIHJlY292ZXJ5IGFwcHJvYWNoIGF2YWlsYWJsZSBkdWUgdG8gaW50ZXJuYWwgc3lzdGVtIGZhaWx1cmUuJywgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gc2hpZnQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc3RhY2tbc3BdID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgIHZzdGFja1tzcF0gPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgbHN0YWNrW3NwXSA9IGNvcHlfeXlsbG9jKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICAgICAgc3N0YWNrW3NwXSA9IG5ld1N0YXRlOyAvLyBwdXNoIHN0YXRlXG5cbiAgICAgICAgICAgICAgICArK3NwO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHVwIHRoZSBsZXhlciBkZXRhaWxzIGZvciB0aGUgY3VycmVudCBzeW1ib2wgYXMgdGhhdCBvbmUgaXMgbm90ICdsb29rLWFoZWFkJyBhbnkgbW9yZTpcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgXG5cblxuXG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gcmVkdWNlOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXNfcHJvZHVjdGlvbiA9IHRoaXMucHJvZHVjdGlvbnNfW25ld1N0YXRlIC0gMV07ICAvLyBgdGhpcy5wcm9kdWN0aW9uc19bXWAgaXMgemVyby1iYXNlZCBpbmRleGVkIHdoaWxlIHN0YXRlcyBzdGFydCBmcm9tIDEgdXB3YXJkcy4uLlxuICAgICAgICAgICAgICAgIHl5cnVsZWxlbiA9IHRoaXNfcHJvZHVjdGlvblsxXTtcblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXlsb2MsIG5ld1N0YXRlLCBzcCAtIDEsIHZzdGFjaywgbHN0YWNrKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcG9wIG9mZiBzdGFja1xuICAgICAgICAgICAgICAgIHNwIC09IHl5cnVsZWxlbjtcblxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSB0aGUgYHN5bWJvbGAgdmFyaWFibGU6IHVzZSBhIGxvY2FsIHZhciB0byBzcGVlZCB0aGluZ3MgdXA6XG4gICAgICAgICAgICAgICAgdmFyIG50c3ltYm9sID0gdGhpc19wcm9kdWN0aW9uWzBdOyAgICAvLyBwdXNoIG5vbnRlcm1pbmFsIChyZWR1Y2UpXG4gICAgICAgICAgICAgICAgc3RhY2tbc3BdID0gbnRzeW1ib2w7XG4gICAgICAgICAgICAgICAgdnN0YWNrW3NwXSA9IHl5dmFsLiQ7XG4gICAgICAgICAgICAgICAgbHN0YWNrW3NwXSA9IHl5dmFsLl8kO1xuICAgICAgICAgICAgICAgIC8vIGdvdG8gbmV3IHN0YXRlID0gdGFibGVbU1RBVEVdW05PTlRFUk1JTkFMXVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3N0YWNrW3NwIC0gMV1dW250c3ltYm9sXTtcbiAgICAgICAgICAgICAgICBzc3RhY2tbc3BdID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgKytzcDtcblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gYWNjZXB0OlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBgJGFjY2VwdGAgcnVsZSdzIGAkJGAgcmVzdWx0LCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBKSVNPTiBhbHdheXMgYWRkcyB0aGlzIHRvcC1tb3N0IGAkYWNjZXB0YCBydWxlICh3aXRoIGltcGxpY2l0LFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQsIGFjdGlvbik6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgJGFjY2VwdDogPHN0YXJ0U3ltYm9sPiAkZW5kXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAleyAkJCA9ICQxOyBAJCA9IEAxOyAlfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gd2hpY2gsIGNvbWJpbmVkIHdpdGggdGhlIHBhcnNlIGtlcm5lbCdzIGAkYWNjZXB0YCBzdGF0ZSBiZWhhdmlvdXIgY29kZWQgYmVsb3csXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBwcm9kdWNlIHRoZSBgJCRgIHZhbHVlIG91dHB1dCBvZiB0aGUgPHN0YXJ0U3ltYm9sPiBydWxlIGFzIHRoZSBwYXJzZSByZXN1bHQsXG4gICAgICAgICAgICAgICAgLy8gSUZGIHRoYXQgcmVzdWx0IGlzICpub3QqIGB1bmRlZmluZWRgLiAoU2VlIGFsc28gdGhlIHBhcnNlciBrZXJuZWwgY29kZS4pXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiBjb2RlOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAle1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIEAkID0gQDE7ICAgICAgICAgICAgLy8gaWYgbG9jYXRpb24gdHJhY2tpbmcgc3VwcG9ydCBpcyBpbmNsdWRlZFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgJDEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDE7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IHBhcnNlIHJlc3VsdCBpZiB0aGUgcnVsZSBhY3Rpb25zIGRvbid0IHByb2R1Y2UgYW55dGhpbmdcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICV9XG4gICAgICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZzdGFja1tzcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHZzdGFja1tzcF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJyZWFrIG91dCBvZiBsb29wOiB3ZSBhY2NlcHQgb3IgZmFpbCB3aXRoIGVycm9yXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIHJlcG9ydCBleGNlcHRpb25zIHRocm91Z2ggdGhlIHBhcnNlRXJyb3IgY2FsbGJhY2sgdG9vLCBidXQga2VlcCB0aGUgZXhjZXB0aW9uIGludGFjdFxuICAgICAgICAvLyBpZiBpdCBpcyBhIGtub3duIHBhcnNlciBvciBsZXhlciBlcnJvciB3aGljaCBoYXMgYmVlbiB0aHJvd24gYnkgcGFyc2VFcnJvcigpIGFscmVhZHk6XG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIHRoaXMuSmlzb25QYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV4ZXIgJiYgdHlwZW9mIGxleGVyLkppc29uTGV4ZXJFcnJvciA9PT0gJ2Z1bmN0aW9uJyAmJiBleCBpbnN0YW5jZW9mIGxleGVyLkppc29uTGV4ZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2luZyBhYm9ydGVkIGR1ZSB0byBleGNlcHRpb24uJywgZXgsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHZhbCA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJldHZhbCA9IHRoaXMuY2xlYW51cEFmdGVyUGFyc2UocmV0dmFsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoLS07XG4gICAgfSAgIC8vIC9maW5hbGx5XG5cbiAgICByZXR1cm4gcmV0dmFsO1xufVxufTtcbnBhcnNlci5vcmlnaW5hbFBhcnNlRXJyb3IgPSBwYXJzZXIucGFyc2VFcnJvcjtcbnBhcnNlci5vcmlnaW5hbFF1b3RlTmFtZSA9IHBhcnNlci5xdW90ZU5hbWU7XG5cblxuLyogbGV4ZXIgZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjYuMS0yMDMgKi9cblxuLypcbiAqIFJldHVybnMgYSBMZXhlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIExleGVyOiB7XG4gKiAgICB5eToge30gICAgIFRoZSBzby1jYWxsZWQgXCJzaGFyZWQgc3RhdGVcIiBvciByYXRoZXIgdGhlICpzb3VyY2UqIG9mIGl0O1xuICogICAgICAgICAgICAgICB0aGUgcmVhbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgcGFzc2VkIGFyb3VuZCB0b1xuICogICAgICAgICAgICAgICB0aGUgcnVsZSBhY3Rpb25zLCBldGMuIGlzIGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgXCJzaGFyZWQgY29udGV4dFwiIG9iamVjdCB3YXMgcGFzc2VkIHRvIHRoZSBsZXhlciBieSB3YXkgb2YgXG4gKiAgICAgICAgICAgICAgIHRoZSBgbGV4ZXIuc2V0SW5wdXQoc3RyLCB5eSlgIEFQSSBiZWZvcmUgeW91IG1heSB1c2UgaXQuXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSBsZXhlciBhY3Rpb24gY29kZSBpbiBgcGVyZm9ybUFjdGlvbigpYFxuICogICAgICAgICAgICAgICBzbyB1c2VybGFuZCBjb2RlIGluIHRoZSBsZXhlciBhY3Rpb25zIG1heSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBvdXRzaWRlIHdvcmxkIFxuICogICAgICAgICAgICAgICBhbmQvb3Igb3RoZXIgbGV4ZXIgcnVsZXMnIGFjdGlvbnMgaW4gbW9yZSBvciBsZXNzIGNvbXBsZXggd2F5cy5cbiAqXG4gKiAgfVxuICpcbiAqICBMZXhlci5wcm90b3R5cGU6IHtcbiAqICAgIEVPRjogMSxcbiAqICAgIEVSUk9SOiAyLFxuICpcbiAqICAgIHl5OiAgICAgICAgVGhlIG92ZXJhbGwgXCJzaGFyZWQgY29udGV4dFwiIG9iamVjdCByZWZlcmVuY2UuXG4gKlxuICogICAgSmlzb25MZXhlckVycm9yOiBmdW5jdGlvbihtc2csIGhhc2gpLFxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGxleGVyX19wZXJmb3JtQWN0aW9uKHl5LCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSxcbiAqXG4gKiAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFuZCBgdGhpc2AgaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlL21lYW5pbmc6XG4gKiAgICAgICAgICAgICAgIC0gYHRoaXNgICAgIDogcmVmZXJlbmNlIHRvIHRoZSBgbGV4ZXJgIGluc3RhbmNlLiBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB5eV9gIGlzIGFuIGFsaWFzIGZvciBgdGhpc2AgbGV4ZXIgaW5zdGFuY2UgcmVmZXJlbmNlIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5YCAgICAgIDogYSByZWZlcmVuY2UgdG8gdGhlIGB5eWAgXCJzaGFyZWQgc3RhdGVcIiBvYmplY3Qgd2hpY2ggd2FzIHBhc3NlZCB0byB0aGUgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSB3YXkgb2YgdGhlIGBsZXhlci5zZXRJbnB1dChzdHIsIHl5KWAgQVBJIGJlZm9yZS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmEgYXJndW1lbnRzIHlvdSBzcGVjaWZpZWQgaW4gdGhlIGAlcGFyc2UtcGFyYW1gIHN0YXRlbWVudCBpbiB5b3VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKipwYXJzZXIqKiBncmFtbWFyIGRlZmluaXRpb24gZmlsZSBhcmUgcGFzc2VkIHRvIHRoZSBsZXhlciB2aWEgdGhpcyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZW51bWJlcmAgICA6IGluZGV4IG9mIHRoZSBtYXRjaGVkIGxleGVyIHJ1bGUgKHJlZ2V4KSwgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqICAgICAgICAgICAgICAgLSBgWVlfU1RBUlRgOiB0aGUgY3VycmVudCBsZXhlciBcInN0YXJ0IGNvbmRpdGlvblwiIHN0YXRlLlxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICpcbiAqICAgIGNvbnN0cnVjdExleEVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgaXNfcmVjb3ZlcmFibGUpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2VzIGEgbmV3IGVycm9ySW5mbyAnaGFzaCBvYmplY3QnIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBgcGFyc2VFcnJvcigpYC5cbiAqICAgICAgICAgICAgICAgU2VlIGl0J3MgdXNlIGluIHRoaXMgbGV4ZXIga2VybmVsIGluIG1hbnkgcGxhY2VzOyBleGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICAgICAgICAgICAgICAgIHZhciBpbmZvT2JqID0gbGV4ZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgdHJ1ZSk7XG4gKiAgICAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gbGV4ZXIucGFyc2VFcnJvcihpbmZvT2JqLmVyclN0ciwgaW5mb09iaiwgbGV4ZXIuSmlzb25MZXhlckVycm9yKTtcbiAqXG4gKiAgICBvcHRpb25zOiB7IC4uLiBsZXhlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBsZXg6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2Ugb25lIHRva2VuIG9mIGxleGVkIGlucHV0LCB3aGljaCB3YXMgcGFzc2VkIGluIGVhcmxpZXIgdmlhIHRoZSBgbGV4ZXIuc2V0SW5wdXQoKWAgQVBJLlxuICogICAgICAgICAgICAgICBZb3UgTUFZIHVzZSB0aGUgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyBhcyBwZXIgYCVwYXJzZS1wYXJhbWAgc3BlYyBvZiB0aGUgKipsZXhlcioqIGdyYW1tYXI6XG4gKiAgICAgICAgICAgICAgIHRoZXNlIGV4dHJhIGBhcmdzLi4uYCBhcmUgYWRkZWQgdmVyYmF0aW0gdG8gdGhlIGB5eWAgb2JqZWN0IHJlZmVyZW5jZSBhcyBtZW1iZXIgdmFyaWFibGVzLlxuICpcbiAqICAgICAgICAgICAgICAgV0FSTklORzpcbiAqICAgICAgICAgICAgICAgTGV4ZXIncyBhZGRpdGlvbmFsIGBhcmdzLi4uYCBwYXJhbWV0ZXJzICh2aWEgbGV4ZXIncyBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSAqKnBhcnNlcioqIG9yIHRoZSBqaXNvbiBydW4tdGltZTsgXG4gKiAgICAgICAgICAgICAgIHdoZW4gc3VjaCBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCBhbiBleGNlcHRpb24gaXMgdGhyb3duIHRvIHByZXZlbnQgdGhlIGdlbmVyYXRlZCBydW4tdGltZSBcbiAqICAgICAgICAgICAgICAgZnJvbSBzaWxlbnRseSBhY2NlcHRpbmcgdGhpcyBjb25mdXNpbmcgYW5kIHBvdGVudGlhbGx5IGhhemFyZG91cyBzaXR1YXRpb24hIFxuICpcbiAqICAgIGNsZWFudXBBZnRlckxleDogZnVuY3Rpb24oZG9fbm90X251a2VfZXJyb3JpbmZvcyksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbi5cbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIHdoZW4gdGhlICoqcGFyc2UgcHJvY2VzcyoqIGhhcyBjb21wbGV0ZWQ6IGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eVxuICogICAgICAgICAgICAgICBvZiB0aGUgKipwYXJzZXIqKiAob3IgdGhlIGNhbGxpbmcgdXNlcmxhbmQgY29kZSkgdG8gaW52b2tlIHRoaXMgbWV0aG9kIG9uY2UgY2xlYW51cCBpcyBkZXNpcmVkLiBcbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIG1heSBiZSBpbnZva2VkIGJ5IHVzZXIgY29kZSB0byBlbnN1cmUgdGhlIGludGVybmFsIGxleGVyIGdldHMgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKlxuICogICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqXG4gKlxuICogICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICpcbiAqXG4gKiAgICBtb3JlOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICByZWplY3Q6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICpcbiAqXG4gKiAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICpcbiAqXG4gKiAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gKlxuICpcbiAqICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICpcbiAqXG4gKiAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKlxuICpcbiAqICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgc3RhdGVTdGFja1NpemU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpLFxuICpcbiAqXG4gKiAgICBydWxlczogWy4uLl0sXG4gKlxuICpcbiAqICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICogIH1cbiAqXG4gKlxuICogIHRva2VuIGxvY2F0aW9uIGluZm8gKGB5eWxsb2NgKToge1xuICogICAgZmlyc3RfbGluZTogbixcbiAqICAgIGxhc3RfbGluZTogbixcbiAqICAgIGZpcnN0X2NvbHVtbjogbixcbiAqICAgIGxhc3RfY29sdW1uOiBuLFxuICogICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdXG4gKiAgICAgICAgICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHplcm8tYmFzZWQpXG4gKiAgfVxuICpcbiAqIC0tLVxuICpcbiAqIFRoZSBgcGFyc2VFcnJvcmAgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgZXJyb3JzOlxuICpcbiAqICB7XG4gKiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAqICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gKiAgICB0b2tlbl9pZDogICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiBudW1lcmljIElELCBpZiBhbnkpXG4gKiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICogICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gKiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIE1BWSBoYXZlIGFuIGVycm9yIHJlY292ZXJ5IHJ1bGVcbiAqICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gKiAgICB5eTogICAgICAgICAgKG9iamVjdDogdGhlIGN1cnJlbnQgcGFyc2VyIGludGVybmFsIFwic2hhcmVkIHN0YXRlXCIgYHl5YFxuICogICAgICAgICAgICAgICAgICBhcyBpcyBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcnVsZSBhY3Rpb25zOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UgdXNlZCBieSB0aGUgcGFyc2VyKVxuICogIH1cbiAqXG4gKiB3aGlsZSBgdGhpc2Agd2lsbCByZWZlcmVuY2UgdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UuXG4gKlxuICogV2hlbiBgcGFyc2VFcnJvcmAgaXMgaW52b2tlZCBieSB0aGUgbGV4ZXIsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGxcbiAqIGF0dGVtcHQgdG8gaW52b2tlIGB5eS5wYXJzZXIucGFyc2VFcnJvcigpYDsgd2hlbiB0aGlzIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZFxuICogaXQgd2lsbCB0cnkgdG8gaW52b2tlIGB5eS5wYXJzZUVycm9yKClgIGluc3RlYWQuIFdoZW4gdGhhdCBjYWxsYmFjayBpcyBhbHNvIG5vdFxuICogcHJvdmlkZWQsIGEgYEppc29uTGV4ZXJFcnJvcmAgZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIGNvbnRhaW5pbmcgdGhlIGVycm9yXG4gKiBtZXNzYWdlIGFuZCBgaGFzaGAsIGFzIGNvbnN0cnVjdGVkIGJ5IHRoZSBgY29uc3RydWN0TGV4RXJyb3JJbmZvKClgIEFQSS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGxleGVyJ3MgYEppc29uTGV4ZXJFcnJvcmAgZXJyb3IgY2xhc3MgaXMgcGFzc2VkIHZpYSB0aGVcbiAqIGBFeGNlcHRpb25DbGFzc2AgYXJndW1lbnQsIHdoaWNoIGlzIGludm9rZWQgdG8gY29uc3RydWN0IHRoZSBleGNlcHRpb25cbiAqIGluc3RhbmNlIHRvIGJlIHRocm93biwgc28gdGVjaG5pY2FsbHkgYHBhcnNlRXJyb3JgIHdpbGwgdGhyb3cgdGhlIG9iamVjdFxuICogcHJvZHVjZWQgYnkgdGhlIGBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKWAgSmF2YVNjcmlwdCBleHByZXNzaW9uLlxuICpcbiAqIC0tLVxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBsZXhlciBvcHRpb25zIGJ5IHNldHRpbmcgLyBtb2RpZnlpbmcgdGhlIGAub3B0aW9uc2Agb2JqZWN0IG9mIHlvdXIgTGV4ZXIgaW5zdGFuY2UuXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKlxuICogKE9wdGlvbnMgYXJlIHBlcm1hbmVudC4pXG4gKiAgXG4gKiAgeXk6IHtcbiAqICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcylcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIGxleGVyLm9wdGlvbnM6IHtcbiAqICAgICAgcHJlX2xleDogIGZ1bmN0aW9uKClcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCBiZWZvcmUgdGhlIGxleGVyIGlzIGludm9rZWQgdG8gcHJvZHVjZSBhbm90aGVyIHRva2VuLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqICAgICAgcG9zdF9sZXg6IGZ1bmN0aW9uKHRva2VuKSB7IHJldHVybiB0b2tlbjsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIGxleGVyIGhhcyBwcm9kdWNlZCBhIHRva2VuIGB0b2tlbmA7XG4gKiAgICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiBjYW4gb3ZlcnJpZGUgdGhlIHJldHVybmVkIHRva2VuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSAodHJ1dGh5KSB2YWx1ZSwgdGhlIGxleGVyIHdpbGwgcmV0dXJuXG4gKiAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbmFsIGB0b2tlbmAuXG4gKiAgICAgICAgICAgICAgICAgYHRoaXNgIHJlZmVycyB0byB0aGUgTGV4ZXIgb2JqZWN0LlxuICpcbiAqIFdBUk5JTkc6IHRoZSBuZXh0IHNldCBvZiBvcHRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgY2hhbmdlZC4gVGhleSBlY2hvIHRoZSBhYmlsaXRpZXMgb2ZcbiAqIHRoZSBsZXhlciBhcyBwZXIgd2hlbiBpdCB3YXMgY29tcGlsZWQhXG4gKlxuICogICAgICByYW5nZXM6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlci5cbiAqICAgICAgZmxleDogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkXG4gKiAgICAgICAgICAgICAgICAgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2guXG4gKiAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGludm9rZWQ7XG4gKiAgICAgICAgICAgICAgICAgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZS5cbiAqICAgICAgeHJlZ2V4cDogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGxleGVyIHJ1bGUgcmVnZXhlcyBhcmUgXCJleHRlbmRlZCByZWdleCBmb3JtYXRcIiByZXF1aXJpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgYFhSZWdFeHBgIGxpYnJhcnkuIFdoZW4gdGhpcyAlb3B0aW9uIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQgYXQgY29tcGlsZSB0aW1lLCBhbGwgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICBydWxlIHJlZ2V4ZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gYXMgc3RhbmRhcmQgSmF2YVNjcmlwdCBSZWdFeHAgZXhwcmVzc2lvbnMuXG4gKiAgfVxuICovXG5cblxudmFyIGxleGVyID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBTZWUgYWxzbzpcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHQvIzM1ODgxNTA4XG4gICAqIGJ1dCB3ZSBrZWVwIHRoZSBwcm90b3R5cGUuY29uc3RydWN0b3IgYW5kIHByb3RvdHlwZS5uYW1lIGFzc2lnbm1lbnQgbGluZXMgdG9vIGZvciBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggdXNlcmxhbmQgY29kZSB3aGljaCBtaWdodCBhY2Nlc3MgdGhlIGRlcml2ZWQgY2xhc3MgaW4gYSAnY2xhc3NpYycgd2F5LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbm9jb2xsYXBzZVxuICAgKi9cbiAgZnVuY3Rpb24gSmlzb25MZXhlckVycm9yKG1zZywgaGFzaCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICdKaXNvbkxleGVyRXJyb3InXG4gICAgfSk7XG5cbiAgICBpZiAobXNnID09IG51bGwpXG4gICAgICBtc2cgPSAnPz8/JztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbXNnXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgIHZhciBzdGFja3RyYWNlO1xuXG4gICAgaWYgKGhhc2ggJiYgaGFzaC5leGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdmFyIGV4MiA9IGhhc2guZXhjZXB0aW9uO1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXgyLm1lc3NhZ2UgfHwgbXNnO1xuICAgICAgc3RhY2t0cmFjZSA9IGV4Mi5zdGFjaztcbiAgICB9XG5cbiAgICBpZiAoIXN0YWNrdHJhY2UpIHtcbiAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICAvLyBWOFxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrdHJhY2UgPSBuZXcgRXJyb3IobXNnKS5zdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhY2t0cmFjZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHN0YWNrdHJhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgSmlzb25MZXhlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKaXNvbkxleGVyRXJyb3I7XG4gIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdKaXNvbkxleGVyRXJyb3InO1xuXG4gIHZhciBsZXhlciA9IHtcbiAgICBcbi8vIENvZGUgR2VuZXJhdG9yIEluZm9ybWF0aW9uIFJlcG9ydFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gT3B0aW9uczpcbi8vXG4vLyAgIGJhY2t0cmFja2luZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgbG9jYXRpb24ucmFuZ2VzOiAuLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICBsb2NhdGlvbiBsaW5lK2NvbHVtbiB0cmFja2luZzogLi4uIHRydWVcbi8vXG4vL1xuLy8gRm9yd2FyZGVkIFBhcnNlciBBbmFseXNpcyBmbGFnczpcbi8vXG4vLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5dGV4dDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyBsZXhlciB2YWx1ZXM6IC4uLi4uLi4uLi4uLi4uLiB0cnVlIC8gdHJ1ZVxuLy8gICBsb2NhdGlvbiB0cmFja2luZzogLi4uLi4uLi4uLi4uLi4uIHRydWVcbi8vICAgbG9jYXRpb24gYXNzaWdubWVudDogLi4uLi4uLi4uLi4uLiB0cnVlXG4vL1xuLy9cbi8vIExleGVyIEFuYWx5c2lzIGZsYWdzOlxuLy9cbi8vICAgdXNlcyB5eWxlbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWxsb2M6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBQYXJzZUVycm9yIEFQSTogLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWVycm9yOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBsb2NhdGlvbiB0cmFja2luZyAmIGVkaXRpbmc6ICA/Pz9cbi8vICAgdXNlcyBtb3JlKCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB1bnB1dCgpIEFQSTogLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyByZWplY3QoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBsZXNzKCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBkaXNwbGF5IEFQSXMgcGFzdElucHV0KCksIHVwY29taW5nSW5wdXQoKSwgc2hvd1Bvc2l0aW9uKCk6XG4vLyAgICAgICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgZGVzY3JpYmVZWUxMT0MoKSBBUEk6IC4uLi4uLi4gPz8/XG4vL1xuLy8gLS0tLS0tLS0tIEVORCBPRiBSRVBPUlQgLS0tLS0tLS0tLS1cblxuRU9GOiAxLFxuICAgIEVSUk9SOiAyLFxuXG4gICAgLy8gSmlzb25MZXhlckVycm9yOiBKaXNvbkxleGVyRXJyb3IsICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRvclxuXG4gICAgLy8gb3B0aW9uczoge30sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRvclxuXG4gICAgLy8geXk6IC4uLiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHNldElucHV0KClcblxuICAgIF9fY3VycmVudFJ1bGVTZXRfXzogbnVsbCwgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiBpbnRlcm5hbCBydWxlIHNldCBjYWNoZSBmb3IgdGhlIGN1cnJlbnQgbGV4ZXIgc3RhdGUgIFxuXG4gICAgX19lcnJvcl9pbmZvczogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IHRoZSBzZXQgb2YgbGV4RXJyb3JJbmZvIG9iamVjdHMgY3JlYXRlZCBzaW5jZSB0aGUgbGFzdCBjbGVhbnVwICBcbiAgICBfX2RlY29tcHJlc3NlZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogbWFyayB3aGV0aGVyIHRoZSBsZXhlciBpbnN0YW5jZSBoYXMgYmVlbiAndW5mb2xkZWQnIGNvbXBsZXRlbHkgYW5kIGlzIG5vdyByZWFkeSBmb3IgdXNlICBcbiAgICBkb25lOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX2JhY2t0cmFjazogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9pbnB1dDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfbW9yZTogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX3NpZ25hbGVkX2Vycm9yX3Rva2VuOiBmYWxzZSwgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIGNvbmRpdGlvblN0YWNrOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOyBtYW5hZ2VkIHZpYSBgcHVzaFN0YXRlKClgLCBgcG9wU3RhdGUoKWAsIGB0b3BTdGF0ZSgpYCBhbmQgYHN0YXRlU3RhY2tTaXplKClgICBcbiAgICBtYXRjaDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGxleGVyIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbi4gYG1hdGNoYCBpcyBpZGVudGljYWwgdG8gYHl5dGV4dGAgZXhjZXB0IHRoYXQgdGhpcyBvbmUgc3RpbGwgY29udGFpbnMgdGhlIG1hdGNoZWQgaW5wdXQgc3RyaW5nIGFmdGVyIGBsZXhlci5wZXJmb3JtQWN0aW9uKClgIGhhcyBiZWVuIGludm9rZWQsIHdoZXJlIHVzZXJsYW5kIGNvZGUgTUFZIGhhdmUgY2hhbmdlZC9yZXBsYWNlZCB0aGUgYHl5dGV4dGAgdmFsdWUgZW50aXJlbHkhICBcbiAgICBtYXRjaGVkOiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBlbnRpcmUgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgIFxuICAgIG1hdGNoZXM6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIFJFIG1hdGNoIHJlc3VsdCBmb3IgbGFzdCAoc3VjY2Vzc2Z1bCkgbWF0Y2ggYXR0ZW1wdCAgXG4gICAgeXl0ZXh0OiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGxleGVyIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbjsgdGhpcyB2YWx1ZSBpcyB0cmFuc2ZlcnJlZCB0byB0aGUgcGFyc2VyIGFzIHRoZSAndG9rZW4gdmFsdWUnIHdoZW4gdGhlIHBhcnNlciBjb25zdW1lcyB0aGUgbGV4ZXIgdG9rZW4gcHJvZHVjZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIGBsZXgoKWAgQVBJLiAgXG4gICAgb2Zmc2V0OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgdGhlICdjdXJzb3IgcG9zaXRpb24nIGluIHRoZSBpbnB1dCBzdHJpbmcsIGkuZS4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1hdGNoZWQgc28gZmFyICBcbiAgICB5eWxlbmc6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IGxlbmd0aCBvZiBtYXRjaGVkIGlucHV0IGZvciB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uIChgeXl0ZXh0YCkgIFxuICAgIHl5bGluZW5vOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogJ2xpbmUgbnVtYmVyJyBhdCB3aGljaCB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uIGlzIGxvY2F0ZWQgIFxuICAgIHl5bGxvYzogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGxvY2F0aW9uIGluZm8gKGxpbmVzICsgY29sdW1ucykgZm9yIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gIFxuXG4gICAgLyoqXG4gICAgICogSU5URVJOQUwgVVNFOiBjb25zdHJ1Y3QgYSBzdWl0YWJsZSBlcnJvciBpbmZvIGhhc2ggb2JqZWN0IGluc3RhbmNlIGZvciBgcGFyc2VFcnJvcmAuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RMZXhFcnJvckluZm86IGZ1bmN0aW9uIGxleGVyX2NvbnN0cnVjdExleEVycm9ySW5mbyhtc2csIHJlY292ZXJhYmxlKSB7XG4gICAgICAvKiogQGNvbnN0cnVjdG9yICovXG4gICAgICB2YXIgcGVpID0ge1xuICAgICAgICBlcnJTdHI6IG1zZyxcbiAgICAgICAgcmVjb3ZlcmFibGU6ICEhcmVjb3ZlcmFibGUsXG4gICAgICAgIHRleHQ6IHRoaXMubWF0Y2gsICAgICAgICAgICAvLyBUaGlzIG9uZSBNQVkgYmUgZW1wdHk7IHVzZXJsYW5kIGNvZGUgc2hvdWxkIHVzZSB0aGUgYHVwY29taW5nSW5wdXRgIEFQSSB0byBvYnRhaW4gbW9yZSB0ZXh0IHdoaWNoIGZvbGxvd3MgdGhlICdsZXhlciBjdXJzb3IgcG9zaXRpb24nLi4uICBcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm8sXG4gICAgICAgIGxvYzogdGhpcy55eWxsb2MsXG4gICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICBsZXhlcjogdGhpcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5kIG1ha2Ugc3VyZSB0aGUgZXJyb3IgaW5mbyBkb2Vzbid0IHN0YXkgZHVlIHRvIHBvdGVudGlhbFxuICAgICAgICAgKiByZWYgY3ljbGUgdmlhIHVzZXJsYW5kIGNvZGUgbWFuaXB1bGF0aW9ucy5cbiAgICAgICAgICogVGhlc2Ugd291bGQgb3RoZXJ3aXNlIGFsbCBiZSBtZW1vcnkgbGVhayBvcHBvcnR1bml0aWVzIVxuICAgICAgICAgKiBcbiAgICAgICAgICogTm90ZSB0aGF0IG9ubHkgYXJyYXkgYW5kIG9iamVjdCByZWZlcmVuY2VzIGFyZSBudWtlZCBhcyB0aG9zZVxuICAgICAgICAgKiBjb25zdGl0dXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgd2hpY2ggY2FuIHByb2R1Y2UgYSBjeWNsaWMgcmVmLlxuICAgICAgICAgKiBUaGUgcmVzdCBvZiB0aGUgbWVtYmVycyBpcyBrZXB0IGludGFjdCBhcyB0aGV5IGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHRoaXMge0xleEVycm9ySW5mb31cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3RydWN0TGV4RXJyb3JJbmZvKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBjeWNsaWMgcmVmZXJlbmNlcyBhZGRlZCB0byBlcnJvciBpbmZvOlxuICAgICAgICAgIC8vIGluZm8ueXkgPSBudWxsO1xuICAgICAgICAgIC8vIGluZm8ubGV4ZXIgPSBudWxsO1xuICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgIHZhciByZWMgPSAhIXRoaXMucmVjb3ZlcmFibGU7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWNvdmVyYWJsZSA9IHJlYztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdHJhY2sgdGhpcyBpbnN0YW5jZSBzbyB3ZSBjYW4gYGRlc3Ryb3koKWAgaXQgb25jZSB3ZSBkZWVtIGl0IHN1cGVyZmx1b3VzIGFuZCByZWFkeSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIVxuICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLnB1c2gocGVpKTtcblxuICAgICAgcmV0dXJuIHBlaTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlciB3aGljaCBpcyBpbnZva2VkIHdoZW4gYSBsZXhlciBlcnJvciBvY2N1cnMuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBsZXhlcl9wYXJzZUVycm9yKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uTGV4ZXJFcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueXkpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyICYmIHR5cGVvZiB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3IuY2FsbCh0aGlzLCBzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy55eS5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWV0aG9kIHdoaWNoIGltcGxlbWVudHMgYHl5ZXJyb3Ioc3RyLCAuLi5hcmdzKWAgZnVuY3Rpb25hbGl0eSBmb3IgdXNlIGluc2lkZSBsZXhlciBhY3Rpb25zLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgeXllcnJvcjogZnVuY3Rpb24geXlFcnJvcihzdHIgLyosIC4uLmFyZ3MgKi8pIHtcbiAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogJyArIHN0cixcbiAgICAgICAgdGhpcy5vcHRpb25zLmxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGVcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCBhbnkgZXh0cmEgYXJncyB0byB0aGUgaGFzaCB1bmRlciB0aGUgbmFtZSBgZXh0cmFfZXJyb3JfYXR0cmlidXRlc2A6XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBwLmV4dHJhX2Vycm9yX2F0dHJpYnV0ZXMgPSBhcmdzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZmluYWwgY2xlYW51cCBmdW5jdGlvbiBmb3Igd2hlbiB3ZSBoYXZlIGNvbXBsZXRlZCBsZXhpbmcgdGhlIGlucHV0O1xuICAgICAqIG1ha2UgaXQgYW4gQVBJIHNvIHRoYXQgZXh0ZXJuYWwgY29kZSBjYW4gdXNlIHRoaXMgb25lIG9uY2UgdXNlcmxhbmRcbiAgICAgKiBjb2RlIGhhcyBkZWNpZGVkIGl0J3MgdGltZSB0byBkZXN0cm95IGFueSBsaW5nZXJpbmcgbGV4ZXIgZXJyb3JcbiAgICAgKiBoYXNoIG9iamVjdCBpbnN0YW5jZXMgYW5kIHRoZSBsaWtlOiB0aGlzIGZ1bmN0aW9uIGhlbHBzIHRvIGNsZWFuXG4gICAgICogdXAgdGhlc2UgY29uc3RydWN0cywgd2hpY2ggKm1heSogY2FycnkgY3ljbGljIHJlZmVyZW5jZXMgd2hpY2ggd291bGRcbiAgICAgKiBvdGhlcndpc2UgcHJldmVudCB0aGUgaW5zdGFuY2VzIGZyb20gYmVpbmcgcHJvcGVybHkgYW5kIHRpbWVseVxuICAgICAqIGdhcmJhZ2UtY29sbGVjdGVkLCBpLmUuIHRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBtZW1vcnkgbGVha3MhXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uIGxleGVyX2NsZWFudXBBZnRlckxleChkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAvLyBwcmV2ZW50IGxpbmdlcmluZyBjaXJjdWxhciByZWZlcmVuY2VzIGZyb20gY2F1c2luZyBtZW1vcnkgbGVha3M6XG4gICAgICB0aGlzLnNldElucHV0KCcnLCB7fSk7XG5cbiAgICAgIC8vIG51a2UgdGhlIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZXMgY3JlYXRlZCBkdXJpbmcgdGhpcyBydW4uXG4gICAgICAvLyBVc2VybGFuZCBjb2RlIG11c3QgQ09QWSBhbnkgZGF0YS9yZWZlcmVuY2VzXG4gICAgICAvLyBpbiB0aGUgZXJyb3IgaGFzaCBpbnN0YW5jZShzKSBpdCBpcyBtb3JlIHBlcm1hbmVudGx5IGludGVyZXN0ZWQgaW4uXG4gICAgICBpZiAoIWRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBlbCA9IHRoaXMuX19lcnJvcl9pbmZvc1tpXTtcblxuICAgICAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZWwuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2xlYXIgdGhlIGxleGVyIHRva2VuIGNvbnRleHQ7IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGxleGVyX2NsZWFyKCkge1xuICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgIHRoaXMueXlsZW5nID0gMDtcbiAgICAgIHRoaXMubWF0Y2ggPSAnJztcblxuICAgICAgLy8gLSBETyBOT1QgcmVzZXQgYHRoaXMubWF0Y2hlZGBcbiAgICAgIHRoaXMubWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciBjb2wgPSAodGhpcy55eWxsb2MgPyB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA6IDApO1xuXG4gICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogY29sLFxuICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogY29sLFxuICAgICAgICByYW5nZTogW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldF1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzZXRJbnB1dDogZnVuY3Rpb24gbGV4ZXJfc2V0SW5wdXQoaW5wdXQsIHl5KSB7XG4gICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcblxuICAgICAgLy8gYWxzbyBjaGVjayBpZiB3ZSd2ZSBmdWxseSBpbml0aWFsaXplZCB0aGUgbGV4ZXIgaW5zdGFuY2UsXG4gICAgICAvLyBpbmNsdWRpbmcgZXhwYW5zaW9uIHdvcmsgdG8gYmUgZG9uZSB0byBnbyBmcm9tIGEgbG9hZGVkXG4gICAgICAvLyBsZXhlciB0byBhIHVzYWJsZSBsZXhlcjpcbiAgICAgIGlmICghdGhpcy5fX2RlY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBzdGVwIDE6IGRlY29tcHJlc3MgdGhlIHJlZ2V4IGxpc3Q6XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJ1bGVfcmUgPSBydWxlc1tpXTtcblxuICAgICAgICAgIC8vIGNvbXByZXNzaW9uOiBpcyB0aGUgUkUgYW4geHJlZiB0byBhbm90aGVyIFJFIHNsb3QgaW4gdGhlIHJ1bGVzW10gdGFibGU/XG4gICAgICAgICAgaWYgKHR5cGVvZiBydWxlX3JlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcnVsZXNbaV0gPSBydWxlc1tydWxlX3JlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGVwIDI6IHVuZm9sZCB0aGUgY29uZGl0aW9uc1tdIHNldCB0byBtYWtlIHRoZXNlIHJlYWR5IGZvciB1c2U6XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gdGhpcy5jb25kaXRpb25zO1xuXG4gICAgICAgIGZvciAodmFyIGsgaW4gY29uZGl0aW9ucykge1xuICAgICAgICAgIHZhciBzcGVjID0gY29uZGl0aW9uc1trXTtcbiAgICAgICAgICB2YXIgcnVsZV9pZHMgPSBzcGVjLnJ1bGVzO1xuICAgICAgICAgIHZhciBsZW4gPSBydWxlX2lkcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHJ1bGVfcmVnZXhlcyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgLy8gc2xvdCAwIGlzIHVudXNlZDsgd2UgdXNlIGEgMS1iYXNlZCBpbmRleCBhcHByb2FjaCBoZXJlIHRvIGtlZXAgdGhlIGhvdHRlc3QgY29kZSBpbiBgbGV4ZXJfbmV4dCgpYCBmYXN0IGFuZCBzaW1wbGUhIFxuICAgICAgICAgIHZhciBydWxlX25ld19pZHMgPSBuZXcgQXJyYXkobGVuICsgMSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gcnVsZV9pZHNbaV07XG4gICAgICAgICAgICB2YXIgcnVsZV9yZSA9IHJ1bGVzW2lkeF07XG4gICAgICAgICAgICBydWxlX3JlZ2V4ZXNbaSArIDFdID0gcnVsZV9yZTtcbiAgICAgICAgICAgIHJ1bGVfbmV3X2lkc1tpICsgMV0gPSBpZHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BlYy5ydWxlcyA9IHJ1bGVfbmV3X2lkcztcbiAgICAgICAgICBzcGVjLl9fcnVsZV9yZWdleGVzID0gcnVsZV9yZWdleGVzO1xuICAgICAgICAgIHNwZWMuX19ydWxlX2NvdW50ID0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2RlY29tcHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQgfHwgJyc7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLnl5bGluZW5vID0gMDtcbiAgICAgIHRoaXMubWF0Y2hlZCA9ICcnO1xuICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuXG4gICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgIGxhc3RfY29sdW1uOiAwLFxuICAgICAgICByYW5nZTogWzAsIDBdXG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZWRpdCB0aGUgcmVtYWluaW5nIGlucHV0IHZpYSB1c2VyLXNwZWNpZmllZCBjYWxsYmFjay5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGZvcndhcmQtYWRqdXN0IHRoZSBpbnB1dC10by1wYXJzZSwgXG4gICAgICogZS5nLiBpbnNlcnRpbmcgbWFjcm8gZXhwYW5zaW9ucyBhbmQgYWxpa2UgaW4gdGhlXG4gICAgICogaW5wdXQgd2hpY2ggaGFzIHlldCB0byBiZSBsZXhlZC5cbiAgICAgKiBUaGUgYmVoYXZpb3VyIG9mIHRoaXMgQVBJIGNvbnRyYXN0cyB0aGUgYHVucHV0KClgIGV0IGFsXG4gICAgICogQVBJcyBhcyB0aG9zZSBhY3Qgb24gdGhlICpjb25zdW1lZCogaW5wdXQsIHdoaWxlIHRoaXNcbiAgICAgKiBvbmUgYWxsb3dzIG9uZSB0byBtYW5pcHVsYXRlIHRoZSBmdXR1cmUsIHdpdGhvdXQgaW1wYWN0aW5nXG4gICAgICogdGhlIGN1cnJlbnQgYHl5bG9jYCBjdXJzb3IgbG9jYXRpb24gb3IgYW55IGhpc3RvcnkuIFxuICAgICAqIFxuICAgICAqIFVzZSB0aGlzIEFQSSB0byBoZWxwIGltcGxlbWVudCBDLXByZXByb2Nlc3Nvci1saWtlXG4gICAgICogYCNpbmNsdWRlYCBzdGF0ZW1lbnRzLCBldGMuXG4gICAgICogXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIG11c3QgYmUgc3luY2hyb25vdXMgYW5kIGlzXG4gICAgICogZXhwZWN0ZWQgdG8gcmV0dXJuIHRoZSBlZGl0ZWQgaW5wdXQgKHN0cmluZykuXG4gICAgICpcbiAgICAgKiBUaGUgYGNwc0FyZ2AgYXJndW1lbnQgdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICAgICAqIGFzLWlzLlxuICAgICAqXG4gICAgICogYGNhbGxiYWNrYCBpbnRlcmZhY2U6IFxuICAgICAqIGBmdW5jdGlvbiBjYWxsYmFjayhpbnB1dCwgY3BzQXJnKWBcbiAgICAgKiBcbiAgICAgKiAtIGBpbnB1dGAgd2lsbCBjYXJyeSB0aGUgcmVtYWluaW5nLWlucHV0LXRvLWxleCBzdHJpbmdcbiAgICAgKiAgIGZyb20gdGhlIGxleGVyLlxuICAgICAqIC0gYGNwc0FyZ2AgaXMgYGNwc0FyZ2AgcGFzc2VkIGludG8gdGhpcyBBUEkuXG4gICAgICogXG4gICAgICogVGhlIGB0aGlzYCByZWZlcmVuY2UgZm9yIHRoZSBjYWxsYmFjayB3aWxsIGJlIHNldCB0b1xuICAgICAqIHJlZmVyZW5jZSB0aGlzIGxleGVyIGluc3RhbmNlIHNvIHRoYXQgdXNlcmxhbmQgY29kZVxuICAgICAqIGluIHRoZSBjYWxsYmFjayBjYW4gZWFzaWx5IGFuZCBxdWlja2x5IGFjY2VzcyBhbnkgbGV4ZXJcbiAgICAgKiBBUEkuIFxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIG5vbi1zdHJpbmctdHlwZSBmYWxzZXkgdmFsdWUsXG4gICAgICogd2UgYXNzdW1lIHRoZSBjYWxsYmFjayBkaWQgbm90IGVkaXQgdGhlIGlucHV0IGFuZCB3ZVxuICAgICAqIHdpbGwgdXNpbmcgdGhlIGlucHV0IGFzLWlzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIG5vbi1zdHJpbmctdHlwZSB2YWx1ZSwgaXRcbiAgICAgKiBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIGxleGluZyB2aWEgdGhlIGBcIlwiICsgcmV0dmFsYFxuICAgICAqIG9wZXJhdGlvbi4gKFNlZSBhbHNvIHdoeTogaHR0cDovLzJhbGl0eS5jb20vMjAxMi8wMy9jb252ZXJ0aW5nLXRvLXN0cmluZy5odG1sIFxuICAgICAqIC0tIHRoYXQgd2F5IGFueSByZXR1cm5lZCBvYmplY3QncyBgdG9WYWx1ZSgpYCBhbmQgYHRvU3RyaW5nKClgXG4gICAgICogbWV0aG9kcyB3aWxsIGJlIGludm9rZWQgaW4gYSBwcm9wZXIvZGVzaXJhYmxlIG9yZGVyLilcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGVkaXRSZW1haW5pbmdJbnB1dDogZnVuY3Rpb24gbGV4ZXJfZWRpdFJlbWFpbmluZ0lucHV0KGNhbGxiYWNrLCBjcHNBcmcpIHtcbiAgICAgIHZhciBydiA9IGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5faW5wdXQsIGNwc0FyZyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChydikge1xuICAgICAgICAgIHRoaXMuX2lucHV0ID0gJycgKyBydjtcbiAgICAgICAgfSBcbiAgICAgICAgLy8gZWxzZToga2VlcCBgdGhpcy5faW5wdXRgIGFzIGlzLiAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHJ2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGlucHV0OiBmdW5jdGlvbiBsZXhlcl9pbnB1dCgpIHtcbiAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgLy90aGlzLmRvbmUgPSB0cnVlOyAgICAtLSBkb24ndCBzZXQgYGRvbmVgIGFzIHdlIHdhbnQgdGhlIGxleCgpL25leHQoKSBBUEkgdG8gYmUgYWJsZSB0byBwcm9kdWNlIG9uZSBjdXN0b20gRU9GIHRva2VuIG1hdGNoIGFmdGVyIHRoaXMgYW55aG93LiAobGV4ZXIgY2FuIG1hdGNoIHNwZWNpYWwgPDxFT0Y+PiB0b2tlbnMgYW5kIHBlcmZvcm0gdXNlciBhY3Rpb24gY29kZSBmb3IgYSA8PEVPRj4+IG1hdGNoLCBidXQgb25seSBkb2VzIHNvICpvbmNlKilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG5cbiAgICAgIC8vIENvdW50IHRoZSBsaW5lbnVtYmVyIHVwIHdoZW4gd2UgaGl0IHRoZSBMRiAob3IgYSBzdGFuZC1hbG9uZSBDUikuXG4gICAgICAvLyBPbiBDUkxGLCB0aGUgbGluZW51bWJlciBpcyBpbmNyZW1lbnRlZCB3aGVuIHlvdSBmZXRjaCB0aGUgQ1Igb3IgdGhlIENSTEYgY29tYm9cbiAgICAgIC8vIGFuZCB3ZSBhZHZhbmNlIGltbWVkaWF0ZWx5IHBhc3QgdGhlIExGIGFzIHdlbGwsIHJldHVybmluZyBib3RoIHRvZ2V0aGVyIGFzIGlmXG4gICAgICAvLyBpdCB3YXMgYWxsIGEgc2luZ2xlICdjaGFyYWN0ZXInIG9ubHkuXG4gICAgICB2YXIgc2xpY2VfbGVuID0gMTtcblxuICAgICAgdmFyIGxpbmVzID0gZmFsc2U7XG5cbiAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgbGluZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgbGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgY2gyID0gdGhpcy5faW5wdXRbMV07XG5cbiAgICAgICAgaWYgKGNoMiA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBzbGljZV9sZW4rKztcbiAgICAgICAgICBjaCArPSBjaDI7XG4gICAgICAgICAgdGhpcy55eXRleHQgKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICB0aGlzLm1hdGNoICs9IGNoMjtcbiAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKHNsaWNlX2xlbik7XG4gICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhbiBlbnRpcmUgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3VucHV0KGNoKSB7XG4gICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIGxlbik7XG4gICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSBsZW4pO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsaW5lbm8gKyAxO1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5tYXRjaDtcbiAgICAgICAgdmFyIHByZV9saW5lcyA9IHByZS5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIGlmIChwcmVfbGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcHJlID0gdGhpcy5tYXRjaGVkO1xuICAgICAgICAgIHByZV9saW5lcyA9IHByZS5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSBwcmVfbGluZXNbcHJlX2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uIC09IGxlbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0gPSB0aGlzLnl5bGxvYy5yYW5nZVswXSArIHRoaXMueXlsZW5nO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FjaGUgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmQgaXQgb24gbmV4dCBhY3Rpb25cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIG1vcmU6IGZ1bmN0aW9uIGxleGVyX21vcmUoKSB7XG4gICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaWduYWwgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlXG4gICAgICogbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcmVqZWN0OiBmdW5jdGlvbiBsZXhlcl9yZWplY3QoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgYHBhcnNlRXJyb3IoKWAgY2FsbCByZXR1cm5zLCB3ZSBNVVNUIGVuc3VyZSB0aGF0IHRoZSBlcnJvciBpcyByZWdpc3RlcmVkLlxuICAgICAgICAvLyBXZSBhY2NvbXBsaXNoIHRoaXMgYnkgc2lnbmFsaW5nIGFuICdlcnJvcicgdG9rZW4gdG8gYmUgcHJvZHVjZWQgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGAubGV4KClgIHJ1bi5cbiAgICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc19zdHIgPSAnJztcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG9zX3N0ciA9IHRoaXMuc2hvd1Bvc2l0aW9uKCk7XG5cbiAgICAgICAgICBpZiAocG9zX3N0ciAmJiBwb3Nfc3RyWzBdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgcG9zX3N0ciA9ICdcXG4nICsgcG9zX3N0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAgICdMZXhpY2FsIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuJyArIHBvc19zdHIsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbiA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbGVzczogZnVuY3Rpb24gbGV4ZXJfbGVzcyhuKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIChwYXJ0IG9mIHRoZSkgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvclxuICAgICAqIG1lc3NhZ2VzLlxuICAgICAqIFxuICAgICAqIExpbWl0IHRoZSByZXR1cm5lZCBzdHJpbmcgbGVuZ3RoIHRvIGBtYXhTaXplYCAoZGVmYXVsdDogMjApLlxuICAgICAqIFxuICAgICAqIExpbWl0IHRoZSByZXR1cm5lZCBzdHJpbmcgdG8gdGhlIGBtYXhMaW5lc2AgbnVtYmVyIG9mIGxpbmVzIG9mXG4gICAgICogaW5wdXQgKGRlZmF1bHQ6IDEpLlxuICAgICAqIFxuICAgICAqIE5lZ2F0aXZlIGxpbWl0IHZhbHVlcyBlcXVhbCAqdW5saW1pdGVkKi5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHBhc3RJbnB1dDogZnVuY3Rpb24gbGV4ZXJfcGFzdElucHV0KG1heFNpemUsIG1heExpbmVzKSB7XG4gICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHJpbmcoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcblxuICAgICAgaWYgKG1heFNpemUgPCAwKVxuICAgICAgICBtYXhTaXplID0gcGFzdC5sZW5ndGg7XG4gICAgICBlbHNlIGlmICghbWF4U2l6ZSlcbiAgICAgICAgbWF4U2l6ZSA9IDIwO1xuXG4gICAgICBpZiAobWF4TGluZXMgPCAwKVxuICAgICAgICBtYXhMaW5lcyA9IHBhc3QubGVuZ3RoOyAgICAgICAgICAvLyBjYW4ndCBldmVyIGhhdmUgbW9yZSBpbnB1dCBsaW5lcyB0aGFuIHRoaXMhIFxuICAgICAgZWxzZSBpZiAoIW1heExpbmVzKVxuICAgICAgICBtYXhMaW5lcyA9IDE7XG5cbiAgICAgIC8vIGBzdWJzdHJgIGFudGljaXBhdGlvbjogdHJlYXQgXFxyXFxuIGFzIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGFrZSBhIGxpdHRsZVxuICAgICAgLy8gbW9yZSB0aGFuIG5lY2Vzc2FyeSBzbyB0aGF0IHdlIGNhbiBzdGlsbCBwcm9wZXJseSBjaGVjayBhZ2FpbnN0IG1heFNpemVcbiAgICAgIC8vIGFmdGVyIHdlJ3ZlIHRyYW5zZm9ybWVkIGFuZCBsaW1pdGVkIHRoZSBuZXdMaW5lcyBpbiBoZXJlOlxuICAgICAgcGFzdCA9IHBhc3Quc3Vic3RyKC1tYXhTaXplICogMiAtIDIpO1xuXG4gICAgICAvLyBub3cgdGhhdCB3ZSBoYXZlIGEgc2lnbmlmaWNhbnRseSByZWR1Y2VkIHN0cmluZyB0byBwcm9jZXNzLCB0cmFuc2Zvcm0gdGhlIG5ld2xpbmVzXG4gICAgICAvLyBhbmQgY2hvcCB0aGVtLCB0aGVuIGxpbWl0IHRoZW06XG4gICAgICB2YXIgYSA9IHBhc3QucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICBhID0gYS5zbGljZSgtbWF4TGluZXMpO1xuICAgICAgcGFzdCA9IGEuam9pbignXFxuJyk7XG5cbiAgICAgIC8vIFdoZW4sIGFmdGVyIGxpbWl0aW5nIHRvIG1heExpbmVzLCB3ZSBzdGlsbCBoYXZlIHRvbyBtdWNoIHRvIHJldHVybixcbiAgICAgIC8vIGRvIGFkZCBhbiBlbGxpcHNpcyBwcmVmaXguLi5cbiAgICAgIGlmIChwYXN0Lmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgcGFzdCA9ICcuLi4nICsgcGFzdC5zdWJzdHIoLW1heFNpemUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIChwYXJ0IG9mIHRoZSkgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAgICAqIFxuICAgICAqIExpbWl0IHRoZSByZXR1cm5lZCBzdHJpbmcgbGVuZ3RoIHRvIGBtYXhTaXplYCAoZGVmYXVsdDogMjApLlxuICAgICAqIFxuICAgICAqIExpbWl0IHRoZSByZXR1cm5lZCBzdHJpbmcgdG8gdGhlIGBtYXhMaW5lc2AgbnVtYmVyIG9mIGxpbmVzIG9mIGlucHV0IChkZWZhdWx0OiAxKS5cbiAgICAgKiBcbiAgICAgKiBOZWdhdGl2ZSBsaW1pdCB2YWx1ZXMgZXF1YWwgKnVubGltaXRlZCouXG4gICAgICpcbiAgICAgKiA+ICMjIyBOT1RFICMjI1xuICAgICAqID5cbiAgICAgKiA+ICpcInVwY29taW5nIGlucHV0XCIqIGlzIGRlZmluZWQgYXMgdGhlIHdob2xlIG9mIHRoZSBib3RoXG4gICAgICogPiB0aGUgKmN1cnJlbnRseSBsZXhlZCogaW5wdXQsIHRvZ2V0aGVyIHdpdGggYW55IHJlbWFpbmluZyBpbnB1dFxuICAgICAqID4gZm9sbG93aW5nIHRoYXQuICpcImN1cnJlbnRseSBsZXhlZFwiKiBpbnB1dCBpcyB0aGUgaW5wdXQgXG4gICAgICogPiBhbHJlYWR5IHJlY29nbml6ZWQgYnkgdGhlIGxleGVyIGJ1dCBub3QgeWV0IHJldHVybmVkIHdpdGhcbiAgICAgKiA+IHRoZSBsZXhlciB0b2tlbi4gVGhpcyBoYXBwZW5zIHdoZW4geW91IGFyZSBpbnZva2luZyB0aGlzIEFQSVxuICAgICAqID4gZnJvbSBpbnNpZGUgYW55IGxleGVyIHJ1bGUgYWN0aW9uIGNvZGUgYmxvY2suIFxuICAgICAqID5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3VwY29taW5nSW5wdXQobWF4U2l6ZSwgbWF4TGluZXMpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcblxuICAgICAgaWYgKG1heFNpemUgPCAwKVxuICAgICAgICBtYXhTaXplID0gbmV4dC5sZW5ndGggKyB0aGlzLl9pbnB1dC5sZW5ndGg7XG4gICAgICBlbHNlIGlmICghbWF4U2l6ZSlcbiAgICAgICAgbWF4U2l6ZSA9IDIwO1xuXG4gICAgICBpZiAobWF4TGluZXMgPCAwKVxuICAgICAgICBtYXhMaW5lcyA9IG1heFNpemU7ICAgICAgICAgIC8vIGNhbid0IGV2ZXIgaGF2ZSBtb3JlIGlucHV0IGxpbmVzIHRoYW4gdGhpcyEgXG4gICAgICBlbHNlIGlmICghbWF4TGluZXMpXG4gICAgICAgIG1heExpbmVzID0gMTtcblxuICAgICAgLy8gYHN1YnN0cmluZ2AgYW50aWNpcGF0aW9uOiB0cmVhdCBcXHJcXG4gYXMgYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCB0YWtlIGEgbGl0dGxlXG4gICAgICAvLyBtb3JlIHRoYW4gbmVjZXNzYXJ5IHNvIHRoYXQgd2UgY2FuIHN0aWxsIHByb3Blcmx5IGNoZWNrIGFnYWluc3QgbWF4U2l6ZVxuICAgICAgLy8gYWZ0ZXIgd2UndmUgdHJhbnNmb3JtZWQgYW5kIGxpbWl0ZWQgdGhlIG5ld0xpbmVzIGluIGhlcmU6XG4gICAgICBpZiAobmV4dC5sZW5ndGggPCBtYXhTaXplICogMiArIDIpIHtcbiAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoMCwgbWF4U2l6ZSAqIDIgKyAyKTsgICAvLyBzdWJzdHJpbmcgaXMgZmFzdGVyIG9uIENocm9tZS9WOCBcbiAgICAgIH1cblxuICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSBhIHNpZ25pZmljYW50bHkgcmVkdWNlZCBzdHJpbmcgdG8gcHJvY2VzcywgdHJhbnNmb3JtIHRoZSBuZXdsaW5lc1xuICAgICAgLy8gYW5kIGNob3AgdGhlbSwgdGhlbiBsaW1pdCB0aGVtOlxuICAgICAgdmFyIGEgPSBuZXh0LnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgYSA9IGEuc2xpY2UoMCwgbWF4TGluZXMpO1xuICAgICAgbmV4dCA9IGEuam9pbignXFxuJyk7XG5cbiAgICAgIC8vIFdoZW4sIGFmdGVyIGxpbWl0aW5nIHRvIG1heExpbmVzLCB3ZSBzdGlsbCBoYXZlIHRvbyBtdWNoIHRvIHJldHVybixcbiAgICAgIC8vIGRvIGFkZCBhbiBlbGxpcHNpcyBwb3N0Zml4Li4uXG4gICAgICBpZiAobmV4dC5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgICAgIG5leHQgPSBuZXh0LnN1YnN0cmluZygwLCBtYXhTaXplKSArICcuLi4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgc3RyaW5nIHdoaWNoIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlXG4gICAgICogbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbiBsZXhlcl9zaG93UG9zaXRpb24obWF4UHJlZml4LCBtYXhQb3N0Zml4KSB7XG4gICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQobWF4UHJlZml4KS5yZXBsYWNlKC9cXHMvZywgJyAnKTtcbiAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKCctJyk7XG4gICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KG1heFBvc3RmaXgpLnJlcGxhY2UoL1xccy9nLCAnICcpICsgJ1xcbicgKyBjICsgJ14nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgd2hpY2ggZGlzcGxheXMgdGhlIGxpbmVzICYgY29sdW1ucyBvZiBpbnB1dCB3aGljaCBhcmUgcmVmZXJlbmNlZCBcbiAgICAgKiBieSB0aGUgZ2l2ZW4gbG9jYXRpb24gaW5mbyByYW5nZSwgcGx1cyBhIGZldyBsaW5lcyBvZiBjb250ZXh0LlxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHJldHR5LXByaW50cyB0aGUgaW5kaWNhdGVkIHNlY3Rpb24gb2YgdGhlIGlucHV0LCB3aXRoIGxpbmUgbnVtYmVycyBcbiAgICAgKiBhbmQgZXZlcnl0aGluZyFcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHZlcnkgdXNlZnVsIHRvIHByb3ZpZGUgaGlnaGx5IHJlYWRhYmxlIGVycm9yIHJlcG9ydHMsIHdoaWxlXG4gICAgICogdGhlIGxvY2F0aW9uIHJhbmdlIG1heSBiZSBzcGVjaWZpZWQgaW4gdmFyaW91cyBmbGV4aWJsZSB3YXlzOlxuICAgICAqIFxuICAgICAqIC0gYGxvY2AgaXMgdGhlIGxvY2F0aW9uIGluZm8gb2JqZWN0IHdoaWNoIHJlZmVyZW5jZXMgdGhlIGFyZWEgd2hpY2ggc2hvdWxkIGJlXG4gICAgICogICBkaXNwbGF5ZWQgYW5kICdtYXJrZWQgdXAnOiB0aGVzZSBsaW5lcyAmIGNvbHVtbnMgb2YgdGV4dCBhcmUgbWFya2VkIHVwIGJ5IGBeYFxuICAgICAqICAgY2hhcmFjdGVycyBiZWxvdyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgZW50aXJlIGlucHV0IHJhbmdlLlxuICAgICAqIFxuICAgICAqIC0gYGNvbnRleHRfbG9jYCBpcyB0aGUgKm9wdGlvbmFsKiBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGljaCBpbnN0cnVjdHMgdGhpc1xuICAgICAqICAgcHJldHR5LXByaW50ZXIgaG93IG11Y2ggKmxlYWRpbmcqIGNvbnRleHQgc2hvdWxkIGJlIGRpc3BsYXllZCBhbG9uZ3NpZGVcbiAgICAgKiAgIHRoZSBhcmVhIHJlZmVyZW5jZWQgYnkgYGxvY2AuIFRoaXMgY2FuIGhlbHAgcHJvdmlkZSBjb250ZXh0IGZvciB0aGUgZGlzcGxheWVkXG4gICAgICogICBlcnJvciwgZXRjLlxuICAgICAqIFxuICAgICAqICAgV2hlbiB0aGlzIGxvY2F0aW9uIGluZm8gaXMgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgY29udGV4dCBvZiAzIGxpbmVzIGlzXG4gICAgICogICB1c2VkLlxuICAgICAqIFxuICAgICAqIC0gYGNvbnRleHRfbG9jMmAgaXMgYW5vdGhlciAqb3B0aW9uYWwqIGxvY2F0aW9uIGluZm8gb2JqZWN0LCB3aGljaCBzZXJ2ZXNcbiAgICAgKiAgIGEgc2ltaWxhciBwdXJwb3NlIHRvIGBjb250ZXh0X2xvY2A6IGl0IHNwZWNpZmllcyB0aGUgYW1vdW50IG9mICp0cmFpbGluZypcbiAgICAgKiAgIGNvbnRleHQgbGluZXMgdG8gZGlzcGxheSBpbiB0aGUgcHJldHR5LXByaW50IG91dHB1dC5cbiAgICAgKiBcbiAgICAgKiAgIFdoZW4gdGhpcyBsb2NhdGlvbiBpbmZvIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbnRleHQgb2YgMSBsaW5lIG9ubHkgaXNcbiAgICAgKiAgIHVzZWQuXG4gICAgICogXG4gICAgICogU3BlY2lhbCBOb3RlczpcbiAgICAgKiBcbiAgICAgKiAtIHdoZW4gdGhlIGBsb2NgLWluZGljYXRlZCByYW5nZSBpcyB2ZXJ5IGxhcmdlIChhYm91dCA1IGxpbmVzIG9yIG1vcmUpLCB0aGVuXG4gICAgICogICBvbmx5IHRoZSBmaXJzdCBhbmQgbGFzdCBmZXcgbGluZXMgb2YgdGhpcyBibG9jayBhcmUgcHJpbnRlZCB3aGlsZSBhXG4gICAgICogICBgLi4uY29udGludWVkLi4uYCBtZXNzYWdlIHdpbGwgYmUgcHJpbnRlZCBiZXR3ZWVuIHRoZW0uXG4gICAgICogXG4gICAgICogICBUaGlzIHNlcnZlcyB0aGUgcHVycG9zZSBvZiBub3QgcHJpbnRpbmcgYSBodWdlIGFtb3VudCBvZiB0ZXh0IHdoZW4gdGhlIGBsb2NgXG4gICAgICogICByYW5nZSBoYXBwZW5zIHRvIGJlIGh1Z2U6IHRoaXMgd2F5IGEgbWFuYWdlYWJsZSAmIHJlYWRhYmxlIG91dHB1dCByZXN1bHRzXG4gICAgICogICBmb3IgYXJiaXRyYXJ5IGxhcmdlIHJhbmdlcy5cbiAgICAgKiBcbiAgICAgKiAtIHRoaXMgZnVuY3Rpb24gY2FuIGRpc3BsYXkgbGluZXMgb2YgaW5wdXQgd2hpY2ggd2hhdmUgbm90IHlldCBiZWVuIGxleGVkLlxuICAgICAqICAgYHByZXR0eVByaW50UmFuZ2UoKWAgY2FuIGFjY2VzcyB0aGUgZW50aXJlIGlucHV0IVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcHJldHR5UHJpbnRSYW5nZTogZnVuY3Rpb24gbGV4ZXJfcHJldHR5UHJpbnRSYW5nZShsb2MsIGNvbnRleHRfbG9jLCBjb250ZXh0X2xvYzIpIHtcbiAgICAgIHZhciBlcnJvcl9zaXplID0gbG9jLmxhc3RfbGluZSAtIGxvYy5maXJzdF9saW5lO1xuICAgICAgY29uc3QgQ09OVEVYVCA9IDM7XG4gICAgICBjb25zdCBDT05URVhUX1RBSUwgPSAxO1xuICAgICAgY29uc3QgTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQgPSAyO1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5tYXRjaGVkICsgdGhpcy5faW5wdXQ7XG4gICAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIC8vdmFyIHNob3dfY29udGV4dCA9IChlcnJvcl9zaXplIDwgNSB8fCBjb250ZXh0X2xvYyk7XG4gICAgICB2YXIgbDAgPSBNYXRoLm1heCgxLCAoY29udGV4dF9sb2MgPyBjb250ZXh0X2xvYy5maXJzdF9saW5lIDogbG9jLmZpcnN0X2xpbmUgLSBDT05URVhUKSk7XG5cbiAgICAgIHZhciBsMSA9IE1hdGgubWF4KDEsIChjb250ZXh0X2xvYzIgPyBjb250ZXh0X2xvYzIubGFzdF9saW5lIDogbG9jLmxhc3RfbGluZSArIENPTlRFWFRfVEFJTCkpO1xuICAgICAgdmFyIGxpbmVub19kaXNwbGF5X3dpZHRoID0gMSArIE1hdGgubG9nMTAobDEgfCAxKSB8IDA7XG4gICAgICB2YXIgd3NfcHJlZml4ID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoKS5qb2luKCcgJyk7XG4gICAgICB2YXIgbm9uZW1wdHlfbGluZV9pbmRleGVzID0gW107XG5cbiAgICAgIHZhciBydiA9IGxpbmVzLnNsaWNlKGwwIC0gMSwgbDEgKyAxKS5tYXAoZnVuY3Rpb24gaW5qZWN0TGluZU51bWJlcihsaW5lLCBpbmRleCkge1xuICAgICAgICB2YXIgbG5vID0gaW5kZXggKyBsMDtcbiAgICAgICAgdmFyIGxub19wZnggPSAod3NfcHJlZml4ICsgbG5vKS5zdWJzdHIoLWxpbmVub19kaXNwbGF5X3dpZHRoKTtcbiAgICAgICAgdmFyIHJ2ID0gbG5vX3BmeCArICc6ICcgKyBsaW5lO1xuICAgICAgICB2YXIgZXJycGZ4ID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignXicpO1xuXG4gICAgICAgIGlmIChsbm8gPT09IGxvYy5maXJzdF9saW5lKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IGxvYy5maXJzdF9jb2x1bW4gKyAyO1xuXG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgICgobG5vID09PSBsb2MubGFzdF9saW5lID8gbG9jLmxhc3RfY29sdW1uIDogbGluZS5sZW5ndGgpKSAtIGxvYy5maXJzdF9jb2x1bW4gKyAxXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZhciBsZWFkID0gbmV3IEFycmF5KG9mZnNldCkuam9pbignLicpO1xuICAgICAgICAgIHZhciBtYXJrID0gbmV3IEFycmF5KGxlbikuam9pbignXicpO1xuICAgICAgICAgIHJ2ICs9ICdcXG4nICsgZXJycGZ4ICsgbGVhZCArIG1hcms7XG5cbiAgICAgICAgICBpZiAobGluZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbm9uZW1wdHlfbGluZV9pbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsbm8gPT09IGxvYy5sYXN0X2xpbmUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMiArIDE7XG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KDIsIGxvYy5sYXN0X2NvbHVtbiArIDEpO1xuICAgICAgICAgIHZhciBsZWFkID0gbmV3IEFycmF5KG9mZnNldCkuam9pbignLicpO1xuICAgICAgICAgIHZhciBtYXJrID0gbmV3IEFycmF5KGxlbikuam9pbignXicpO1xuICAgICAgICAgIHJ2ICs9ICdcXG4nICsgZXJycGZ4ICsgbGVhZCArIG1hcms7XG5cbiAgICAgICAgICBpZiAobGluZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbm9uZW1wdHlfbGluZV9pbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsbm8gPiBsb2MuZmlyc3RfbGluZSAmJiBsbm8gPCBsb2MubGFzdF9saW5lKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDIgKyAxO1xuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgyLCBsaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgIHZhciBsZWFkID0gbmV3IEFycmF5KG9mZnNldCkuam9pbignLicpO1xuICAgICAgICAgIHZhciBtYXJrID0gbmV3IEFycmF5KGxlbikuam9pbignXicpO1xuICAgICAgICAgIHJ2ICs9ICdcXG4nICsgZXJycGZ4ICsgbGVhZCArIG1hcms7XG5cbiAgICAgICAgICBpZiAobGluZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbm9uZW1wdHlfbGluZV9pbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ2ID0gcnYucmVwbGFjZSgvXFx0L2csICcgJyk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IHByaW50IGFuIG92ZXJseSBsYXJnZSBhbW91bnQgb2YgZXJyb3IgYXJlYTogbGltaXQgaXQgXG4gICAgICAvLyB0byB0aGUgdG9wIGFuZCBib3R0b20gbGluZSBjb3VudDpcbiAgICAgIGlmIChub25lbXB0eV9saW5lX2luZGV4ZXMubGVuZ3RoID4gMiAqIE1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UKSB7XG4gICAgICAgIHZhciBjbGlwX3N0YXJ0ID0gbm9uZW1wdHlfbGluZV9pbmRleGVzW01JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UIC0gMV0gKyAxO1xuICAgICAgICB2YXIgY2xpcF9lbmQgPSBub25lbXB0eV9saW5lX2luZGV4ZXNbbm9uZW1wdHlfbGluZV9pbmRleGVzLmxlbmd0aCAtIE1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UXSAtIDE7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2NsaXAgb2ZmOiAnLCB7XG4gICAgICAgICAgc3RhcnQ6IGNsaXBfc3RhcnQsXG4gICAgICAgICAgZW5kOiBjbGlwX2VuZCxcbiAgICAgICAgICBsZW46IGNsaXBfZW5kIC0gY2xpcF9zdGFydCArIDEsXG4gICAgICAgICAgYXJyOiBub25lbXB0eV9saW5lX2luZGV4ZXMsXG4gICAgICAgICAgcnZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGludGVybWVkaWF0ZV9saW5lID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignICcpICsgJyAgKC4uLmNvbnRpbnVlZC4uLiknO1xuICAgICAgICBpbnRlcm1lZGlhdGVfbGluZSArPSAnXFxuJyArIG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJy0nKSArICcgICgtLS0tLS0tLS0tLS0tLS0pJztcbiAgICAgICAgcnYuc3BsaWNlKGNsaXBfc3RhcnQsIGNsaXBfZW5kIC0gY2xpcF9zdGFydCArIDEsIGludGVybWVkaWF0ZV9saW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2LmpvaW4oJ1xcbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgZnVuY3Rpb24sIHVzZWQgdG8gcHJvZHVjZSBhIGh1bWFuIHJlYWRhYmxlIGRlc2NyaXB0aW9uIGFzIGEgc3RyaW5nLCBnaXZlblxuICAgICAqIHRoZSBpbnB1dCBgeXlsbG9jYCBsb2NhdGlvbiBvYmplY3QuXG4gICAgICogXG4gICAgICogU2V0IGBkaXNwbGF5X3JhbmdlX3Rvb2AgdG8gVFJVRSB0byBpbmNsdWRlIHRoZSBzdHJpbmcgY2hhcmFjdGVyIGluZGV4IHBvc2l0aW9uKHMpXG4gICAgICogaW4gdGhlIGRlc2NyaXB0aW9uIGlmIHRoZSBgeXlsbG9jLnJhbmdlYCBpcyBhdmFpbGFibGUuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBkZXNjcmliZVlZTExPQzogZnVuY3Rpb24gbGV4ZXJfZGVzY3JpYmVfeXlsbG9jKHl5bGxvYywgZGlzcGxheV9yYW5nZV90b28pIHtcbiAgICAgIHZhciBsMSA9IHl5bGxvYy5maXJzdF9saW5lO1xuICAgICAgdmFyIGwyID0geXlsbG9jLmxhc3RfbGluZTtcbiAgICAgIHZhciBjMSA9IHl5bGxvYy5maXJzdF9jb2x1bW47XG4gICAgICB2YXIgYzIgPSB5eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICB2YXIgZGwgPSBsMiAtIGwxO1xuICAgICAgdmFyIGRjID0gYzIgLSBjMTtcbiAgICAgIHZhciBydjtcblxuICAgICAgaWYgKGRsID09PSAwKSB7XG4gICAgICAgIHJ2ID0gJ2xpbmUgJyArIGwxICsgJywgJztcblxuICAgICAgICBpZiAoZGMgPD0gMSkge1xuICAgICAgICAgIHJ2ICs9ICdjb2x1bW4gJyArIGMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ICs9ICdjb2x1bW5zICcgKyBjMSArICcgLi4gJyArIGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydiA9ICdsaW5lcyAnICsgbDEgKyAnKGNvbHVtbiAnICsgYzEgKyAnKSAuLiAnICsgbDIgKyAnKGNvbHVtbiAnICsgYzIgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh5eWxsb2MucmFuZ2UgJiYgZGlzcGxheV9yYW5nZV90b28pIHtcbiAgICAgICAgdmFyIHIxID0geXlsbG9jLnJhbmdlWzBdO1xuICAgICAgICB2YXIgcjIgPSB5eWxsb2MucmFuZ2VbMV0gLSAxO1xuXG4gICAgICAgIGlmIChyMiA8PSByMSkge1xuICAgICAgICAgIHJ2ICs9ICcge1N0cmluZyBPZmZzZXQ6ICcgKyByMSArICd9JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydiArPSAnIHtTdHJpbmcgT2Zmc2V0IHJhbmdlOiAnICsgcjEgKyAnIC4uICcgKyByMiArICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlbi5cbiAgICAgKiBcbiAgICAgKiBgbWF0Y2hgIGlzIHN1cHBvc2VkIHRvIGJlIGFuIGFycmF5IGNvbWluZyBvdXQgb2YgYSByZWdleCBtYXRjaCwgaS5lLiBgbWF0Y2hbMF1gXG4gICAgICogY29udGFpbnMgdGhlIGFjdHVhbGx5IG1hdGNoZWQgdGV4dCBzdHJpbmcuXG4gICAgICogXG4gICAgICogQWxzbyBtb3ZlIHRoZSBpbnB1dCBjdXJzb3IgZm9yd2FyZCBhbmQgdXBkYXRlIHRoZSBtYXRjaCBjb2xsZWN0b3JzOlxuICAgICAqIFxuICAgICAqIC0gYHl5dGV4dGBcbiAgICAgKiAtIGB5eWxlbmdgXG4gICAgICogLSBgbWF0Y2hgXG4gICAgICogLSBgbWF0Y2hlc2BcbiAgICAgKiAtIGB5eWxsb2NgXG4gICAgICogLSBgb2Zmc2V0YFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdGVzdF9tYXRjaDogZnVuY3Rpb24gbGV4ZXJfdGVzdF9tYXRjaChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICB2YXIgdG9rZW4sIGxpbmVzLCBiYWNrdXAsIG1hdGNoX3N0ciwgbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcblxuICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICByYW5nZTogdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMClcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuXG4gICAgICAgICAgLy9fc2lnbmFsZWRfZXJyb3JfdG9rZW46IHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuLFxuICAgICAgICAgIHl5OiB0aGlzLnl5LFxuXG4gICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1hdGNoX3N0ciA9IG1hdGNoWzBdO1xuICAgICAgbWF0Y2hfc3RyX2xlbiA9IG1hdGNoX3N0ci5sZW5ndGg7XG5cbiAgICAgIC8vIGlmIChtYXRjaF9zdHIuaW5kZXhPZignXFxuJykgIT09IC0xIHx8IG1hdGNoX3N0ci5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICAgIGxpbmVzID0gbWF0Y2hfc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gdGhpcy55eWxpbmVubyArIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKz0gbWF0Y2hfc3RyX2xlbjtcbiAgICAgIH1cblxuICAgICAgLy8gfVxuICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hfc3RyO1xuXG4gICAgICB0aGlzLm1hdGNoICs9IG1hdGNoX3N0cjtcbiAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaF9zdHI7XG4gICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0gKz0gbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgLy8gcHJldmlvdXMgbGV4IHJ1bGVzIE1BWSBoYXZlIGludm9rZWQgdGhlIGBtb3JlKClgIEFQSSByYXRoZXIgdGhhbiBwcm9kdWNpbmcgYSB0b2tlbjpcbiAgICAgIC8vIHRob3NlIHJ1bGVzIHdpbGwgYWxyZWFkeSBoYXZlIG1vdmVkIHRoaXMgYG9mZnNldGAgZm9yd2FyZCBtYXRjaGluZyB0aGVpciBtYXRjaCBsZW5ndGhzLFxuICAgICAgLy8gaGVuY2Ugd2UgbXVzdCBvbmx5IGFkZCBvdXIgb3duIG1hdGNoIGxlbmd0aCBub3c6XG4gICAgICB0aGlzLm9mZnNldCArPSBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hfc3RyX2xlbik7XG5cbiAgICAgIC8vIGNhbGxpbmcgdGhpcyBtZXRob2Q6XG4gICAgICAvL1xuICAgICAgLy8gICBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCkgey4uLn1cbiAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMueXksXG4gICAgICAgIGluZGV4ZWRfcnVsZSxcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdIC8qID0gWVlfU1RBUlQgKi9cbiAgICAgICk7XG5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2hlbiB0aGUgYWN0aW9uIGNvZGVzIGFyZSBhbGwgc2ltcGxlIHJldHVybiB0b2tlbiBzdGF0ZW1lbnRzOlxuICAgICAgLy90b2tlbiA9IHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW2luZGV4ZWRfcnVsZV07XG5cbiAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgICByZXR1cm4gZmFsc2U7ICAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuIFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbikge1xuICAgICAgICAvLyBwcm9kdWNlIG9uZSAnZXJyb3InIHRva2VuIGFzIGAucGFyc2VFcnJvcigpYCBpbiBgcmVqZWN0KClgXG4gICAgICAgIC8vIGRpZCBub3QgZ3VhcmFudGVlIGEgZmFpbHVyZSBzaWduYWwgYnkgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIVxuICAgICAgICB0b2tlbiA9IHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24gbGV4ZXJfbmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBtYXRjaCwgdGVtcE1hdGNoLCBpbmRleDtcblxuICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWMgPSB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXztcblxuICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcnVsZXNldCBjYWNoZSBhcyB3ZSBhcHBhcmVudGx5IGVuY291bnRlcmVkIGEgc3RhdGUgY2hhbmdlIG9yIGp1c3Qgc3RhcnRlZCBsZXhpbmcuXG4gICAgICAgIC8vIFRoZSBjYWNoZSBpcyBzZXQgdXAgZm9yIGZhc3QgbG9va3VwIC0tIHdlIGFzc3VtZSBhIGxleGVyIHdpbGwgc3dpdGNoIHN0YXRlcyBtdWNoIGxlc3Mgb2Z0ZW4gdGhhbiBpdCB3aWxsXG4gICAgICAgIC8vIGludm9rZSB0aGUgYGxleCgpYCB0b2tlbi1wcm9kdWNpbmcgQVBJIGFuZCByZWxhdGVkIEFQSXMsIGhlbmNlIGNhY2hpbmcgdGhlIHNldCBmb3IgZGlyZWN0IGFjY2VzcyBoZWxwc1xuICAgICAgICAvLyBzcGVlZCB1cCB0aG9zZSBhY3Rpdml0aWVzIGEgdGlueSBiaXQuXG4gICAgICAgIHNwZWMgPSB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYSAqc2FuZSogY29uZGl0aW9uIGhhcyBiZWVuIHB1c2hlZCBiZWZvcmU6IHRoaXMgbWFrZXMgdGhlIGxleGVyIHJvYnVzdCBhZ2FpbnN0XG4gICAgICAgIC8vIHVzZXItcHJvZ3JhbW1lciBidWdzIHN1Y2ggYXMgaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uLWxleC9pc3N1ZXMvMTlcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLnJ1bGVzKSB7XG4gICAgICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9zX3N0ciA9ICcnO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcG9zX3N0ciA9IHRoaXMuc2hvd1Bvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmIChwb3Nfc3RyICYmIHBvc19zdHJbMF0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHBvc19zdHIgPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAgICdJbnRlcm5hbCBsZXhlciBlbmdpbmUgZXJyb3InICsgbGluZW5vX21zZyArICc6IFRoZSBsZXggZ3JhbW1hciBwcm9ncmFtbWVyIHB1c2hlZCBhIG5vbi1leGlzdGluZyBjb25kaXRpb24gbmFtZSBcIicgKyB0aGlzLnRvcFN0YXRlKCkgKyAnXCI7IHRoaXMgaXMgYSBmYXRhbCBlcnJvciBhbmQgc2hvdWxkIGJlIHJlcG9ydGVkIHRvIHRoZSBhcHBsaWNhdGlvbiBwcm9ncmFtbWVyIHRlYW0hJyArIHBvc19zdHIsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBwcm9kdWNlIG9uZSAnZXJyb3InIHRva2VuIHVudGlsIHRoaXMgc2l0dWF0aW9uIGhhcyBiZWVuIHJlc29sdmVkLCBtb3N0IHByb2JhYmx5IGJ5IHBhcnNlIHRlcm1pbmF0aW9uIVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBydWxlX2lkcyA9IHNwZWMucnVsZXM7XG4gICAgICB2YXIgcmVnZXhlcyA9IHNwZWMuX19ydWxlX3JlZ2V4ZXM7XG4gICAgICB2YXIgbGVuID0gc3BlYy5fX3J1bGVfY291bnQ7XG5cbiAgICAgIC8vIE5vdGU6IHRoZSBhcnJheXMgYXJlIDEtYmFzZWQsIHdoaWxlIGBsZW5gIGl0c2VsZiBpcyBhIHZhbGlkIGluZGV4LFxuICAgICAgLy8gaGVuY2UgdGhlIG5vbi1zdGFuZGFyZCBsZXNzLW9yLWVxdWFsIGNoZWNrIGluIHRoZSBuZXh0IGxvb3AgY29uZGl0aW9uIVxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2gocmVnZXhlc1tpXSk7XG5cbiAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZV9pZHNbaV0pO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjb250aW51ZTsgIC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVfaWRzW2luZGV4XSk7XG5cbiAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc19zdHIgPSAnJztcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG9zX3N0ciA9IHRoaXMuc2hvd1Bvc2l0aW9uKCk7XG5cbiAgICAgICAgICBpZiAocG9zX3N0ciAmJiBwb3Nfc3RyWzBdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgcG9zX3N0ciA9ICdcXG4nICsgcG9zX3N0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAgICdMZXhpY2FsIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBVbnJlY29nbml6ZWQgdGV4dC4nICsgcG9zX3N0cixcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubGV4ZXJFcnJvcnNBcmVSZWNvdmVyYWJsZVxuICAgICAgICApO1xuXG4gICAgICAgIHRva2VuID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcblxuICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMuRVJST1IpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4gdHJ5IHRvIHJlY292ZXIgZnJvbSBhIGxleGVyIGVycm9yIHRoYXQgYHBhcnNlRXJyb3IoKWAgZGlkIG5vdCAncmVjb3ZlcicgZm9yIHVzXG4gICAgICAgICAgLy8gYnkgbW92aW5nIGZvcndhcmQgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhdCBhIHRpbWU6XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbGV4OiBmdW5jdGlvbiBsZXhlcl9sZXgoKSB7XG4gICAgICB2YXIgcjtcblxuICAgICAgLy8gYWxsb3cgdGhlIFBSRS9QT1NUIGhhbmRsZXJzIHNldC9tb2RpZnkgdGhlIHJldHVybiB0b2tlbiBmb3IgbWF4aW11bSBmbGV4aWJpbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIGxleGVyOlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlX2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByID0gdGhpcy5vcHRpb25zLnByZV9sZXguY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFyKSB7XG4gICAgICAgIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucG9zdF9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKGFsc28gYWNjb3VudCBmb3IgYSB1c2VyZGVmIGZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWU6IGtlZXAgdGhlIHRva2VuIGFzIGlzKVxuICAgICAgICByID0gdGhpcy5vcHRpb25zLnBvc3RfbGV4LmNhbGwodGhpcywgcikgfHwgcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJhY2t3YXJkcyBjb21wYXRpYmxlIGFsaWFzIGZvciBgcHVzaFN0YXRlKClgO1xuICAgICAqIHRoZSBsYXR0ZXIgaXMgc3ltbWV0cmljYWwgd2l0aCBgcG9wU3RhdGUoKWAgYW5kIHdlIGFkdmlzZSB0byB1c2VcbiAgICAgKiB0aG9zZSBBUElzIGluIGFueSBtb2Rlcm4gbGV4ZXIgY29kZSwgcmF0aGVyIHRoYW4gYGJlZ2luKClgLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgYmVnaW46IGZ1bmN0aW9uIGxleGVyX2JlZ2luKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YXRlKGNvbmRpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyXG4gICAgICogY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb25cbiAgICAgKiBzdGFja1xuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcG9wU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3BvcFN0YXRlKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChuID4gMCkge1xuICAgICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXhcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsXG4gICAgICogaWYgYXZhaWxhYmxlXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB0b3BTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfdG9wU3RhdGUobikge1xuICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG5cbiAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0lOSVRJQUwnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAoaW50ZXJuYWwpIGRldGVybWluZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGVcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24gbGV4ZXJfX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1snSU5JVElBTCddO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc3RhdGVTdGFja1NpemU6IGZ1bmN0aW9uIGxleGVyX3N0YXRlU3RhY2tTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICBmbGV4OiB0cnVlLFxuICAgICAgdHJhY2tQb3NpdGlvbjogdHJ1ZSxcbiAgICAgIHBhcnNlQWN0aW9uc1VzZVlZTUVSR0VMT0NBVElPTklORk86IHRydWVcbiAgICB9LFxuXG4gICAgSmlzb25MZXhlckVycm9yOiBKaXNvbkxleGVyRXJyb3IsXG5cbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCkge1xuICAgICAgdmFyIHl5XyA9IHRoaXM7XG4gICAgICB2YXIgWVlTVEFURSA9IFlZX1NUQVJUO1xuXG4gICAgICBzd2l0Y2ggKHl5cnVsZW51bWJlcikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHMrICovXG4gICAgICAgIHJldHVybjtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHslICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTlRST0wnKTtcblxuICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwhLS0gKi9cbiAgICAgICAgdGhpcy5iZWdpbignQ09NTUVOVCcpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdUQUcnKTtcblxuICAgICAgICByZXR1cm4gMTM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxce1xceyAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdFWFBSRVNTSU9OJyk7XG5cbiAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8+ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gMzc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE3OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgID4gKi9cbiAgICAgICAgdGhpcy5iZWdpbignQ0hJTERSRU4nKTtcblxuICAgICAgICByZXR1cm4gMTQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE4OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxce1xceyAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdFWFBSRVNTSU9OJyk7XG5cbiAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxce1xceyAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdFWFBSRVNTSU9OJyk7XG5cbiAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyMDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyUgKi9cbiAgICAgICAgdGhpcy5iZWdpbignQ09OVFJPTCcpO1xuXG4gICAgICAgIHJldHVybiAyODtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjE6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8IS0tICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTU1FTlQnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDIyOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPFxcLyAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdUQUcnKTtcblxuICAgICAgICByZXR1cm4gMzY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDIzOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdUQUcnKTtcblxuICAgICAgICByZXR1cm4gMTM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDU0OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA9ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTlRST0xfQ0hJTEQnKTtcblxuICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICVcXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1OTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAlXFx9ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDc2OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH1cXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNzc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09NTUVOVCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICgufFxccnxcXG4pKj8tLT4gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTA4OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAuICovXG4gICAgICAgIGNvbnNvbGUubG9nKCcnLCB5eV8ueXl0ZXh0KTtcblxuICAgICAgICAvKiBgZmxleGAgbGV4aW5nIG1vZGU6IHRoZSBsYXN0IHJlc29ydCBydWxlISAqL1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW3l5cnVsZW51bWJlcl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyczoge1xuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGltcG9ydCAqL1xuICAgICAgMTogMjUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmcm9tICovXG4gICAgICAyOiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHVzaW5nICovXG4gICAgICAzOiAnVVNJTkcnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDQ6IDI3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgOTogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDEwOiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdHJ1ZSAqL1xuICAgICAgMTE6IDUzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmYWxzZSAqL1xuICAgICAgMTI6IDU0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICAxMzogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgMTQ6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8gKi9cbiAgICAgIDE2OiAnTk9TRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgW14vPD57JX1dKyAqL1xuICAgICAgMjQ6IDQ3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgbWFpbiAqL1xuICAgICAgMjU6IDI5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kbWFpbiAqL1xuICAgICAgMjY6ICdFTkRNQUlOJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIG1hY3JvICovXG4gICAgICAyNzogJ01BQ1JPJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZG1hY3JvICovXG4gICAgICAyODogJ0VORE1BQ1JPJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZvciAqL1xuICAgICAgMjk6IDQwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kZm9yICovXG4gICAgICAzMDogNDIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpZiAqL1xuICAgICAgMzE6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kaWYgKi9cbiAgICAgIDMyOiA0NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVsc2UgKi9cbiAgICAgIDMzOiA0NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVsc2VpZiAqL1xuICAgICAgMzQ6ICdFTFNFSUYnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgaW4gKi9cbiAgICAgIDM1OiA0MSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGNhc2UgKi9cbiAgICAgIDM2OiAnQ0FTRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRjYXNlICovXG4gICAgICAzNzogJ0VORENBU0UnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZXhwb3J0ICovXG4gICAgICAzODogMzEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmcm9tICovXG4gICAgICAzOTogMjYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB2aWV3ICovXG4gICAgICA0MDogMzIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB1c2luZyAqL1xuICAgICAgNDE6ICdVU0lORycsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmR2aWV3ICovXG4gICAgICA0MjogMzMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBtYXRjaCAqL1xuICAgICAgNDM6ICdNQVRDSCcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRtYXRjaCAqL1xuICAgICAgNDQ6ICdFTkRNQVRDSCcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpbnN0YW5jZW9mICovXG4gICAgICA0NTogNjMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB0eXBlb2YgKi9cbiAgICAgIDQ2OiAnVFlQRU9GJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRoaXMgKi9cbiAgICAgIDQ3OiAnVEhJUycsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmdW4gKi9cbiAgICAgIDQ4OiAzNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZGZ1biAqL1xuICAgICAgNDk6IDM1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDUwOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIDo6ICovXG4gICAgICA1MTogJzo6JyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDUyOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKFxcKSAqL1xuICAgICAgNTM6ICcoKScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICA1NTogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDU2OiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDYxOiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgNjI6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx8ICovXG4gICAgICA2MzogMTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PiAqL1xuICAgICAgNjQ6IDUwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLT4gKi9cbiAgICAgIDY1OiAnLT4nLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgQCAqL1xuICAgICAgNjY6IDE5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgaW5zdGFuY2VvZiAqL1xuICAgICAgNjc6IDYzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdHJ1ZSAqL1xuICAgICAgNjg6IDUzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZmFsc2UgKi9cbiAgICAgIDY5OiA1NCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGlmICovXG4gICAgICA3MDogNDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB0aGVuICovXG4gICAgICA3MTogNDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbHNlICovXG4gICAgICA3MjogNDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBhcyAqL1xuICAgICAgNzM6IDI3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgNzQ6IDU2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICA3NTogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7TnVtYmVyTGl0ZXJhbH0gKi9cbiAgICAgIDc4OiA1MixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtTdHJpbmdMaXRlcmFsfSAqL1xuICAgICAgNzk6IDUxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPiAqL1xuICAgICAgODA6IDE0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgODE6IDEzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwoICovXG4gICAgICA4MjogNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKSAqL1xuICAgICAgODM6IDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFsgKi9cbiAgICAgIDg0OiAxMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcXSAqL1xuICAgICAgODU6IDExLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOyAqL1xuICAgICAgODY6IDIwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOiAqL1xuICAgICAgODc6IDEyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgODg6IDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PSAqL1xuICAgICAgODk6IDU5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgIT0gKi9cbiAgICAgIDkwOiA2MCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgID49ICovXG4gICAgICA5MTogNTcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA8PSAqL1xuICAgICAgOTI6IDU4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwrICovXG4gICAgICA5MzogMjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAtICovXG4gICAgICA5NDogMjMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCogKi9cbiAgICAgIDk1OiAzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwvICovXG4gICAgICA5NjogMjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFxcICovXG4gICAgICA5NzogNDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAmJiAqL1xuICAgICAgOTg6IDYxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx8XFx8ICovXG4gICAgICA5OTogNjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXF4gKi9cbiAgICAgIDEwMDogMjQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAhICovXG4gICAgICAxMDE6IDE2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLCAqL1xuICAgICAgMTAyOiA2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFw/ICovXG4gICAgICAxMDM6IDE4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwuICovXG4gICAgICAxMDQ6IDE3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICAxMDU6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDEwNjogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICQgKi9cbiAgICAgIDEwNzogMVxuICAgIH0sXG5cbiAgICBydWxlczogW1xuICAgICAgLyogICAwOiAqLyAgL14oPzpcXHMrKS8sXG4gICAgICAvKiAgIDE6ICovICAvXig/OmltcG9ydCkvLFxuICAgICAgLyogICAyOiAqLyAgL14oPzpmcm9tKS8sXG4gICAgICAvKiAgIDM6ICovICAvXig/OnVzaW5nKS8sXG4gICAgICAvKiAgIDQ6ICovICAvXig/OmFzKS8sXG4gICAgICAvKiAgIDU6ICovICAvXig/OlxceyUpLyxcbiAgICAgIC8qICAgNjogKi8gIC9eKD86PCEtLSkvLFxuICAgICAgLyogICA3OiAqLyAgL14oPzo8KS8sXG4gICAgICAvKiAgIDg6ICovICAvXig/Olxce1xceykvLFxuICAgICAgLyogICA5OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDEwOiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTE6ICovICAvXig/OnRydWUpLyxcbiAgICAgIC8qICAxMjogKi8gIC9eKD86ZmFsc2UpLyxcbiAgICAgIC8qICAxMzogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICAxNDogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDE1OiAqLyAgL14oPzpcXC8+KS8sXG4gICAgICAvKiAgMTY6ICovICAvXig/OlxcLykvLFxuICAgICAgLyogIDE3OiAqLyAgL14oPzo+KS8sXG4gICAgICAvKiAgMTg6ICovICAvXig/Olxce1xceykvLFxuICAgICAgLyogIDE5OiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICAyMDogKi8gIC9eKD86XFx7JSkvLFxuICAgICAgLyogIDIxOiAqLyAgL14oPzo8IS0tKS8sXG4gICAgICAvKiAgMjI6ICovICAvXig/OjxcXC8pLyxcbiAgICAgIC8qICAyMzogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDI0OiAqLyAgL14oPzpbXlxcLzw+eyV9XSspLyxcbiAgICAgIC8qICAyNTogKi8gIC9eKD86bWFpbikvLFxuICAgICAgLyogIDI2OiAqLyAgL14oPzplbmRtYWluKS8sXG4gICAgICAvKiAgMjc6ICovICAvXig/Om1hY3JvKS8sXG4gICAgICAvKiAgMjg6ICovICAvXig/OmVuZG1hY3JvKS8sXG4gICAgICAvKiAgMjk6ICovICAvXig/OmZvcikvLFxuICAgICAgLyogIDMwOiAqLyAgL14oPzplbmRmb3IpLyxcbiAgICAgIC8qICAzMTogKi8gIC9eKD86aWYpLyxcbiAgICAgIC8qICAzMjogKi8gIC9eKD86ZW5kaWYpLyxcbiAgICAgIC8qICAzMzogKi8gIC9eKD86ZWxzZSkvLFxuICAgICAgLyogIDM0OiAqLyAgL14oPzplbHNlaWYpLyxcbiAgICAgIC8qICAzNTogKi8gIC9eKD86aW4pLyxcbiAgICAgIC8qICAzNjogKi8gIC9eKD86Y2FzZSkvLFxuICAgICAgLyogIDM3OiAqLyAgL14oPzplbmRjYXNlKS8sXG4gICAgICAvKiAgMzg6ICovICAvXig/OmV4cG9ydCkvLFxuICAgICAgLyogIDM5OiAqLyAgL14oPzpmcm9tKS8sXG4gICAgICAvKiAgNDA6ICovICAvXig/OnZpZXcpLyxcbiAgICAgIC8qICA0MTogKi8gIC9eKD86dXNpbmcpLyxcbiAgICAgIC8qICA0MjogKi8gIC9eKD86ZW5kdmlldykvLFxuICAgICAgLyogIDQzOiAqLyAgL14oPzptYXRjaCkvLFxuICAgICAgLyogIDQ0OiAqLyAgL14oPzplbmRtYXRjaCkvLFxuICAgICAgLyogIDQ1OiAqLyAgL14oPzppbnN0YW5jZW9mKS8sXG4gICAgICAvKiAgNDY6ICovICAvXig/OnR5cGVvZikvLFxuICAgICAgLyogIDQ3OiAqLyAgL14oPzp0aGlzKS8sXG4gICAgICAvKiAgNDg6ICovICAvXig/OmZ1bikvLFxuICAgICAgLyogIDQ5OiAqLyAgL14oPzplbmRmdW4pLyxcbiAgICAgIC8qICA1MDogKi8gIC9eKD86YXMpLyxcbiAgICAgIC8qICA1MTogKi8gIC9eKD86OjopLyxcbiAgICAgIC8qICA1MjogKi8gIC9eKD86QCkvLFxuICAgICAgLyogIDUzOiAqLyAgL14oPzpcXChcXCkpLyxcbiAgICAgIC8qICA1NDogKi8gIC9eKD86PSkvLFxuICAgICAgLyogIDU1OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDU2OiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgNTc6ICovICAvXig/OiVcXH0pLyxcbiAgICAgIC8qICA1ODogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDU5OiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICA2MDogKi8gIC9eKD86JVxcfSkvLFxuICAgICAgLyogIDYxOiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDYyOiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgNjM6ICovICAvXig/OlxcfCkvLFxuICAgICAgLyogIDY0OiAqLyAgL14oPzo9PikvLFxuICAgICAgLyogIDY1OiAqLyAgL14oPzotPikvLFxuICAgICAgLyogIDY2OiAqLyAgL14oPzpAKS8sXG4gICAgICAvKiAgNjc6ICovICAvXig/Omluc3RhbmNlb2YpLyxcbiAgICAgIC8qICA2ODogKi8gIC9eKD86dHJ1ZSkvLFxuICAgICAgLyogIDY5OiAqLyAgL14oPzpmYWxzZSkvLFxuICAgICAgLyogIDcwOiAqLyAgL14oPzppZikvLFxuICAgICAgLyogIDcxOiAqLyAgL14oPzp0aGVuKS8sXG4gICAgICAvKiAgNzI6ICovICAvXig/OmVsc2UpLyxcbiAgICAgIC8qICA3MzogKi8gIC9eKD86YXMpLyxcbiAgICAgIC8qICA3NDogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA3NTogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDc2OiAqLyAgL14oPzpcXH1cXH0pLyxcbiAgICAgIC8qICA3NzogKi8gIC9eKD86KC58XFxyfFxcbikqPy0tPikvLFxuICAgICAgLyogIDc4OiAqLyAgL14oPzooKD86KFstXT8oPzpbLV0/KFswXXwoKD86WzEtOV0pKD86XFxkKykqKSkpXFwuKD86XFxkKykqKD86KD86W0VlXSkoPzpbKy1dP1xcZCspKT8pfChcXC4oPzpcXGQrKSg/Oig/OltFZV0pKD86WystXT9cXGQrKSk/KXwoKD86Wy1dPyhbMF18KCg/OlsxLTldKSg/OlxcZCspKikpKSg/Oig/OltFZV0pKD86WystXT9cXGQrKSk/KSl8KD86WzBdW1h4XSg/OltcXGRBLUZhLWZdKSspfCg/OlswXSg/OlswLTddKSspKSkvLFxuICAgICAgLyogIDc5OiAqLyAgL14oPzooKFwiKD86KFteXFxuXFxyXCJcXFxcXSspfChcXFxcKD86KD86KD86W1wiJ1xcXFxiZm5ydHZdKXwoPzpbXlxcZFwiJ1xcXFxiZm5ydC12eF0pKXwoPzooPzpbMS03XVswLTddezAsMn18WzAtN117MiwzfSkpfCg/Olt4XSg/OltcXGRBLUZhLWZdKXsyfSl8KD86W3VdKD86W1xcZEEtRmEtZl0pezR9KSkpfCg/OlxcXFwoXFxyXFxufFxccnxcXG4pKSkqXCIpfCgnKD86KFteXFxuXFxyJ1xcXFxdKyl8KFxcXFwoPzooPzooPzpbXCInXFxcXGJmbnJ0dl0pfCg/OlteXFxkXCInXFxcXGJmbnJ0LXZ4XSkpfCg/Oig/OlsxLTddWzAtN117MCwyfXxbMC03XXsyLDN9KSl8KD86W3hdKD86W1xcZEEtRmEtZl0pezJ9KXwoPzpbdV0oPzpbXFxkQS1GYS1mXSl7NH0pKSl8KD86XFxcXChcXHJcXG58XFxyfFxcbikpKSonKXwoYCg/OihbXlxcblxcclxcXFxgXSspfChcXFxcKD86KD86KD86W1wiJ1xcXFxiZm5ydHZdKXwoPzpbXlxcZFwiJ1xcXFxiZm5ydC12eF0pKXwoPzooPzpbMS03XVswLTddezAsMn18WzAtN117MiwzfSkpfCg/Olt4XSg/OltcXGRBLUZhLWZdKXsyfSl8KD86W3VdKD86W1xcZEEtRmEtZl0pezR9KSkpfCg/OlxcXFwoXFxyXFxufFxccnxcXG4pKSkqYCkpKS8sXG4gICAgICAvKiAgODA6ICovICAvXig/Oj4pLyxcbiAgICAgIC8qICA4MTogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDgyOiAqLyAgL14oPzpcXCgpLyxcbiAgICAgIC8qICA4MzogKi8gIC9eKD86XFwpKS8sXG4gICAgICAvKiAgODQ6ICovICAvXig/OlxcWykvLFxuICAgICAgLyogIDg1OiAqLyAgL14oPzpcXF0pLyxcbiAgICAgIC8qICA4NjogKi8gIC9eKD86OykvLFxuICAgICAgLyogIDg3OiAqLyAgL14oPzo6KS8sXG4gICAgICAvKiAgODg6ICovICAvXig/Oj0pLyxcbiAgICAgIC8qICA4OTogKi8gIC9eKD86PT0pLyxcbiAgICAgIC8qICA5MDogKi8gIC9eKD86IT0pLyxcbiAgICAgIC8qICA5MTogKi8gIC9eKD86Pj0pLyxcbiAgICAgIC8qICA5MjogKi8gIC9eKD86PD0pLyxcbiAgICAgIC8qICA5MzogKi8gIC9eKD86XFwrKS8sXG4gICAgICAvKiAgOTQ6ICovICAvXig/Oi0pLyxcbiAgICAgIC8qICA5NTogKi8gIC9eKD86XFwqKS8sXG4gICAgICAvKiAgOTY6ICovICAvXig/OlxcLykvLFxuICAgICAgLyogIDk3OiAqLyAgL14oPzpcXFxcKS8sXG4gICAgICAvKiAgOTg6ICovICAvXig/OiYmKS8sXG4gICAgICAvKiAgOTk6ICovICAvXig/OlxcfFxcfCkvLFxuICAgICAgLyogMTAwOiAqLyAgL14oPzpcXF4pLyxcbiAgICAgIC8qIDEwMTogKi8gIC9eKD86ISkvLFxuICAgICAgLyogMTAyOiAqLyAgL14oPzosKS8sXG4gICAgICAvKiAxMDM6ICovICAvXig/OlxcPykvLFxuICAgICAgLyogMTA0OiAqLyAgL14oPzpcXC4pLyxcbiAgICAgIC8qIDEwNTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAxMDY6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogMTA3OiAqLyAgL14oPzokKS8sXG4gICAgICAvKiAxMDg6ICovICAvXig/Oi4pL1xuICAgIF0sXG5cbiAgICBjb25kaXRpb25zOiB7XG4gICAgICAnQ0hJTERSRU4nOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxOSxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAyMSxcbiAgICAgICAgICAyMixcbiAgICAgICAgICAyMyxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTU1FTlQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA3NyxcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTlRST0wnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAyNSxcbiAgICAgICAgICAyNixcbiAgICAgICAgICAyNyxcbiAgICAgICAgICAyOCxcbiAgICAgICAgICAyOSxcbiAgICAgICAgICAzMCxcbiAgICAgICAgICAzMSxcbiAgICAgICAgICAzMixcbiAgICAgICAgICAzMyxcbiAgICAgICAgICAzNCxcbiAgICAgICAgICAzNSxcbiAgICAgICAgICAzNixcbiAgICAgICAgICAzNyxcbiAgICAgICAgICAzOCxcbiAgICAgICAgICAzOSxcbiAgICAgICAgICA0MCxcbiAgICAgICAgICA0MSxcbiAgICAgICAgICA0MixcbiAgICAgICAgICA0MyxcbiAgICAgICAgICA0NCxcbiAgICAgICAgICA0NSxcbiAgICAgICAgICA0NixcbiAgICAgICAgICA0NyxcbiAgICAgICAgICA0OCxcbiAgICAgICAgICA0OSxcbiAgICAgICAgICA1MCxcbiAgICAgICAgICA1MSxcbiAgICAgICAgICA1MixcbiAgICAgICAgICA1MyxcbiAgICAgICAgICA1NCxcbiAgICAgICAgICA1NSxcbiAgICAgICAgICA1NixcbiAgICAgICAgICA1NyxcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0VYUFJFU1NJT04nOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA2MyxcbiAgICAgICAgICA2NCxcbiAgICAgICAgICA2NSxcbiAgICAgICAgICA2NixcbiAgICAgICAgICA2NyxcbiAgICAgICAgICA2OCxcbiAgICAgICAgICA2OSxcbiAgICAgICAgICA3MCxcbiAgICAgICAgICA3MSxcbiAgICAgICAgICA3MixcbiAgICAgICAgICA3MyxcbiAgICAgICAgICA3NCxcbiAgICAgICAgICA3NSxcbiAgICAgICAgICA3NixcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTlRST0xfQ0hJTEQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA1OCxcbiAgICAgICAgICA1OSxcbiAgICAgICAgICA2MCxcbiAgICAgICAgICA2MSxcbiAgICAgICAgICA2MixcbiAgICAgICAgICA3OCxcbiAgICAgICAgICA3OSxcbiAgICAgICAgICA4MCxcbiAgICAgICAgICA4MSxcbiAgICAgICAgICA4MixcbiAgICAgICAgICA4MyxcbiAgICAgICAgICA4NCxcbiAgICAgICAgICA4NSxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ1RBRyc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDExLFxuICAgICAgICAgIDEyLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgIDE0LFxuICAgICAgICAgIDE1LFxuICAgICAgICAgIDE2LFxuICAgICAgICAgIDE3LFxuICAgICAgICAgIDE4LFxuICAgICAgICAgIDc4LFxuICAgICAgICAgIDc5LFxuICAgICAgICAgIDgwLFxuICAgICAgICAgIDgxLFxuICAgICAgICAgIDgyLFxuICAgICAgICAgIDgzLFxuICAgICAgICAgIDg0LFxuICAgICAgICAgIDg1LFxuICAgICAgICAgIDg2LFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDdcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnSU5JVElBTCc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMixcbiAgICAgICAgICAzLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgNSxcbiAgICAgICAgICA2LFxuICAgICAgICAgIDcsXG4gICAgICAgICAgOCxcbiAgICAgICAgICA5LFxuICAgICAgICAgIDEwLFxuICAgICAgICAgIDc4LFxuICAgICAgICAgIDc5LFxuICAgICAgICAgIDgwLFxuICAgICAgICAgIDgxLFxuICAgICAgICAgIDgyLFxuICAgICAgICAgIDgzLFxuICAgICAgICAgIDg0LFxuICAgICAgICAgIDg1LFxuICAgICAgICAgIDg2LFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsZXhlcjtcbn0oKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuXG5mdW5jdGlvbiBQYXJzZXIoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7XG5wYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xuXG5yZXR1cm4gbmV3IFBhcnNlcigpO1xufSkoKTtcblxuICAgICAgICBcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLnBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXIuUGFyc2VyO1xuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UuYXBwbHkoUGFyc2VyLCBhcmd1bWVudHMpO1xuICB9O1xuICBcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5vZGVzID0gcmVxdWlyZShcIi4vQVNUXCIpO1xudmFyIGFmcGwgPSByZXF1aXJlKFwiYWZwbFwiKTtcbnZhciBDT05URVhUID0gJ19fX2NvbnRleHQnO1xudmFyIFZJRVcgPSAnX19fdmlldyc7XG52YXIgcHJpbXMgPSBbJ1N0cmluZycsICdCb29sZWFuJywgJ051bWJlcicsICdPYmplY3QnLCAnVW5kZWZpbmVkJywgJ051bGwnLCAnVm9pZCcsICdOZXZlcicsICdBbnknXTtcbi8qKlxuICogVHlwZXMgYW5kIGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyB0eXBlc2NyaXB0IHByb2dyYW0gdGV4dC5cbiAqL1xudmFyIF90aHJvd05vdEtub3duID0gZnVuY3Rpb24gKG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBU1Qgbm9kZSBcIiArICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgPyBuLmNvbnN0cnVjdG9yLm5hbWUgOiBuKSArIFwiIVwiKTtcbn07XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiZnVuY3Rpb24gKCkge31cIjsgfTtcbi8qKlxuICogdmlldyB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0cy52aWV3ID0gZnVuY3Rpb24gKGlkLCB0eXBlQ2xhc3NlcywgcGFyYW1zLCBjdHgsIHRhZykge1xuICAgIHJldHVybiBcImV4cG9ydCBjbGFzcyBcIiArIGlkICsgdHlwZUNsYXNzZXMgKyBcIiBleHRlbmRzICR3bWwuQXBwVmlldzxcIiArIGN0eCArIFwiPiB7XFxuXFxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQ6IFwiICsgY3R4ICsgKHBhcmFtcyA/ICcsJyArIHBhcmFtcyA6ICcnKSArIFwiKSB7XFxuXFxuICAgICAgICBzdXBlcihjb250ZXh0KTtcXG5cXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoXCIgKyBDT05URVhUICsgXCI6XCIgKyBjdHggKyBcIiwgXCIgKyBWSUVXICsgXCI6JHdtbC5BcHBWaWV3PFwiICsgY3R4ICsgXCI+KSA9PlxcbiAgICAgICAgICBcIiArICh0YWcgPyB0YWcgOiAnPE5vZGU+ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpJykgKyBcIjtcXG5cXG4gICAgICAgfVxcblxcbiAgICAgfVxcblwiO1xufTtcbi8qKlxuICogY29kZSB0dXJucyBhbiBBU1QgaW50byB0eXBlc2NyaXB0IGNvZGUuXG4gKi9cbmV4cG9ydHMuY29kZSA9IGZ1bmN0aW9uIChuLCBvKSB7IHJldHVybiBleHBvcnRzLm1vZHVsZTJUUyhuLCBvKTsgfTtcbi8qKlxuICogbW9kdWxlMlRTIGNvbnZlcnRzIGEgbW9kdWxlIHRvIGEgdHlwZXNjcmlwdCBtb2R1bGUuXG4gKi9cbmV4cG9ydHMubW9kdWxlMlRTID0gZnVuY3Rpb24gKG4sIF9hKSB7XG4gICAgdmFyIG1vZHVsZSA9IF9hLm1vZHVsZTtcbiAgICByZXR1cm4gXCJcXG5pbXBvcnQgKiBhcyAkd21sIGZyb20gJ1wiICsgbW9kdWxlICsgXCInO1xcblwiICsgbi5pbXBvcnRzLm1hcChleHBvcnRzLmltcG9ydFN0YXRlbWVudDJUUykuam9pbignO1xcbicpICsgXCJcXG5cXG5cIiArIG4uZXhwb3J0cy5tYXAoZXhwb3J0cy5leHBvcnRzMlRTKS5qb2luKCc7XFxuJykgKyBcIlxcblxcblwiICsgKG4ubWFpbiA/IGV4cG9ydHMubWFpbjJUUyhuLm1haW4pIDogJycpICsgXCJcXG5cIjtcbn07XG4vKipcbiAqIGV4cG9ydHMyVFMgY29udmVydHMgdmFyaW91cyBleHBvcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZXhwb3J0czJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5FeHBvcnRTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRnVuU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5TdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBpbXBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gaW1wb3J0IHN0YXRlbWVudC5cbiAqL1xuZXhwb3J0cy5pbXBvcnRTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcImltcG9ydCBcIiArIGV4cG9ydHMuaW1wb3J0TWVtYmVyMlRTKG4ubWVtYmVyKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7IFwiO1xufTtcbi8qKlxuICogaW1wb3J0TWVtYmVyMlRTIGNvbnZlcnRzIHRoZSBtZW1iZXJzIG9mIGFuIGltcG9ydCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmltcG9ydE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5BZ2dyZWdhdGVNZW1iZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmFnZ3JlZ2F0ZU1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQWxpYXNlZE1lbWJlcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29tcG9zaXRlTWVtYmVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiBhbGlhc2VkTWVtYmVyMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGFsaWFzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5tZW1iZXIpICsgXCIgYXMgXCIgKyBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uYWxpYXMpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBhZ2dyZWdhdGVNZW1iZXIyVFMgY29udmVydHMgYSBxdWFsaWZpZWQgbWVtYmVyIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWdncmVnYXRlTWVtYmVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIqIGFzIFwiICsgZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLmlkKSArIFwiIFwiO1xufTtcbi8qKlxuICogY29tcG9zaXRlTWVtYmVyMlRTIGNvdmVydHMgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAneycgKyAobi5tZW1iZXJzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKG0gaW5zdGFuY2VvZiBub2Rlcy5BbGlhc2VkTWVtYmVyKSA/XG4gICAgICAgIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhtKSA6XG4gICAgICAgIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobSk7IH0pLmpvaW4oJywnKSkgKyAnfSc7XG59O1xuLyoqXG4gKiBtYWluMlRTIGNvbnZlcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMubWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRNYWluKSA/XG4gICAgICAgIGV4cG9ydHMudHlwZWRNYWluMlRTKG4pIDpcbiAgICAgICAgZXhwb3J0cy51bnR5cGVkTWFpbjJUUyhuKTtcbn07XG4vKipcbiAqIHR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhIHR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnR5cGVkTWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhuLmlkID8gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobi5pZCkgOiAnTWFpbicsIGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcyksIG4ucGFyYW1ldGVycy5tYXAoZXhwb3J0cy5wYXJhbWV0ZXIyVFMpLmpvaW4oJywnKSwgZXhwb3J0cy50eXBlMlRTKG4uY29udGV4dCksIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiB1bnR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhbiB1bnR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVudHlwZWRNYWluMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy52aWV3KCdNYWluJywgJycsICcnLCAndm9pZCcsIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiBleHBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gZXhwb3J0IHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiZXhwb3J0IFwiICsgZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobi5tZW1iZXJzKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7XFxuXCI7XG59O1xuLyoqXG4gKiB2aWV3U3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgdmlldyBzdGF0ZW1lbnQgaW50byBhIHR5cGVzY3JpcHQgY2xhc3MuXG4gKi9cbmV4cG9ydHMudmlld1N0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4uaWQpLCBleHBvcnRzLnR5cGVDbGFzc2VzMlRTKG4udHlwZUNsYXNzZXMpLCBuLnBhcmFtZXRlcnMubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJyksIGV4cG9ydHMudHlwZTJUUyhuLmNvbnRleHQpLCBleHBvcnRzLnRhZzJUUyhuLnRhZykpO1xufTtcbnZhciBfZnVuQ29udGV4dCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIihcIiArIENPTlRFWFQgKyBcIjpcIiArIGV4cG9ydHMudHlwZTJUUyhuKSArIFwiKT0+XCI7IH07XG52YXIgX2Z1blZpZXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIihcIiArIFZJRVcgKyBcIjokd21sLlZpZXcpPT5cIjsgfTtcbi8qKlxuICogZnVuU3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgZnVuY3Rpb24gc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZnVuU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJleHBvcnQgY29uc3QgXCIgKyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuLmlkKSArIFwiID0gXCIgK1xuICAgICAgICAoZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSArIFwiKFwiICsgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpPT5cIikgK1xuICAgICAgICAoKG4uY29udGV4dCAhPSBudWxsKSA/IF9mdW5Db250ZXh0KG4uY29udGV4dCkgOiAnJykgK1xuICAgICAgICBfZnVuVmlldygpICtcbiAgICAgICAgKChBcnJheS5pc0FycmF5KG4uYm9keSkgPyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uYm9keSkgOiBleHBvcnRzLmNoaWxkMlRTKG4uYm9keSkpICsgXCI7XCIpO1xufTtcbi8qKlxuICogdHlwZUNsYXNzZXMyVFMgY29udmVydHMgYSBsaXN0IG9mIHR5cGVjbGFzc2VzIGludG8gdGhlIGEgbGlzdCBvZiB0eXBlc2NyaXB0IHR5cGVjbGFzc2VzLlxuICovXG5leHBvcnRzLnR5cGVDbGFzc2VzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBcIjwgXCIgKyBucy5tYXAoZXhwb3J0cy50eXBlQ2xhc3MyVFMpLmpvaW4oJywnKSArIFwiPlwiO1xufTtcbi8qKlxuICogdHlwZUNsYXNzMlRTIGNvbnZlcnRzIGEgdHlwZWNsYXNzIGludG8gYSB0eXBlc2NyaXB0IHR5cGVjbGFzcy5cbiAqL1xuZXhwb3J0cy50eXBlQ2xhc3MyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpICsgXCIgXCIgK1xuICAgICAgICAoKG4uY29uc3RyYWludCA/ICdleHRlbmRzICcgKyBleHBvcnRzLnR5cGUyVFMobi5jb25zdHJhaW50KSA6ICcnKSArIFwiIFwiKTtcbn07XG52YXIgX3RvUHJpbSA9IGZ1bmN0aW9uICh0eXApIHtcbiAgICByZXR1cm4gcHJpbXMuaW5kZXhPZih0eXApID4gLTEgPyB0eXAudG9Mb3dlckNhc2UoKSA6IHR5cDtcbn07XG4vKipcbiAqIHR5cGUyVFMgY29udmVydHMgYSB0eXBlIGhpbnQgdG8gYSB0eXBlc2NyaXB0IHR5cGUgaGludC5cbiAqL1xuZXhwb3J0cy50eXBlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gX3RvUHJpbShleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpKSArIFwiIFwiICtcbiAgICAgICAgKGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcykgKyBcIiBcIiArIChuLmxpc3QgPyAnW10nIDogJycpKTtcbn07XG4vKipcbiAqIHBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHBhcmFtZXRlciB0byBhIHR5cGVzY3JpcHQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLnBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRQYXJhbWV0ZXIpID8gZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW50eXBlZFBhcmFtZXRlcikgPyBleHBvcnRzLnVudHlwZWRQYXJhbWV0ZXIyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiB0eXBlZFBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHR5cGVkIHBhcmFtZXRlciBpbnRvIGEgbm9uLWFueSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLmlkKSArIFwiOlwiICsgZXhwb3J0cy50eXBlMlRTKG4uaGludCkgKyBcIiBcIjtcbn07XG4vKipcbiAqIHVudHlwZWRQYXJhbWV0ZXIyVFMgY29udmVydHMgYW4gdHlwZSBpbmZlcnJlZCBwYXJhbWV0ZXIgdG8gYSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy51bnR5cGVkUGFyYW1ldGVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4uaWQpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBjaGlsZHJlbjJUUyBjb252ZXJ0cyBhIGxpc3Qgb2YgY2hpbGRyZW4gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jaGlsZHJlbjJUUyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgcmV0dXJuIChsaXN0Lmxlbmd0aCA9PT0gMCkgPyAnZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOycgOlxuICAgICAgICAobGlzdC5sZW5ndGggPT09IDEpID8gZXhwb3J0cy5jaGlsZDJUUyhsaXN0WzBdKSA6XG4gICAgICAgICAgICBcIiR3bWwuYm94KFwiICsgbGlzdC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGV4cG9ydHMuY2hpbGQyVFMobCk7IH0pLmpvaW4oJywnKSArIFwiKSBcIjtcbn07XG4vKipcbiAqIGNoaWxkMlRTIGNvbnZlcnRzIGNoaWxkcmVuIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuY2hpbGQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICgobiBpbnN0YW5jZW9mIG5vZGVzLk5vZGUpIHx8IChuIGluc3RhbmNlb2Ygbm9kZXMuV2lkZ2V0KSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGFnMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5JbnRlcnBvbGF0aW9uKVxuICAgICAgICByZXR1cm4gXCIkd21sLmRvbWlmeShcIiArIGV4cG9ydHMuaW50ZXJwb2xhdGlvbjJUUyhuKSArIFwiKSBcIjtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSWZTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmlmU3RhdGVtZW50MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Gb3JTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmZvclN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ2hhcmFjdGVycylcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2hhcmFjdGVyczJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29udGV4dFByb3BlcnR5KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb250ZXh0UHJvcGVydHkyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRJZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1YWxpZmllZElkZW50aWZpZXIyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiB0YWcyVFMgY29udmVydHMgYSB0YWcgKG5vZGUvd2lkZ2V0KSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnRhZzJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbi5jaGlsZHJlbi5tYXAoZXhwb3J0cy5jaGlsZDJUUyk7XG4gICAgdmFyIGF0dHJzID0gZXhwb3J0cy5hdHRyczJTdHJpbmcoZXhwb3J0cy5ncm91cEF0dHJzKG4uYXR0cmlidXRlcykpO1xuICAgIHZhciBuYW1lID0gZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLm9wZW4pO1xuICAgIHJldHVybiAobi50eXBlID09PSAnd2lkZ2V0JykgPyBcIiR3bWwud2lkZ2V0KFwiICsgbmFtZSArIFwiLCBcIiArIGF0dHJzICsgXCIsIFtcIiArIGNoaWxkcmVuICsgXCJdLCBcIiArIFZJRVcgKyBcIilcIiA6XG4gICAgICAgIFwiJHdtbC5ub2RlKCdcIiArIG5hbWUgKyBcIicsIFwiICsgYXR0cnMgKyBcIiwgW1wiICsgY2hpbGRyZW4gKyBcIl0sIFwiICsgVklFVyArIFwiKSBcIjtcbn07XG4vKipcbiAqIGF0dHJzMlN0cmluZ1xuICovXG5leHBvcnRzLmF0dHJzMlN0cmluZyA9IGZ1bmN0aW9uIChhdHRycykgeyByZXR1cm4gJ3snICtcbiAgICAoT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAobnMpIHsgcmV0dXJuIG5zICsgXCIgOiB7IFwiICsgYXR0cnNbbnNdLmpvaW4oJywnKSArIFwiIH0gXCI7IH0pKSArICd9JzsgfTtcbi8qKlxuICogZ3JvdXBBdHRycyBncm91cHMgYXR0cmlidXRlcyBhY2NvcmRpbmcgdG8gdGhlaXIgbmFtZXNwYWNlLlxuICovXG5leHBvcnRzLmdyb3VwQXR0cnMgPSBmdW5jdGlvbiAobnMpIHsgcmV0dXJuIG5zLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuICAgIHJldHVybiBhZnBsLnV0aWwubWVyZ2UocCwgKF9hID0ge30sXG4gICAgICAgIF9hW2MubmFtZXNwYWNlLmlkIHx8ICdodG1sJ10gPSAocFtjLm5hbWVzcGFjZS5pZCB8fCAnaHRtbCddIHx8IFtdKS5jb25jYXQoZXhwb3J0cy5hdHRyaWJ1dGUyVFMoYykpLFxuICAgICAgICBfYSkpO1xuICAgIHZhciBfYTtcbn0sIHsgaHRtbDogW10sIHdtbDogW10gfSk7IH07XG4vKipcbiAqIGF0dHJpYnV0ZTJWYWx1ZVxuICovXG5leHBvcnRzLmF0dHJpYnV0ZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4ubmFtZSkgKyBcIiA6IFwiICsgZXhwb3J0cy5hdHRyaWJ1dGVWYWx1ZTJUUyhuLnZhbHVlKSArIFwiIFwiO1xufTtcbi8qKlxuICogYXR0cmlidXRlVmFsdWUyVFMgY29udmVydHMgYW4gYXR0cmlidXRlIHZhbHVlIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYXR0cmlidXRlVmFsdWUyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLkludGVycG9sYXRpb24pID8gZXhwb3J0cy5pbnRlcnBvbGF0aW9uMlRTKG4pIDogZXhwb3J0cy5saXRlcmFsMlRTKG4pO1xufTtcbi8qKlxuICogaW50ZXJwb2xhdGlvbjJUUyBjb252ZXJ0cyBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25zIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuaW50ZXJwb2xhdGlvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uZmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHsgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhjKSArIFwiIChcIiArIHAgKyBcIilcIjsgfSwgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uZXhwcmVzc2lvbikpO1xufTtcbi8qKlxuICogZm9yU3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgZm9yIHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmZvclN0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiJHdtbC5tYXAoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5saXN0KSArIFwiLCBmdW5jdGlvbiBfbWFwXCIgK1xuICAgICAgICAoXCIoXCIgKyBbbi52YXJpYWJsZSwgbi5pbmRleCwgbi5hbGxdLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSkubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJykgKyBcIikgXCIpICtcbiAgICAgICAgKFwieyByZXR1cm4gXCIgKyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uYm9keSkgKyBcIiB9LCBcIikgK1xuICAgICAgICAoXCJmdW5jdGlvbiBvdGhlcndpc2UoKSB7IHJldHVybiBcIiArIGV4cG9ydHMuY2hpbGRyZW4yVFMobi5vdGhlcndpc2UpICsgXCIgfSkgXCIpO1xufTtcbi8qKlxuICogaWZTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gaWYgc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuaWZTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIiR3bWwuaWZ0aGVuKFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uY29uZGl0aW9uKSArIFwiLCBcIiArXG4gICAgICAgIFwiZnVuY3Rpb24gdGhlbigpXCIgK1xuICAgICAgICAoXCJ7IHJldHVybiBcIiArIGV4cG9ydHMuY2hpbGRyZW4yVFMobi50aGVuKSArIFwiIH0sIFwiICsgKG4uZWxzZUNsYXVzZSA/IGVsc2UyVFMobi5lbHNlQ2xhdXNlKSA6IG5vb3AoKSkgKyBcIikgXCIpO1xufTtcbnZhciBlbHNlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5FbHNlQ2xhdXNlKSA/IGV4cG9ydHMuZWxzZUNsYXVzZTJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuRWxzZUlmQ2xhdXNlKSA/IGV4cG9ydHMuZWxzZUlmQ2xhdXNlMlRTKG4pIDpcbiAgICAgICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogZWxzZUNsYXVzZTJUUyBjb252ZXJ0cyB0aGUgZWxzZSBjbGF1c2Ugb2YgYW4gaWYgc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZWxzZUNsYXVzZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb24gZWxzZV9jbGF1c2UoKSB7IHJldHVybiBcIiArIGV4cG9ydHMuY2hpbGRyZW4yVFMobi5jaGlsZHJlbikgKyBcIiB9IFwiO1xufTtcbi8qKlxuICogZWxzZUlmQ2xhdXNlMlRTIGNvbnZlcnRzIGFuIGVsc2UgaWYgY2xhdXNlIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZWxzZUlmQ2xhdXNlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJmdW5jdGlvbiBlbHNlaWYoKVwiICtcbiAgICAgICAgKFwieyByZXR1cm4gJHdtbC5pZnRoZW4oXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIsIFwiKSArXG4gICAgICAgIFwiZnVuY3Rpb24gdGhlbigpIFwiICtcbiAgICAgICAgKFwieyByZXR1cm4gXCIgKyBleHBvcnRzLmNoaWxkcmVuMlRTKG4udGhlbikgKyBcIjsgfSwgXCIpICtcbiAgICAgICAgKGVsc2UyVFMobi5lbHNlQ2xhdXNlKSArIFwiKTt9XCIpO1xufTtcbi8qKlxuICogY2hhcmFjdGVyczJUUyBjb252ZXJ0cyBjaGFyYWN0ZXIgdGV4dCB0byBhIHR5cGVzY3JpcHQgc3RyaW5nLlxuICovXG5leHBvcnRzLmNoYXJhY3RlcnMyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCIkd21sLnRleHQoYFwiICsgbi52YWx1ZSArIFwiYClcIjsgfTtcbi8qKlxuICogZXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIHdtbCBleHByZXNzaW9uIHRvIGEgdHlwZXNjcmlwdCBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSWZUaGVuRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaWZUaGVuRXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQmluYXJ5RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYmluYXJ5RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5hcnlFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bmFyeUV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdDb25zdHJ1Y3Rpb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdDb25zdHJ1Y3Rpb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bkFwcGxpY2F0aW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29uc3RydWN0RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uc3RydWN0RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5NZW1iZXJFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWFkRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVhZEV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZnVuY3Rpb25FeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWNvcmQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlY29yZDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuTGlzdClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGlzdDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQm9vbGVhbkxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJvb2xlYW4yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLk51bWJlckxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLm51bWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3RyaW5nMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Db250ZXh0UHJvcGVydHkpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnRleHRQcm9wZXJ0eTJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29udGV4dFZhcmlhYmxlKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb250ZXh0VmFyaWFibGUyVFMobik7XG4gICAgZWxzZVxuICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGlmVGhlbkV4cHJlc3Npb24yVFMgY29udmVydHMgYW4gaWYtdGhlbi1lbHNlIGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pZlRoZW5FeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIpID8gXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5pZnRydWUpICsgXCIgOiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmlmZmFsc2UpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBiaW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgYmluYXJ5IGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5iaW5hcnlFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5sZWZ0KSArIFwiIFwiICsgZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3Iobi5vcGVyYXRvcikgKyBcIiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnJpZ2h0KSArIFwiKSBcIjtcbn07XG4vKipcbiAqIGNvbnZlcnRPcGVyYXRvciBmb3Igc3RyaWN0bmVzcy5cbiAqL1xuZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICByZXR1cm4gKG9wID09PSAnPT0nKSA/ICc9PT0nIDpcbiAgICAgICAgKG9wID09PSAnIT0nKSA/ICchPT0nIDpcbiAgICAgICAgICAgIG9wO1xufTtcbi8qKlxuICogdW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgdW5hcnkgZXhwcmVzc2lvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVuYXJ5RXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ub3BlcmF0b3IgKyBcIiAoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5leHByZXNzaW9uKSArIFwiKVwiO1xufTtcbi8qKlxuICogdmlld0NvbnN0cnVjdGlvbjJUUyBjb252ZXJzIGEgdmlldyBjb25zdHJ1Y3Rpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy52aWV3Q29uc3RydWN0aW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIobmV3IFwiICsgZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuLmNvbnMpICsgXCIoXCIgKyBleHBvcnRzLmFyZ3MyVFMobi5jb250ZXh0KSArIFwiKSkucmVuZGVyKClcIjtcbn07XG52YXIgX2FwcGx5RnVuID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gKGNvbnRleHQubGVuZ3RoID4gMCA/IFwiKFwiICsgZXhwb3J0cy5hcmdzMlRTKGNvbnRleHQpICsgXCIpXCIgOiAnJykgKyAoXCIoXCIgKyBWSUVXICsgXCIpXCIpO1xufTtcbi8qKlxuICogZnVuQXBwbGljYXRpb24yVFMgY29udmVydHMgYSBmdW4gYXBwbGljYXRpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIiBcIiArIGV4cG9ydHMudHlwZUFyZ3MyVFMobi50eXBlQXJncykgKyBcIiBcIiArXG4gICAgICAgIChcIihcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCIgKyBfYXBwbHlGdW4obi5jb250ZXh0KSk7XG59O1xuLyoqXG4gKiBjb25zdHJ1Y3RFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgY29uc3RydWN0IGV4cHJlc3Npb24gdG8gYSB0eXBlc2NyaXB0IG5ldyBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmNvbnN0cnVjdEV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIm5ldyBcIiArIGV4cG9ydHMuY29uc3RydWN0b3IyVFMobi5jb25zKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiBjYWxsRXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIGNhbGwgZXhwcmVzc2lvbiAoYXBwbHkpIHRvIGEgdHlwZXNjcmlwdCBpbnZvY2F0aW9uLlxuICovXG5leHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIFwiIFwiICsgZXhwb3J0cy50eXBlQXJnczJUUyhuLnR5cGVBcmdzKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiB0eXBlQXJnczJUUyBjb252ZXJ0cyBwYXNzZWQgdHlwZSBhcmd1bWVudHMgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnR5cGVBcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIG5zLmxlbmd0aCA9PT0gMCA/ICcnIDogXCI8IFwiICsgbnMubWFwKGV4cG9ydHMudHlwZTJUUykuam9pbignLCcpICsgXCI+XCI7XG59O1xuLyoqXG4gKiBhcmdzMlRTIGNvbnZlcnRzIGEgbGlzdCBvZiBhcmd1bWVudHMgdG8gYSB0eXBlc2NyaXB0IGFyZ3VtZW50IHR1cHBsZS5cbiAqL1xuZXhwb3J0cy5hcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBucy5tYXAoZXhwb3J0cy5leHByZXNzaW9uMlRTKS5qb2luKCcsJyk7XG59O1xuLyoqXG4gKiBtZW1iZXJFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGV4cHJlc3Npb24gaW50byBhIHR5cGVzY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMubWVtYmVyRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIi5cIiArIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLm1lbWJlcikgKyBcIiBcIjtcbn07XG4vKipcbiAqIHJlYWRFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgcmVhZCBleHByZXNzaW9uIHRvIHNpZGUgZWZmZWN0IGZ1bGwgcHJvcGVydHkgbG9vayB1cC5cbiAqXG4gKiBOT1RFOiB0aGlzIHBhcnQgb2YgdGhlIGxhbmd1YWdlIGlzIG1vc3QgbGlrZWx5IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0cy5yZWFkRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiJHdtbC5yZWFkIDwgXCIgKyBleHBvcnRzLnR5cGUyVFMobi5oaW50KSArIFwiPihcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnBhdGgpICsgXCIsIFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIFwiIFwiICtcbiAgICAgICAgKChuLmRlZmF1bHRzID8gJywnICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uZGVmYXVsdHMpIDogJycpICsgXCIpXCIpO1xufTtcbi8qKlxuICogZnVuY3Rpb25FeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiB0byBhIHR5cGVzY3JpcHQgZnVuY3Rpb24gZXhwcmVzc2lvbi5cbiAqL1xuZXhwb3J0cy5mdW5jdGlvbkV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIihcIiArIG4ucGFyYW1ldGVycy5tYXAoZXhwb3J0cy5wYXJhbWV0ZXIyVFMpLmpvaW4oJywnKSArIFwiKT0+XCIgK1xuICAgICAgICAoXCJcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmJvZHkpKTtcbn07XG4vKipcbiAqIGxpdGVyYWwyVFMgY29udmVydHMgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydHMubGl0ZXJhbDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuQm9vbGVhbkxpdGVyYWwpID8gZXhwb3J0cy5ib29sZWFuMlRTKG4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5TdHJpbmdMaXRlcmFsKSA/IGV4cG9ydHMuc3RyaW5nMlRTKG4pIDpcbiAgICAgICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuTnVtYmVyTGl0ZXJhbCkgPyBleHBvcnRzLm51bWJlcjJUUyhuKSA6XG4gICAgICAgICAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWNvcmQpID8gZXhwb3J0cy5yZWNvcmQyVFMobikgOlxuICAgICAgICAgICAgICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLkxpc3QpID8gZXhwb3J0cy5saXN0MlRTKG4pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogYm9vbGVhbjJUUyBjb252ZXJ0cyBhIGJvb2xlYW4gbGl0ZXJhbCB0byBhIHR5cGVzY3JpcHQgYm9vbGVhbiBsaXRlcmFsLlxuICovXG5leHBvcnRzLmJvb2xlYW4yVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbi52YWx1ZSArIFwiIFwiOyB9O1xuLyoqXG4gKiBzdHJpbmcyVFMgY29udmVydHMgYSBzdHJpbmcgbGl0ZXJhbCB0byBhIHR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMuc3RyaW5nMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiYFwiICsgbi52YWx1ZSArIFwiYFwiOyB9O1xuLyoqXG4gKiBudW1iZXIyVFMgY29udmVydHMgYSBudW1iZXIgbGl0ZXJhbCB0byBhIHR5cGVjcmlwdCBudW1iZXIgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5udW1iZXIyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCJcIiArIHBhcnNlRmxvYXQobi52YWx1ZSk7IH07XG4vKipcbiAqIHJlY29yZDJUUyBjb252ZXJ0cyBhIHJlY29yZCB0byBhIHR5cGVzY3JpcHQgb2JqZWN0IGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMucmVjb3JkMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJ7XCIgKyBuLnByb3BlcnRpZXMubWFwKGV4cG9ydHMucHJvcGVydHkyVFMpLmpvaW4oJywnKSArIFwifVwiO1xufTtcbi8qKlxuICogbGlzdDJUUyBjb252ZXJ0cyBhIGxpc3QgdG8gYSB0eXBlc2NyaXB0IGFycmF5IGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMubGlzdDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgbi5tZW1iZXJzLm1hcChleHBvcnRzLmV4cHJlc3Npb24yVFMpLmpvaW4oJywnKSArIFwiXVwiO1xufTtcbi8qKlxuICogcHJvcGVydHkyVFMgY29udmVydHMgYSBwcm9wZXJ0eSBvZiBhIGEgcmVjb3JkIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMucHJvcGVydHkyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIidcIiArIGV4cG9ydHMua2V5MlRTKG4ua2V5KSArIFwiJyA6IFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udmFsdWUpO1xufTtcbi8qKlxuICoga2V5MlRTIGNvbnZlcnRzIGEgc2luZ2xlIGtleSBvbiBhIHJlY29yZC5cbiAqL1xuZXhwb3J0cy5rZXkyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLlN0cmluZ0xpdGVyYWwpID8gZXhwb3J0cy5zdHJpbmcyVFMobikgOiBleHBvcnRzLmlkZW50aWZpZXIyVFMobik7XG59O1xuLyoqXG4gKiBjb250ZXh0UHJvcGVydHkyVFMgdHVybnMgcHJvcGVydHkgYWNjZXNzIG9uIHRoZSBjb250ZXh0IHRvIHJlZ3VsYXIgVFNcbiAqIHByb3BlcnR5IGFjY2Vzcy5cbiAqL1xuZXhwb3J0cy5jb250ZXh0UHJvcGVydHkyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBDT05URVhUICsgXCIuXCIgKyBleHBvcnRzLmlkZW50aWZpZXIyVFMobi5tZW1iZXIpO1xufTtcbi8qKlxuICogY29udGV4dFZhcmlhYmxlMlRTIHR1cm5zIHRoZSBjb250ZXh0IHZhcmlhYmxlIGludG8gdGhlIGNvbnRleHQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5jb250ZXh0VmFyaWFibGUyVFMgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXCJcIiArIENPTlRFWFQ7IH07XG4vKipcbiAqIGlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTXG4gKi9cbmV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICgobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkSWRlbnRpZmllcikgfHxcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRJZGVudGlmaWVyKSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmICgobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IpIHx8XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGNvbnN0cnVjdG9yMlRTIHR1cm5zIGEgY29uc3RydWN0b3IgdG8gYSB0eXBlc2NyaXB0IGlkZW50aWZpZXIuXG4gKlxuICogUmVtZW1iZXIgY29uc3RydWN0b3JzIGFyZSBwcm9wZXIgY2FzZWQuXG4gKi9cbmV4cG9ydHMuY29uc3RydWN0b3IyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZENvbnN0cnVjdG9yKSA/IGV4cG9ydHMucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobikgOlxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IpID8gZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pIDpcbiAgICAgICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogdW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyBjb252ZXJ0cyBhbiB1bnF1YWxpZmllZCBjb25zdHJ1Y3RvciB0byB0eXBlc2NyaXB0XG4gKi9cbmV4cG9ydHMudW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIlwiICsgbi5pZDsgfTtcbi8qKlxuICogcXVhbGlmaWVkQ29uc3RydWN0b3IgY29udmVydHMgYSBxdWFsaWZpZWQgY29uc3RydWN0b3IgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ucXVhbGlmaWVyICsgXCIuXCIgKyBuLm1lbWJlcjtcbn07XG4vKipcbiAqIGlkZW50aWZpZXIyVFMgdHVybnMgYW4gaWRlbnRpZmllciB0byBhIHR5cGVzY3JpcHQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5pZGVudGlmaWVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRJZGVudGlmaWVyKSA/IGV4cG9ydHMucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRJZGVudGlmaWVyKSA/IGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pIDpcbiAgICAgICAgICAgIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogcXVhbGlmaWVkSWRlbnRpZmllcjJUUyBjb252ZXJ0cyBhIHF1YWxpZmllZCBpZGVudGlmaWVyIHRvIHR5cGVzY3JpcHRcbiAqL1xuZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5xdWFsaWZpZXIgKyBcIi5cIiArIG4ubWVtYmVyO1xufTtcbi8qKlxuICogdW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTIGNvbnZlcnRzIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIlwiICsgbi5pZDsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVTY3JpcHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJvcGVydHkgPSByZXF1aXJlKFwicHJvcGVydHktc2Vla1wiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xudmFyIENvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9Db21waWxlclwiKTtcbmV4cG9ydHMucGFyc2UgPSBDb21waWxlcl8xLnBhcnNlO1xuZXhwb3J0cy5jb21waWxlID0gQ29tcGlsZXJfMS5jb21waWxlO1xuO1xuLyoqXG4gKiBDb21wb25lbnQgaXMgYW4gYWJzdHJhY3QgV2lkZ2V0IGltcGxlbWVudGF0aW9uXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgbWFudWFsbHkgaW1wbGVtZW50aW5nIHRoZSB3aG9sZSBpbnRlcmZhY2UuXG4gKlxuICovXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIGF0dHJzIGlzIHRoZSBhdHRyaWJ1dGVzIHRoaXMgQ29tcG9uZW50IGV4Y2VwdHMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogY2hpbGRyZW4gaXMgYW4gYXJyYXkgb2YgY29udGVudCBwYXNzZWQgdG8gdGhpcyBDb21wb25lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZpZXcucmVuZGVyKCk7IH07XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbn0oKSk7XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbjtcbi8qKlxuICogcmVhZCBhIHZhbHVlIGZvcm0gYW4gb2JqZWN0LlxuICpcbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCB3aWxsIHRocm93IGV4Y2VwdGlvbnNcbiAqIGlmIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBwYXJ0IGFyZSBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byBsb29rIHVwIG9uIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge29iamVjdH0gbyAtIFRoZSBvYmplY3RcbiAqIEBwYXJhbSB7QX0gW2RlZmF1bHRWYWx1ZV0gLSBUaGlzIHZhbHVlIGlzIHJldHVybmVkIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKHBhdGgsIG8sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXQgPSBwcm9wZXJ0eS5nZXQocGF0aC5zcGxpdCgnOicpLmpvaW4oJy4nKSwgbyk7XG4gICAgcmV0dXJuIChyZXQgIT0gbnVsbCkgPyByZXQgOiBkZWZhdWx0VmFsdWU7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRvcHQgPSBmdW5jdGlvbiAoY2hpbGQsIGUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjaGlsZCkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjaGlsZCkpO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IGFkb3B0IGNoaWxkIFwiICsgY2hpbGQgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIGNoaWxkKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGVudCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNvbnRlbnRbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGMpOyB9KTtcbiAgICByZXR1cm4gZnJhZztcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZG9taWZ5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmJveC5hcHBseShudWxsLCBhLm1hcChleHBvcnRzLmRvbWlmeSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAodHlwZW9mIGEgPT09ICdudW1iZXInKSB8fFxuICAgICAgICAodHlwZW9mIGEgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGV4dChhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgdXNlICdcIiArIGEgKyBcIicodHlwZW9mIFwiICsgdHlwZW9mIGEgKyBcIikgYXMgQ29udGVudCFcIik7XG4gICAgfVxufTtcbi8qKlxuICogdGV4dCBjcmVhdGVzIGEgbmV3IFRleHROb2RlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy50ZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnICsgdmFsdWUpO1xufTtcbi8qKlxuICogbm9kZSBpcyBjYWxsZWQgdG8gY3JlYXRlIGEgcmVndWxhciBET00gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5ub2RlID0gZnVuY3Rpb24gKHRhZywgYXR0cmlidXRlcywgY2hpbGRyZW4sIHZpZXcpIHtcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbJ2h0bWwnXSA9PT0gJ29iamVjdCcpXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXNbJ2h0bWwnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzWydodG1sJ11ba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBhZG9wdChjLCBlKTsgfSk7XG4gICAgdmFyIGlkID0gYXR0cmlidXRlc1snd21sJ10uaWQ7XG4gICAgdmFyIGdyb3VwID0gYXR0cmlidXRlcy53bWwuZ3JvdXA7XG4gICAgaWYgKGlkKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyQnlJZChpZCwgZSk7XG4gICAgaWYgKGdyb3VwKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyQnlHcm91cChncm91cCwgZSk7XG4gICAgcmV0dXJuIGU7XG59O1xuLyoqXG4gKiB3aWRnZXQgY3JlYXRlcyBhbmQgcmVuZGVycyBhIG5ldyB3bWwgd2lkZ2V0IGluc3RhbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ29uc3RydXRvclxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nfG51bWJlcnxXaWRnZXQ+fSBjaGlsZHJlblxuICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7V2lkZ2V0fVxuICovXG5leHBvcnRzLndpZGdldCA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgYXR0cmlidXRlcywgY2hpbGRyZW4sIHZpZXcpIHtcbiAgICB2YXIgY2hpbGRzID0gW107XG4gICAgdmFyIHc7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjaGlsZCBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgIGNoaWxkcy5wdXNoLmFwcGx5KGNoaWxkcywgY2hpbGQpIDogY2hpbGRzLnB1c2goY2hpbGQpOyB9KTtcbiAgICB3ID0gbmV3IENvbnN0cnVjdG9yKGF0dHJpYnV0ZXMsIGNoaWxkcyk7XG4gICAgdmFyIGlkID0gYXR0cmlidXRlcy53bWwuaWQ7XG4gICAgdmFyIGdyb3VwID0gYXR0cmlidXRlcy53bWwuZ3JvdXA7XG4gICAgaWYgKGlkKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyQnlJZChpZCwgdyk7XG4gICAgaWYgKGdyb3VwKVxuICAgICAgICB2aWV3LnJlZ2lzdGVyQnlHcm91cChncm91cCwgdyk7XG4gICAgdmlldy5yZWdpc3RlcldpZGdldCh3KTtcbiAgICByZXR1cm4gdy5yZW5kZXIoKTtcbn07XG4vKipcbiAqIGlmdGhlbiBwcm92aWRlcyBhbiBpZiB0aGVuIGV4cHJlc3Npb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuaWZ0aGVuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgcG9zaXRpdmUsIG5lZ2F0aXZlKSB7XG4gICAgcmV0dXJuIChwcmVkaWNhdGUpID8gcG9zaXRpdmUoKSA6IG5lZ2F0aXZlKCk7XG59O1xuLyoqXG4gKiBmb3JFIHByb3ZpZGVzIGEgZm9yIGV4cHJlc3Npb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNiLCBjYjIpIHtcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHYsIGssIGEpIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoY2IodiwgaywgYSkpOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjYjIoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbCA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAobC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGNiKGNvbGxlY3Rpb25ba10sIGssIGNvbGxlY3Rpb24pKTsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2IyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbn07XG4vKipcbiAqIEFwcFZpZXcgaXMgdGhlIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgVmlldy5cbiAqXG4gKiBAcHJvcGVydHkgezxDPn0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRoZSB2aWV3IGlzIHJlbmRlcmVkIGluLlxuICovXG52YXIgQXBwVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHBWaWV3KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgfVxuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlZ2lzdGVyV2lkZ2V0ID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVnaXN0ZXJCeUlkID0gZnVuY3Rpb24gKGlkLCB3KSB7XG4gICAgICAgIGlmICh0aGlzLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgaWQgJ1wiICsgaWQgKyBcIicgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICB0aGlzLmlkc1tpZF0gPSB3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlZ2lzdGVyQnlHcm91cCA9IGZ1bmN0aW9uIChncm91cCwgZSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cF0gPSB0aGlzLmdyb3Vwc1tncm91cF0gfHwgW107XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXS5wdXNoKGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBNYXliZV8xLk1heWJlLmZyb21BbnkodGhpcy5pZHNbaWRdKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmZpbmRHcm91cEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBNYXliZV8xLk1heWJlLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMuZ3JvdXBzW25hbWVdIDogW10pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcztcbiAgICAgICAgdmFyIHJlYWxGaXJzdENoaWxkO1xuICAgICAgICB2YXIgcmVhbEZpcnN0Q2hpbGRJbmRleDtcbiAgICAgICAgdmFyIHRyZWUgPSAodGhpcy5fZnJhZ1Jvb3QpID8gdGhpcy5fZnJhZ1Jvb3QgOiB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcbiAgICAgICAgaWYgKHRyZWUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdBdHRlbXB0IHRvIGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIGluc2VydGVkIHRvIERPTSEnKTtcbiAgICAgICAgY2hpbGRzID0gdHJlZS5wYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgICAgICAvL2ZvciBzb21lIHJlYXNvbiB0aGUgcmVmZXJlbmNlIHN0b3JlZCBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHBhcmVudCBub2RlLlxuICAgICAgICAvL3dlIGRvIHRoaXMgdG8gZ2V0IGEgJ2xpdmUnIHZlcnNpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoaWxkc1tpXSA9PT0gdHJlZSkge1xuICAgICAgICAgICAgICAgIHJlYWxGaXJzdENoaWxkID0gY2hpbGRzW2ldO1xuICAgICAgICAgICAgICAgIHJlYWxGaXJzdENoaWxkSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHJlYWxGaXJzdENoaWxkKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcucmVtb3ZlZCgpOyB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuX2ZyYWdSb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmVlID0gdGhpcy50ZW1wbGF0ZSh0aGlzLmNvbnRleHQsIHRoaXMpO1xuICAgICAgICB0aGlzLmlkc1sncm9vdCddID0gKHRoaXMuaWRzWydyb290J10pID8gdGhpcy5pZHNbJ3Jvb3QnXSA6IHRoaXMudHJlZTtcbiAgICAgICAgaWYgKHRoaXMudHJlZS5ub2RlTmFtZSA9PT0gKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkubm9kZU5hbWUpXG4gICAgICAgICAgICB0aGlzLl9mcmFnUm9vdCA9IHRoaXMudHJlZS5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW5kZXJlZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBBcHBWaWV3O1xufSgpKTtcbmV4cG9ydHMuQXBwVmlldyA9IEFwcFZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZjEgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZjsgfTtcbmV4cG9ydHMuZjIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmKGEsIGIpOyB9OyB9OyB9O1xuZXhwb3J0cy5mMyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGYoYSwgYiwgYyk7IH07IH07IH07XG59O1xuZXhwb3J0cy5mNCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBmKGEsIGIsIGMsIGQpOyB9OyB9OyB9OyB9O1xufTtcbmV4cG9ydHMuZjUgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGYoYSwgYiwgYywgZCwgZSk7IH07IH07IH07IH07IH07XG59O1xuZXhwb3J0cy5mNiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZnVuY3Rpb24gKF9mKSB7IHJldHVybiBmKGEsIGIsIGMsIGQsIGUsIF9mKTsgfTsgfTsgfTsgfTsgfTsgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudXRpbCA9IHV0aWw7XG52YXIgY3VycnkgPSByZXF1aXJlKFwiLi9jdXJyeVwiKTtcbmV4cG9ydHMuY3VycnkgPSBjdXJyeTtcbnZhciBJZGVudGl0eV8xID0gcmVxdWlyZShcIi4vbW9uYWQvSWRlbnRpdHlcIik7XG5leHBvcnRzLklkZW50aXR5ID0gSWRlbnRpdHlfMS5JZGVudGl0eTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcIi4vbW9uYWQvTWF5YmVcIik7XG5leHBvcnRzLk1heWJlID0gTWF5YmVfMS5NYXliZTtcbnZhciBFaXRoZXJfMSA9IHJlcXVpcmUoXCIuL21vbmFkL0VpdGhlclwiKTtcbmV4cG9ydHMuRWl0aGVyID0gRWl0aGVyXzEuRWl0aGVyO1xudmFyIFN0YXRlXzEgPSByZXF1aXJlKFwiLi9tb25hZC9TdGF0ZVwiKTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZV8xLlN0YXRlO1xudmFyIEZyZWVfMSA9IHJlcXVpcmUoXCIuL21vbmFkL0ZyZWVcIik7XG5leHBvcnRzLkZyZWUgPSBGcmVlXzEuRnJlZTtcbnZhciBJT18xID0gcmVxdWlyZShcIi4vbW9uYWQvSU9cIik7XG5leHBvcnRzLklPID0gSU9fMS5JTztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGxlZnQgd3JhcHMgYSB2YWx1ZSBvbiB0aGUgbGVmdCBzaWRlLlxuICovXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IExlZnQoYSk7IH07XG4vKipcbiAqIHJpZ2h0IHdyYXBzIGEgdmFsdWUgb24gdGhlIHJpZ2h0IHNpZGUuXG4gKi9cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbiAoYikgeyByZXR1cm4gbmV3IFJpZ2h0KGIpOyB9O1xuLyoqXG4gKiBmcm9tQm9vbGVhbiBjb25zdHJ1Y3RzIGFuIEVpdGhlciB1c2luZyBhIGJvb2xlYW4gdmFsdWUuXG4gKi9cbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiBiID8gZXhwb3J0cy5yaWdodCh0cnVlKSA6IGV4cG9ydHMubGVmdChmYWxzZSk7XG59O1xuLyoqXG4gKiBFaXRoZXIgbW9uYWQgaW1wbGVtZW50YXRpb25cbiAqL1xudmFyIEVpdGhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWl0aGVyKCkge1xuICAgIH1cbiAgICBFaXRoZXIucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodCh2KTtcbiAgICB9O1xuICAgIEVpdGhlci5sZWZ0ID0gZXhwb3J0cy5sZWZ0O1xuICAgIEVpdGhlci5yaWdodCA9IGV4cG9ydHMucmlnaHQ7XG4gICAgRWl0aGVyLmZyb21Cb29sZWFuID0gZXhwb3J0cy5mcm9tQm9vbGVhbjtcbiAgICByZXR1cm4gRWl0aGVyO1xufSgpKTtcbmV4cG9ydHMuRWl0aGVyID0gRWl0aGVyO1xudmFyIExlZnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWZ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlZnQobCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sID0gbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMZWZ0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLm1hcExlZnQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQoZih0aGlzLmwpKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKGYsIF8pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGVmdChmKHRoaXMubCkpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMubCk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5vclJpZ2h0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodChmKHRoaXMubCkpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLnRha2VMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUudGFrZVJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IHJpZ2h0IVwiKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoZiwgXykge1xuICAgICAgICByZXR1cm4gZih0aGlzLmwpO1xuICAgIH07XG4gICAgcmV0dXJuIExlZnQ7XG59KEVpdGhlcikpO1xuZXhwb3J0cy5MZWZ0ID0gTGVmdDtcbnZhciBSaWdodCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJpZ2h0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpZ2h0KHIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuciA9IHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmlnaHQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQoZih0aGlzLnIpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5tYXBMZWZ0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodCh0aGlzLnIpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKF8sIGcpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmlnaHQoZyh0aGlzLnIpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMucik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvckVsc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGYgaWYgdGhlIEVpdGhlciBpcyBsZWZ0LlxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5vclJpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhcFxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5hcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBlLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZihfdGhpcy5yKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICogdGFrZUxlZnQgZXh0cmFjdHMgdGhlIGxlZnQgdmFsdWUgb2YgYW4gRWl0aGVyLCB0aHJvd2luZyBhbiBlcnJvciBpZiB0aGUgRWl0aGVyIGlzIHJpZ2h0LlxuICAgICAgKi9cbiAgICBSaWdodC5wcm90b3R5cGUudGFrZUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgbGVmdCFcIik7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUudGFrZVJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2F0YVxuICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKF8sIGcpIHtcbiAgICAgICAgcmV0dXJuIGcodGhpcy5yKTtcbiAgICB9O1xuICAgIHJldHVybiBSaWdodDtcbn0oRWl0aGVyKSk7XG5leHBvcnRzLlJpZ2h0ID0gUmlnaHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FaXRoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBFaXRoZXJfMSA9IHJlcXVpcmUoXCIuL0VpdGhlclwiKTtcbi8qKlxuICogZnJlZSB3cmFwcyBhIHZhbHVlIGluIGEgZnJlZVxuICovXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IFJldHVybihhKTsgfTtcbi8qKlxuICogc3VzcGVuZCBsaWZ0cyBhIGZ1bmN0aW9uIGludG8gYSBGcmVlIG1vbmFkIHRvIG1pbWljIHRhaWwgY2FsbCByZWN1cnNpb24uXG4gKi9cbmV4cG9ydHMuc3VzcGVuZCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBuZXcgU3VzcGVuZCh1dGlsXzEuY29tcG9zZShleHBvcnRzLmZyZWUsIGYpKTsgfTtcbi8qKlxuICogbGlmdEYgbGlmdHMgYSBGdW5jdG9yIGludG8gYSBGcmVlLlxuICovXG5leHBvcnRzLmxpZnRGID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5ldyBTdXNwZW5kKGYubWFwKGV4cG9ydHMuZnJlZSkpOyB9O1xuLyoqXG4gKiBGcmVlIGlzIGEgRnJlZSBtb25hZCB0aGF0IGFsc28gaW1wbGVtZW50cyBhIEZyZWUgQXBwbGljYXRpdmUgKGFsbW9zdCkuXG4gKlxuICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9jd215ZXJzLmdpdGh1Yi5pby9tb25ldC5qcy8jZnJlZVxuICovXG52YXIgRnJlZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJlZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb2ZcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmV0dXJuKGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWFwXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGV4cG9ydHMuZnJlZShmKGEpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdXNwZW5kKSB7XG4gICAgICAgICAgICB2YXIgZl8xID0gdGhpcy5mO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgZl8xID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICAgICAgbmV3IFN1c3BlbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGZfMSh4KS5jaGFpbihnKTsgfSkgOlxuICAgICAgICAgICAgICAgIG5ldyBTdXNwZW5kKGZfMS5tYXAoZnVuY3Rpb24gKGZyZWUpIHsgcmV0dXJuIGZyZWUuY2hhaW4oZyk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICBnKHRoaXMuYSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlc3VtZSB0aGUgbmV4dCBzdGFnZSBvZiB0aGUgY29tcHV0YXRpb25cbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VzcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIEVpdGhlcl8xLmxlZnQodGhpcy5mKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWl0aGVyXzEucmlnaHQodGhpcy5hKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogaG9pc3RcbiAgICBob2lzdDxCPihmdW5jOiAoZmI6IEZ1bmN0b3I8Qj4pID0+IEZ1bmN0b3I8Qj4pOiBGcmVlPEYsIEE+IHtcblxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdXNwZW5kKChmdW5jKHRoaXMuZikpXG4gICAgICAgICAgICAgICAgLm1hcCgoZnI6IEZyZWU8RiwgQj4pID0+IGZyLmhvaXN0PGFueT4oZnVuYykpKVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBjYXRhXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChmLCBnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VtZSgpLmNhdGEoZiwgZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnbyBydW5zIHRoZSBjb21wdXRhdGlvbiB0byBjb21wbGV0aW9uIHVzaW5nIGYgdG8gZXh0cmFjdCBlYWNoIHN0YWdlLlxuICAgICAqIEBzdW1tbWFyeSBnbyA6OiBGcmVlPEY8Kj4sIEE+IOKGkiAgKEY8RnJlZTxGLEE+PiDihpIgIEZyZWU8RixBPikg4oaSICBBXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyIGluc3RhbmNlb2YgRWl0aGVyXzEuTGVmdClcbiAgICAgICAgICAgICAgICByID0gKGYoci50YWtlTGVmdCgpKSkucmVzdW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gci50YWtlUmlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIEZyZWUgY2hhaW4gdG8gY29tcGxldGlvblxuICAgICAqIEBzdW1tYXJ5IHJ1biA6OiBGcmVlPEHihpIgQSxBPiDihpIgIEFcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdvKGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgIH07XG4gICAgRnJlZS5mcmVlID0gZXhwb3J0cy5mcmVlO1xuICAgIEZyZWUuc3VzcGVuZCA9IGV4cG9ydHMuc3VzcGVuZDtcbiAgICBGcmVlLmxpZnRGID0gZXhwb3J0cy5saWZ0RjtcbiAgICByZXR1cm4gRnJlZTtcbn0oKSk7XG5leHBvcnRzLkZyZWUgPSBGcmVlO1xudmFyIFN1c3BlbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdXNwZW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1c3BlbmQoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mID0gZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3VzcGVuZDtcbn0oRnJlZSkpO1xuZXhwb3J0cy5TdXNwZW5kID0gU3VzcGVuZDtcbnZhciBSZXR1cm4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXR1cm4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0dXJuKGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYSA9IGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJldHVybjtcbn0oRnJlZSkpO1xuZXhwb3J0cy5SZXR1cm4gPSBSZXR1cm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiB3cmFwSU8gYSB2YWx1ZSBpbiB0aGUgSU8gbW9uYWRcbiAqL1xuZXhwb3J0cy53cmFwSU8gPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH0pOyB9O1xuLyoqXG4gKiBzYWZlSU8gYWNjZXB0cyBhIGZ1bmN0aW9uIHRoYXQgaGFzIHNpZGUgZWZmZWN0cyBhbmQgd3JhcElPcyBpdCBpbiBhbiBJTyBNb25hZC5cbiAqL1xuZXhwb3J0cy5zYWZlSU8gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gbmV3IElPKGYpOyB9O1xuZXhwb3J0cy5wdXJlID0gZXhwb3J0cy53cmFwSU87XG5leHBvcnRzLnN1c3BlbmQgPSBleHBvcnRzLnNhZmVJTztcbi8qKlxuICogSU8gbW9uYWRpYyB0eXBlIGZvciBjb250YWluaW5nIGludGVyYWN0aW9ucyB3aXRoIHRoZSAncmVhbCB3b3JsZCcuXG4gKi9cbnZhciBJTyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSU8oZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgICBJTy5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH0pO1xuICAgIH07XG4gICAgSU8ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSU8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZihfdGhpcy5lZmZlY3QoKSk7IH0pO1xuICAgIH07XG4gICAgSU8ucHJvdG90eXBlLm1hcEluID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGI7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW5cbiAgICAgKi9cbiAgICBJTy5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IElPKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoX3RoaXMuZWZmZWN0KCkpLnJ1bigpOyB9KTtcbiAgICB9O1xuICAgIElPLnByb3RvdHlwZS5jaGFpbkluID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy53cmFwSU8oYik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcnVuXG4gICAgICovXG4gICAgSU8ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0KCk7XG4gICAgfTtcbiAgICBJTy5zYWZlSU8gPSBleHBvcnRzLnNhZmVJTztcbiAgICBJTy5wdXJlID0gZXhwb3J0cy5wdXJlO1xuICAgIElPLnN1c3BlbmQgPSBleHBvcnRzLnN1c3BlbmQ7XG4gICAgSU8uY2hhaW4gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2hhaW4oZik7IH07IH07XG4gICAgcmV0dXJuIElPO1xufSgpKTtcbmV4cG9ydHMuSU8gPSBJTztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlPLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBJZGVudGl0eVxuICovXG52YXIgSWRlbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElkZW50aXR5KGEpIHtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb2ZcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5KGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWFwXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHkoZih0aGlzLmdldCgpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMuZ2V0KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYXBcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaS5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoX3RoaXMuZ2V0KCkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYW4gSWRlbnRpdHlcbiAgICAgKiBAc3VtbWFyeSBnZXQgOjogSWRlbnRpdHk8QT4g4oaSICBBXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICB9O1xuICAgIHJldHVybiBJZGVudGl0eTtcbn0oKSk7XG5leHBvcnRzLklkZW50aXR5ID0gSWRlbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JZGVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVpdGhlcl8xID0gcmVxdWlyZShcIi4vRWl0aGVyXCIpO1xuLyoqXG4gKiBqdXN0IHdyYXBzIGEgdmFsdWUgaW4gYSBKdXN0XG4gKi9cbmV4cG9ydHMuanVzdCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgSnVzdChhKTsgfTtcbjtcbi8qKlxuICogbm90aGluZyBjb25zdHJ1Y3RzIG5vdGhpbmdcbiAqL1xuZXhwb3J0cy5ub3RoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE5vdGhpbmcoKTsgfTtcbi8qKlxuICogZnJvbUFueSBjb25zdHJ1Y3RzIGEgTWF5YmUgZnJvbSBhIHZhbHVlIHRoYXQgbWF5IGJlIG51bGwuXG4gKi9cbmV4cG9ydHMuZnJvbUFueSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhID09IG51bGwgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChhKTsgfTtcbi8qKlxuICogZnJvbUFycmF5IGNoZWNrcyBhbiBhcnJheSB0byBzZWUgaWYgaXQncyBlbXB0eSAob3IgZnVsbCBvZiBudWxscylcbiAqIGFuZCByZXR1cm5zIGEgTWF5YmUuXG4gKi9cbmV4cG9ydHMuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKChhLmxlbmd0aCA9PT0gMCkgfHwgKGEucmVkdWNlKGZ1bmN0aW9uIChjLCB2KSB7IHJldHVybiAodiA9PSBudWxsKSA/IGMgKyAxIDogYzsgfSwgMCkgPT09IGEubGVuZ3RoKSkgP1xuICAgICAgICBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChhKTtcbn07XG4vKipcbiAqIGZyb21PQmplY3QgdXNlcyBPYmplY3Qua2V5cyB0byB0dXJuIHNlZSBpZiBhbiBvYmplY3QgaGFzIGFueSBvd24gcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0cy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qobyk7XG59O1xuLyoqXG4gKiBmcm9tU3RyaW5nIGNvbnN0cnVjdHMgbm90aGluZyBpZiB0aGUgc3RyaW5nIGlzIGVtcHR5IG9yIGp1c3Qgb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiAocyA9PT0gJycpID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qocyk7XG59O1xuLyoqXG4gKiBmcm9tQm9vbGVhbiBjb25zdHJ1Y3RzIG5vdGhpbmcgaWYgYiBpcyBmYWxzZSwganVzdCBvdGhlcndpc2VcbiAqL1xuZXhwb3J0cy5mcm9tQm9vbGVhbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIChiID09PSBmYWxzZSkgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChiKTtcbn07XG4vKipcbiAqIGZyb21OdW1iZXIgY29uc3RydWN0cyBub3RoaW5nIGlmIG4gaXMgMCBqdXN0IG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gPT09IDApID8gZXhwb3J0cy5ub3RoaW5nKCkgOiBleHBvcnRzLmp1c3Qobik7XG59O1xuLyoqXG4gKiBNYXliZVxuICovXG52YXIgTWF5YmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heWJlKCkge1xuICAgIH1cbiAgICBNYXliZS5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IEp1c3QoYSk7XG4gICAgfTtcbiAgICBNYXliZS5qdXN0ID0gZXhwb3J0cy5qdXN0O1xuICAgIE1heWJlLm5vdGhpbmcgPSBleHBvcnRzLm5vdGhpbmc7XG4gICAgTWF5YmUuZnJvbUFueSA9IGV4cG9ydHMuZnJvbUFueTtcbiAgICBNYXliZS5mcm9tT2JqZWN0ID0gZXhwb3J0cy5mcm9tT2JqZWN0O1xuICAgIE1heWJlLmZyb21BcnJheSA9IGV4cG9ydHMuZnJvbUFycmF5O1xuICAgIE1heWJlLmZyb21TdHJpbmcgPSBleHBvcnRzLmZyb21TdHJpbmc7XG4gICAgTWF5YmUuZnJvbUJvb2xlYW4gPSBleHBvcnRzLmZyb21Cb29sZWFuO1xuICAgIE1heWJlLmZyb21OdW1iZXIgPSBleHBvcnRzLmZyb21OdW1iZXI7XG4gICAgcmV0dXJuIE1heWJlO1xufSgpKTtcbmV4cG9ydHMuTWF5YmUgPSBNYXliZTtcbi8qKlxuICogTm90aGluZ1xuICovXG52YXIgTm90aGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGhpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90aGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RoaW5nKCk7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBnZXQgYW55dGhpbmcgZnJvbSBOb3RoaW5nIScpO1xuICAgIH07XG4gICAgTm90aGluZy5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9ySnVzdCB3aWxsIHR1cm4gTm90aGluZyBpbnRvIEp1c3QsIHdyYXBwaW5nIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUub3JKdXN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuanVzdChmKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2F0YSBhcHBsaWVzIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIHRvIHRoZSBNYXliZVxuICAgICAqL1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoZiwgX2cpIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLnRvRWl0aGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRWl0aGVyXzEubGVmdCh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGhpbmc7XG59KE1heWJlKSk7XG5leHBvcnRzLk5vdGhpbmcgPSBOb3RoaW5nO1xuLyoqXG4gKiBKdXN0XG4gKi9cbnZhciBKdXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSnVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKdXN0KGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYSA9IGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSnVzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKdXN0KGYodGhpcy5hKSk7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih0aGlzLmEpO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUub3JKdXN0ID0gZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChfZiwgZykge1xuICAgICAgICByZXR1cm4gZyh0aGlzLmEpO1xuICAgIH07XG4gICAgSnVzdC5wcm90b3R5cGUudG9FaXRoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBFaXRoZXJfMS5yaWdodCh0aGlzLmEpO1xuICAgIH07XG4gICAgcmV0dXJuIEp1c3Q7XG59KE1heWJlKSk7XG5leHBvcnRzLkp1c3QgPSBKdXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF5YmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGdldCB0aGUgc3RhdGUgZnJvbSB0aGUgaW50ZXJuYWxzIG9mIHRoZSBtb25hZFxuICovXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAocykgeyByZXR1cm4gKFtzLCBzXSk7IH0pOyB9O1xuLyoqXG4gKiBwdXRcbiAqL1xuZXhwb3J0cy5wdXQgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChbbnVsbCwgc10pOyB9KTsgfTtcbi8qKlxuICogbW9kaWZ5IHRoZSBzdGF0ZVxuICogQHN1bW1hcnkgIChTIOKGkiAgUykg4oaSICBTdGF0ZTxTIOKGkiAge0EsIFN9ID5cbiAqL1xuZXhwb3J0cy5tb2RpZnkgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZXhwb3J0cy5nZXQoKS5jaGFpbihmdW5jdGlvbiAocykgeyByZXR1cm4gZXhwb3J0cy5wdXQoZihzKSk7IH0pOyB9O1xuLyoqXG4gKiBnZXRzIGFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgc3RhdGUgcHV0dGluZyB1c2luZyB0aGUgcmVzdWx0XG4gKiBhcyB0aGUgcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvbi5cbiAqIEBzdW1tYXJ5IChTIOKGkiAgQSkg4oaSICBTdGF0ZTxTIOKGkiAge0EsIFN9PlxuICovXG5leHBvcnRzLmdldHMgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZXhwb3J0cy5nZXQoKS5jaGFpbihmdW5jdGlvbiAocykgeyByZXR1cm4gZXhwb3J0cy5zdGF0ZShmKHMpKTsgfSk7IH07XG4vKipcbiAqIHN0YXRlIGNyZWF0ZSBhIG5ldyBTdGF0ZSBtb25hZFxuICovXG5leHBvcnRzLnN0YXRlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAocykgeyByZXR1cm4gKFthLCBzXSk7IH0pOyB9O1xuLyoqXG4gKiBTdGF0ZSBpcyBhIG1vbmFkaWMgY2xhc3MgdGhhdCB3ZSB1c2UgdG8gaG9sZCBpbmZvcm1hdGlvbiB0aGF0IGNoYW5nZXNcbiAqIGR1cmluZyBjb21wdXRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluZmx1ZW5jZWQgYnk6XG4gKiBAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb25hZF8oZnVuY3Rpb25hbF9wcm9ncmFtbWluZykjU3RhdGVfbW9uYWRzXG4gKiBAcHJvcGVydHkge3Mg4oaSICAoYSwgcyl9IGFcbiAqL1xudmFyIFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZShmKSB7XG4gICAgICAgIHRoaXMuZiA9IGY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9mIHdyYXBzIGEgdmFsdWUgaW4gdGhlIFN0YXRlIG1vbmFkLlxuICAgICAqIEBzdW1tYXJ5IEEg4oaSICBTdGF0ZTxT4oaSIHtBLFN9PlxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChbYSwgc10pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1hcFxuICAgICAqIEBzdW1tYXJ5IFN0YXRlPFMg4oaSIHtBLFN9PiDihpIgIChBIOKGkiAgQikg4oaSICBTdGF0ZTxTIOKGkiAge0MsIFN9PlxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucnVuKHhzKSwgYSA9IF9hWzBdLCBzID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gW2YoYSksIHNdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGpvaW4gcmVwbGFjZXMgdGhlIG91dGVyIFN0YXRlIHdpdGggYW4gaW5uZXIgU3RhdGVcbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnJ1bih4cyksIGEgPSBfYVswXSwgcyA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEucnVuKHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGYpLmpvaW4oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV2YWx1YXRlIHRoZSBTdGF0ZSByZXR1cm5pbmcgdGhlIGZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuKHMpWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXhlY3V0ZSB0aGUgU3RhdGUgcmV0dXJuaW5nIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bihzKVsxXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgU3RhdGUgeWllbGRpbmcgdGhlIGZpbmFsIHZhbHVlIGFuZCBzdGF0ZS5cbiAgICAgKiBAc3VtbWFyeSBTdGF0ZTxT4oaSIHtBPFN9PiDihpIgIFMg4oaSICB7QSxTfVxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5mKHMpO1xuICAgIH07XG4gICAgU3RhdGUuZ2V0ID0gZXhwb3J0cy5nZXQ7XG4gICAgU3RhdGUucHV0ID0gZXhwb3J0cy5wdXQ7XG4gICAgU3RhdGUubW9kaWZ5ID0gZXhwb3J0cy5tb2RpZnk7XG4gICAgU3RhdGUuZ2V0cyA9IGV4cG9ydHMuZ2V0cztcbiAgICBTdGF0ZS5zdGF0ZSA9IGV4cG9ydHMuc3RhdGU7XG4gICAgcmV0dXJuIFN0YXRlO1xufSgpKTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuO1xuLyoqXG4gKiBpZGVudGl0eSBpcyB0aGUgZmFtZWQgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydHMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYTsgfTtcbi8qKlxuICogbWVyZ2UgdHdvIG9iamVjdHMgZWFzaWx5XG4gKi9cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG8gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQobykpO1xufTtcbi8qKlxuICogZnVzZSBpcyB0aGUgZGVlcCB2ZXJzaW9uIG9mIG1lcmdlXG4gKi9cbmV4cG9ydHMuZnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChvLCBjKSB7XG4gICAgICAgIGlmIChjID09PSB2b2lkIDApIHsgYyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShjLCBmdW5jdGlvbiAoY28sIGNjLCBrKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjYykgP1xuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvW2tdKSA/XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYSA9IHt9LCBfYVtrXSA9IChjb1trXSkubWFwKGV4cG9ydHMuY29weSkuY29uY2F0KGNjLm1hcChleHBvcnRzLmNvcHkpKSwgX2EpKSA6XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYiA9IHt9LCBfYltrXSA9IGNjLm1hcChleHBvcnRzLmNvcHkpLCBfYikpKSA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIGNjICE9PSAnb2JqZWN0JyA/XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UoY28sIChfYyA9IHt9LCBfY1trXSA9IGNjLCBfYykpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjbywgKF9kID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZFtrXSA9ICh0eXBlb2YgY29ba10gIT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjb1trXSwgY2MpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmZ1c2UoY29ba10sIGNjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKSk7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIH0sIG8pO1xuICAgIH0sIHt9KTtcbn07XG5leHBvcnRzLmNvcHkgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvKSkgP1xuICAgICAgICBvLm1hcChleHBvcnRzLmNvcHkpIDpcbiAgICAgICAgKHR5cGVvZiBvID09PSAnb2JqZWN0JykgP1xuICAgICAgICAgICAgZXhwb3J0cy5yZWR1Y2UobywgZnVuY3Rpb24gKHAsIGMsIGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBleHBvcnRzLmNvcHkoYyksIF9hKSk7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgfSwge30pIDogbztcbn07XG4vKipcbiAqIHJlZHVjZSBhbiBvYmplY3QncyBrZXlzIChpbiBubyBndWFyYW50ZWVkIG9yZGVyKVxuICovXG5leHBvcnRzLnJlZHVjZSA9IGZ1bmN0aW9uIChvLCBmLCBhY2N1bSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGspIHsgcmV0dXJuIGYocCwgb1trXSwgaywgbyk7IH0sIGFjY3VtKTtcbn07XG4vKipcbiAqIG1hcCBvdmVyIGFuIG9iamVjdCAoaW4gbm8gZ3VhcmFudGVlZCBvcmVkZXIpXG4gKi9cbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKG8sIGYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubWFwKChmdW5jdGlvbiAoaykgeyByZXR1cm4gZihvW2tdLCBrLCBvKTsgfSkpO1xufTtcbi8qKlxuICogY29tcG9zZSB0d28gZnVuY3Rpb25zIGludG8gb25lLlxuICovXG5leHBvcnRzLmNvbXBvc2UgPSBmdW5jdGlvbiAoZiwgZykgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGYoZyh4KSk7IH07IH07XG4vKipcbiAqIGZsaW5nIHJlbW92ZXMgYSBrZXkgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzdW1tYXJ5IHsoc3RyaW5nLE9iamVjdCkg4oaSICBPYmplY3R9XG4gKi9cbmV4cG9ydHMuZmxpbmcgPSBmdW5jdGlvbiAocywgbykge1xuICAgIGlmICgobyA9PSBudWxsKSB8fCAoby5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmxpbmcoKTogb25seSB3b3JrcyB3aXRoIG9iamVjdCBsaXRlcmFscyEnKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChvMiwgaykge1xuICAgICAgICByZXR1cm4gayA9PT0gcyA/IG8yIDogZXhwb3J0cy5tZXJnZShvMiwgKF9hID0ge30sXG4gICAgICAgICAgICBfYVtrXSA9IG9ba10sXG4gICAgICAgICAgICBfYSkpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfSwge30pO1xufTtcbi8qKlxuICogaGVhZCByZXR1cm5zIHRoZSBpdGVtIGF0IGluZGV4IDAgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc3VtbWFyeSB7IEFycmF5IOKGkiAgKiB9XG4gKi9cbmV4cG9ydHMuaGVhZCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0WzBdOyB9O1xuLyoqXG4gKiB0YWlsIHJldHVybnMgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzdW1tYXJ5IHtBcnJheSDihpIgICp9XG4gKi9cbmV4cG9ydHMudGFpbCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0W2xpc3QubGVuZ3RoIC0gMV07IH07XG4vKipcbiAqIGNvbnN0YW50IGdpdmVuIGEgdmFsdWUsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhpcyB2YWx1ZS5cbiAqIEBzdW1tYXJ5IGNvbnN0YW50IFgg4oaSICAqIOKGkiAgWFxuICpcbiAqL1xuZXhwb3J0cy5jb25zdGFudCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBhOyB9OyB9O1xuLyoqXG4gKiBmMSBwYXJ0aWFsIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnRzLmYxID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhKSk7IH07XG59O1xuLyoqXG4gKiBmMiBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjIgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSwgYWEpKTsgfTsgfTtcbn07XG4vKipcbiAqIGYzIHBhcnRpYWwgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5mMyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYSkgeyByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhLCBhYSwgYWFhKSk7IH07IH07IH07XG59O1xuLyoqXG4gKiBmNCBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjQgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWFhKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhLCBhYWEsIGFhYWEpKTtcbiAgICB9OyB9OyB9OyB9O1xufTtcbi8qKlxuICogZjUgcGFydGlhbCBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmY1ID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYWFhKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhLCBhYWEsIGFhYWEsIGFhYWFhKSk7XG4gICAgfTsgfTsgfTsgfTsgfTtcbn07XG4vKipcbiAqIGV4Y2VwdCBjb3BpZXMgYW4gb2JqZWN0IHJlbW92aW5nIGEgc2luZ2xlIGtleS5cbiAqL1xuZXhwb3J0cy5leGNlcHQgPSBmdW5jdGlvbiAoa2V5cywgbykge1xuICAgIHJldHVybiBleHBvcnRzLnJlZHVjZShvLCBmdW5jdGlvbiAocCwgYywgaykge1xuICAgICAgICByZXR1cm4ga2V5cy5pbmRleE9mKGspID4gLTEgPyBwIDogZXhwb3J0cy5tZXJnZShwLCAoX2EgPSB7fSwgX2Fba10gPSBjLCBfYSkpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfSwge30pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuKi9cblxuLyoqXG5UaGUgZm9sbG93aW5nIGJhdGNoZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5Jyk7XG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzO1xudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzX2JlYXV0aWZ5O1xuXG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbDtcbnZhciBiZWF1dGlmeV9odG1sID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5odG1sX2JlYXV0aWZ5O1xuXG5BbGwgbWV0aG9kcyByZXR1cm5lZCBhY2NlcHQgdHdvIGFyZ3VtZW50cywgdGhlIHNvdXJjZSBzdHJpbmcgYW5kIGFuIG9wdGlvbnMgb2JqZWN0LlxuKiovXG5cbmZ1bmN0aW9uIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gICAgLy8gdGhlIGRlZmF1bHQgaXMganNcbiAgICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4ganNfYmVhdXRpZnkuanNfYmVhdXRpZnkoc3JjLCBjb25maWcpO1xuICAgIH07XG5cbiAgICAvLyBzaG9ydCBhbGlhc2VzXG4gICAgYmVhdXRpZnkuanMgPSBqc19iZWF1dGlmeS5qc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5Lmh0bWwgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgICAvLyBsZWdhY3kgYWxpYXNlc1xuICAgIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5odG1sX2JlYXV0aWZ5ID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gICAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW1xuICAgICAgICBcIi4vbGliL2JlYXV0aWZ5XCIsXG4gICAgICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgICAgIFwiLi9saWIvYmVhdXRpZnktaHRtbFwiXG4gICAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgICAgICByZXR1cm4gZ2V0X2JlYXV0aWZ5KGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpO1xuICAgIH0pO1xufSBlbHNlIHtcbiAgICAoZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5Jyk7XG4gICAgICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2xpYi9iZWF1dGlmeS1jc3MnKTtcbiAgICAgICAgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2xpYi9iZWF1dGlmeS1odG1sJyk7XG5cbiAgICAgICAgbW9kLmV4cG9ydHMgPSBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG5cbiAgICB9KShtb2R1bGUpO1xufSIsIi8qanNoaW50IGN1cmx5OmZhbHNlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gQ1NTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG4gICAgV3JpdHRlbiBieSBIYXJ1dHl1biBBbWlyamFueWFuLCAoYW1pcmphbnlhbkBnbWFpbC5jb20pXG5cbiAgICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGpzYmVhdXRpZmllci5vcmc+XG4gICAgICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gICAgVXNhZ2U6XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCk7XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgICBUaGUgb3B0aW9ucyBhcmUgKGRlZmF1bHQgaW4gYnJhY2tldHMpOlxuICAgICAgICBpbmRlbnRfc2l6ZSAoNCkgICAgICAgICAgICAgICAgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgICAgIGluZGVudF9jaGFyIChzcGFjZSkgICAgICAgICAgICAgICAgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgICAgICBzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSAodHJ1ZSkgICAgICAgLSBzZXBhcmF0ZSBzZWxlY3RvcnMgd2l0aCBuZXdsaW5lIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCAoZS5nLiBcImEsXFxuYnJcIiBvciBcImEsIGJyXCIpXG4gICAgICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgICAgICBuZXdsaW5lX2JldHdlZW5fcnVsZXMgKHRydWUpICAgICAgICAgICAgLSBhZGQgYSBuZXcgbGluZSBhZnRlciBldmVyeSBjc3MgcnVsZVxuICAgICAgICBzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yIChmYWxzZSkgLSBlbnN1cmUgc3BhY2UgYXJvdW5kIHNlbGVjdG9yIHNlcGFyYXRvcnM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc+JywgJysnLCAnficgKGUuZy4gXCJhPmJcIiAtPiBcImEgPiBiXCIpXG4gICAgZS5nXG5cbiAgICBjc3NfYmVhdXRpZnkoY3NzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCcsXG4gICAgICAnc2VsZWN0b3Jfc2VwYXJhdG9yJzogJyAnLFxuICAgICAgJ2VuZF93aXRoX25ld2xpbmUnOiBmYWxzZSxcbiAgICAgICduZXdsaW5lX2JldHdlZW5fcnVsZXMnOiB0cnVlLFxuICAgICAgJ3NwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3InOiB0cnVlXG4gICAgfSk7XG4qL1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdG9rZW5pemF0aW9uXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC9cblxuKGZ1bmN0aW9uKCkge1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9jc3MgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbnZhciBtZXJnZU9wdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLm1lcmdlT3B0cztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5PdXRwdXQ7XG5cblxudmFyIGxpbmVCcmVhayA9IGFjb3JuLmxpbmVCcmVhaztcbnZhciBhbGxMaW5lQnJlYWtzID0gYWNvcm4uYWxsTGluZUJyZWFrcztcblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgICBvcHRpb25zID0gbWVyZ2VPcHRzKG9wdGlvbnMsICdjc3MnKTtcblxuICAgIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG5cbiAgICB2YXIgbmV3bGluZXNGcm9tTGFzdFdTRWF0ID0gMDtcbiAgICB2YXIgaW5kZW50U2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemUgPyBwYXJzZUludChvcHRpb25zLmluZGVudF9zaXplLCAxMCkgOiA0O1xuICAgIHZhciBpbmRlbnRDaGFyYWN0ZXIgPSBvcHRpb25zLmluZGVudF9jaGFyIHx8ICcgJztcbiAgICB2YXIgcHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICB2YXIgc2VsZWN0b3JTZXBhcmF0b3JOZXdsaW5lID0gKG9wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZTtcbiAgICB2YXIgZW5kX3dpdGhfbmV3bGluZSA9IChvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgICB2YXIgbmV3bGluZV9iZXR3ZWVuX3J1bGVzID0gKG9wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzO1xuICAgIHZhciBzcGFjZV9hcm91bmRfY29tYmluYXRvciA9IChvcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yO1xuICAgIHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgfHwgKChvcHRpb25zLnNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcik7XG4gICAgdmFyIGVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgIGluZGVudENoYXJhY3RlciA9ICdcXHQnO1xuICAgICAgICBpbmRlbnRTaXplID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICAgICAgZW9sID0gJ1xcbic7XG4gICAgICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgICAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlb2wgPSBlb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICAvLyB0b2tlbml6ZXJcbiAgICB2YXIgd2hpdGVSZSA9IC9eXFxzKyQvO1xuXG4gICAgdmFyIHBvcyA9IC0xLFxuICAgICAgICBjaDtcbiAgICB2YXIgcGFyZW5MZXZlbCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBjaCA9IHNvdXJjZV90ZXh0LmNoYXJBdCgrK3Bvcyk7XG4gICAgICAgIHJldHVybiBjaCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKHNraXBXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIHByZXZfcG9zID0gcG9zO1xuICAgICAgICBpZiAoc2tpcFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBzb3VyY2VfdGV4dC5jaGFyQXQocG9zICsgMSkgfHwgJyc7XG4gICAgICAgIHBvcyA9IHByZXZfcG9zIC0gMTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdFN0cmluZyhlbmRDaGFycykge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZENoYXJzLmluZGV4T2YoY2gpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyArIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZWtTdHJpbmcoZW5kQ2hhcikge1xuICAgICAgICB2YXIgcHJldl9wb3MgPSBwb3M7XG4gICAgICAgIHZhciBzdHIgPSBlYXRTdHJpbmcoZW5kQ2hhcik7XG4gICAgICAgIHBvcyA9IHByZXZfcG9zIC0gMTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdFdoaXRlc3BhY2UocHJlc2VydmVfbmV3bGluZXNfbG9jYWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIHdoaWxlICh3aGl0ZVJlLnRlc3QocGVlaygpKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJyAmJiBwcmVzZXJ2ZV9uZXdsaW5lc19sb2NhbCAmJiBwcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3bGluZXNGcm9tTGFzdFdTRWF0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmIChjaCAmJiB3aGl0ZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjaDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAod2hpdGVSZS50ZXN0KG5leHQoKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhdENvbW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcztcbiAgICAgICAgdmFyIHNpbmdsZUxpbmUgPSBwZWVrKCkgPT09IFwiL1wiO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlTGluZSAmJiBjaCA9PT0gXCIqXCIgJiYgcGVlaygpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlTGluZSAmJiBjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpICsgY2g7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsb29rQmFjayhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhwb3MgLSBzdHIubGVuZ3RoLCBwb3MpLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICBzdHI7XG4gICAgfVxuXG4gICAgLy8gTmVzdGVkIHBzZXVkby1jbGFzcyBpZiB3ZSBhcmUgaW5zaWRlUnVsZVxuICAgIC8vIGFuZCB0aGUgbmV4dCBzcGVjaWFsIGNoYXJhY3RlciBmb3VuZCBvcGVuc1xuICAgIC8vIGEgbmV3IGJsb2NrXG4gICAgZnVuY3Rpb24gZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpIHtcbiAgICAgICAgdmFyIG9wZW5QYXJlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwb3MgKyAxOyBpIDwgc291cmNlX3RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHNvdXJjZV90ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICAgICAgICAgIC8vIHBzZXVkb2NsYXNzZXMgY2FuIGNvbnRhaW4gKClcbiAgICAgICAgICAgICAgICBvcGVuUGFyZW4gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuUGFyZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuUGFyZW4gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcHJpbnRlclxuICAgIHZhciBiYXNlSW5kZW50U3RyaW5nID0gJyc7XG4gICAgdmFyIHByZWluZGVudF9pbmRleCA9IDA7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIHNvdXJjZV90ZXh0Lmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAoKHNvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpID09PSAnICcgfHxcbiAgICAgICAgICAgICAgICBzb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJ1xcdCcpKSB7XG4gICAgICAgICAgICBwcmVpbmRlbnRfaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQuc3Vic3RyaW5nKDAsIHByZWluZGVudF9pbmRleCk7XG4gICAgICAgIGpzX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQuc3Vic3RyaW5nKHByZWluZGVudF9pbmRleCk7XG4gICAgfVxuXG5cbiAgICB2YXIgc2luZ2xlSW5kZW50ID0gbmV3IEFycmF5KGluZGVudFNpemUgKyAxKS5qb2luKGluZGVudENoYXJhY3Rlcik7XG4gICAgdmFyIGluZGVudExldmVsO1xuICAgIHZhciBuZXN0ZWRMZXZlbDtcbiAgICB2YXIgb3V0cHV0O1xuXG4gICAgZnVuY3Rpb24gcHJpbnRfc3RyaW5nKG91dHB1dF9zdHJpbmcpIHtcbiAgICAgICAgaWYgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgb3V0cHV0LnNldF9pbmRlbnQoaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGRfdG9rZW4ob3V0cHV0X3N0cmluZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpIHtcbiAgICAgICAgaWYgKGlzQWZ0ZXJTcGFjZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgICAgIGluZGVudExldmVsKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZGVudCgpIHtcbiAgICAgICAgaWYgKGluZGVudExldmVsID4gMCkge1xuICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qX19fX19fX19fX19fX19fX19fX19fLS0tLS0tLS0tLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX18qL1xuXG4gICAgdGhpcy5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBvdXRwdXQgPSBuZXcgT3V0cHV0KHNpbmdsZUluZGVudCwgYmFzZUluZGVudFN0cmluZyk7XG4gICAgICAgIGluZGVudExldmVsID0gMDtcbiAgICAgICAgbmVzdGVkTGV2ZWwgPSAwO1xuXG4gICAgICAgIHBvcyA9IC0xO1xuICAgICAgICBjaCA9IG51bGw7XG4gICAgICAgIHBhcmVuTGV2ZWwgPSAwO1xuXG4gICAgICAgIHZhciBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICAgIHZhciBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHZhciBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvcF9jaCA9ICcnO1xuICAgICAgICB2YXIgbGFzdF90b3BfY2ggPSAnJztcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgdmFyIGlzQWZ0ZXJTcGFjZSA9IHdoaXRlc3BhY2UgIT09ICcnO1xuICAgICAgICAgICAgdmFyIGlzQWZ0ZXJOZXdsaW5lID0gd2hpdGVzcGFjZS5pbmRleE9mKCdcXG4nKSAhPT0gLTE7XG4gICAgICAgICAgICBsYXN0X3RvcF9jaCA9IHRvcF9jaDtcbiAgICAgICAgICAgIHRvcF9jaCA9IGNoO1xuXG4gICAgICAgICAgICBpZiAoIWNoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnLycgJiYgcGVlaygpID09PSAnKicpIHsgLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gaW5kZW50TGV2ZWwgPT09IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBZnRlck5ld2xpbmUgfHwgaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0Q29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJyAmJiBwZWVrKCkgPT09ICcvJykgeyAvLyBzaW5nbGUgbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FmdGVyTmV3bGluZSAmJiBsYXN0X3RvcF9jaCAhPT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0Q29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggbGVzcyBwcm9wZXJ5IG1peGlucyBAey4uLn1cbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdFN0cmluZygnfScpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNwYWNlLCBpZiBwcmVzZW50LCBmb3IgaGFzaCBwcm9wZXJ0eSBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlT3JSdWxlID0gcGVla1N0cmluZyhcIjogLDt7fSgpW10vPSdcXFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHZhcmlhYmxlIG9yIHBzZXVkby1jbGFzcywgYWRkIGl0IGFuZCBpbnNlcnQgb25lIHNwYWNlIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZU9yUnVsZSA9IGVhdFN0cmluZyhcIjogXCIpLnJlcGxhY2UoL1xccyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcodmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZU9yUnVsZSA9IHZhcmlhYmxlT3JSdWxlLnJlcGxhY2UoL1xccyQvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuTkVTVEVEX0FUX1JVTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZExldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcjJyAmJiBwZWVrKCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0U3RyaW5nKCd9JykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsodHJ1ZSkgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdsaW5lc0Zyb21MYXN0V1NFYXQgPCAyICYmIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiBpbmRlbnRMZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGVudGVyaW5nIGNvbmRpdGlvbmFsIGdyb3Vwcywgb25seSBydWxlc2V0cyBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSAoaW5kZW50TGV2ZWwgPiBuZXN0ZWRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGRlY2xhcmF0aW9ucyBhcmUgYWxzbyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gKGluZGVudExldmVsID49IG5lc3RlZExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG91dGRlbnQoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRMZXZlbC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5ld2xpbmVzRnJvbUxhc3RXU0VhdCA8IDIgJiYgbmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluZGVudExldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKChpbnNpZGVSdWxlIHx8IGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShsb29rQmFjayhcIiZcIikgfHwgZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhbG9va0JhY2soXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICdwcm9wZXJ0eTogdmFsdWUnIGRlbGltaXRlclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjb3VsZCBiZSBpbiBhIGNvbmRpdGlvbmFsIGdyb3VwIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZygnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXNzL2xlc3MgcGFyZW50IHJlZmVyZW5jZSBkb24ndCB1c2UgYSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBzYXNzIG5lc3RlZCBwc2V1ZG8tY2xhc3MgZG9uJ3QgdXNlIGEgc3BhY2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgcHNldWRvY2xhc3Nlcy9wc2V1ZG9lbGVtZW50cywgYXMgaXQgbWVhbnMgXCJpbiBhbnkgY2hpbGRcIlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va0JhY2soXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhcIjo6XCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoY2gpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJygnKSB7IC8vIG1heSBiZSBhIHVybFxuICAgICAgICAgICAgICAgIGlmIChsb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJyknICYmIGNoICE9PSAnXCInICYmIGNoICE9PSAnXFwnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoJyknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIHBhcmVuTGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcsJykge1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpICYmIHNlbGVjdG9yU2VwYXJhdG9yTmV3bGluZSAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSAmJiBwYXJlbkxldmVsIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgoY2ggPT09ICc+JyB8fCBjaCA9PT0gJysnIHx8IGNoID09PSAnficpICYmXG4gICAgICAgICAgICAgICAgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBjb21iaW5hdG9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3F1YXNoIGV4dHJhIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoICYmIHdoaXRlUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnPScpIHsgLy8gbm8gd2hpdGVzcGFjZSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKCc9Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHdoaXRlUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3dlZXRDb2RlID0gb3V0cHV0LmdldF9jb2RlKGVuZF93aXRoX25ld2xpbmUsIGVvbCk7XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0Q29kZTtcbiAgICB9O1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0LXJ1bGVcbiAgICB0aGlzLk5FU1RFRF9BVF9SVUxFID0ge1xuICAgICAgICBcIkBwYWdlXCI6IHRydWUsXG4gICAgICAgIFwiQGZvbnQtZmFjZVwiOiB0cnVlLFxuICAgICAgICBcIkBrZXlmcmFtZXNcIjogdHJ1ZSxcbiAgICAgICAgLy8gYWxzbyBpbiBDT05ESVRJT05BTF9HUk9VUF9SVUxFIGJlbG93XG4gICAgICAgIFwiQG1lZGlhXCI6IHRydWUsXG4gICAgICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgICAgIFwiQGRvY3VtZW50XCI6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICAgICAgXCJAbWVkaWFcIjogdHJ1ZSxcbiAgICAgICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICAgICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBqc2hpbnQgY3VybHk6IGZhbHNlICovXG4vLyBUaGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIHBlcm1pdCAkICgzNikgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNiB8fCBjb2RlID09PSA2NDtcbiAgICAvLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBwZXJtaXQgXyAoOTUpLlxuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAvLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIHRhcmdldFR5cGUpIHtcbiAgICB2YXIgZmluYWxPcHRzID0ge307XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgdGFyZ2V0VHlwZVxuICAgIGlmICh0YXJnZXRUeXBlIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV0pIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICAgIHZhciBfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciBsaW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gICAgdmFyIF9pbmRlbnRfY291bnQgPSAtMTtcblxuICAgIHZhciBfaXRlbXMgPSBbXTtcbiAgICB2YXIgX2VtcHR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgPSBwYXJlbnQuYmFzZUluZGVudExlbmd0aCArIGxldmVsICogcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIF9pbmRlbnRfY291bnQgPSBsZXZlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY2hhcmFjdGVyX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2hhcmFjdGVyX2NvdW50O1xuICAgIH07XG5cbiAgICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZW1zW19pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIF9pdGVtcy5wdXNoKGlucHV0KTtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCArPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIF9lbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9IG51bGw7XG4gICAgICAgIGlmICghX2VtcHR5KSB7XG4gICAgICAgICAgICBpdGVtID0gX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+IDApIHtcbiAgICAgICAgICAgIF9pbmRlbnRfY291bnQgLT0gMTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChfaW5kZW50X2NvdW50ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQuaW5kZW50X2NhY2hlW19pbmRlbnRfY291bnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IF9pdGVtcy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE91dHB1dChpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gICAgdGhpcy5pbmRlbnRfY2FjaGUgPSBbYmFzZUluZGVudFN0cmluZ107XG4gICAgdGhpcy5iYXNlSW5kZW50TGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5pbmRlbnRfbGVuZ3RoID0gaW5kZW50X3N0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcblxuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHRoaXMuYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gICAgdGhpcy5pbmRlbnRfc3RyaW5nID0gaW5kZW50X3N0cmluZztcbiAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG4gICAgfTtcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG5cblxuICAgIHRoaXMuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsaW5lcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIFVzaW5nIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZyB0byBhbGxvdyBmb3IgbGF0ZXIgZXhwYW5zaW9uIG9mIGluZm8gYWJvdXQgZWFjaCBsaW5lXG4gICAgdGhpcy5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmdldF9saW5lX251bWJlcigpID09PSAxICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm8gbmV3bGluZSBvbiBzdGFydCBvZiBmaWxlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfbmV3bGluZSB8fCAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jb2RlID0gZnVuY3Rpb24oZW5kX3dpdGhfbmV3bGluZSwgZW9sKSB7XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbGluZXMuam9pbignXFxuJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCAnJyk7XG5cbiAgICAgICAgaWYgKGVuZF93aXRoX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgICAgICAgICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgd2hpbGUgKGxldmVsID49IHRoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NhY2hlLnB1c2godGhpcy5pbmRlbnRfY2FjaGVbdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoIC0gMV0gKyB0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgb3V0cHV0X2xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNbaW5kZXhdLnJlbW92ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gICAgICAgIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgICAgIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgbGluZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gbGluZXMubGVuZ3RoID4gMSA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc3RhcnQgb2YgdGhlIGZpbGUgYW5kIG5ld2xpbmUgPSBibGFua1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5CZWF1dGlmaWVyO1xuXG5mdW5jdGlvbiBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNzc19iZWF1dGlmeTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIGNzc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9jc3M7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjc3NfYmVhdXRpZnk6IGNzc19iZWF1dGlmeVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn1cblxufSgpKTtcbiIsIi8qanNoaW50IGN1cmx5OmZhbHNlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gU3R5bGUgSFRNTFxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgV3JpdHRlbiBieSBOb2NodW0gU29zc29ua28sIChuc29zc29ua29AaG90bWFpbC5jb20pXG5cbiAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gIFVzYWdlOlxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UpO1xuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9pbm5lcl9odG1sIChkZWZhdWx0IGZhbHNlKSAg4oCUIGluZGVudCA8aGVhZD4gYW5kIDxib2R5PiBzZWN0aW9ucyxcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgMjUwKSAgICAgICAgICAgIC0gIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgKDAgPSBkaXNhYmxlKVxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICB1bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gaW5saW5lIHRhZ3MpIC0gbGlzdCBvZiB0YWdzLCB0aGF0IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGNvbnRlbnRfdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIHByZSB0YWcpIC0gbGlzdCBvZiB0YWdzLCB3aG9zZSBjb250ZW50IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGluZGVudF9zY3JpcHRzIChkZWZhdWx0IG5vcm1hbCkgIC0gXCJrZWVwXCJ8XCJzZXBhcmF0ZVwifFwibm9ybWFsXCJcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3MgYmVmb3JlIGVsZW1lbnRzIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGJlZm9yZSBlbGVtZW50cywgbm90IGluc2lkZSB0YWdzIG9yIGZvciB0ZXh0LlxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVua1xuICAgIGluZGVudF9oYW5kbGViYXJzIChkZWZhdWx0IGZhbHNlKSAtIGZvcm1hdCBhbmQgaW5kZW50IHt7I2Zvb319IGFuZCB7ey9mb299fVxuICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgIGV4dHJhX2xpbmVycyAoZGVmYXVsdCBbaGVhZCxib2R5LC9odG1sXSkgLUxpc3Qgb2YgdGFncyB0aGF0IHNob3VsZCBoYXZlIGFuIGV4dHJhIG5ld2xpbmUgYmVmb3JlIHRoZW0uXG5cbiAgICBlLmcuXG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCB7XG4gICAgICAnaW5kZW50X2lubmVyX2h0bWwnOiBmYWxzZSxcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDIsXG4gICAgICAnaW5kZW50X2NoYXInOiAnICcsXG4gICAgICAnd3JhcF9saW5lX2xlbmd0aCc6IDc4LFxuICAgICAgJ2JyYWNlX3N0eWxlJzogJ2V4cGFuZCcsXG4gICAgICAncHJlc2VydmVfbmV3bGluZXMnOiB0cnVlLFxuICAgICAgJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcyc6IDUsXG4gICAgICAnaW5kZW50X2hhbmRsZWJhcnMnOiBmYWxzZSxcbiAgICAgICdleHRyYV9saW5lcnMnOiBbJy9odG1sJ11cbiAgICB9KTtcbiovXG5cbihmdW5jdGlvbigpIHtcbnZhciBsZWdhY3lfYmVhdXRpZnlfaHRtbCA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxudmFyIG1lcmdlT3B0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikubWVyZ2VPcHRzO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG52YXIgbGluZUJyZWFrID0gYWNvcm4ubGluZUJyZWFrO1xudmFyIGFsbExpbmVCcmVha3MgPSBhY29ybi5hbGxMaW5lQnJlYWtzO1xuXG4vLyBmdW5jdGlvbiB0cmltKHMpIHtcbi8vICAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4vLyB9XG5cbmZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzKy9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIHJ0cmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXHMrJC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgICAvL1dyYXBwZXIgZnVuY3Rpb24gdG8gaW52b2tlIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnN0cnVjdG9ycyBhbmQgZGVhbCB3aXRoIHRoZSBvdXRwdXQuXG4gICAgaHRtbF9zb3VyY2UgPSBodG1sX3NvdXJjZSB8fCAnJztcblxuICAgIHZhciBtdWx0aV9wYXJzZXIsXG4gICAgICAgIGluZGVudF9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfYm9keV9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfaGVhZF9pbm5lcl9odG1sLFxuICAgICAgICBpbmRlbnRfc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXJhY3RlcixcbiAgICAgICAgd3JhcF9saW5lX2xlbmd0aCxcbiAgICAgICAgYnJhY2Vfc3R5bGUsXG4gICAgICAgIHVuZm9ybWF0dGVkLFxuICAgICAgICBjb250ZW50X3VuZm9ybWF0dGVkLFxuICAgICAgICBwcmVzZXJ2ZV9uZXdsaW5lcyxcbiAgICAgICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzLFxuICAgICAgICBpbmRlbnRfaGFuZGxlYmFycyxcbiAgICAgICAgd3JhcF9hdHRyaWJ1dGVzLFxuICAgICAgICB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsXG4gICAgICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZSxcbiAgICAgICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUsXG4gICAgICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkLFxuICAgICAgICBlbmRfd2l0aF9uZXdsaW5lLFxuICAgICAgICBleHRyYV9saW5lcnMsXG4gICAgICAgIGVvbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgICBvcHRpb25zID0gbWVyZ2VPcHRzKG9wdGlvbnMsICdodG1sJyk7XG5cbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB0byAxLjMuNFxuICAgIGlmICgob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCkgPT09IDApICYmXG4gICAgICAgIChvcHRpb25zLm1heF9jaGFyICE9PSB1bmRlZmluZWQgJiYgcGFyc2VJbnQob3B0aW9ucy5tYXhfY2hhciwgMTApICE9PSAwKSkge1xuICAgICAgICBvcHRpb25zLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLm1heF9jaGFyO1xuICAgIH1cblxuICAgIGluZGVudF9pbm5lcl9odG1sID0gKG9wdGlvbnMuaW5kZW50X2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuaW5kZW50X2lubmVyX2h0bWw7XG4gICAgaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IChvcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5pbmRlbnRfYm9keV9pbm5lcl9odG1sO1xuICAgIGluZGVudF9oZWFkX2lubmVyX2h0bWwgPSAob3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcbiAgICBpbmRlbnRfc2l6ZSA9IChvcHRpb25zLmluZGVudF9zaXplID09PSB1bmRlZmluZWQpID8gNCA6IHBhcnNlSW50KG9wdGlvbnMuaW5kZW50X3NpemUsIDEwKTtcbiAgICBpbmRlbnRfY2hhcmFjdGVyID0gKG9wdGlvbnMuaW5kZW50X2NoYXIgPT09IHVuZGVmaW5lZCkgPyAnICcgOiBvcHRpb25zLmluZGVudF9jaGFyO1xuICAgIGJyYWNlX3N0eWxlID0gKG9wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IHVuZGVmaW5lZCkgPyAnY29sbGFwc2UnIDogb3B0aW9ucy5icmFjZV9zdHlsZTtcbiAgICB3cmFwX2xpbmVfbGVuZ3RoID0gcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCkgPT09IDAgPyAzMjc4NiA6IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCB8fCAyNTAsIDEwKTtcbiAgICB1bmZvcm1hdHRlZCA9IG9wdGlvbnMudW5mb3JtYXR0ZWQgfHwgW1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICAgICAgICAnYScsICdhYmJyJywgJ2FyZWEnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2l0ZScsXG4gICAgICAgICdjb2RlJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGVsJywgJ2RmbicsICdlbScsICdlbWJlZCcsICdpJywgJ2lmcmFtZScsICdpbWcnLFxuICAgICAgICAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbWFwJywgJ21hcmsnLCAnbWF0aCcsICdtZXRlcicsICdub3NjcmlwdCcsXG4gICAgICAgICdvYmplY3QnLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3EnLCAncnVieScsICdzJywgJ3NhbXAnLCAvKiAnc2NyaXB0JywgKi8gJ3NlbGVjdCcsICdzbWFsbCcsXG4gICAgICAgICdzcGFuJywgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0aW1lJywgJ3UnLCAndmFyJyxcbiAgICAgICAgJ3ZpZGVvJywgJ3dicicsICd0ZXh0JyxcbiAgICAgICAgLy8gcHJleGlzdGluZyAtIG5vdCBzdXJlIG9mIGZ1bGwgZWZmZWN0IG9mIHJlbW92aW5nLCBsZWF2aW5nIGluXG4gICAgICAgICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYmlnJywgJ2R0JywgJ2lucycsICdzdHJpa2UnLCAndHQnLFxuICAgIF07XG4gICAgY29udGVudF91bmZvcm1hdHRlZCA9IG9wdGlvbnMuY29udGVudF91bmZvcm1hdHRlZCB8fCBbXG4gICAgICAgICdwcmUnLFxuICAgIF07XG4gICAgcHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHByZXNlcnZlX25ld2xpbmVzID9cbiAgICAgICAgKGlzTmFOKHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCkpID8gMzI3ODYgOiBwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywgMTApKSA6XG4gICAgICAgIDA7XG4gICAgaW5kZW50X2hhbmRsZWJhcnMgPSAob3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycztcbiAgICB3cmFwX2F0dHJpYnV0ZXMgPSAob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkgPyAnYXV0bycgOiBvcHRpb25zLndyYXBfYXR0cmlidXRlcztcbiAgICB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUgPSAoaXNOYU4ocGFyc2VJbnQob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsIDEwKSkpID8gaW5kZW50X3NpemUgOiBwYXJzZUludChvcHRpb25zLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSwgMTApO1xuICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZSA9IHdyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ2ZvcmNlJy5sZW5ndGgpID09PSAnZm9yY2UnO1xuICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lID0gKHdyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnKTtcbiAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCA9ICh3cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1hbGlnbmVkJyk7XG4gICAgZW5kX3dpdGhfbmV3bGluZSA9IChvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgICBleHRyYV9saW5lcnMgPSAodHlwZW9mIG9wdGlvbnMuZXh0cmFfbGluZXJzID09PSAnb2JqZWN0JykgJiYgb3B0aW9ucy5leHRyYV9saW5lcnMgP1xuICAgICAgICBvcHRpb25zLmV4dHJhX2xpbmVycy5jb25jYXQoKSA6ICh0eXBlb2Ygb3B0aW9ucy5leHRyYV9saW5lcnMgPT09ICdzdHJpbmcnKSA/XG4gICAgICAgIG9wdGlvbnMuZXh0cmFfbGluZXJzLnNwbGl0KCcsJykgOiAnaGVhZCxib2R5LC9odG1sJy5zcGxpdCgnLCcpO1xuICAgIGVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgIGluZGVudF9jaGFyYWN0ZXIgPSAnXFx0JztcbiAgICAgICAgaW5kZW50X3NpemUgPSAxO1xuICAgIH1cblxuICAgIGlmIChlb2wgPT09ICdhdXRvJykge1xuICAgICAgICBlb2wgPSAnXFxuJztcbiAgICAgICAgaWYgKGh0bWxfc291cmNlICYmIGxpbmVCcmVhay50ZXN0KGh0bWxfc291cmNlIHx8ICcnKSkge1xuICAgICAgICAgICAgZW9sID0gaHRtbF9zb3VyY2UubWF0Y2gobGluZUJyZWFrKVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVvbCA9IGVvbC5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKTtcblxuICAgIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gICAgaHRtbF9zb3VyY2UgPSBodG1sX3NvdXJjZS5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcblxuICAgICAgICB0aGlzLnBvcyA9IDA7IC8vUGFyc2VyIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudG9rZW4gPSAnJztcbiAgICAgICAgdGhpcy5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7IC8vcmVmbGVjdHMgdGhlIGN1cnJlbnQgUGFyc2VyIG1vZGU6IFRBRy9DT05URU5UXG4gICAgICAgIHRoaXMudGFncyA9IHsgLy9BbiBvYmplY3QgdG8gaG9sZCB0YWdzLCB0aGVpciBwb3NpdGlvbiwgYW5kIHRoZWlyIHBhcmVudC10YWdzLCBpbml0aWF0ZWQgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgcGFyZW50OiAncGFyZW50MScsXG4gICAgICAgICAgICBwYXJlbnRjb3VudDogMSxcbiAgICAgICAgICAgIHBhcmVudDE6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFnX3R5cGUgPSAnJztcbiAgICAgICAgdGhpcy50b2tlbl90ZXh0ID0gdGhpcy5sYXN0X3Rva2VuID0gdGhpcy5sYXN0X3RleHQgPSB0aGlzLnRva2VuX3R5cGUgPSAnJztcbiAgICAgICAgdGhpcy5uZXdsaW5lcyA9IDA7XG4gICAgICAgIHRoaXMuaW5kZW50X2NvbnRlbnQgPSBpbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgICAgdGhpcy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID0gaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgICAgdGhpcy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID0gaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcblxuICAgICAgICB0aGlzLlV0aWxzID0geyAvL1VpbGl0aWVzIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSB2YXJpb3VzIGZ1bmN0aW9uc1xuICAgICAgICAgICAgd2hpdGVzcGFjZTogXCJcXG5cXHJcXHQgXCIuc3BsaXQoJycpLFxuXG4gICAgICAgICAgICBzaW5nbGVfdG9rZW46IG9wdGlvbnMudm9pZF9lbGVtZW50cyB8fCBbXG4gICAgICAgICAgICAgICAgLy8gSFRMTSB2b2lkIGVsZW1lbnRzIC0gYWthIHNlbGYtY2xvc2luZyB0YWdzIC0gYWthIHNpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgICAgICAgICAgICAgICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLFxuICAgICAgICAgICAgICAgICdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsXG4gICAgICAgICAgICAgICAgLy8gTk9URTogT3B0aW9uYWwgdGFncyAtIGFyZSBub3QgdW5kZXJzdG9vZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICAgICAgICAgICAgICAgIC8vIFRoZSBydWxlcyBmb3Igb3B0aW9uYWwgdGFncyBhcmUgdG9vIGNvbXBsZXggZm9yIGEgc2ltcGxlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBBbHNvLCB0aGUgY29udGVudCBvZiB0aGVzZSB0YWdzIHNob3VsZCBzdGlsbCBiZSBpbmRlbnRlZCBpbiBtYW55IGNhc2VzLlxuICAgICAgICAgICAgICAgIC8vICdsaScgaXMgYSBnb29kIGV4bXBsZS5cblxuICAgICAgICAgICAgICAgIC8vIERvY3R5cGUgYW5kIHhtbCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICchZG9jdHlwZScsICc/eG1sJyxcbiAgICAgICAgICAgICAgICAvLyA/cGhwIHRhZ1xuICAgICAgICAgICAgICAgICc/cGhwJyxcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0YWdzIHRoYXQgd2VyZSBpbiB0aGlzIGxpc3QsIGtlZXBpbmcganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgJ2Jhc2Vmb250JywgJ2lzaW5kZXgnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmFfbGluZXJzOiBleHRyYV9saW5lcnMsIC8vZm9yIHRhZ3MgdGhhdCBuZWVkIGEgbGluZSBvZiB3aGl0ZXNwYWNlIGJlZm9yZSB0aGVtXG4gICAgICAgICAgICBpbl9hcnJheTogZnVuY3Rpb24od2hhdCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoYXQgPT09IGFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiB0ZXh0IGlzIGNvbXBvc2VkIGVudGlyZWx5IG9mIHdoaXRlc3BhY2UuXG4gICAgICAgIHRoaXMuaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGV4dC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5VdGlscy5pbl9hcnJheSh0ZXh0LmNoYXJBdChuKSwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnO1xuXG4gICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlX25ld2xpbmVzICYmIGlucHV0X2NoYXIgPT09ICdcXG4nICYmIHRoaXMubmV3bGluZXMgPD0gbWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2xpbmVzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBcHBlbmQgYSBzcGFjZSB0byB0aGUgZ2l2ZW4gY29udGVudCAoc3RyaW5nIGFycmF5KSBvciwgaWYgd2UgYXJlXG4gICAgICAgIC8vIGF0IHRoZSB3cmFwX2xpbmVfbGVuZ3RoLCBhcHBlbmQgYSBuZXdsaW5lL2luZGVudGF0aW9uLlxuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBhIG5ld2xpbmUgd2FzIGFkZGVkLCBmYWxzZSBpZiBhIHNwYWNlIHdhcyBhZGRlZFxuICAgICAgICB0aGlzLnNwYWNlX29yX3dyYXAgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lX2NoYXJfY291bnQgPj0gdGhpcy53cmFwX2xpbmVfbGVuZ3RoKSB7IC8vaW5zZXJ0IGEgbGluZSB3aGVuIHRoZSB3cmFwX2xpbmVfbGVuZ3RoIGlzIHJlYWNoZWRcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24oY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X2NvbnRlbnQgPSBmdW5jdGlvbigpIHsgLy9mdW5jdGlvbiB0byBjYXB0dXJlIHJlZ3VsYXIgY29udGVudCBiZXR3ZWVuIHRhZ3NcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJycsXG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtdLFxuICAgICAgICAgICAgICAgIGhhbmRsZWJhcnNTdGFydGVkID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKSAhPT0gJzwnIHx8IGhhbmRsZWJhcnNTdGFydGVkID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlYmFyc1N0YXJ0ZWQgPCAyICYmIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGViYXJzU3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZWJhcnNTdGFydGVkIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlYmFyc1N0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICd9JyAmJiBoYW5kbGViYXJzU3RhcnRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGViYXJzU3RhcnRlZC0tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlYmFycyBwYXJzaW5nIGlzIGNvbXBsaWNhdGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyB7eyNmb299fSBhbmQge3svZm9vfX0gYXJlIGZvcm1hdHRlZCB0YWdzLlxuICAgICAgICAgICAgICAgICAgICAvLyB7e3NvbWV0aGluZ319IHNob3VsZCBnZXQgdHJlYXRlZCBhcyBjb250ZW50LCBleGNlcHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHt7ZWxzZX19IHNwZWNpZmljYWxseSBiZWhhdmVzIGxpa2Uge3sjaWZ9fSBhbmQge3svaWZ9fVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVlazMgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgMyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrMyA9PT0gJ3t7IycgfHwgcGVlazMgPT09ICd7ey8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGFncyBhbmQgbm90IGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZWVrMyA9PT0gJ3t7IScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZXRfdGFnKCksICdUS19UQUdfSEFORExFQkFSU19DT01NRU5UJ107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MsIDIpID09PSAne3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRfdGFnKHRydWUpID09PSAne3tlbHNlfX0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGlucHV0X2NoYXIpOyAvL2xldHRlciBhdC1hLXRpbWUgKG9yIHN0cmluZykgaW5zZXJ0ZWQgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9jb250ZW50c190byA9IGZ1bmN0aW9uKG5hbWUpIHsgLy9nZXQgdGhlIGZ1bGwgY29udGVudCBvZiBhIHNjcmlwdCBvciBzdHlsZSB0byBwYXNzIHRvIGpzX2JlYXV0aWZ5XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIHZhciByZWdfbWF0Y2ggPSBuZXcgUmVnRXhwKCc8LycgKyBuYW1lICsgJ1xcXFxzKj4nLCAnaWdtJyk7XG4gICAgICAgICAgICByZWdfbWF0Y2gubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgcmVnX2FycmF5ID0gcmVnX21hdGNoLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgICAgICB2YXIgZW5kX3NjcmlwdCA9IHJlZ19hcnJheSA/IHJlZ19hcnJheS5pbmRleCA6IHRoaXMuaW5wdXQubGVuZ3RoOyAvL2Fic29sdXRlIGVuZCBvZiBzY3JpcHRcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA8IGVuZF9zY3JpcHQpIHsgLy9nZXQgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHRoZSBzY3JpcHQgdGFnc1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLnBvcywgZW5kX3NjcmlwdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmRfc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZWNvcmRfdGFnID0gZnVuY3Rpb24odGFnKSB7IC8vZnVuY3Rpb24gdG8gcmVjb3JkIGEgdGFnIGFuZCBpdHMgcGFyZW50IGluIHRoaXMudGFncyBPYmplY3RcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10pIHsgLy9jaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddKys7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV0gPSB0aGlzLmluZGVudF9sZXZlbDsgLy9hbmQgcmVjb3JkIHRoZSBwcmVzZW50IGluZGVudCBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgaW5pdGlhbGl6ZSB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXSA9IHRoaXMuaW5kZW50X2xldmVsOyAvL2FuZCByZWNvcmQgdGhlIHByZXNlbnQgaW5kZW50IGxldmVsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddICsgJ3BhcmVudCddID0gdGhpcy50YWdzLnBhcmVudDsgLy9zZXQgdGhlIHBhcmVudCAoaS5lLiBpbiB0aGUgY2FzZSBvZiBhIGRpdiB0aGlzLnRhZ3MuZGl2MXBhcmVudClcbiAgICAgICAgICAgIHRoaXMudGFncy5wYXJlbnQgPSB0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J107IC8vYW5kIG1ha2UgdGhpcyB0aGUgY3VycmVudCBwYXJlbnQgKGkuZS4gaW4gdGhlIGNhc2Ugb2YgYSBkaXYgJ2RpdjEnKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmV0cmlldmVfdGFnID0gZnVuY3Rpb24odGFnKSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICAgICAgICAgICAgaWYgKHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSkgeyAvL2lmIHRoZSBvcGVuZW5lciBpcyBub3QgaW4gdGhlIE9iamVjdCB3ZSBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICB2YXIgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3MucGFyZW50OyAvL2NoZWNrIHRvIHNlZSBpZiBpdCdzIGEgY2xvc2FibGUgdGFnLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0ZW1wX3BhcmVudCkgeyAvL3RpbGwgd2UgcmVhY2ggJycgKHRoZSBpbml0aWFsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gdGVtcF9wYXJlbnQpIHsgLy9pZiB0aGlzIGlzIGl0IHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3NbdGVtcF9wYXJlbnQgKyAncGFyZW50J107IC8vb3RoZXJ3aXNlIGtlZXAgb24gY2xpbWJpbmcgdXAgdGhlIERPTSBUcmVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wX3BhcmVudCkgeyAvL2lmIHdlIGNhdWdodCBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTsgLy9zZXQgdGhlIGluZGVudF9sZXZlbCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucGFyZW50ID0gdGhpcy50YWdzW3RlbXBfcGFyZW50ICsgJ3BhcmVudCddOyAvL2FuZCBzZXQgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddICsgJ3BhcmVudCddOyAvL2RlbGV0ZSB0aGUgY2xvc2VkIHRhZ3MgcGFyZW50IHJlZmVyZW5jZS4uLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTsgLy8uLi5hbmQgdGhlIHRhZyBpdHNlbGZcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWdzW3RhZyArICdjb3VudCddID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArICdjb3VudCddLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgLy8gTWF0Y2ggdGhlIGluZGVudGF0aW9uIGxldmVsIHRvIHRoZSBsYXN0IHVzZSBvZiB0aGlzIHRhZywgYnV0IGRvbid0IHJlbW92ZSBpdC5cbiAgICAgICAgICAgIGlmICghdGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICh0ZW1wX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPT09IHRlbXBfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wX3BhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfdGFnID0gZnVuY3Rpb24ocGVlaykgeyAvL2Z1bmN0aW9uIHRvIGdldCBhIGZ1bGwgdGFnIGFuZCBwYXJzZSBpdHMgdHlwZVxuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJyxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW10sXG4gICAgICAgICAgICAgICAgY29tbWVudCA9ICcnLFxuICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZmlyc3RfYXR0ciA9IHRydWUsXG4gICAgICAgICAgICAgICAgaGFzX3dyYXBwZWRfYXR0cnMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWdfc3RhcnQsIHRhZ19lbmQsXG4gICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIsXG4gICAgICAgICAgICAgICAgb3JpZ19wb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICBvcmlnX2xpbmVfY2hhcl9jb3VudCA9IHRoaXMubGluZV9jaGFyX2NvdW50LFxuICAgICAgICAgICAgICAgIGlzX3RhZ19jbG9zZWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWlsO1xuXG4gICAgICAgICAgICBwZWVrID0gcGVlayAhPT0gdW5kZWZpbmVkID8gcGVlayA6IGZhbHNlO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG9yaWdfcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSBvcmlnX2xpbmVfY2hhcl9jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudC5sZW5ndGggPyBjb250ZW50LmpvaW4oJycpIDogWycnLCAnVEtfRU9GJ107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkgeyAvL2Rvbid0IHdhbnQgdG8gaW5zZXJ0IHVubmVjZXNzYXJ5IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09IFwiJ1wiIHx8IGlucHV0X2NoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciArPSB0aGlzLmdldF91bmZvcm1hdHRlZChpbnB1dF9jaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnPScpIHsgLy9ubyBzcGFjZSBiZWZvcmUgPVxuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWlsID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgaGFzX3dyYXBwZWRfYXR0cnMgJiYgIWlzX3RhZ19jbG9zZWQgJiYgKGlucHV0X2NoYXIgPT09ICc+JyB8fCBpbnB1dF9jaGFyID09PSAnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWlsLm1hdGNoKC9eXFwvP1xccyo+LykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc190YWdfY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICc9JyAmJiBpbnB1dF9jaGFyICE9PSAnPicgJiYgc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBzcGFjZSBhZnRlciA9IG9yIGJlZm9yZSA+XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkID0gdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50QXR0cnMgPSB3cmFwcGVkICYmIGlucHV0X2NoYXIgIT09ICcvJyAmJiAhaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgJiYgaW5wdXRfY2hhciAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2VfZmlyc3RfYXR0cl93cmFwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgZmlyc3RfYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc19vbmx5X2F0dHJpYnV0ZSA9IHRhaWwubWF0Y2goL15cXFMqKD1cIihbXlwiXXxcXFxcXCIpKlwiKT9cXHMqXFwvP1xccyo+LykgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VfZmlyc3RfYXR0cl93cmFwID0gIWlzX29ubHlfYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdF9hdHRyIHx8IGZvcmNlX2ZpcnN0X2F0dHJfd3JhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbihjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRBdHRycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNfd3JhcHBlZF9hdHRycyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5kZW50IGF0dHJpYnV0ZXMgYW4gYXV0bywgZm9yY2VkLCBvciBmb3JjZWQtYWxpZ24gbGluZS13cmFwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50X3NpemUgPSB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRfc2l6ZSA9IGNvbnRlbnQuaW5kZXhPZignICcpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IGFsaWdubWVudF9zaXplOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBldmVyIGZ1cnRoZXIgaW5kZW50IHdpdGggc3BhY2VzIHNpbmNlIHdlJ3JlIHRyeWluZyB0byBhbGlnbiBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0X2F0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50W2ldID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfYXR0ciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGluc2lkZSBhbiBhbmdsZS1icmFja2V0IHRhZywgcHV0IHNwYWNlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlYmFycyBub3QgaW5zaWRlIG9mIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5wdXRfY2hhciArIHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKSkgPT09ICd7eycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnICcgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gJyAnICsgaW5wdXRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnPCcgJiYgIXRhZ19zdGFydF9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIgPSAnPCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmICF0YWdfc3RhcnRfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPj0gMiAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICd7JyAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMl0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICcjJyB8fCBpbnB1dF9jaGFyID09PSAnLycgfHwgaW5wdXRfY2hhciA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0ID0gdGhpcy5wb3MgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnQgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnRfY2hhciA9ICd7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGlucHV0X2NoYXIpOyAvL2luc2VydHMgY2hhcmFjdGVyIGF0LWEtdGltZSAob3Igc3RyaW5nKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMV0gJiYgKGNvbnRlbnRbMV0gPT09ICchJyB8fCBjb250ZW50WzFdID09PSAnPycgfHwgY29udGVudFsxXSA9PT0gJyUnKSkgeyAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFt0aGlzLmdldF9jb21tZW50KHRhZ19zdGFydCldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgY29udGVudFsxXSAmJiBjb250ZW50WzFdID09PSAneycgJiYgY29udGVudFsyXSAmJiBjb250ZW50WzJdID09PSAnIScpIHsgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbdGhpcy5nZXRfY29tbWVudCh0YWdfc3RhcnQpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIHRhZ19zdGFydF9jaGFyID09PSAneycgJiYgY29udGVudC5sZW5ndGggPiAyICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAyXSA9PT0gJ30nICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGlucHV0X2NoYXIgIT09ICc+Jyk7XG5cbiAgICAgICAgICAgIHZhciB0YWdfY29tcGxldGUgPSBjb250ZW50LmpvaW4oJycpO1xuICAgICAgICAgICAgdmFyIHRhZ19pbmRleDtcbiAgICAgICAgICAgIHZhciB0YWdfb2Zmc2V0O1xuXG4gICAgICAgICAgICAvLyBtdXN0IGNoZWNrIGZvciBzcGFjZSBmaXJzdCBvdGhlcndpc2UgdGhlIHRhZyBjb3VsZCBoYXZlIHRoZSBmaXJzdCBhdHRyaWJ1dGUgaW5jbHVkZWQsIGFuZFxuICAgICAgICAgICAgLy8gdGhlbiBub3QgdW4taW5kZW50IGNvcnJlY3RseVxuICAgICAgICAgICAgaWYgKHRhZ19jb21wbGV0ZS5pbmRleE9mKCcgJykgIT09IC0xKSB7IC8vaWYgdGhlcmUncyB3aGl0ZXNwYWNlLCB0aGF0cyB3aGVyZSB0aGUgdGFnIG5hbWUgZW5kc1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jb21wbGV0ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHsgLy9pZiB0aGVyZSdzIGEgbGluZSBicmVhaywgdGhhdHMgd2hlcmUgdGhlIHRhZyBuYW1lIGVuZHNcbiAgICAgICAgICAgICAgICB0YWdfaW5kZXggPSB0YWdfY29tcGxldGUuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jb21wbGV0ZS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCd9Jyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvL290aGVyd2lzZSBnbyB3aXRoIHRoZSB0YWcgZW5kaW5nXG4gICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJz4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAnPCcgfHwgIWluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgICAgICAgICAgICAgdGFnX29mZnNldCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhZ19vZmZzZXQgPSB0YWdfY29tcGxldGUuY2hhckF0KDIpID09PSAnIycgPyAzIDogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWdfY2hlY2sgPSB0YWdfY29tcGxldGUuc3Vic3RyaW5nKHRhZ19vZmZzZXQsIHRhZ19pbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KHRhZ19jb21wbGV0ZS5sZW5ndGggLSAyKSA9PT0gJy8nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHRoaXMuVXRpbHMuc2luZ2xlX3Rva2VuKSkgeyAvL2lmIHRoaXMgdGFnIG5hbWUgaXMgYSBzaW5nbGUgdGFnIHR5cGUgKGVpdGhlciBpbiB0aGUgbGlzdCBvciBoYXMgYSBjbG9zaW5nIC8pXG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIHRhZ19jb21wbGV0ZS5jaGFyQXQoMCkgPT09ICd7JyAmJiB0YWdfY2hlY2sgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF90b190YWcoJ2lmJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnSEFORExFQkFSU19FTFNFJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc191bmZvcm1hdHRlZCh0YWdfY2hlY2ssIHVuZm9ybWF0dGVkKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNfdW5mb3JtYXR0ZWQodGFnX2NoZWNrLCBjb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCByZWZvcm1hdCB0aGUgXCJ1bmZvcm1hdHRlZFwiIG9yIFwiY29udGVudF91bmZvcm1hdHRlZFwiIHRhZ3NcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJzwvJyArIHRhZ19jaGVjayArICc+JywgdGFnX2NvbXBsZXRlKTsgLy8uLi5kZWxlZ2F0ZSB0byBnZXRfdW5mb3JtYXR0ZWQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGFnX2VuZCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NJTkdMRSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3NjcmlwdCcgJiZcbiAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19jb21wbGV0ZS5zZWFyY2goL1xcYih0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oamF2YXNjcmlwdHxlY21hc2NyaXB0fGpzY3JpcHR8bGl2ZXNjcmlwdHwobGRcXCspP2pzb258bWV0aG9kfGFzcGVjdCkvKSA+IC0xKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0NSSVBUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJyAmJlxuICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPiAtMSAmJiB0YWdfY29tcGxldGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZF90YWcodGFnX2NoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTVFlMRSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY2hlY2suY2hhckF0KDApID09PSAnIScpIHsgLy9wZWVrIGZvciA8ISBjb21tZW50XG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbW1lbnRzIGNvbnRlbnQgaXMgYWxyZWFkeSBjb3JyZWN0LlxuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NJTkdMRSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnX2NoZWNrLmNoYXJBdCgwKSA9PT0gJy8nKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cmlldmVfdGFnKHRhZ19jaGVjay5zdWJzdHJpbmcoMSkpOyAvL3JlbW92ZSBpdCBhbmQgYWxsIGFuY2VzdG9yc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ0VORCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgaXQncyBhIHN0YXJ0LXRhZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZF90YWcodGFnX2NoZWNrKTsgLy9wdXNoIGl0IG9uIHRoZSB0YWcgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19jaGVjay50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU1RBUlQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFsbG93IHByZXNlcnZpbmcgb2YgbmV3bGluZXMgYWZ0ZXIgYSBzdGFydCBvciBlbmQgdGFnXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHRoaXMuVXRpbHMuZXh0cmFfbGluZXJzKSkgeyAvL2NoZWNrIGlmIHRoaXMgZG91YmxlIG5lZWRzIGFuIGV4dHJhIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggJiYgdGhpcy5vdXRwdXRbdGhpcy5vdXRwdXQubGVuZ3RoIC0gMl0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGVlaykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gb3JpZ19wb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSBvcmlnX2xpbmVfY2hhcl9jb3VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuam9pbignJyk7IC8vcmV0dXJucyBmdWxseSBmb3JtYXR0ZWQgdGFnXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfY29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0X3BvcykgeyAvL2Z1bmN0aW9uIHRvIHJldHVybiBjb21tZW50IGNvbnRlbnQgaW4gaXRzIGVudGlyZXR5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHdpbGwgaGF2ZSB2ZXJ5IHBvb3IgcGVyZiwgYnV0IHdpbGwgd29yayBmb3Igbm93LlxuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSAnJyxcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnPicsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0X3BvcztcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDw9IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCArPSBpbnB1dF9jaGFyO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIGNoZWNrIGZvciB0aGUgZGVsaW1pdGVyIGlmIHRoZSBsYXN0IGNoYXJzIG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuY2hhckF0KGNvbW1lbnQubGVuZ3RoIC0gMSkgPT09IGRlbGltaXRlci5jaGFyQXQoZGVsaW1pdGVyLmxlbmd0aCAtIDEpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuaW5kZXhPZihkZWxpbWl0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gc2VhcmNoIGZvciBjdXN0b20gZGVsaW1pdGVyIGZvciB0aGUgZmlyc3QgZmV3IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWQgJiYgY29tbWVudC5sZW5ndGggPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5pbmRleE9mKCc8IVtpZicpID09PSAwKSB7IC8vcGVlayBmb3IgPCFbaWYgY29uZGl0aW9uYWwgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJzwhW2VuZGlmXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8IVtjZGF0YVsnKSA9PT0gMCkgeyAvL2lmIGl0J3MgYSA8W2NkYXRhWyBjb21tZW50Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnXV0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPCFbJykgPT09IDApIHsgLy8gc29tZSBvdGhlciAhWyBjb21tZW50PyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICddPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhLS0nKSA9PT0gMCkgeyAvLyA8IS0tIGNvbW1lbnQgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnLS0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZigne3shLS0nKSA9PT0gMCkgeyAvLyB7eyEtLSBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICctLX19JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZigne3shJykgPT09IDApIHsgLy8ge3shIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQubGVuZ3RoID09PSA1ICYmIGNvbW1lbnQuaW5kZXhPZigne3shLS0nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPD8nKSA9PT0gMCkgeyAvLyB7eyEgaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnPz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8JScpID09PSAwKSB7IC8vIHt7ISBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICclPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW5NYXRjaGVyKGRlbGltaXRlcikge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gJyc7XG5cbiAgICAgICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VG9rZW4gPSB0b2tlbiArIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gbmV3VG9rZW4ubGVuZ3RoIDw9IGRlbGltaXRlci5sZW5ndGggPyBuZXdUb2tlbiA6IG5ld1Rva2VuLnN1YnN0cihuZXdUb2tlbi5sZW5ndGggLSBkZWxpbWl0ZXIubGVuZ3RoLCBkZWxpbWl0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkb2VzTm90TWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uaW5kZXhPZihkZWxpbWl0ZXIpID09PSAtMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgICAgICAgICAgZG9lc05vdE1hdGNoOiBkb2VzTm90TWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldF91bmZvcm1hdHRlZCA9IGZ1bmN0aW9uKGRlbGltaXRlciwgb3JpZ190YWcpIHsgLy9mdW5jdGlvbiB0byByZXR1cm4gdW5mb3JtYXR0ZWQgY29udGVudCBpbiBpdHMgZW50aXJldHlcbiAgICAgICAgICAgIGlmIChvcmlnX3RhZyAmJiBvcmlnX3RhZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZGVsaW1pdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBkZWxpbWl0ZXJNYXRjaGVyID0gdG9rZW5NYXRjaGVyKGRlbGltaXRlcik7XG5cbiAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJ1xcbicgfHwgaW5wdXRfY2hhciA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiAgRG9uJ3QgY2hhbmdlIHRhYiBpbmRlbnRpb24gZm9yIHVuZm9ybWF0dGVkIGJsb2Nrcy4gIElmIHVzaW5nIGNvZGUgZm9yIGh0bWwgZWRpdGluZywgdGhpcyB3aWxsIGdyZWF0bHkgYWZmZWN0IDxwcmU+IHRhZ3MgaWYgdGhleSBhcmUgc3BlY2lmaWVkIGluIHRoZSAndW5mb3JtYXR0ZWQgYXJyYXknXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5pbmRlbnRfbGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZW50ICs9IHRoaXMuaW5kZW50X3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7IC8vLi4uYW5kIG1ha2Ugc3VyZSBvdGhlciBpbmRlbnRhdGlvbiBpcyBlcmFzZWRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGlucHV0X2NoYXI7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyTWF0Y2hlci5hZGQoaW5wdXRfY2hhcik7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQrKztcbiAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgaW5wdXRfY2hhciA9PT0gJ3snICYmIGNvbnRlbnQubGVuZ3RoICYmIGNvbnRlbnQuY2hhckF0KGNvbnRlbnQubGVuZ3RoIC0gMikgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGViYXJzIGV4cHJlc3Npb25zIGluIHN0cmluZ3Mgc2hvdWxkIGFsc28gYmUgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnNpZGVyIHdoZW4gc3RvcHBpbmcgZm9yIGRlbGltaXRlcnMuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoZGVsaW1pdGVyTWF0Y2hlci5kb2VzTm90TWF0Y2goKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X3Rva2VuID0gZnVuY3Rpb24oKSB7IC8vaW5pdGlhbCBoYW5kbGVyIGZvciB0b2tlbi1yZXRyaWV2YWxcbiAgICAgICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdF90b2tlbiA9PT0gJ1RLX1RBR19TQ1JJUFQnIHx8IHRoaXMubGFzdF90b2tlbiA9PT0gJ1RLX1RBR19TVFlMRScpIHsgLy9jaGVjayBpZiB3ZSBuZWVkIHRvIGZvcm1hdCBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxhc3RfdG9rZW4uc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfY29udGVudHNfdG8odHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuLCAnVEtfJyArIHR5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9tb2RlID09PSAnQ09OVEVOVCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X2NvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlbiwgJ1RLX0NPTlRFTlQnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfbW9kZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3RhZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX25hbWVfdHlwZSA9ICdUS19UQUdfJyArIHRoaXMudGFnX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sIHRhZ19uYW1lX3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9mdWxsX2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHRoaXMuaW5kZW50X2xldmVsICsgbGV2ZWwgfHwgMDtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4odGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzX3VuZm9ybWF0dGVkID0gZnVuY3Rpb24odGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgLy9pcyB0aGlzIGFuIEhUTUw1IGJsb2NrLWxldmVsIGxpbms/XG4gICAgICAgICAgICBpZiAoIXRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWdfY2hlY2sudG9Mb3dlckNhc2UoKSAhPT0gJ2EnIHx8ICF0aGlzLlV0aWxzLmluX2FycmF5KCdhJywgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuICB0YWc7IGlzIGl0cyBmaXJzdCBjaGlsZCBzb21ldGhpbmcgd2Ugd2FudCB0byByZW1haW5cbiAgICAgICAgICAgIC8vdW5mb3JtYXR0ZWQ/XG4gICAgICAgICAgICB2YXIgbmV4dF90YWcgPSB0aGlzLmdldF90YWcodHJ1ZSAvKiBwZWVrLiAqLyApO1xuXG4gICAgICAgICAgICAvLyB0ZXN0IG5leHRfdGFnIHRvIHNlZSBpZiBpdCBpcyBqdXN0IGh0bWwgdGFnIChubyBleHRlcm5hbCBjb250ZW50KVxuICAgICAgICAgICAgdmFyIHRhZyA9IChuZXh0X3RhZyB8fCBcIlwiKS5tYXRjaCgvXlxccyo8XFxzKlxcLz8oW2Etel0qKVxccypbXj5dKj5cXHMqJC8pO1xuXG4gICAgICAgICAgICAvLyBpZiBuZXh0X3RhZyBjb21lcyBiYWNrIGJ1dCBpcyBub3QgYW4gaXNvbGF0ZWQgdGFnLCB0aGVuXG4gICAgICAgICAgICAvLyBsZXQncyB0cmVhdCB0aGUgJ2EnIHRhZyBhcyBoYXZpbmcgY29udGVudFxuICAgICAgICAgICAgLy8gYW5kIHJlc3BlY3QgdGhlIHVuZm9ybWF0dGVkIG9wdGlvblxuICAgICAgICAgICAgaWYgKCF0YWcgfHwgdGhpcy5VdGlscy5pbl9hcnJheSh0YWdbMV0sIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wcmludGVyID0gZnVuY3Rpb24oanNfc291cmNlLCBpbmRlbnRfY2hhcmFjdGVyLCBpbmRlbnRfc2l6ZSwgd3JhcF9saW5lX2xlbmd0aCwgYnJhY2Vfc3R5bGUpIHsgLy9oYW5kbGVzIGlucHV0L291dHB1dCBhbmQgc29tZSBvdGhlciBwcmludGluZyBmdW5jdGlvbnNcblxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGpzX3NvdXJjZSB8fCAnJzsgLy9nZXRzIHRoZSBpbnB1dCBmb3IgdGhlIFBhcnNlclxuXG4gICAgICAgICAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQucmVwbGFjZSgvXFxyXFxufFtcXHJcXHUyMDI4XFx1MjAyOV0vZywgJ1xcbicpO1xuXG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfY2hhcmFjdGVyID0gaW5kZW50X2NoYXJhY3RlcjtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X3N0cmluZyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IGluZGVudF9zaXplO1xuICAgICAgICAgICAgdGhpcy5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gd3JhcF9saW5lX2xlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDsgLy9jb3VudCB0byBzZWUgaWYgd3JhcF9saW5lX2xlbmd0aCB3YXMgZXhjZWVkZWRcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGVudF9zaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9zdHJpbmcgKz0gdGhpcy5pbmRlbnRfY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICghYXJyIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8IChhcnJbYXJyLmxlbmd0aCAtIDFdICE9PSAnXFxuJykpIHsgLy93ZSBtaWdodCB3YW50IHRoZSBleHRyYSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYXJyW2Fyci5sZW5ndGggLSAxXSAhPT0gJ1xcbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdID0gcnRyaW0oYXJyW2Fyci5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24gPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5kZW50X2xldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5pbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgKz0gdGhpcy5pbmRlbnRfc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHByaW50aW5nIGluaXRpYWwgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc193aGl0ZXNwYWNlKHRleHQpICYmICF0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICYmIHRoaXMub3V0cHV0W3RoaXMub3V0cHV0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbih0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbHRyaW0odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF90b2tlbl9yYXcodGV4dCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuX3JhdyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gcHJpbnQgbmV3bGluZXMsIHRydW5jYXRlIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZSwgYXMgdGhlIG5ld2xpbmVzIHdpbGwgcmVwcmVzZW50IHRoZSBzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdsaW5lcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHJ0cmltKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmIHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEgJiYgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZm9ybWF0dGVkIHRhZ3MgY2FuIGdyYWIgbmV3bGluZXMgYXMgdGhlaXIgbGFzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGV4dC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLm5ld2xpbmVzOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKG4gPiAwLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbCsrO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuICAgIHRoaXMuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbXVsdGlfcGFyc2VyID0gbmV3IFBhcnNlcigpOyAvL3dyYXBwaW5nIGZ1bmN0aW9ucyBQYXJzZXJcbiAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50ZXIoaHRtbF9zb3VyY2UsIGluZGVudF9jaGFyYWN0ZXIsIGluZGVudF9zaXplLCB3cmFwX2xpbmVfbGVuZ3RoLCBicmFjZV9zdHlsZSk7IC8vaW5pdGlhbGl6ZSBzdGFydGluZyB2YWx1ZXNcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbXVsdGlfcGFyc2VyLmdldF90b2tlbigpO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnRva2VuX3RleHQgPSB0WzBdO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPSB0WzFdO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19FT0YnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU1RBUlQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobXVsdGlfcGFyc2VyLmluZGVudF9ib2R5X2lubmVyX2h0bWwgfHwgIW11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC88Ym9keSg/Oi4qKT4vKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobXVsdGlfcGFyc2VyLmluZGVudF9oZWFkX2lubmVyX2h0bWwgfHwgIW11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC88aGVhZCg/Oi4qKT4vKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NUWUxFJzpcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU0NSSVBUJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfRU5EJzpcbiAgICAgICAgICAgICAgICAgICAgLy9QcmludCBuZXcgbGluZSBvbmx5IGlmIHRoZSB0YWcgaGFzIG5vIGNvbnRlbnQgYW5kIGhhcyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmxhc3RfdG9rZW4gPT09ICdUS19DT05URU5UJyAmJiBtdWx0aV9wYXJzZXIubGFzdF90ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19uYW1lID0gKG11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC9cXHcrLykgfHwgW10pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXQgPSBtdWx0aV9wYXJzZXIub3V0cHV0W211bHRpX3BhcnNlci5vdXRwdXQubGVuZ3RoIC0gMV0ubWF0Y2goLyg/Ojx8e3sjKVxccyooXFx3KykvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0WzFdICE9PSB0YWdfbmFtZSAmJiAhbXVsdGlfcGFyc2VyLlV0aWxzLmluX2FycmF5KHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dFsxXSwgdW5mb3JtYXR0ZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU0lOR0xFJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBiZWZvcmUgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVtYWluIHVuZm9ybWF0dGVkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX2NoZWNrID0gbXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goL15cXHMqPChbYS16LV0rKS9pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YWdfY2hlY2sgfHwgIW11bHRpX3BhcnNlci5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2tbMV0sIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19IQU5ETEVCQVJTX0VMU0UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGlmIG9wZW5pbmcge3sjaWZ9fSB0YWcgaXMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRJZk9uQ3VycmVudExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSBtdWx0aV9wYXJzZXIub3V0cHV0Lmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0W2xhc3RDaGVja2VkT3V0cHV0XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5vdXRwdXRbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKC97eyNpZi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRJZk9uQ3VycmVudExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfSEFORExFQkFSU19DT01NRU5UJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdUQUcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19DT05URU5UJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdUQUcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19TVFlMRSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfU0NSSVBUJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSA9PT0gJ1RLX1NDUklQVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllciA9IHR5cGVvZiBqc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJyAmJiBqc19iZWF1dGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19TVFlMRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVhdXRpZmllciA9IHR5cGVvZiBjc3NfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicgJiYgY3NzX2JlYXV0aWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJrZWVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IC1tdWx0aV9wYXJzZXIuaW5kZW50X2xldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50YXRpb24gPSBtdWx0aV9wYXJzZXIuZ2V0X2Z1bGxfaW5kZW50KHNjcmlwdF9pbmRlbnRfbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9iZWF1dGlmaWVyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBCZWF1dGlmaWVyIGlmIGF2YWxpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDaGlsZF9vcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW9sID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGlsZF9vcHRpb25zLnByb3RvdHlwZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkX29wdGlvbnMgPSBuZXcgQ2hpbGRfb3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfYmVhdXRpZmllcih0ZXh0LnJlcGxhY2UoL15cXHMqLywgaW5kZW50YXRpb24pLCBjaGlsZF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IGluZGVudCB0aGUgc3RyaW5nIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IHRleHQubWF0Y2goL15cXHMqLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9sZXZlbCA9IHdoaXRlLm1hdGNoKC9bXlxcblxccl0qJC8pWzBdLnNwbGl0KG11bHRpX3BhcnNlci5pbmRlbnRfc3RyaW5nKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWluZGVudCA9IG11bHRpX3BhcnNlci5nZXRfZnVsbF9pbmRlbnQoc2NyaXB0X2luZGVudF9sZXZlbCAtIF9sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccyovLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csICdcXG4nICsgcmVpbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuX3Jhdyh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZSh0cnVlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ1RBRyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgYmUgZ2V0dGluZyBoZXJlIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGRyb3AgaW5wdXQgb24gdGhlIGZsb29yXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3Qgb3V0cHV0IHRoZSB0ZXh0IGFuZCBtb3ZlIG9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIubGFzdF90b2tlbiA9IG11bHRpX3BhcnNlci50b2tlbl90eXBlO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmxhc3RfdGV4dCA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbXVsdGlfcGFyc2VyLm91dHB1dC5qb2luKCcnKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICAvLyBlc3RhYmxpc2ggZW5kX3dpdGhfbmV3bGluZVxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRfY29kZSArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGpzaGludCBjdXJseTogZmFsc2UgKi9cbi8vIFRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbi8vIFdoZXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyIGRlbm90ZXMgYSBuZXdsaW5lLlxuXG5leHBvcnRzLm5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWsgPSBuZXcgUmVnRXhwKCdcXHJcXG58JyArIGV4cG9ydHMubmV3bGluZS5zb3VyY2UpO1xuZXhwb3J0cy5hbGxMaW5lQnJlYWtzID0gbmV3IFJlZ0V4cChleHBvcnRzLmxpbmVCcmVhay5zb3VyY2UsICdnJyk7XG5cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gcGVybWl0ICQgKDM2KSBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2IHx8IGNvZGUgPT09IDY0O1xuICAgIC8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIC8vIHBlcm1pdCBfICg5NSkuXG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIC8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBtZXJnZU9wdHMoYWxsT3B0aW9ucywgdGFyZ2V0VHlwZSkge1xuICAgIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSB0YXJnZXRUeXBlXG4gICAgaWYgKHRhcmdldFR5cGUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBtZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkJlYXV0aWZpZXI7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KTtcbiAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlX2h0bWw7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBzdHlsZV9odG1sID0gbGVnYWN5X2JlYXV0aWZ5X2h0bWw7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiLi9iZWF1dGlmeVwiLCBcIi4vYmVhdXRpZnktY3NzXCJdLCBmdW5jdGlvbihyZXF1aXJlYW1kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnktY3NzXCIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnktY3NzLmpzJyk7XG5cbiAgICBleHBvcnRzLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93Lmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgd2luZG93LmpzX2JlYXV0aWZ5LCB3aW5kb3cuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBnbG9iYWwuanNfYmVhdXRpZnksIGdsb2JhbC5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59XG5cbn0oKSk7XG4iLCIvKmpzaGludCBjdXJseTpmYWxzZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLyogc2VlIGpzL3NyYy9qYXZhc2NyaXB0L2luZGV4LmpzICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuIEpTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgV3JpdHRlbiBieSBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgICAgaHR0cDovL2pzYmVhdXRpZmllci5vcmcvXG5cbiAgT3JpZ2luYWxseSBjb252ZXJ0ZWQgdG8gamF2YXNjcmlwdCBieSBWaXRhbCwgPHZpdGFsNzZAZ21haWwuY29tPlxuICBcIkVuZCBicmFjZXMgb24gb3duIGxpbmVcIiBhZGRlZCBieSBDaHJpcyBKLiBTaHVsbCwgPGNocmlzanNodWxsQGdtYWlsLmNvbT5cbiAgUGFyc2luZyBpbXByb3ZlbWVudHMgZm9yIGJyYWNlLWxlc3Mgc3RhdGVtZW50cyBieSBMaWFtIE5ld21hbiA8Yml0d2lzZW1hbkBnbWFpbC5jb20+XG5cblxuICBVc2FnZTpcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCk7XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICAtIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAgLSBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQsXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rLFxuXG4gICAganNsaW50X2hhcHB5IChkZWZhdWx0IGZhbHNlKSAtIGlmIHRydWUsIHRoZW4ganNsaW50LXN0cmljdGVyIG1vZGUgaXMgZW5mb3JjZWQuXG5cbiAgICAgICAgICAgIGpzbGludF9oYXBweSAgICAgICAgIWpzbGludF9oYXBweVxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSAgICAgICAgIGZ1bmN0aW9uKClcblxuICAgICAgICAgICAgc3dpdGNoICgpIHsgICAgICAgICBzd2l0Y2goKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIH1cblxuICAgIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uJ3MgcGFyZW5zIGJlIGFkZGVkLCBcImZ1bmN0aW9uKClcIiB2cyBcImZ1bmN0aW9uICgpXCIsXG4gICAgICAgICAgTk9URTogVGhpcyBvcHRpb24gaXMgb3ZlcnJpZGVuIGJ5IGpzbGludF9oYXBweSAoaS5lLiBpZiBqc2xpbnRfaGFwcHkgaXMgdHJ1ZSwgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiBpcyB0cnVlIGJ5IGRlc2lnbilcblxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIiB8IGFueSBvZiB0aGUgZm9ybWVyICsgXCIscHJlc2VydmUtaW5saW5lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgICAgICAgICBwcmVzZXJ2ZS1pbmxpbmUgd2lsbCB0cnkgdG8gcHJlc2VydmUgaW5saW5lIGJsb2NrcyBvZiBjdXJseSBicmFjZXNcblxuICAgIHNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCAoZGVmYXVsdCB0cnVlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZSBhZGRlZCwgXCJpZih0cnVlKVwiIHZzIFwiaWYgKHRydWUpXCIsXG5cbiAgICB1bmVzY2FwZV9zdHJpbmdzIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCBwcmludGFibGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzIGVuY29kZWQgaW4gXFx4Tk4gbm90YXRpb24gYmUgdW5lc2NhcGVkLCBcImV4YW1wbGVcIiB2cyBcIlxceDY1XFx4NzhcXHg2MVxceDZkXFx4NzBcXHg2Y1xceDY1XCJcblxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgdW5saW1pdGVkKSAtIGxpbmVzIHNob3VsZCB3cmFwIGF0IG5leHQgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICBOT1RFOiBUaGlzIGlzIG5vdCBhIGhhcmQgbGltaXQuIExpbmVzIHdpbGwgY29udGludWUgdW50aWwgYSBwb2ludCB3aGVyZSBhIG5ld2xpbmUgd291bGRcbiAgICAgICAgICAgICAgICBiZSBwcmVzZXJ2ZWQgaWYgaXQgd2VyZSBwcmVzZW50LlxuXG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZGVmYXVsdCBmYWxzZSkgIC0gZW5kIG91dHB1dCB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICBlLmdcblxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCdcbiAgICB9KTtcblxuKi9cblxuKGZ1bmN0aW9uKCkge1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9qcyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoganNoaW50IGN1cmx5OiBmYWxzZSAqL1xuLy8gVGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBwZXJtaXQgJCAoMzYpIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzYgfHwgY29kZSA9PT0gNjQ7XG4gICAgLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgLy8gcGVybWl0IF8gKDk1KS5cbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbnZhciBtZXJnZU9wdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLm1lcmdlT3B0cztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KS5PdXRwdXQ7XG52YXIgVG9rZW5pemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5Ub2tlbml6ZXI7XG5cbmZ1bmN0aW9uIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBmcmFtZSkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZWZmZWN0aXZlIGJ1dCBoYXMgc29tZSBpc3N1ZXM6XG4gICAgLy8gICAgIC0gY2FuIGNhdXNlIGxpbmUgd3JhcCB0byBoYXBwZW4gdG9vIHNvb24gZHVlIHRvIGluZGVudCByZW1vdmFsXG4gICAgLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4gICAgLy8gVGhlc2UgaXNzdWVzIGFyZSBtaW5vciBjb21wYXJlZCB0byB1Z2x5IGluZGVudGF0aW9uLlxuXG4gICAgaWYgKGZyYW1lLm11bHRpbGluZV9mcmFtZSB8fFxuICAgICAgICBmcmFtZS5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8XG4gICAgICAgIGZyYW1lLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBvbmUgaW5kZW50IGZyb20gZWFjaCBsaW5lIGluc2lkZSB0aGlzIHNlY3Rpb25cbiAgICB2YXIgc3RhcnRfaW5kZXggPSBmcmFtZS5zdGFydF9saW5lX2luZGV4O1xuXG4gICAgb3V0cHV0LnJlbW92ZV9pbmRlbnQoc3RhcnRfaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJyW2ldID09PSB3aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuLy8gZnVuY3Rpb24gcnRyaW0ocykge1xuLy8gICAgIHJldHVybiBzLnJlcGxhY2UoL1xccyskL2csICcnKTtcbi8vIH1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKGxpc3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBsaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIG1hcHBlZCBuYW1lcyB1bmRlcnNjb3JlZCBpbnN0ZWFkIG9mIGRhc2hcbiAgICAgICAgcmVzdWx0W2xpc3RbeF0ucmVwbGFjZSgvLS9nLCAnXycpXSA9IGxpc3RbeF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplT3BlcmF0b3JQb3NpdGlvbihvcFBvc2l0aW9uKSB7XG4gICAgb3BQb3NpdGlvbiA9IG9wUG9zaXRpb24gfHwgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU7XG5cbiAgICBpZiAoIWluX2FycmF5KG9wUG9zaXRpb24sIHZhbGlkUG9zaXRpb25WYWx1ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdvcGVyYXRvcl9wb3NpdGlvbicgbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXNcXG5cIiArXG4gICAgICAgICAgICB2YWxpZFBvc2l0aW9uVmFsdWVzICtcbiAgICAgICAgICAgIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgb3BQb3NpdGlvbiArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BQb3NpdGlvbjtcbn1cblxudmFyIHZhbGlkUG9zaXRpb25WYWx1ZXMgPSBbJ2JlZm9yZS1uZXdsaW5lJywgJ2FmdGVyLW5ld2xpbmUnLCAncHJlc2VydmUtbmV3bGluZSddO1xuXG4vLyBHZW5lcmF0ZSBtYXAgZnJvbSBhcnJheVxudmFyIE9QRVJBVE9SX1BPU0lUSU9OID0gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyh2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxudmFyIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSA9IFtPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZSwgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZV07XG5cbnZhciBNT0RFID0ge1xuICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLCAvLyAnQkxPQ0snXG4gICAgU3RhdGVtZW50OiAnU3RhdGVtZW50JywgLy8gJ1NUQVRFTUVOVCdcbiAgICBPYmplY3RMaXRlcmFsOiAnT2JqZWN0TGl0ZXJhbCcsIC8vICdPQkpFQ1QnLFxuICAgIEFycmF5TGl0ZXJhbDogJ0FycmF5TGl0ZXJhbCcsIC8vJ1tFWFBSRVNTSU9OXScsXG4gICAgRm9ySW5pdGlhbGl6ZXI6ICdGb3JJbml0aWFsaXplcicsIC8vJyhGT1ItRVhQUkVTU0lPTiknLFxuICAgIENvbmRpdGlvbmFsOiAnQ29uZGl0aW9uYWwnLCAvLycoQ09ORC1FWFBSRVNTSU9OKScsXG4gICAgRXhwcmVzc2lvbjogJ0V4cHJlc3Npb24nIC8vJyhFWFBSRVNTSU9OKSdcbn07XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgb3V0cHV0O1xuICAgIHZhciB0b2tlbnMgPSBbXSxcbiAgICAgICAgdG9rZW5fcG9zO1xuICAgIHZhciB0b2tlbml6ZXI7XG4gICAgdmFyIGN1cnJlbnRfdG9rZW47XG4gICAgdmFyIGxhc3RfdHlwZSwgbGFzdF9sYXN0X3RleHQsIGluZGVudF9zdHJpbmc7XG4gICAgdmFyIGZsYWdzLCBwcmV2aW91c19mbGFncywgZmxhZ19zdG9yZTtcbiAgICB2YXIgcHJlZml4O1xuXG4gICAgdmFyIGhhbmRsZXJzLCBvcHQ7XG4gICAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSAnJztcblxuICAgIGhhbmRsZXJzID0ge1xuICAgICAgICAnVEtfU1RBUlRfRVhQUic6IGhhbmRsZV9zdGFydF9leHByLFxuICAgICAgICAnVEtfRU5EX0VYUFInOiBoYW5kbGVfZW5kX2V4cHIsXG4gICAgICAgICdUS19TVEFSVF9CTE9DSyc6IGhhbmRsZV9zdGFydF9ibG9jayxcbiAgICAgICAgJ1RLX0VORF9CTE9DSyc6IGhhbmRsZV9lbmRfYmxvY2ssXG4gICAgICAgICdUS19XT1JEJzogaGFuZGxlX3dvcmQsXG4gICAgICAgICdUS19SRVNFUlZFRCc6IGhhbmRsZV93b3JkLFxuICAgICAgICAnVEtfU0VNSUNPTE9OJzogaGFuZGxlX3NlbWljb2xvbixcbiAgICAgICAgJ1RLX1NUUklORyc6IGhhbmRsZV9zdHJpbmcsXG4gICAgICAgICdUS19FUVVBTFMnOiBoYW5kbGVfZXF1YWxzLFxuICAgICAgICAnVEtfT1BFUkFUT1InOiBoYW5kbGVfb3BlcmF0b3IsXG4gICAgICAgICdUS19DT01NQSc6IGhhbmRsZV9jb21tYSxcbiAgICAgICAgJ1RLX0JMT0NLX0NPTU1FTlQnOiBoYW5kbGVfYmxvY2tfY29tbWVudCxcbiAgICAgICAgJ1RLX0NPTU1FTlQnOiBoYW5kbGVfY29tbWVudCxcbiAgICAgICAgJ1RLX0RPVCc6IGhhbmRsZV9kb3QsXG4gICAgICAgICdUS19VTktOT1dOJzogaGFuZGxlX3Vua25vd24sXG4gICAgICAgICdUS19FT0YnOiBoYW5kbGVfZW9mXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9mbGFncyhmbGFnc19iYXNlLCBtb2RlKSB7XG4gICAgICAgIHZhciBuZXh0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgICAgIGlmIChmbGFnc19iYXNlKSB7XG4gICAgICAgICAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoIW91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgPiBuZXh0X2luZGVudF9sZXZlbCkge1xuICAgICAgICAgICAgICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0X2ZsYWdzID0ge1xuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIHBhcmVudDogZmxhZ3NfYmFzZSxcbiAgICAgICAgICAgIGxhc3RfdGV4dDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF90ZXh0IDogJycsIC8vIGxhc3QgdG9rZW4gdGV4dFxuICAgICAgICAgICAgbGFzdF93b3JkOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3dvcmQgOiAnJywgLy8gbGFzdCAnVEtfV09SRCcgcGFzc2VkXG4gICAgICAgICAgICBkZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25fYXNzaWdubWVudDogZmFsc2UsXG4gICAgICAgICAgICBtdWx0aWxpbmVfZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgaW5saW5lX2ZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGlmX2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGVsc2VfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZG9fYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZG9fd2hpbGU6IGZhbHNlLFxuICAgICAgICAgICAgaW1wb3J0X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGluX2Nhc2Vfc3RhdGVtZW50OiBmYWxzZSwgLy8gc3dpdGNoKC4uKXsgSU5TSURFIEhFUkUgfVxuICAgICAgICAgICAgaW5fY2FzZTogZmFsc2UsIC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbiAgICAgICAgICAgIGNhc2VfYm9keTogZmFsc2UsIC8vIHRoZSBpbmRlbnRlZCBjYXNlLWFjdGlvbiBibG9ja1xuICAgICAgICAgICAgaW5kZW50YXRpb25fbGV2ZWw6IG5leHRfaW5kZW50X2xldmVsLFxuICAgICAgICAgICAgbGluZV9pbmRlbnRfbGV2ZWw6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsIDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgICAgICAgICBzdGFydF9saW5lX2luZGV4OiBvdXRwdXQuZ2V0X2xpbmVfbnVtYmVyKCksXG4gICAgICAgICAgICB0ZXJuYXJ5X2RlcHRoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXh0X2ZsYWdzO1xuICAgIH1cblxuICAgIC8vIFNvbWUgaW50ZXJwcmV0ZXJzIGhhdmUgdW5leHBlY3RlZCByZXN1bHRzIHdpdGggZm9vID0gYmF6IHx8IGJhcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gICAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0cyhvcHRpb25zLCAnanMnKTtcblxuICAgIG9wdCA9IHt9O1xuXG4gICAgLy8gY29tcGF0aWJpbGl0eSwgcmVcbiAgICBpZiAob3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmQtc3RyaWN0XCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJleHBhbmRcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZSxwcmVzZXJ2ZS1pbmxpbmVcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYnJhY2VzX29uX293bl9saW5lICE9PSB1bmRlZmluZWQpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gb3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgPyBcImV4cGFuZFwiIDogXCJjb2xsYXBzZVwiO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuYnJhY2Vfc3R5bGUpIC8vTm90aGluZyBleGlzdHMgdG8gc2V0IGl0XG4gICAge1xuICAgICAgICBvcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZVwiO1xuICAgIH1cblxuXG4gICAgdmFyIGJyYWNlX3N0eWxlX3NwbGl0ID0gb3B0aW9ucy5icmFjZV9zdHlsZS5zcGxpdCgvW15hLXpBLVowLTlfXFwtXSsvKTtcbiAgICBvcHQuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFswXTtcbiAgICBvcHQuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gYnJhY2Vfc3R5bGVfc3BsaXRbMV0gPyBicmFjZV9zdHlsZV9zcGxpdFsxXSA6IGZhbHNlO1xuXG4gICAgb3B0LmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZSA/IHBhcnNlSW50KG9wdGlvbnMuaW5kZW50X3NpemUsIDEwKSA6IDQ7XG4gICAgb3B0LmluZGVudF9jaGFyID0gb3B0aW9ucy5pbmRlbnRfY2hhciA/IG9wdGlvbnMuaW5kZW50X2NoYXIgOiAnICc7XG4gICAgb3B0LmVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnYXV0byc7XG4gICAgb3B0LnByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICBvcHQudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID0gKG9wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcztcbiAgICBvcHQuYnJlYWtfY2hhaW5lZF9tZXRob2RzID0gKG9wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcztcbiAgICBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gKG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gMCA6IHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCk7XG4gICAgb3B0LnNwYWNlX2luX3BhcmVuID0gKG9wdGlvbnMuc3BhY2VfaW5fcGFyZW4gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfaW5fcGFyZW47XG4gICAgb3B0LnNwYWNlX2luX2VtcHR5X3BhcmVuID0gKG9wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW4gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW47XG4gICAgb3B0LmpzbGludF9oYXBweSA9IChvcHRpb25zLmpzbGludF9oYXBweSA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5qc2xpbnRfaGFwcHk7XG4gICAgb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSAob3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb247XG4gICAgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSAob3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb247XG4gICAgb3B0LnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9IChvcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbDtcbiAgICBvcHQudW5lc2NhcGVfc3RyaW5ncyA9IChvcHRpb25zLnVuZXNjYXBlX3N0cmluZ3MgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMudW5lc2NhcGVfc3RyaW5ncztcbiAgICBvcHQud3JhcF9saW5lX2xlbmd0aCA9IChvcHRpb25zLndyYXBfbGluZV9sZW5ndGggPT09IHVuZGVmaW5lZCkgPyAwIDogcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCk7XG4gICAgb3B0LmU0eCA9IChvcHRpb25zLmU0eCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5lNHg7XG4gICAgb3B0LmVuZF93aXRoX25ld2xpbmUgPSAob3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gICAgb3B0LmNvbW1hX2ZpcnN0ID0gKG9wdGlvbnMuY29tbWFfZmlyc3QgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuY29tbWFfZmlyc3Q7XG4gICAgb3B0Lm9wZXJhdG9yX3Bvc2l0aW9uID0gc2FuaXRpemVPcGVyYXRvclBvc2l0aW9uKG9wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24pO1xuXG4gICAgLy8gRm9yIHRlc3Rpbmcgb2YgYmVhdXRpZnkgaWdub3JlOnN0YXJ0IGRpcmVjdGl2ZVxuICAgIG9wdC50ZXN0X291dHB1dF9yYXcgPSAob3B0aW9ucy50ZXN0X291dHB1dF9yYXcgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMudGVzdF9vdXRwdXRfcmF3O1xuXG4gICAgLy8gZm9yY2Ugb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gdG8gdHJ1ZSBpZiBvcHQuanNsaW50X2hhcHB5XG4gICAgaWYgKG9wdC5qc2xpbnRfaGFwcHkpIHtcbiAgICAgICAgb3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICAgICAgb3B0LmluZGVudF9jaGFyID0gJ1xcdCc7XG4gICAgICAgIG9wdC5pbmRlbnRfc2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG9wdC5lb2wgPT09ICdhdXRvJykge1xuICAgICAgICBvcHQuZW9sID0gJ1xcbic7XG4gICAgICAgIGlmIChqc19zb3VyY2VfdGV4dCAmJiBhY29ybi5saW5lQnJlYWsudGVzdChqc19zb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgICAgICAgIG9wdC5lb2wgPSBqc19zb3VyY2VfdGV4dC5tYXRjaChhY29ybi5saW5lQnJlYWspWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3B0LmVvbCA9IG9wdC5lb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbmRlbnRfc3RyaW5nID0gJyc7XG4gICAgd2hpbGUgKG9wdC5pbmRlbnRfc2l6ZSA+IDApIHtcbiAgICAgICAgaW5kZW50X3N0cmluZyArPSBvcHQuaW5kZW50X2NoYXI7XG4gICAgICAgIG9wdC5pbmRlbnRfc2l6ZSAtPSAxO1xuICAgIH1cblxuICAgIHZhciBwcmVpbmRlbnRfaW5kZXggPSAwO1xuICAgIGlmIChqc19zb3VyY2VfdGV4dCAmJiBqc19zb3VyY2VfdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKChqc19zb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJyAnIHx8XG4gICAgICAgICAgICAgICAganNfc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCkgPT09ICdcXHQnKSkge1xuICAgICAgICAgICAgcHJlaW5kZW50X2luZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZUluZGVudFN0cmluZyA9IGpzX3NvdXJjZV90ZXh0LnN1YnN0cmluZygwLCBwcmVpbmRlbnRfaW5kZXgpO1xuICAgICAgICBqc19zb3VyY2VfdGV4dCA9IGpzX3NvdXJjZV90ZXh0LnN1YnN0cmluZyhwcmVpbmRlbnRfaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RfdHlwZSA9ICdUS19TVEFSVF9CTE9DSyc7IC8vIGxhc3QgdG9rZW4gdHlwZVxuICAgIGxhc3RfbGFzdF90ZXh0ID0gJyc7IC8vIHByZS1sYXN0IHRva2VuIHRleHRcbiAgICBvdXRwdXQgPSBuZXcgT3V0cHV0KGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgLy8gSWYgdGVzdGluZyB0aGUgaWdub3JlIGRpcmVjdGl2ZSwgc3RhcnQgd2l0aCBvdXRwdXQgZGlzYWJsZSBzZXQgdG8gdHJ1ZVxuICAgIG91dHB1dC5yYXcgPSBvcHQudGVzdF9vdXRwdXRfcmF3O1xuXG5cbiAgICAvLyBTdGFjayBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgc3RhdGVzLCBpbmNsdWRpbmcgTU9ERS5cbiAgICAvLyBXZSB0b2tlbml6ZSwgcGFyc2UsIGFuZCBvdXRwdXQgaW4gYW4gYWxtb3N0IHB1cmVseSBhIGZvcndhcmQtb25seSBzdHJlYW0gb2YgdG9rZW4gaW5wdXRcbiAgICAvLyBhbmQgZm9ybWF0dGVkIG91dHB1dC4gIFRoaXMgbWFrZXMgdGhlIGJlYXV0aWZpZXIgbGVzcyBhY2N1cmF0ZSB0aGFuIGZ1bGwgcGFyc2Vyc1xuICAgIC8vIGJ1dCBhbHNvIGZhciBtb3JlIHRvbGVyYW50IG9mIHN5bnRheCBlcnJvcnMuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIGRlZmF1bHQgbW9kZSBpcyBNT0RFLkJsb2NrU3RhdGVtZW50LiBJZiB3ZSBzZWUgYSAneycgd2UgcHVzaCBhIG5ldyBmcmFtZSBvZiB0eXBlXG4gICAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBvbiB0aGUgdGhlIHN0YWNrLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSBvYmplY3QgbGl0ZXJhbC4gIElmIHdlIGxhdGVyXG4gICAgLy8gZW5jb3VudGVyIGEgXCI6XCIsIHdlJ2xsIHN3aXRjaCB0byB0byBNT0RFLk9iamVjdExpdGVyYWwuICBJZiB3ZSB0aGVuIHNlZSBhIFwiO1wiLFxuICAgIC8vIG1vc3QgZnVsbCBwYXJzZXJzIHdvdWxkIGRpZSwgYnV0IHRoZSBiZWF1dGlmaWVyIGdyYWNlZnVsbHkgZmFsbHMgYmFjayB0b1xuICAgIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgYW5kIGNvbnRpbnVlcyBvbi5cbiAgICBmbGFnX3N0b3JlID0gW107XG4gICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG5cbiAgICB0aGlzLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLypqc2hpbnQgb25ldmFyOnRydWUgKi9cbiAgICAgICAgdmFyIHN3ZWV0X2NvZGU7XG4gICAgICAgIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoanNfc291cmNlX3RleHQsIG9wdCwgaW5kZW50X3N0cmluZyk7XG4gICAgICAgIHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuICAgICAgICB0b2tlbl9wb3MgPSAwO1xuXG4gICAgICAgIGN1cnJlbnRfdG9rZW4gPSBnZXRfdG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRfdG9rZW4pIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2N1cnJlbnRfdG9rZW4udHlwZV0oKTtcblxuICAgICAgICAgICAgbGFzdF9sYXN0X3RleHQgPSBmbGFncy5sYXN0X3RleHQ7XG4gICAgICAgICAgICBsYXN0X3R5cGUgPSBjdXJyZW50X3Rva2VuLnR5cGU7XG4gICAgICAgICAgICBmbGFncy5sYXN0X3RleHQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgICAgICAgICAgIHRva2VuX3BvcyArPSAxO1xuICAgICAgICAgICAgY3VycmVudF90b2tlbiA9IGdldF90b2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dlZXRfY29kZSA9IG91dHB1dC5nZXRfY29kZShvcHQuZW5kX3dpdGhfbmV3bGluZSwgb3B0LmVvbCk7XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhsb2NhbF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIHZhciBuZXdsaW5lcyA9IGxvY2FsX3Rva2VuLm5ld2xpbmVzO1xuICAgICAgICB2YXIga2VlcF93aGl0ZXNwYWNlID0gb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSk7XG4gICAgICAgIHZhciB0ZW1wX3Rva2VuID0gY3VycmVudF90b2tlbjtcblxuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGxvY2FsX3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgICAgLy8gVGhlIGNsZWFuZXN0IGhhbmRsaW5nIG9mIGlubGluZSBjb21tZW50cyBpcyB0byB0cmVhdCB0aGVtIGFzIHRob3VnaCB0aGV5IGFyZW4ndCB0aGVyZS5cbiAgICAgICAgICAgIC8vIEp1c3QgY29udGludWUgZm9ybWF0dGluZyBhbmQgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsb2dpY2FsLlxuICAgICAgICAgICAgLy8gQWxzbyBpZ25vcmUgdW5rbm93biB0b2tlbnMuICBBZ2FpbiwgdGhpcyBzaG91bGQgcmVzdWx0IGluIGJldHRlciBiZWhhdmlvci5cbiAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4gPSBsb2NhbF90b2tlbi5jb21tZW50c19iZWZvcmVbaF07XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2N1cnJlbnRfdG9rZW4udHlwZV0ocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50X3Rva2VuID0gdGVtcF90b2tlbjtcblxuICAgICAgICBpZiAoa2VlcF93aGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld2xpbmVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGkgPiAwLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMgJiYgbmV3bGluZXMgPiBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZXMgPSBvcHQubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0LnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsX3Rva2VuLm5ld2xpbmVzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IG5ld2xpbmVzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUodHJ1ZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gd2UgY291bGQgdXNlIGp1c3Qgc3RyaW5nLnNwbGl0LCBidXRcbiAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBzcGxpdF9saW5lYnJlYWtzKHMpIHtcbiAgICAgICAgLy9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xuXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgICAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIHdoaWxlIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICBvdXQucHVzaChzLnN1YnN0cmluZygwLCBpZHgpKTtcbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICAgICAgICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMgPSBbJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ3JldHVybicsICd0aHJvdycsICd5aWVsZCddO1xuXG4gICAgZnVuY3Rpb24gYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShmb3JjZV9saW5ld3JhcCkge1xuICAgICAgICBmb3JjZV9saW5ld3JhcCA9IChmb3JjZV9saW5ld3JhcCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZm9yY2VfbGluZXdyYXA7XG5cbiAgICAgICAgLy8gTmV2ZXIgd3JhcCB0aGUgZmlyc3QgdG9rZW4gb24gYSBsaW5lXG4gICAgICAgIGlmIChvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSAob3B0LnByZXNlcnZlX25ld2xpbmVzICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHx8IGZvcmNlX2xpbmV3cmFwO1xuICAgICAgICB2YXIgb3BlcmF0b3JMb2dpY0FwcGxpZXMgPSBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKSB8fCBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcblxuICAgICAgICBpZiAob3BlcmF0b3JMb2dpY0FwcGxpZXMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZSA9IChcbiAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycykgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkob3B0Lm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpXG4gICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xuICAgICAgICAgICAgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gc2hvdWxkUHJlc2VydmVPckZvcmNlICYmIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFByZXNlcnZlT3JGb3JjZSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHRva2VucyBzaG91bGQgbmV2ZXIgaGF2ZSBhIG5ld2xpbmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHRoZW0gYW5kIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcG9zZWRfbGluZV9sZW5ndGggPSBvdXRwdXQuY3VycmVudF9saW5lLmdldF9jaGFyYWN0ZXJfY291bnQoKSArIGN1cnJlbnRfdG9rZW4udGV4dC5sZW5ndGggK1xuICAgICAgICAgICAgICAgIChvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHByb3Bvc2VkX2xpbmVfbGVuZ3RoID49IG9wdC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF9uZXdsaW5lKGZvcmNlX25ld2xpbmUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAoIXByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCAhPT0gJzsnICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJywnICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJz0nICYmIGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGZsYWdzLmlmX2Jsb2NrICYmIG5leHRfdG9rZW4gJiYgbmV4dF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZG9fYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2VfbmV3bGluZSkpIHtcbiAgICAgICAgICAgIGZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKCkge1xuICAgICAgICBpZiAob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAob3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5jdXJyZW50X2xpbmUucHVzaChjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC5zZXRfaW5kZW50KGZsYWdzLmluZGVudGF0aW9uX2xldmVsKSkge1xuICAgICAgICAgICAgICAgIGZsYWdzLmxpbmVfaW5kZW50X2xldmVsID0gZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludF90b2tlbihwcmludGFibGVfdG9rZW4pIHtcbiAgICAgICAgaWYgKG91dHB1dC5yYXcpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdC5jb21tYV9maXJzdCAmJiBsYXN0X3R5cGUgPT09ICdUS19DT01NQScgJiZcbiAgICAgICAgICAgIG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHBlZCA9IG91dHB1dC5wcmV2aW91c19saW5lLnBvcCgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb21tYSB3YXMgYWxyZWFkeSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmV2aW91c19saW5lLnB1c2gocG9wcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5jdXJyZW50X2xpbmUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX3Rva2VuKCcsJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmludGFibGVfdG9rZW4gPSBwcmludGFibGVfdG9rZW4gfHwgY3VycmVudF90b2tlbi50ZXh0O1xuICAgICAgICBwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKCk7XG4gICAgICAgIG91dHB1dC5hZGRfdG9rZW4ocHJpbnRhYmxlX3Rva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgICAgIGZsYWdzLmluZGVudGF0aW9uX2xldmVsICs9IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVpbmRlbnQoKSB7XG4gICAgICAgIGlmIChmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IDAgJiZcbiAgICAgICAgICAgICgoIWZsYWdzLnBhcmVudCkgfHwgZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiBmbGFncy5wYXJlbnQuaW5kZW50YXRpb25fbGV2ZWwpKSB7XG4gICAgICAgICAgICBmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCAtPSAxO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRfbW9kZShtb2RlKSB7XG4gICAgICAgIGlmIChmbGFncykge1xuICAgICAgICAgICAgZmxhZ19zdG9yZS5wdXNoKGZsYWdzKTtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncyA9IGNyZWF0ZV9mbGFncyhudWxsLCBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWdzID0gY3JlYXRlX2ZsYWdzKHByZXZpb3VzX2ZsYWdzLCBtb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19hcnJheShtb2RlKSB7XG4gICAgICAgIHJldHVybiBtb2RlID09PSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19leHByZXNzaW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGluX2FycmF5KG1vZGUsIFtNT0RFLkV4cHJlc3Npb24sIE1PREUuRm9ySW5pdGlhbGl6ZXIsIE1PREUuQ29uZGl0aW9uYWxdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN0b3JlX21vZGUoKSB7XG4gICAgICAgIGlmIChmbGFnX3N0b3JlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBmbGFncyA9IGZsYWdfc3RvcmUucG9wKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgIW9wdC51bmluZGVudF9jaGFpbmVkX21ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKG91dHB1dCwgcHJldmlvdXNfZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiAoXG4gICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnOicgJiYgZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZ2V0JywgJ3NldCddKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0X29mX3N0YXRlbWVudCgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19XT1JEJykgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZG8nKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpICYmICFjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdlbHNlJyAmJlxuICAgICAgICAgICAgICAgICEoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJyAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoKSkgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUicgJiYgKHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHwgcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfV09SRCcgJiYgZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbl9jYXNlICYmXG4gICAgICAgICAgICAgICAgIShjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSAmJlxuICAgICAgICAgICAgICAgIGxhc3RfbGFzdF90ZXh0ICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbi50eXBlICE9PSAnVEtfV09SRCcgJiYgY3VycmVudF90b2tlbi50eXBlICE9PSAnVEtfUkVTRVJWRUQnKSB8fFxuICAgICAgICAgICAgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiAoXG4gICAgICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzonICYmIGZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHx8IChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2dldCcsICdzZXQnXSkpKSlcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuU3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmICghb3B0LnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIElzc3VlICMyNzY6XG4gICAgICAgICAgICAvLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuICAgICAgICAgICAgLy8gaWYgKGEpIGlmIChiKSBpZihjKSBkKCk7IGVsc2UgZSgpOyBlbHNlIGYoKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2RvJywgJ2ZvcicsICdpZicsICd3aGlsZSddKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRyaW0obGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KDApICE9PSBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgaW5kZW50KSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGxpbmU7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIC8vIGFsbG93IGVtcHR5IGxpbmVzIHRvIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgaWYgKGxpbmUgJiYgbGluZS5pbmRleE9mKGluZGVudCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfc3BlY2lhbF93b3JkKHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIGluX2FycmF5KHdvcmQsIFsnY2FzZScsICdyZXR1cm4nLCAnZG8nLCAnaWYnLCAndGhyb3cnLCAnZWxzZSddKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfdG9rZW4ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRva2VuX3BvcyArIChvZmZzZXQgfHwgMCk7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRva2Vucy5sZW5ndGgpID8gbnVsbCA6IHRva2Vuc1tpbmRleF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3N0YXJ0X2V4cHIoKSB7XG4gICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgaWYgKCFzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRfbW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snKSB7XG5cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19XT1JEJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIC8vIGFbeF0sIGZuKClbeF1cbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRfbW9kZShuZXh0X21vZGUpO1xuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICAgICAgICAgIGlmIChpc19hcnJheShmbGFncy5tb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncy5sYXN0X3RleHQgPT09ICdbJyB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnLCcgJiYgKGxhc3RfbGFzdF90ZXh0ID09PSAnXScgfHwgbGFzdF9sYXN0X3RleHQgPT09ICd9JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyB9LCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkZvckluaXRpYWxpemVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2lmJywgJ3doaWxlJ10pKSB7XG4gICAgICAgICAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5Db25kaXRpb25hbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzsnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19FTkRfQkxPQ0snIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciB3aGV0aGVyIGZvcmNpbmcgdGhpcyBpcyByZXF1aXJlZC4gIFJldmlldyBmYWlsaW5nIHRlc3RzIHdoZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSk7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nIG9uICgoIGFuZCApKCBhbmQgXVsgYW5kIF0oIGFuZCAuKFxuICAgICAgICB9IGVsc2UgaWYgKCEobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJygnKSAmJiBsYXN0X3R5cGUgIT09ICdUS19XT1JEJyAmJiBsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKGZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyB8fCBmbGFncy5sYXN0X3dvcmQgPT09ICd0eXBlb2YnKSkgfHxcbiAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24oKSB2cyBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgLy8geWllbGQqKCkgdnMgeWllbGQqICgpXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiooKSB2cyBmdW5jdGlvbiogKClcbiAgICAgICAgICAgIGlmIChvcHQuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiAoaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaWYgKG9wdC5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBiZSBhIHNwYWNlIGJldHdlZW4gYXdhaXQgYW5kIGFuIElJRkUsIG9yIGFzeW5jIGFuZCBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKCcgJiYgbGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3Rfd29yZCwgWydhd2FpdCcsICdhc3luYyddKSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0IG9mIHRoaXMga2luZCBvZiBuZXdsaW5lIHByZXNlcnZhdGlvbi5cbiAgICAgICAgLy8gYSA9IChiICYmXG4gICAgICAgIC8vICAgICAoYyB8fCBkKSk7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydCBwcmVzZXJ2aW5nIHdyYXBwZWQgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbnNcbiAgICAgICAgLy8gYS5iKCdjJyxcbiAgICAgICAgLy8gICAgICgpID0+IGQuZVxuICAgICAgICAvLyApXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJyAmJiBsYXN0X3R5cGUgIT09ICdUS19XT1JEJyAmJiBsYXN0X3R5cGUgIT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldF9tb2RlKG5leHRfbW9kZSk7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIGlmIChvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gYWxsIGNhc2VzLCBpZiB3ZSBuZXdsaW5lIHdoaWxlIGluc2lkZSBhbiBleHByZXNzaW9uIGl0IHNob3VsZCBiZSBpbmRlbnRlZC5cbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VuZF9leHByKCkge1xuICAgICAgICAvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4gICAgICAgIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIGlmIChmbGFncy5tdWx0aWxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgIW9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyAmJiAhb3B0LnNwYWNlX2luX2VtcHR5X3BhcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gKCkgW10gbm8gaW5uZXIgc3BhY2UgaW4gZW1wdHkgcGFyZW5zIGxpa2UgdGhlc2UsIGV2ZXIsIHJlZiAjMzIwXG4gICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBwcmV2aW91c19mbGFncyk7XG5cbiAgICAgICAgLy8gZG8ge30gd2hpbGUgKCkgLy8gbm8gc3RhdGVtZW50IHJlcXVpcmVkIGFmdGVyXG4gICAgICAgIGlmIChmbGFncy5kb193aGlsZSAmJiBwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICBwcmV2aW91c19mbGFncy5tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgICAgICAgICAgZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGZsYWdzLmRvX3doaWxlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zdGFydF9ibG9jaygpIHtcbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBPYmplY3RMaXRlcmFsXG4gICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICB2YXIgc2Vjb25kX3Rva2VuID0gZ2V0X3Rva2VuKDIpO1xuICAgICAgICBpZiAoc2Vjb25kX3Rva2VuICYmIChcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgWydUS19TVFJJTkcnLCAnVEtfV09SRCcsICdUS19SRVNFUlZFRCddKSkgfHxcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobmV4dF90b2tlbi50ZXh0LCBbJ2dldCcsICdzZXQnLCAnLi4uJ10pICYmIGluX2FycmF5KHNlY29uZF90b2tlbi50eXBlLCBbJ1RLX1dPUkQnLCAnVEtfUkVTRVJWRUQnXSkpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAgICAgICAgIC8vIFdlJ2xsIHRyeSB0byBrZWVwIG5vdCBicmVha2luZyBpdC5cbiAgICAgICAgICAgIGlmICghaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsnY2xhc3MnLCAnaW50ZXJmYWNlJ10pKSB7XG4gICAgICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJz0+Jykge1xuICAgICAgICAgICAgLy8gYXJyb3cgZnVuY3Rpb246IChwYXJhbTEsIHBhcmFtTikgPT4geyBzdGF0ZW1lbnRzIH1cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19FUVVBTFMnLCAnVEtfU1RBUlRfRVhQUicsICdUS19DT01NQScsICdUS19PUEVSQVRPUiddKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsncmV0dXJuJywgJ3Rocm93JywgJ2ltcG9ydCcsICdkZWZhdWx0J10pKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIERldGVjdGluZyBzaG9ydGhhbmQgZnVuY3Rpb24gc3ludGF4IGlzIGRpZmZpY3VsdCBieSBzY2FubmluZyBmb3J3YXJkLFxuICAgICAgICAgICAgLy8gICAgIHNvIGNoZWNrIHRoZSBzdXJyb3VuZGluZyBjb250ZXh0LlxuICAgICAgICAgICAgLy8gSWYgdGhlIGJsb2NrIGlzIGJlaW5nIHJldHVybmVkLCBpbXBvcnRlZCwgZXhwb3J0IGRlZmF1bHQsIHBhc3NlZCBhcyBhcmcsXG4gICAgICAgICAgICAvLyAgICAgYXNzaWduZWQgd2l0aCA9IG9yIGFzc2lnbmVkIGluIGEgbmVzdGVkIG9iamVjdCwgdHJlYXQgYXMgYW4gT2JqZWN0TGl0ZXJhbC5cbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbXB0eV9icmFjZXMgPSAhbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ30nO1xuICAgICAgICB2YXIgZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uID0gZW1wdHlfYnJhY2VzICYmIGZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgbGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInO1xuXG4gICAgICAgIGlmIChvcHQuYnJhY2VfcHJlc2VydmVfaW5saW5lKSAvLyBjaGVjayBmb3IgaW5saW5lLCBzZXQgaW5saW5lX2ZyYW1lIGlmIHNvXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBhIG5ld2xpbmUgd2FudGVkIGluc2lkZSB0aGlzIGJsb2NrXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGNoZWNrX3Rva2VuID0gbnVsbDtcbiAgICAgICAgICAgIGZsYWdzLmlubGluZV9mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBjaGVja190b2tlbiA9IGdldF90b2tlbihpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrX3Rva2VuLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmlubGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChjaGVja190b2tlbi50eXBlICE9PSAnVEtfRU9GJyAmJlxuICAgICAgICAgICAgICAgICEoY2hlY2tfdG9rZW4udHlwZSA9PT0gJ1RLX0VORF9CTE9DSycgJiYgY2hlY2tfdG9rZW4ub3BlbmVkID09PSBjdXJyZW50X3Rva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpKSAmJlxuICAgICAgICAgICAgIWZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJyAmJlxuICAgICAgICAgICAgICAgIChlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF90eXBlID09PSAnVEtfRVFVQUxTJyB8fFxuICAgICAgICAgICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJ2Vsc2UnKSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGNvbGxhcHNlIHx8IGlubGluZV9mcmFtZVxuICAgICAgICAgICAgaWYgKGlzX2FycmF5KHByZXZpb3VzX2ZsYWdzLm1vZGUpICYmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19DT01NQScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCBvcHQuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgJiYgZmxhZ3MuaW5saW5lX2ZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSB8fCBmbGFncy5tdWx0aWxpbmVfZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm11bHRpbGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicgJiYgbGFzdF90eXBlICE9PSAnVEtfU1RBUlRfRVhQUicpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snICYmICFmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZW5kX2Jsb2NrKCkge1xuICAgICAgICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW1wdHlfYnJhY2VzID0gbGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUgJiYgIWVtcHR5X2JyYWNlcykgeyAvLyB0cnkgaW5saW5lX2ZyYW1lIChvbmx5IHNldCBpZiBvcHQuYnJhY2VzLXByZXNlcnZlLWlubGluZSkgZmlyc3RcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgICAgICAgICAgaWYgKCFlbXB0eV9icmFjZXMpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBza2lwIHt9XG4gICAgICAgICAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc19hcnJheShmbGFncy5tb2RlKSAmJiBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBSRUFMTFkgbmVlZCBhIG5ld2xpbmUgaGVyZSwgYnV0IG5ld2xpbmVyIHdvdWxkIHNraXAgdGhhdFxuICAgICAgICAgICAgICAgICAgICBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3dvcmQoKSB7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnc2V0JywgJ2dldCddKSAmJiBmbGFncy5tb2RlICE9PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydhcycsICdmcm9tJ10pICYmICFmbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSAnVEtfV09SRCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1dPUkQnKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lICYmICFpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpICYmXG4gICAgICAgICAgICAobGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InIHx8IChmbGFncy5sYXN0X3RleHQgPT09ICctLScgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnKysnKSkgJiZcbiAgICAgICAgICAgIGxhc3RfdHlwZSAhPT0gJ1RLX0VRVUFMUycgJiZcbiAgICAgICAgICAgIChvcHQucHJlc2VydmVfbmV3bGluZXMgfHwgIShsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnLCAnc2V0JywgJ2dldCddKSkpKSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuZG9fYmxvY2sgJiYgIWZsYWdzLmRvX3doaWxlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ3doaWxlJykge1xuICAgICAgICAgICAgICAgIC8vIGRvIHt9ICMjIHdoaWxlICgpXG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmbGFncy5kb193aGlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyB7fSBzaG91bGQgYWx3YXlzIGhhdmUgd2hpbGUgYXMgdGhlIG5leHQgd29yZC5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIGV4cGVjdGVkIHdoaWxlLCByZWNvdmVyXG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIGZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBtYXkgYmUgZm9sbG93ZWQgYnkgZWxzZSwgb3Igbm90XG4gICAgICAgIC8vIEJhcmUvaW5saW5lIGlmcyBhcmUgdHJpY2t5XG4gICAgICAgIC8vIE5lZWQgdG8gdW53aW5kIHRoZSBtb2RlcyBjb3JyZWN0bHk6IGlmIChhKSBpZiAoYikgYygpOyBlbHNlIGQoKTsgZWxzZSBlKCk7XG4gICAgICAgIGlmIChmbGFncy5pZl9ibG9jaykge1xuICAgICAgICAgICAgaWYgKCFmbGFncy5lbHNlX2Jsb2NrICYmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnZWxzZScpKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZWxzZV9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxhZ3MuaWZfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmbGFncy5lbHNlX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdjYXNlJyB8fCAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZGVmYXVsdCcgJiYgZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQpKSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgaWYgKGZsYWdzLmNhc2VfYm9keSB8fCBvcHQuanNsaW50X2hhcHB5KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoIGNhc2VzIGZvbGxvd2luZyBvbmUgYW5vdGhlclxuICAgICAgICAgICAgICAgIGRlaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgZmxhZ3MuY2FzZV9ib2R5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgZmxhZ3MuaW5fY2FzZSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5pbl9jYXNlX3N0YXRlbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfQ09NTUEnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnfScsICc7J10pIHx8XG4gICAgICAgICAgICAgICAgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJiAhKGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWycoJywgJ1snLCAneycsICc6JywgJz0nLCAnLCddKSB8fCBsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIG5pY2UgY2xlYW4gc3BhY2Ugb2YgYXQgbGVhc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYSBuZXcgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyB8fCBsYXN0X3R5cGUgPT09ICdUS19XT1JEJykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ2dldCcsICdzZXQnLCAnbmV3JywgJ2V4cG9ydCcsICdhc3luYyddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZGVmYXVsdCcgJiYgbGFzdF9sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vIGZvbyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgKGlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkgfHwgaXNfYXJyYXkoZmxhZ3MubW9kZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gKGZ1bmN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZWZpeCA9ICdOT05FJztcblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0JMT0NLJykge1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNfZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseScsICdmcm9tJ10pKSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU0VNSUNPTE9OJyAmJiBmbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBmb3IgU1RBVEVNRU5UIGFzIHdlbGw/XG4gICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU0VNSUNPTE9OJyAmJiBpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUUklORycpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgfHwgbGFzdF90eXBlID09PSAnVEtfV09SRCcgfHxcbiAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSycpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnKScpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmxpbmVfZnJhbWUgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnZWxzZScgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5J10pKSB7XG4gICAgICAgICAgICBpZiAoKCEobGFzdF90eXBlID09PSAnVEtfRU5EX0JMT0NLJyAmJiBwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAob3B0LmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IG91dHB1dC5jdXJyZW50X2xpbmU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuICAgICAgICAgICAgICAgIC8vIHB1dCBhIG5ld2xpbmUgYmFjayBpbi4gIEhhbmRsZXMgJ30gLy8gY29tbWVudCcgc2NlbmFyaW8uXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGFzdCgpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICdORVdMSU5FJykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5ld2xpbmUgYmV0d2VlbiAncmV0dXJuIG5ubidcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlICE9PSAnVEtfRU5EX0VYUFInKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsYXN0X3R5cGUgIT09ICdUS19TVEFSVF9FWFBSJyB8fCAhKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gZm9yY2UgbmV3bGluZSBvbiAndmFyJzogZm9yICh2YXIgeCA9IDAuLi4pXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnaWYnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXdsaW5lIGZvciB9IGVsc2UgaWYge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSAmJiBmbGFncy5sYXN0X3RleHQgIT09ICcpJykge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgaXNfYXJyYXkoZmxhZ3MubW9kZSkgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnLCcgJiYgbGFzdF9sYXN0X3RleHQgPT09ICd9Jykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpOyAvLyB9LCBpbiBsaXN0cyBnZXQgYSBuZXdsaW5lIHRyZWF0bWVudFxuICAgICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ1NQQUNFJykge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdkbycpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5kb19ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmlmX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0Jykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmltcG9ydF9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmltcG9ydF9ibG9jayAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zZW1pY29sb24oKSB7XG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgLy8gU2VtaWNvbG9uIGNhbiBiZSB0aGUgc3RhcnQgKGFuZCBlbmQpIG9mIGEgc3RhdGVtZW50XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgICAgICAgICAhKGZsYWdzLmlmX2Jsb2NrICYmIG5leHRfdG9rZW4gJiYgbmV4dF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnKSAmJlxuICAgICAgICAgICAgIWZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhY2t5IGJ1dCBlZmZlY3RpdmUgZm9yIHRoZSBtb21lbnRcbiAgICAgICAgaWYgKGZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgICAgICAgICAgZmxhZ3MuaW1wb3J0X2Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc3RyaW5nKCkge1xuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIC8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgfHwgbGFzdF90eXBlID09PSAnVEtfV09SRCcgfHwgZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyB8fCBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyB8fCBsYXN0X3R5cGUgPT09ICdUS19FUVVBTFMnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VxdWFscygpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICAvLyBqdXN0IGdvdCBhbiAnPScgaW4gYSB2YXItbGluZSwgZGlmZmVyZW50IGZvcm1hdHRpbmcvbGluZS1icmVha2luZywgZXRjIHdpbGwgbm93IGJlIGRvbmVcbiAgICAgICAgICAgIGZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfY29tbWEoKSB7XG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcblxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgICAgICAgICAgaWYgKGlzX2V4cHJlc3Npb24oZmxhZ3MucGFyZW50Lm1vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGJyZWFrIG9uIGNvbW1hLCBmb3IodmFyIGEgPSAxLCBiID0gMilcbiAgICAgICAgICAgICAgICBmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHQuY29tbWFfZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgICAgICAgICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgfHxcbiAgICAgICAgICAgIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiBmbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wdC5jb21tYV9maXJzdCkge1xuICAgICAgICAgICAgLy8gRVhQUiBvciBET19CTE9DS1xuICAgICAgICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAgICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX29wZXJhdG9yKCkge1xuICAgICAgICB2YXIgaXNHZW5lcmF0b3JBc3RlcmlzayA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyonICYmXG4gICAgICAgICAgICAoKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkpIHx8XG4gICAgICAgICAgICAgICAgKGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19TVEFSVF9CTE9DSycsICdUS19DT01NQScsICdUS19FTkRfQkxPQ0snLCAnVEtfU0VNSUNPTE9OJ10pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIGlzVW5hcnkgPSBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLScsICcrJ10pICYmIChcbiAgICAgICAgICAgIGluX2FycmF5KGxhc3RfdHlwZSwgWydUS19TVEFSVF9CTE9DSycsICdUS19TVEFSVF9FWFBSJywgJ1RLX0VRVUFMUycsICdUS19PUEVSQVRPUiddKSB8fFxuICAgICAgICAgICAgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykgfHxcbiAgICAgICAgICAgIGZsYWdzLmxhc3RfdGV4dCA9PT0gJywnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzID0gIWlzR2VuZXJhdG9yQXN0ZXJpc2s7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaXNfc3BlY2lhbF93b3JkKGZsYWdzLmxhc3RfdGV4dCkpIHtcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgaGFkIGEgc3BlY2lhbCBoYW5kbGluZyBpbiBUS19XT1JELiBOb3cgd2UgbmVlZCB0byByZXR1cm4gdGhlIGZhdm9yXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYWNrIGZvciBhY3Rpb25zY3JpcHQncyBpbXBvcnQgLio7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJiBsYXN0X3R5cGUgPT09ICdUS19ET1QnKSB7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzo6Jykge1xuICAgICAgICAgICAgLy8gbm8gc3BhY2VzIGFyb3VuZCBleG90aWMgbmFtZXNwYWNpbmcgc3ludGF4IG9wZXJhdG9yXG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgbGluZSB3cmFwcGluZyBiZXR3ZWVuIG9wZXJhdG9ycyB3aGVuIG9wZXJhdG9yX3Bvc2l0aW9uIGlzXG4gICAgICAgIC8vICAgc2V0IHRvIGJlZm9yZSBvciBwcmVzZXJ2ZVxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InICYmIGluX2FycmF5KG9wdC5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKSkge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonICYmIGZsYWdzLmluX2Nhc2UpIHtcbiAgICAgICAgICAgIGZsYWdzLmNhc2VfYm9keSA9IHRydWU7XG4gICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBmbGFncy5pbl9jYXNlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgICAgdmFyIGluX3Rlcm5hcnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50LlxuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncy50ZXJuYXJ5X2RlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgaW5fdGVybmFyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnPycpIHtcbiAgICAgICAgICAgIGZsYWdzLnRlcm5hcnlfZGVwdGggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuICAgICAgICBpZiAoIWlzVW5hcnkgJiYgIWlzR2VuZXJhdG9yQXN0ZXJpc2sgJiYgb3B0LnByZXNlcnZlX25ld2xpbmVzICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpKSB7XG4gICAgICAgICAgICB2YXIgaXNDb2xvbiA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonO1xuICAgICAgICAgICAgdmFyIGlzVGVybmFyeUNvbG9uID0gKGlzQ29sb24gJiYgaW5fdGVybmFyeSk7XG4gICAgICAgICAgICB2YXIgaXNPdGhlckNvbG9uID0gKGlzQ29sb24gJiYgIWluX3Rlcm5hcnkpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdC5vcGVyYXRvcl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSAhaXNPdGhlckNvbG9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5hZnRlcl9uZXdsaW5lOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyBhbnl0aGluZyBidXQgY29sb24sIG9yICh2aWEgZGVkdWN0aW9uKSBpdCdzIGEgY29sb24gYW5kIGluIGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhlbiBwcmludCBhIG5ld2xpbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0X3Rva2VuKDEpLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc090aGVyQ29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSB8fCBpc090aGVyQ29sb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNHZW5lcmF0b3JBc3Rlcmlzaykge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGdldF90b2tlbigxKTtcbiAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gbmV4dF90b2tlbiAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFsnVEtfV09SRCcsICdUS19SRVNFUlZFRCddKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcuLi4nKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSyc7XG4gICAgICAgICAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICcrKycsICchJywgJ34nXSkgfHwgaXNVbmFyeSkge1xuICAgICAgICAgICAgLy8gdW5hcnkgb3BlcmF0b3JzIChhbmQgYmluYXJ5ICsvLSBwcmV0ZW5kaW5nIHRvIGJlIHVuYXJ5KSBzcGVjaWFsIGNhc2VzXG5cbiAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOS4xXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIG5ld2xpbmUgYmV0d2VlbiAtLSBvciArKyBhbmQgYW55dGhpbmcgZWxzZSB3ZSBzaG91bGQgcHJlc2VydmUgaXQuXG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJzsnICYmIGlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgKDs7ICsraSlcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgXl5eXG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJykge1xuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJykge1xuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9ICEoZmxhZ3MubGFzdF90ZXh0ID09PSAnXScgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgLy8gYSsrICsgKytiO1xuICAgICAgICAgICAgICAgIC8vIGEgLSAtYlxuICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSkgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKTtcbiAgICAgICAgICAgICAgICAvLyArIGFuZCAtIGFyZSBub3QgdW5hcnkgd2hlbiBwcmVjZWVkZWQgYnkgLS0gb3IgKysgb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAvLyBhLS0gKyBiXG4gICAgICAgICAgICAgICAgLy8gYSAqICtiXG4gICAgICAgICAgICAgICAgLy8gYSAtIC1iXG4gICAgICAgICAgICAgICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWycrJywgJy0nXSkgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJy0tJywgJysrJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKCgoZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJiAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB8fCBmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkgJiZcbiAgICAgICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAneycgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnOycpKSB7XG4gICAgICAgICAgICAgICAgLy8geyBmb287IC0taSB9XG4gICAgICAgICAgICAgICAgLy8gZm9vKCk7IC0tYmFyO1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuIHx8IHNwYWNlX2JlZm9yZTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2FmdGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9ibG9ja19jb21tZW50KHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAob3V0cHV0LnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzICYmIGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnJhdyA9IG9wdC50ZXN0X291dHB1dF9yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5saW5lIGJsb2NrXG4gICAgICAgIGlmICghYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfdG9rZW4udGV4dCkgJiYgIWN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVzID0gc3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO1xuICAgICAgICB2YXIgajsgLy8gaXRlcmF0b3IgZm9yIHRoaXMgY2FzZVxuICAgICAgICB2YXIgamF2YWRvYyA9IGZhbHNlO1xuICAgICAgICB2YXIgc3Rhcmxlc3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxhc3RJbmRlbnQgPSBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICAgICAgICB2YXIgbGFzdEluZGVudExlbmd0aCA9IGxhc3RJbmRlbnQubGVuZ3RoO1xuXG4gICAgICAgIC8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxuICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgamF2YWRvYyA9IGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLnNsaWNlKDEpLCAnKicpO1xuICAgICAgICAgICAgc3Rhcmxlc3MgPSBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMuc2xpY2UoMSksIGxhc3RJbmRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbiAgICAgICAgcHJpbnRfdG9rZW4obGluZXNbMF0pO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGphdmFkb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBqYXZhZG9jOiByZWZvcm1hdCBhbmQgcmUtaW5kZW50XG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oJyAnICsgbHRyaW0obGluZXNbal0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3Rhcmxlc3MgJiYgbGluZXNbal0ubGVuZ3RoID4gbGFzdEluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbiAgICAgICAgICAgICAgICBwcmludF90b2tlbihsaW5lc1tqXS5zdWJzdHJpbmcobGFzdEluZGVudExlbmd0aCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgY29tbWVudHMgb3V0cHV0IHJhd1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfdG9rZW4obGluZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIGNvbW1lbnRzIG9mIG1vcmUgdGhhbiBvbmUgbGluZSwgbWFrZSBzdXJlIHRoZXJlJ3MgYSBuZXcgbGluZSBhZnRlclxuICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9jb21tZW50KHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2RvdCgpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHByZXNlcnZlZCBuZXdsaW5lcyBiZWZvcmUgZG90cyBpbiBnZW5lcmFsXG4gICAgICAgICAgICAvLyBmb3JjZSBuZXdsaW5lcyBvbiBkb3RzIGFmdGVyIGNsb3NlIHBhcmVuIHdoZW4gYnJlYWtfY2hhaW5lZCAtIGZvciBiYXIoKS5iYXooKVxuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShmbGFncy5sYXN0X3RleHQgPT09ICcpJyAmJiBvcHQuYnJlYWtfY2hhaW5lZF9tZXRob2RzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3Vua25vd24ocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dFtjdXJyZW50X3Rva2VuLnRleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VvZigpIHtcbiAgICAgICAgLy8gVW53aW5kIGFueSBvcGVuIHN0YXRlbWVudHNcbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dCkge1xuICAgIHZhciBfaW5wdXQgPSBpbnB1dDtcbiAgICB2YXIgX2lucHV0X2xlbmd0aCA9IF9pbnB1dC5sZW5ndGg7XG4gICAgdmFyIF9wb3NpdGlvbiA9IDA7XG5cbiAgICB0aGlzLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3Bvc2l0aW9uIC09IDE7XG4gICAgfTtcblxuICAgIHRoaXMuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uIDwgX2lucHV0X2xlbmd0aDtcbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIHZhbCA9IF9pbnB1dC5jaGFyQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgICAgIF9wb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIGluZGV4ICs9IF9wb3NpdGlvbjtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBfaW5wdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWwgPSBfaW5wdXQuY2hhckF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLnBlZWtDaGFyQ29kZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB2YWwgPSAwO1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIGluZGV4ICs9IF9wb3NpdGlvbjtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBfaW5wdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWwgPSBfaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IF9wb3NpdGlvbiArIGluZGV4O1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KF9pbnB1dCk7XG4gICAgfTtcblxuICAgIHRoaXMudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBfcG9zaXRpb247XG4gICAgICAgIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKF9pbnB1dCk7XG4gICAgICAgIGlmIChwYXR0ZXJuX21hdGNoICYmIHBhdHRlcm5fbWF0Y2guaW5kZXggPT09IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG4gICAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIHRhcmdldFR5cGUpIHtcbiAgICB2YXIgZmluYWxPcHRzID0ge307XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgdGFyZ2V0VHlwZVxuICAgIGlmICh0YXJnZXRUeXBlIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV0pIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbdGFyZ2V0VHlwZV1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICAgIHZhciBfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciBsaW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gICAgdmFyIF9pbmRlbnRfY291bnQgPSAtMTtcblxuICAgIHZhciBfaXRlbXMgPSBbXTtcbiAgICB2YXIgX2VtcHR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIF9jaGFyYWN0ZXJfY291bnQgPSBwYXJlbnQuYmFzZUluZGVudExlbmd0aCArIGxldmVsICogcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIF9pbmRlbnRfY291bnQgPSBsZXZlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRfY2hhcmFjdGVyX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2hhcmFjdGVyX2NvdW50O1xuICAgIH07XG5cbiAgICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZW1zW19pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIF9pdGVtcy5wdXNoKGlucHV0KTtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCArPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIF9lbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9IG51bGw7XG4gICAgICAgIGlmICghX2VtcHR5KSB7XG4gICAgICAgICAgICBpdGVtID0gX2l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIF9lbXB0eSA9IF9pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2luZGVudF9jb3VudCA+IDApIHtcbiAgICAgICAgICAgIF9pbmRlbnRfY291bnQgLT0gMTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gcGFyZW50LmluZGVudF9sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChfaW5kZW50X2NvdW50ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQuaW5kZW50X2NhY2hlW19pbmRlbnRfY291bnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IF9pdGVtcy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE91dHB1dChpbmRlbnRfc3RyaW5nLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gICAgdGhpcy5pbmRlbnRfY2FjaGUgPSBbYmFzZUluZGVudFN0cmluZ107XG4gICAgdGhpcy5iYXNlSW5kZW50TGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5pbmRlbnRfbGVuZ3RoID0gaW5kZW50X3N0cmluZy5sZW5ndGg7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcblxuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHRoaXMuYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gICAgdGhpcy5pbmRlbnRfc3RyaW5nID0gaW5kZW50X3N0cmluZztcbiAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG4gICAgfTtcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG5cblxuICAgIHRoaXMuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsaW5lcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIFVzaW5nIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZyB0byBhbGxvdyBmb3IgbGF0ZXIgZXhwYW5zaW9uIG9mIGluZm8gYWJvdXQgZWFjaCBsaW5lXG4gICAgdGhpcy5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmdldF9saW5lX251bWJlcigpID09PSAxICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm8gbmV3bGluZSBvbiBzdGFydCBvZiBmaWxlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfbmV3bGluZSB8fCAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jb2RlID0gZnVuY3Rpb24oZW5kX3dpdGhfbmV3bGluZSwgZW9sKSB7XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbGluZXMuam9pbignXFxuJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCAnJyk7XG5cbiAgICAgICAgaWYgKGVuZF93aXRoX25ld2xpbmUpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgICAgICAgICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzd2VldF9jb2RlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgd2hpbGUgKGxldmVsID49IHRoaXMuaW5kZW50X2NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2NhY2hlLnB1c2godGhpcy5pbmRlbnRfY2FjaGVbdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoIC0gMV0gKyB0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vdXRwdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgb3V0cHV0X2xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNbaW5kZXhdLnJlbW92ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gICAgICAgIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gICAgICAgIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgbGluZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gbGluZXMubGVuZ3RoID4gMSA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc3RhcnQgb2YgdGhlIGZpbGUgYW5kIG5ld2xpbmUgPSBibGFua1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0ZXh0LCBuZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmUsIHBhcmVudCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAgIC8vIGFuZCBtYXkgb3IgbWF5IG5vdCBoYXZlIGEgbmV3bGluZSBhZnRlclxuICAgIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gICAgdGhpcy5jb21tZW50c19iZWZvcmUgPSAvKiBpbmxpbmUgY29tbWVudCovIFtdO1xuXG5cbiAgICB0aGlzLmNvbW1lbnRzX2FmdGVyID0gW107IC8vIG5vIG5ldyBsaW5lIGJlZm9yZSBhbmQgbmV3bGluZSBhZnRlclxuICAgIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICAgIHRoaXMud2FudGVkX25ld2xpbmUgPSBuZXdsaW5lcyA+IDA7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZSA9IHdoaXRlc3BhY2VfYmVmb3JlIHx8ICcnO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJlYXV0aWZpZXI7XG5cbmZ1bmN0aW9uIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc19iZWF1dGlmeTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMikuSW5wdXRTY2FubmVyO1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5Ub2tlbjtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gd2hhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBUb2tlbml6ZXIoaW5wdXRfc3RyaW5nLCBvcHRzKSB7XG5cbiAgICB2YXIgd2hpdGVzcGFjZSA9IFwiXFxuXFxyXFx0IFwiLnNwbGl0KCcnKTtcbiAgICB2YXIgZGlnaXQgPSAvWzAtOV0vO1xuICAgIHZhciBkaWdpdF9iaW4gPSAvWzAxXS87XG4gICAgdmFyIGRpZ2l0X29jdCA9IC9bMDEyMzQ1NjddLztcbiAgICB2YXIgZGlnaXRfaGV4ID0gL1swMTIzNDU2Nzg5YWJjZGVmQUJDREVGXS87XG5cbiAgICB0aGlzLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSAnIT0gIT09ICUgJiAmJiAqICoqICsgLSAvIDogPCA8PCA8PSA9PSA9PT0gPiA+PSA+PiA+Pj4gPyBeIHwgfHwnLnNwbGl0KCcgJyk7XG4gICAgdmFyIHB1bmN0ID0gdGhpcy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzLmNvbmNhdChcbiAgICAgICAgLy8gbm9uLXBvc2l0aW9uYWJsZSBvcGVyYXRvcnMgLSB0aGVzZSBkbyBub3QgZm9sbG93IG9wZXJhdG9yIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICAgICchICU9ICY9ICo9ICoqPSArKyArPSAsIC0tIC09IC89IDo6IDw8PSA9ID0+ID4+PSA+Pj49IF49IHw9IH4gLi4uJy5zcGxpdCgnICcpKTtcblxuICAgIC8vIHdvcmRzIHdoaWNoIHNob3VsZCBhbHdheXMgc3RhcnQgb24gbmV3IGxpbmUuXG4gICAgdGhpcy5saW5lX3N0YXJ0ZXJzID0gJ2NvbnRpbnVlLHRyeSx0aHJvdyxyZXR1cm4sdmFyLGxldCxjb25zdCxpZixzd2l0Y2gsY2FzZSxkZWZhdWx0LGZvcix3aGlsZSxicmVhayxmdW5jdGlvbixpbXBvcnQsZXhwb3J0Jy5zcGxpdCgnLCcpO1xuICAgIHZhciByZXNlcnZlZF93b3JkcyA9IHRoaXMubGluZV9zdGFydGVycy5jb25jYXQoWydkbycsICdpbicsICdvZicsICdlbHNlJywgJ2dldCcsICdzZXQnLCAnbmV3JywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAndHlwZW9mJywgJ3lpZWxkJywgJ2FzeW5jJywgJ2F3YWl0JywgJ2Zyb20nLCAnYXMnXSk7XG5cbiAgICAvLyAgLyogLi4uICovIGNvbW1lbnQgZW5kcyB3aXRoIG5lYXJlc3QgKi8gb3IgZW5kIG9mIGZpbGVcbiAgICB2YXIgYmxvY2tfY29tbWVudF9wYXR0ZXJuID0gLyhbXFxzXFxTXSo/KSgoPzpcXCpcXC8pfCQpL2c7XG5cbiAgICAvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxuICAgIHZhciBjb21tZW50X3BhdHRlcm4gPSAvKFteXFxuXFxyXFx1MjAyOFxcdTIwMjldKikvZztcblxuICAgIHZhciBkaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4gPSAvXFwvXFwqIGJlYXV0aWZ5KCBcXHcrWzpdXFx3KykrIFxcKlxcLy9nO1xuICAgIHZhciBkaXJlY3RpdmVfcGF0dGVybiA9IC8gKFxcdyspWzpdKFxcdyspL2c7XG4gICAgdmFyIGRpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuID0gLyhbXFxzXFxTXSo/KSgoPzpcXC9cXCpcXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHNcXCpcXC8pfCQpL2c7XG5cbiAgICB2YXIgdGVtcGxhdGVfcGF0dGVybiA9IC8oKDxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg8JVtcXHNcXFNdKj8lPikvZztcblxuICAgIHZhciBuX25ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiwgaW5faHRtbF9jb21tZW50LCB0b2tlbnM7XG4gICAgdmFyIGlucHV0O1xuXG4gICAgdGhpcy50b2tlbml6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dCA9IG5ldyBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKTtcbiAgICAgICAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHRva2VucyA9IFtdO1xuXG4gICAgICAgIHZhciBuZXh0LCBsYXN0O1xuICAgICAgICB2YXIgdG9rZW5fdmFsdWVzO1xuICAgICAgICB2YXIgb3BlbiA9IG51bGw7XG4gICAgICAgIHZhciBvcGVuX3N0YWNrID0gW107XG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghKGxhc3QgJiYgbGFzdC50eXBlID09PSAnVEtfRU9GJykpIHtcbiAgICAgICAgICAgIHRva2VuX3ZhbHVlcyA9IHRva2VuaXplX25leHQoKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXcgVG9rZW4odG9rZW5fdmFsdWVzWzFdLCB0b2tlbl92YWx1ZXNbMF0sIG5fbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0LnR5cGUgPT09ICdUS19DT01NRU5UJyB8fCBuZXh0LnR5cGUgPT09ICdUS19CTE9DS19DT01NRU5UJyB8fCBuZXh0LnR5cGUgPT09ICdUS19VTktOT1dOJykge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnR5cGUgPT09ICdUS19CTE9DS19DT01NRU5UJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcmVjdGl2ZXMgPSB0b2tlbl92YWx1ZXNbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgdG9rZW5fdmFsdWVzID0gdG9rZW5pemVfbmV4dCgpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXcgVG9rZW4odG9rZW5fdmFsdWVzWzFdLCB0b2tlbl92YWx1ZXNbMF0sIG5fbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQudHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJyB8fCBuZXh0LnR5cGUgPT09ICdUS19TVEFSVF9FWFBSJykge1xuICAgICAgICAgICAgICAgIG5leHQucGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbik7XG4gICAgICAgICAgICAgICAgb3BlbiA9IG5leHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChuZXh0LnR5cGUgPT09ICdUS19FTkRfQkxPQ0snIHx8IG5leHQudHlwZSA9PT0gJ1RLX0VORF9FWFBSJykgJiZcbiAgICAgICAgICAgICAgICAob3BlbiAmJiAoXG4gICAgICAgICAgICAgICAgICAgIChuZXh0LnRleHQgPT09ICddJyAmJiBvcGVuLnRleHQgPT09ICdbJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5leHQudGV4dCA9PT0gJyknICYmIG9wZW4udGV4dCA9PT0gJygnKSB8fFxuICAgICAgICAgICAgICAgICAgICAobmV4dC50ZXh0ID09PSAnfScgJiYgb3Blbi50ZXh0ID09PSAneycpKSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnBhcmVudCA9IG9wZW4ucGFyZW50O1xuICAgICAgICAgICAgICAgIG5leHQub3BlbmVkID0gb3BlbjtcblxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuX3N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2tlbnMucHVzaChuZXh0KTtcbiAgICAgICAgICAgIGxhc3QgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0X2RpcmVjdGl2ZXModGV4dCkge1xuICAgICAgICBpZiAoIXRleHQubWF0Y2goZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICAgICAgICBkaXJlY3RpdmVfcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZGlyZWN0aXZlX21hdGNoID0gZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICAgICAgICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgICAgICAgICBkaXJlY3RpdmVfbWF0Y2ggPSBkaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5pemVfbmV4dCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdGluZ19zdHJpbmc7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZSA9IFtdO1xuXG4gICAgICAgIG5fbmV3bGluZXMgPSAwO1xuICAgICAgICB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gICAgICAgIHZhciBjID0gaW5wdXQubmV4dCgpO1xuXG4gICAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gWycnLCAnVEtfRU9GJ107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdF90b2tlbjtcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RfdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBzYWtlIG9mIHRva2VuaXppbmcgd2UgY2FuIHByZXRlbmQgdGhhdCB0aGVyZSB3YXMgb24gb3BlbiBicmFjZSB0byBzdGFydFxuICAgICAgICAgICAgbGFzdF90b2tlbiA9IG5ldyBUb2tlbignVEtfU1RBUlRfQkxPQ0snLCAneycpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluX2FycmF5KGMsIHdoaXRlc3BhY2UpKSB7XG5cbiAgICAgICAgICAgIGlmIChhY29ybi5uZXdsaW5lLnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjID09PSAnXFxuJyAmJiBpbnB1dC5wZWVrKC0yKSA9PT0gJ1xccicpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5fbmV3bGluZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZV9vbl90aGlzX2xpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2Vfb25fdGhpc19saW5lLnB1c2goYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMgPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdoaXRlc3BhY2Vfb25fdGhpc19saW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZS5qb2luKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWdpdC50ZXN0KGMpIHx8IChjID09PSAnLicgJiYgaW5wdXQudGVzdENoYXIoZGlnaXQpKSkge1xuICAgICAgICAgICAgdmFyIGFsbG93X2RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGFsbG93X2UgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGxvY2FsX2RpZ2l0ID0gZGlnaXQ7XG5cbiAgICAgICAgICAgIGlmIChjID09PSAnMCcgJiYgaW5wdXQudGVzdENoYXIoL1tYeE9vQmJdLykpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gaGV4L29jdC9iaW4gbnVtYmVyLCBubyBkZWNpbWFsIG9yIGUsIGp1c3QgaGV4L29jdC9iaW4gZGlnaXRzXG4gICAgICAgICAgICAgICAgYWxsb3dfZGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbG93X2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudGVzdENoYXIoL1tCYl0vKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbF9kaWdpdCA9IGRpZ2l0X2JpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnRlc3RDaGFyKC9bT29dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfZGlnaXQgPSBkaWdpdF9vY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfZGlnaXQgPSBkaWdpdF9oZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGhhdmUgYSBkZWNpbWFsIGZvciB0aGlzIGxpdGVyYWwsIGRvbid0IGFsbG93IGFub3RoZXJcbiAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhpcyBmaXJzdCBsb29wIHdpbGwgcnVuLiAgSXQga2VlcHMgdGhlIGxvZ2ljIHNpbXBsZXIuXG4gICAgICAgICAgICAgICAgYyA9ICcnO1xuICAgICAgICAgICAgICAgIGlucHV0LmJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBkaWdpdHNcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC50ZXN0Q2hhcihsb2NhbF9kaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxvd19kZWNpbWFsICYmIGlucHV0LnBlZWsoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYSA9IDEuZS03IGlzIHZhbGlkLCBzbyB3ZSB0ZXN0IGZvciAuIHRoZW4gZSBpbiBvbmUgbG9vcFxuICAgICAgICAgICAgICAgIGlmIChhbGxvd19lICYmIGlucHV0LnRlc3RDaGFyKC9bRWVdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnRlc3RDaGFyKC9bKy1dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19XT1JEJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWNvcm4uaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQucGVla0NoYXJDb2RlKC0xKSkpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYWNvcm4uaXNJZGVudGlmaWVyQ2hhcihpbnB1dC5wZWVrQ2hhckNvZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEobGFzdF90b2tlbi50eXBlID09PSAnVEtfRE9UJyB8fFxuICAgICAgICAgICAgICAgICAgICAobGFzdF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGxhc3RfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pKSkgJiZcbiAgICAgICAgICAgICAgICBpbl9hcnJheShjLCByZXNlcnZlZF93b3JkcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ2luJyB8fCBjID09PSAnb2YnKSB7IC8vIGhhY2sgZm9yICdpbicgYW5kICdvZicgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX09QRVJBVE9SJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1JFU0VSVkVEJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1dPUkQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnKCcgfHwgYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19TVEFSVF9FWFBSJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJyknIHx8IGMgPT09ICddJykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfRU5EX0VYUFInXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAneycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NUQVJUX0JMT0NLJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19FTkRfQkxPQ0snXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnOycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NFTUlDT0xPTiddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgIHZhciBjb21tZW50X21hdGNoO1xuICAgICAgICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvKiAuLi4gKi9cbiAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb21tZW50X21hdGNoID0gaW5wdXQubWF0Y2goYmxvY2tfY29tbWVudF9wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gJy8qJyArIGNvbW1lbnRfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBnZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50X21hdGNoID0gaW5wdXQubWF0Y2goZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29tbWVudCwgJ1RLX0JMT0NLX0NPTU1FTlQnLCBkaXJlY3RpdmVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLy8gLi4uXG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29tbWVudF9tYXRjaCA9IGlucHV0Lm1hdGNoKGNvbW1lbnRfcGF0dGVybik7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9ICcvLycgKyBjb21tZW50X21hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29tbWVudCwgJ1RLX0NPTU1FTlQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0WG1sUmVnRXhwID0gLzwoKShbLWEtekEtWjowLTlfLl0rfHtbXFxzXFxTXSs/fXwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdKShcXHMre1tcXHNcXFNdKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7W1xcc1xcU10rP30pKSpcXHMqKFxcLz8pXFxzKj4vZztcblxuICAgICAgICBpZiAoYyA9PT0gJ2AnIHx8IGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicgfHwgLy8gc3RyaW5nXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgKGMgPT09ICcvJykgfHwgLy8gcmVnZXhwXG4gICAgICAgICAgICAgICAgKG9wdHMuZTR4ICYmIGMgPT09IFwiPFwiICYmIGlucHV0LnRlc3Qoc3RhcnRYbWxSZWdFeHAsIC0xKSkgLy8geG1sXG4gICAgICAgICAgICApICYmICggLy8gcmVnZXggYW5kIHhtbCBjYW4gb25seSBhcHBlYXIgaW4gc3BlY2lmaWMgbG9jYXRpb25zIGR1cmluZyBwYXJzaW5nXG4gICAgICAgICAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShsYXN0X3Rva2VuLnRleHQsIFsncmV0dXJuJywgJ2Nhc2UnLCAndGhyb3cnLCAnZWxzZScsICdkbycsICd0eXBlb2YnLCAneWllbGQnXSkpIHx8XG4gICAgICAgICAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX0VORF9FWFBSJyAmJiBsYXN0X3Rva2VuLnRleHQgPT09ICcpJyAmJlxuICAgICAgICAgICAgICAgICAgICBsYXN0X3Rva2VuLnBhcmVudCAmJiBsYXN0X3Rva2VuLnBhcmVudC50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGxhc3RfdG9rZW4ucGFyZW50LnRleHQsIFsnaWYnLCAnd2hpbGUnLCAnZm9yJ10pKSB8fFxuICAgICAgICAgICAgICAgIChpbl9hcnJheShsYXN0X3Rva2VuLnR5cGUsIFsnVEtfQ09NTUVOVCcsICdUS19TVEFSVF9FWFBSJywgJ1RLX1NUQVJUX0JMT0NLJyxcbiAgICAgICAgICAgICAgICAgICAgJ1RLX0VORF9CTE9DSycsICdUS19PUEVSQVRPUicsICdUS19FUVVBTFMnLCAnVEtfRU9GJywgJ1RLX1NFTUlDT0xPTicsICdUS19DT01NQSdcbiAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICkpIHtcblxuICAgICAgICAgICAgdmFyIHNlcCA9IGMsXG4gICAgICAgICAgICAgICAgZXNjID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGFzX2NoYXJfZXNjYXBlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gYztcblxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcmVnZXhwXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChlc2MgfHwgaW5fY2hhcl9jbGFzcyB8fCBpbnB1dC5wZWVrKCkgIT09IHNlcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBpbnB1dC5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2MgPSBpbnB1dC5wZWVrKCkgPT09ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5wZWVrKCkgPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZTR4ICYmIHNlcCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZTR4IHhtbCBsaXRlcmFsc1xuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICB2YXIgeG1sUmVnRXhwID0gL1tcXHNcXFNdKj88KFxcLz8pKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi9nO1xuICAgICAgICAgICAgICAgIGlucHV0LmJhY2soKTtcbiAgICAgICAgICAgICAgICB2YXIgeG1sU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goc3RhcnRYbWxSZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHJvb3QgdGFnIHRvIGF0dGVtcHQgdG9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RUYWcgPSBtYXRjaFsyXS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0N1cmx5Um9vdCA9IHJvb3RUYWcuaW5kZXhPZigneycpID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VuZFRhZyA9ICEhbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2luZ2xldG9uVGFnID0gKCEhbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIHx8ICh0YWdOYW1lLnNsaWNlKDAsIDgpID09PSBcIiFbQ0RBVEFbXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NpbmdsZXRvblRhZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YWdOYW1lID09PSByb290VGFnIHx8IChpc0N1cmx5Um9vdCAmJiB0YWdOYW1lLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW5kVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxTdHIgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaCh4bWxSZWdFeHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBjbG9zZSBjb3JyZWN0bHksIGtlZXAgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbnB1dC5tYXRjaCgvW1xcc1xcU10qL2cpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhtbFN0ciA9IHhtbFN0ci5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt4bWxTdHIsIFwiVEtfU1RSSU5HXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2Vfc3RyaW5nID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsIHN0YXJ0X3N1Yikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBzdHJpbmdzIGNhbiB0cmF2ZXJzIGxpbmVzIHdpdGhvdXQgZXNjYXBlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHN0cmluZ3MgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2NoYXI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY2hhciA9IGlucHV0LnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVzYyB8fCAoY3VycmVudF9jaGFyICE9PSBkZWxpbWl0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyB8fCAhYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfY2hhcikpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIFxcclxcbiBsaW5lYnJlYWtzIGFmdGVyIGVzY2FwZXMgb3IgaW4gdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlc2MgfHwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzKSAmJiBhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF9jaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICdcXHInICYmIGlucHV0LnBlZWsoMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jaGFyID0gaW5wdXQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGN1cnJlbnRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICd4JyB8fCBjdXJyZW50X2NoYXIgPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfY2hhcl9lc2NhcGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGN1cnJlbnRfY2hhciA9PT0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydF9zdWIgJiYgcmVzdWx0aW5nX3N0cmluZy5pbmRleE9mKHN0YXJ0X3N1YiwgcmVzdWx0aW5nX3N0cmluZy5sZW5ndGggLSBzdGFydF9zdWIubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyaW5nKCd9JywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnYCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZygnYCcsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZygnYCcsIHRydWUsICckeycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX3N0cmluZyhzZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc19jaGFyX2VzY2FwZXMgJiYgb3B0cy51bmVzY2FwZV9zdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHVuZXNjYXBlX3N0cmluZyhyZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gc2VwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBzZXA7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2V4cHMgbWF5IGhhdmUgbW9kaWZpZXJzIC9yZWdleHAvTU9EICwgc28gZmV0Y2ggdGhvc2UsIHRvb1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IFtnaW1dIGFyZSB2YWxpZCwgYnV0IGlmIHRoZSB1c2VyIHB1dHMgaW4gZ2FyYmFnZSwgZG8gd2hhdCB3ZSBjYW4gdG8gdGFrZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBhY29ybi5pc0lkZW50aWZpZXJTdGFydChpbnB1dC5wZWVrQ2hhckNvZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHRpbmdfc3RyaW5nLCAnVEtfU1RSSU5HJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJyMnKSB7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwICYmIGlucHV0LnBlZWsoKSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hlYmFuZ1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSBjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgYyAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RyaW0ocmVzdWx0aW5nX3N0cmluZykgKyAnXFxuJywgJ1RLX1VOS05PV04nXTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIC8vIFNwaWRlcm1vbmtleS1zcGVjaWZpYyBzaGFycCB2YXJpYWJsZXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL1NoYXJwX3ZhcmlhYmxlc19pbl9KYXZhU2NyaXB0XG4gICAgICAgICAgICAvLyBodHRwOi8vbXhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UvanMvc3JjL2pzc2Nhbi5jcHAgYXJvdW5kIGxpbmUgMTkzNVxuICAgICAgICAgICAgdmFyIHNoYXJwID0gJyMnO1xuICAgICAgICAgICAgaWYgKGlucHV0Lmhhc05leHQoKSAmJiBpbnB1dC50ZXN0Q2hhcihkaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJwICs9IGM7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmIGMgIT09ICcjJyAmJiBjICE9PSAnPScpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ1snICYmIGlucHV0LnBlZWsoMSkgPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBzaGFycCArPSAnW10nO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ3snICYmIGlucHV0LnBlZWsoMSkgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBzaGFycCArPSAne30nO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzaGFycCwgJ1RLX1dPUkQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnPCcgJiYgKGlucHV0LnBlZWsoKSA9PT0gJz8nIHx8IGlucHV0LnBlZWsoKSA9PT0gJyUnKSkge1xuICAgICAgICAgICAgaW5wdXQuYmFjaygpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlX21hdGNoID0gaW5wdXQubWF0Y2godGVtcGxhdGVfcGF0dGVybik7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVfbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjID0gdGVtcGxhdGVfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgYyA9IGMucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfU1RSSU5HJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJzwnICYmIGlucHV0Lm1hdGNoKC9cXCEtLS9nKSkge1xuICAgICAgICAgICAgYyA9ICc8IS0tJztcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgIWlucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbl9odG1sX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfQ09NTUVOVCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICctJyAmJiBpbl9odG1sX2NvbW1lbnQgJiYgaW5wdXQubWF0Y2goLy0+L2cpKSB7XG4gICAgICAgICAgICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBbJy0tPicsICdUS19DT01NRU5UJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSAnLicgJiYgaW5wdXQucGVlaygxKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCkgKyBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfT1BFUkFUT1InXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0RPVCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluX2FycmF5KGMsIHB1bmN0KSkge1xuICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBpbl9hcnJheShjICsgaW5wdXQucGVlaygpLCBwdW5jdCkpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19DT01NQSddO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19FUVVBTFMnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfT1BFUkFUT1InXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYywgJ1RLX1VOS05PV04nXTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlX3N0cmluZyhzKSB7XG4gICAgICAgIC8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuICAgICAgICAvLyByZXR1cm4gcy5yZXBsYWNlKC9cXFxceChbMC05YS1mXXsyfSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCB2YWwpIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2YWwsIDE2KSk7XG4gICAgICAgIC8vICAgICB9KVxuICAgICAgICAvLyBIb3dldmVyLCBkZWFsaW5nIHdpdGggJ1xceGZmJywgJ1xcXFx4ZmYnLCAnXFxcXFxceGZmJyBtYWtlcyB0aGlzIG1vcmUgZnVuLlxuICAgICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgICBlc2NhcGVkID0gMDtcblxuICAgICAgICB2YXIgaW5wdXRfc2NhbiA9IG5ldyBJbnB1dFNjYW5uZXIocyk7XG4gICAgICAgIHZhciBtYXRjaGVkID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYW55IHdoaXRlc3BhY2UsIG5vbi1zbGFzaCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyBhbHNvIGtlZXAgc2xhc2ggcGFpcnMuXG4gICAgICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvKFtcXHNdfFteXFxcXF18XFxcXFxcXFwpKy9nKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gbWF0Y2hlZFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgveChbMC05QS1GYS1mXXsyfSkvZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIHNvbWUgZXJyb3IgZGVjb2RpbmcsIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBwYXJzZUludChtYXRjaGVkWzFdLCAxNik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCA+IDB4N2UgJiYgZXNjYXBlZCA8PSAweGZmICYmIG1hdGNoZWRbMF0uaW5kZXhPZigneCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIFxceDdmLi5cXHhmZixcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmluZyB3aG9sZSBzdHJpbmcgZXNjYXBlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyBwcm9iYWJseSBjb21wbGV0ZWx5IGJpbmFyeVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPj0gMHgwMCAmJiBlc2NhcGVkIDwgMHgyMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSAweDAwLi4uMHgxZiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnXFxcXCcgKyBtYXRjaGVkWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPT09IDB4MjIgfHwgZXNjYXBlZCA9PT0gMHgyNyB8fCBlc2NhcGVkID09PSAweDVjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZS1xdW90ZSwgYXBvc3Ryb3BoZSwgYmFja3NsYXNoIC0gZXNjYXBlIHRoZXNlXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBqc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9qcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsganNfYmVhdXRpZnk6IGpzX2JlYXV0aWZ5IH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuanNfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGJvdW5kYXJ5X3RvX2RvdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnXVsnKS5qb2luKCcuJykuc3BsaXQoJ1snKS5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiBzdHJpcF9icmFjZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJ1snKS5qb2luKCcuJykuc3BsaXQoJ10nKS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9kb3RzKHZhbHVlKSB7XG4gICAgdmFyIHZhbCA9IHZhbHVlLnNwbGl0KCdcXCcnKTtcbiAgICByZXR1cm4gKHZhbC5sZW5ndGggPCAzKSA/IHZhbC5qb2luKCdcXCcnKSA6IHZhbC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICBpZiAoc2VnLmxlbmd0aCA8IDMpXG4gICAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICBpZiAoKHNlZ1swXSA9PT0gJy4nKSB8fCAoc2VnW3NlZy5sZW5ndGggLSAxXSA9PT0gJy4nKSlcbiAgICAgICAgICAgIHJldHVybiBzZWc7XG4gICAgICAgIHJldHVybiBzZWcuc3BsaXQoJy4nKS5qb2luKCcmJicpO1xuICAgIH0pLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gdW5lc2NhcGVfZG90cyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJiYnKS5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiBwYXJ0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBlc2NhcGVfZG90cyhzdHJpcF9icmFjZXMoYm91bmRhcnlfdG9fZG90KCcnICsgdmFsdWUpKSkuc3BsaXQoJy4nKTtcbn1cbmZ1bmN0aW9uIGNhbkNsb25lKG8pIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvLl9fQ0xPTkVfXyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBjbG9uZShvKSB7XG4gICAgaWYgKCh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHx8IChvID09PSBudWxsKSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpXG4gICAgICAgIHJldHVybiBvLm1hcChjbG9uZSk7XG4gICAgcmV0dXJuIChjYW5DbG9uZShvKSkgP1xuICAgICAgICBvLl9fQ0xPTkVfXyhjbG9uZSkgOiAoby5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSA/IG8gOlxuICAgICAgICBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24gKHByZSwgaykge1xuICAgICAgICAgICAgcHJlW2tdID0gKHR5cGVvZiBvW2tdID09PSAnb2JqZWN0JykgP1xuICAgICAgICAgICAgICAgIGNsb25lKG9ba10pIDogb1trXTtcbiAgICAgICAgICAgIHJldHVybiBwcmU7XG4gICAgICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldChwYXRoLCBvKSB7XG4gICAgdmFyIHBhcnRzID0gcGFydGlmeShwYXRoKTtcbiAgICB2YXIgZmlyc3Q7XG4gICAgaWYgKHR5cGVvZiBvID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG9bdW5lc2NhcGVfZG90cyhwYXJ0c1swXSldO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmaXJzdCA9IG9bcGFydHMuc2hpZnQoKV07XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiBvID09PSAnb2JqZWN0JykgJiYgKG8gIT09IG51bGwpKSA/XG4gICAgICAgICAgICBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3VuZXNjYXBlX2RvdHMocHJvcCldO1xuICAgICAgICAgICAgfSwgZmlyc3QpIDogbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldCgpOiBleHBlY3RzIGFuIG9iamVjdCBnb3QgJyArIHR5cGVvZiBvKTtcbiAgICB9XG59XG5leHBvcnRzLmdldCA9IGdldDtcbjtcbmZ1bmN0aW9uIHNldChwYXRoLCB2YWx1ZSwgb2JqKSB7XG4gICAgdmFyIHBhcnRzID0gcGFydGlmeShwYXRoKTtcbiAgICBpZiAoKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB8fCAob2JqID09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZShvYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zZXQob2JqLCB2YWx1ZSwgcGFydHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0ID0gc2V0O1xuO1xuZnVuY3Rpb24gX3NldChvYmosIHZhbHVlLCBwYXJ0cykge1xuICAgIHZhciBvO1xuICAgIHZhciBrO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBvID0gKCh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgfHwgKG9iaiA9PT0gbnVsbCkpID8ge30gOiBjbG9uZShvYmopO1xuICAgIGsgPSB1bmVzY2FwZV9kb3RzKHBhcnRzWzBdKTtcbiAgICBvW2tdID0gX3NldChvW2tdLCB2YWx1ZSwgcGFydHMuc2xpY2UoMSkpO1xuICAgIHJldHVybiBvO1xufVxuZnVuY3Rpb24gZGVmYXVsdF8xKGssIHYsIG8pIHtcbiAgICBpZiAobyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZ2V0KGssIHYpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNldChrLCB2LCBvKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdfQ==
