(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("./wml/app");
var navigation_1 = require("./wml/navigation");
var home_1 = require("./pages/home");
var panel_1 = require("./pages/panel");
var list_group_1 = require("./pages/list-group");
var table_1 = require("./pages/table");
var text_field_1 = require("./pages/text-field");
var date_1 = require("./pages/date");
var select_1 = require("./pages/select");
var button_select_1 = require("./pages/button-select");
var checkbox_1 = require("./pages/checkbox");
var switch_1 = require("./pages/switch");
var tabs_1 = require("./pages/tabs");
var stack_1 = require("./pages/stack");
var search_stack_1 = require("./pages/search-stack");
var autocomplete_1 = require("./pages/autocomplete");
var breadcrumbs_1 = require("./pages/breadcrumbs");
var busy_indicator_1 = require("./pages/busy-indicator");
var menu_1 = require("./pages/menu");
var button_menu_1 = require("./pages/button-menu");
var App = /** @class */ (function () {
    function App() {
        var _this = this;
        /**
         * page currently displayed.
         */
        this.page = 'home';
        /**
         * pages to show the user.
         */
        this.pages = {
            home: new home_1.HomePage(this),
            panel: new panel_1.PanelPage(this),
            'list-group': new list_group_1.ListGroupPage(this),
            table: new table_1.TablePage(this),
            'text-field': new text_field_1.TextFieldPage(this),
            date: new date_1.DatePage(this),
            select: new select_1.SelectPage(this),
            autocomplete: new autocomplete_1.AutocompletePage(this),
            'button-select': new button_select_1.ButtonSelectPage(this),
            tabs: new tabs_1.TabsPage(this),
            stack: new stack_1.StackPage(this),
            checkbox: new checkbox_1.CheckboxPage(this),
            'switch': new switch_1.SwitchPage(this),
            'busy-indicator': new busy_indicator_1.BusyIndicatorPage(this),
            'search-stack': new search_stack_1.SearchStackPage(this),
            breadcrumbs: new breadcrumbs_1.BreadCrumbsPage(this),
            menu: new menu_1.MenuPage(this),
            'button-menu': new button_menu_1.ButtonMenuPage(this)
        };
        /**
         * navigation view
         */
        this.navigation = new navigation_1.Navigation(this);
        /**
         * values used within the template.
         */
        this.values = {
            id: {
                layout: 'layout'
            }
        };
        /**
         * view is the current application view.
         */
        this.view = new app_1.Main(this);
        /**
         * content displayed as the main content.
         */
        this.content = this.pages.home.view;
        /**
         * toggleDrawer
         */
        this.toggleDrawer = function () {
            _this
                .view
                .findById(_this.values.id.layout)
                .map(function (d) { return d.toggleDrawer(); });
        };
        /**
         * navigate is called when the user clicks on a
         * navigation link.
         */
        this.navigate = function (_a) {
            var name = _a.name;
            return _this.route(name);
        };
    }
    /**
     * route the main content based on the passed string.
     */
    App.prototype.route = function (name) {
        console.info('name-> ', name);
        console.info(this.pages.hasOwnProperty(name));
        this.page = name;
        if (this.pages.hasOwnProperty(name))
            this.content = this.pages[name].view;
        this.view.invalidate();
        this.navigation.invalidate();
    };
    /**
     * run the application.
     */
    App.prototype.run = function () {
        var root = document.getElementById('app');
        while (root.lastChild)
            root.removeChild(root.lastChild);
        root.appendChild(this.view.render());
        this.layout = this.view.findById(this.values.id.layout);
        var path = window.location.hash.split('#')[1];
        path = path ? path.split('/').join('') : '';
        this.route(path);
    };
    App.main = function () {
        return new App();
    };
    return App;
}());
exports.App = App;
var w = window;
w.app = App.main();
w.app.run();

},{"./pages/autocomplete":3,"./pages/breadcrumbs":5,"./pages/busy-indicator":7,"./pages/button-menu":9,"./pages/button-select":11,"./pages/checkbox":13,"./pages/date":15,"./pages/home":17,"./pages/list-group":19,"./pages/menu":21,"./pages/panel":23,"./pages/search-stack":25,"./pages/select":27,"./pages/stack":29,"./pages/switch":31,"./pages/table":34,"./pages/tabs":36,"./pages/text-field":38,"./wml/app":40,"./wml/navigation":41}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Page = /** @class */ (function () {
    function Page(app) {
        this.app = app;
    }
    Page.prototype.get = function (id, fn) {
        this
            .view
            .findById(id)
            .map(fn)
            .orJust(function () { return console.warn(id + ": is missing"); });
    };
    return Page;
}());
exports.Page = Page;

},{}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/autocomplete");
var Page_1 = require("../Page");
var AutocompletePage = /** @class */ (function (_super) {
    __extends(AutocompletePage, _super);
    function AutocompletePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: 'search',
            name: 'search',
            results: [
                { label: 'Asus', value: 'Asus' },
                { label: 'MSI', value: 'MSI' },
                { label: 'Gigabyte', value: 'Gigabyte' },
                { label: 'Gigas', value: 'Gigas' },
                { label: 'AsusTek', value: 'AsusTek' },
                { label: 'Asusuga', value: 'Asusuga' },
                { label: 'Qualcomm', value: 'Qualcomm' },
                { label: 'Qualitative', value: 'Qualitatve' },
                { label: 'Asunder', value: 'Asunder' }
            ]
        };
        _this.onSearch = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById(_this.values.id)
                .map(function (s) {
                var hit = _this.values.results.filter(function (c) {
                    return c.value.toLowerCase().startsWith(value) ? true : false;
                });
                s.update(hit);
            });
        };
        _this.onSelect = function (_a) {
            var value = _a.value;
            _this.view.findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value.value));
            });
        };
        return _this;
    }
    return AutocompletePage;
}(Page_1.Page));
exports.AutocompletePage = AutocompletePage;

},{"../Page":2,"./wml/autocomplete":4}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var autocomplete_1 = require("@package/self/control/autocomplete");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(nothing)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(autocomplete_1.Autocomplete, {
                                html: {},
                                wml: {
                                    'id': ___context.values.id
                                },
                                ww: {
                                    'name': ___context.values.name,
                                    'stringifier': function (r) { return r.value; },
                                    'onSearch': ___context.onSearch,
                                    'onSelect': ___context.onSelect
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/autocomplete":57,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var breadcrumbs_1 = require("./wml/breadcrumbs");
var BreadCrumbsPage = /** @class */ (function (_super) {
    __extends(BreadCrumbsPage, _super);
    function BreadCrumbsPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new breadcrumbs_1.Main(_this);
        return _this;
    }
    return BreadCrumbsPage;
}(Page_1.Page));
exports.BreadCrumbsPage = BreadCrumbsPage;

},{"../Page":2,"./wml/breadcrumbs":6}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var BreadCrumbs_1 = require("@package/self/nav/breadcrumbs/BreadCrumbs");
;
var Item_1 = require("@package/self/nav/breadcrumbs/Item");
;
var Link_1 = require("@package/self/nav/link/Link");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(BreadCrumbs_1.BreadCrumbs, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "One"
                                    }
                                }, [], ___view)], ___view), ___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "Two"
                                    }
                                }, [], ___view)], ___view), ___wml.widget(Item_1.Item, {
                                html: {},
                                wml: {}
                            }, [___wml.widget(Link_1.Link, {
                                    html: {},
                                    wml: {},
                                    ww: {
                                        'text': "Three"
                                    }
                                }, [], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/nav/breadcrumbs/BreadCrumbs":133,"@package/self/nav/breadcrumbs/Item":134,"@package/self/nav/link/Link":136,"@quenk/wml":167}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var busy_indicator_1 = require("./wml/busy-indicator");
var Page_1 = require("../Page");
var BusyIndicatorPage = /** @class */ (function (_super) {
    __extends(BusyIndicatorPage, _super);
    function BusyIndicatorPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new busy_indicator_1.Main(_this);
        return _this;
    }
    return BusyIndicatorPage;
}(Page_1.Page));
exports.BusyIndicatorPage = BusyIndicatorPage;

},{"../Page":2,"./wml/busy-indicator":8}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var BusyIndicator_1 = require("@package/self/app/busy-indicator/BusyIndicator");
;
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(BusyIndicator_1.BusyIndicator, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/app/busy-indicator/BusyIndicator":44,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-menu");
var Page_1 = require("../Page");
var ButtonMenuPage = /** @class */ (function (_super) {
    __extends(ButtonMenuPage, _super);
    function ButtonMenuPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onClick = function (msg) { return function (e) {
            e.preventDefault();
            alert(msg);
        }; };
        return _this;
    }
    return ButtonMenuPage;
}(Page_1.Page));
exports.ButtonMenuPage = ButtonMenuPage;

},{"../Page":2,"./wml/button-menu":10}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var button_menu_1 = require("@package/self/menu/button-menu");
;
var menu_1 = require("@package/self/menu");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_menu_1.ButtonMenu, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Click Me"
                                }
                            }, [___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked one")
                                        },
                                        wml: {}
                                    }, [___wml.text("One")], ___view)], ___view), ___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked two")
                                        },
                                        wml: {}
                                    }, [___wml.text("Two")], ___view)], ___view), ___wml.widget(menu_1.MenuItem, {
                                    html: {},
                                    wml: {}
                                }, [___wml.node('a', {
                                        html: {
                                            'href': "#",
                                            'onclick': ___context.onClick("You clicked three")
                                        },
                                        wml: {}
                                    }, [___wml.text("Three")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/menu":128,"@package/self/menu/button-menu":126,"@quenk/wml":167}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/button-select");
var Page_1 = require("../Page");
var ButtonSelectPage = /** @class */ (function (_super) {
    __extends(ButtonSelectPage, _super);
    function ButtonSelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            options: [
                { text: 'Asus', value: 'Asus' },
                { text: 'MSI', value: 'MSI' },
                { text: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        _this.onChange = function (_a) {
            var value = _a.value, name = _a.name;
            _this
                .view
                .findById(name + "-content")
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(String(value)));
            });
        };
        return _this;
    }
    return ButtonSelectPage;
}(Page_1.Page));
exports.ButtonSelectPage = ButtonSelectPage;

},{"../Page":2,"./wml/button-select":12}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var button_select_1 = require("@package/self/control/button-select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "select-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.ButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "select"
                                },
                                ww: {
                                    'name': "select",
                                    'variant': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You can also use MultiButtonSelect instead: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "multi-content"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(button_select_1.MultiButtonSelect, {
                                html: {},
                                wml: {
                                    'id': "multi"
                                },
                                ww: {
                                    'name': "multi",
                                    'variant': "-primary",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/button-select":63,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/checkbox");
var Page_1 = require("../Page");
var CheckboxPage = /** @class */ (function (_super) {
    __extends(CheckboxPage, _super);
    function CheckboxPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return CheckboxPage;
}(Page_1.Page));
exports.CheckboxPage = CheckboxPage;

},{"../Page":2,"./wml/checkbox":14}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Checkbox_1 = require("@package/self/control/checkbox/Checkbox");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The checkbox is "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "content"
                                }
                            }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Checkbox_1.Checkbox, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "checkbox",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/checkbox/Checkbox":67,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var Page_1 = require("../Page");
var DatePage = /** @class */ (function (_super) {
    __extends(DatePage, _super);
    function DatePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value));
            });
        };
        return _this;
    }
    return DatePage;
}(Page_1.Page));
exports.DatePage = DatePage;

},{"../Page":2,"./wml/date":16}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Date_1 = require("@package/self/control/date/Date");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The date is : "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(None selected)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Date_1.Date, {
                                html: {},
                                wml: {
                                    'id': "date"
                                },
                                ww: {
                                    'name': "date",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/date/Date":70,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var home_1 = require("./wml/home");
var HomePage = /** @class */ (function (_super) {
    __extends(HomePage, _super);
    function HomePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new home_1.Main(_this);
        return _this;
    }
    return HomePage;
}(Page_1.Page));
exports.HomePage = HomePage;

},{"../Page":2,"./wml/home":18}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('b', {
                html: {},
                wml: {}
            }, [___wml.text("Index")], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var list_group_1 = require("./wml/list-group");
var ListGroupPage = /** @class */ (function (_super) {
    __extends(ListGroupPage, _super);
    function ListGroupPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new list_group_1.Main(_this);
        return _this;
    }
    return ListGroupPage;
}(Page_1.Page));
exports.ListGroupPage = ListGroupPage;

},{"../Page":2,"./wml/list-group":20}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var list_group_1 = require("@package/self/layout/list-group");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(list_group_1.ListGroup, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('p', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is the first item.")], ___view)], ___view), ___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('b', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is the second item.")], ___view)], ___view), ___wml.widget(list_group_1.ListGroupItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('h3', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("Whoa!")], ___view), ___wml.node('p', {
                                    html: {},
                                    wml: {}
                                }, [___wml.text("This is a third item!")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/layout/list-group":113,"@quenk/wml":167}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var menu_1 = require("./wml/menu");
var MenuPage = /** @class */ (function (_super) {
    __extends(MenuPage, _super);
    function MenuPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        return _this;
    }
    return MenuPage;
}(Page_1.Page));
exports.MenuPage = MenuPage;

},{"../Page":2,"./wml/menu":22}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var menu_1 = require("@package/self/menu");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(menu_1.Menu, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(menu_1.Header, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Heading"
                                }
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {},
                                ww: {
                                    'disabled': true,
                                    'text': "Back"
                                }
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {},
                                ww: {
                                    'text': "Refresh"
                                }
                            }, [], ___view), ___wml.widget(menu_1.Divider, {
                                html: {},
                                wml: {}
                            }, [], ___view), ___wml.widget(menu_1.MenuItem, {
                                html: {},
                                wml: {}
                            }, [___wml.node('a', {
                                    html: {
                                        'href': "#/menu"
                                    },
                                    wml: {}
                                }, [___wml.text("Quit")], ___view)], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/menu":128,"@quenk/wml":167}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var panel_1 = require("./wml/panel");
var PanelPage = /** @class */ (function (_super) {
    __extends(PanelPage, _super);
    function PanelPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new panel_1.Main(_this);
        return _this;
    }
    return PanelPage;
}(Page_1.Page));
exports.PanelPage = PanelPage;

},{"../Page":2,"./wml/panel":24}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Panel_1 = require("@package/self/layout/panel/Panel");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Body only.")], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With Header")], ___view), ___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.widget(Panel_1.Panel, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Panel_1.Header, {
                                html: {},
                                wml: {}
                            }, [___wml.text("With Footer")], ___view), ___wml.widget(Panel_1.Body, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Lorem impsum dilium net set.")], ___view), ___wml.widget(Panel_1.Footer, {
                                html: {},
                                wml: {}
                            }, [___wml.text("Meh foot.")], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/layout/panel/Panel":118,"@quenk/wml":167}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/search-stack");
var Page_1 = require("../Page");
var options = [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' },
    { label: 'Gigas', value: 'Gigas' },
    { label: 'AsusTek', value: 'AsusTek' },
    { label: 'Asusuga', value: 'Asusuga' },
    { label: 'Qualcomm', value: 'Qualcomm' },
    { label: 'Qualitative', value: 'Qualitatve' },
    { label: 'Asunder', value: 'Asunder' }
];
var SearchStackPage = /** @class */ (function (_super) {
    __extends(SearchStackPage, _super);
    function SearchStackPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: 'search',
            name: 'search',
            text: function () { return _this.values.selected.map(function (m) { return m.label; }).join(','); },
            selected: [],
            options: options
        };
        _this.onSearch = function (_a) {
            var value = _a.value;
            _this.view.findById(_this.values.id).map(function (s) {
                return s.update(options.filter(function (s) { return s.value.toLowerCase().startsWith(value.toLowerCase()); }));
            });
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.values.selected = value;
            _this.view.invalidate();
        };
        return _this;
    }
    return SearchStackPage;
}(Page_1.Page));
exports.SearchStackPage = SearchStackPage;

},{"../Page":2,"./wml/search-stack":26}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var SearchStack_1 = require("@package/self/control/search-stack/SearchStack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 6
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "text"
                                }
                            }, [___wml.domify(___context.values.text())], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(SearchStack_1.SearchStack, {
                                html: {},
                                wml: {
                                    'id': ___context.values.id
                                },
                                ww: {
                                    'name': ___context.values.name,
                                    'value': ___context.values.selected,
                                    'decorator': function (r) { return r.label; },
                                    'onChange': ___context.onChange,
                                    'onSearch': ___context.onSearch
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/search-stack/SearchStack":81,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var Page_1 = require("../Page");
var SelectPage = /** @class */ (function (_super) {
    __extends(SelectPage, _super);
    function SelectPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            options: [
                { label: 'Asus', value: 'Asus' },
                { label: 'MSI', value: 'MSI' },
                { label: 'Gigabyte', value: 'Gigabyte' }
            ]
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            _this
                .view
                .findById('selected')
                .map(function (e) {
                while (e.lastChild)
                    e.removeChild(e.lastChild);
                e.appendChild(document.createTextNode(value));
            });
        };
        return _this;
    }
    return SelectPage;
}(Page_1.Page));
exports.SelectPage = SelectPage;

},{"../Page":2,"./wml/select":28}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Select_1 = require("@package/self/control/select/Select");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("You selected: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.text("(None)")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Select_1.Select, {
                                html: {},
                                wml: {
                                    'id': "select"
                                },
                                ww: {
                                    'name': "select",
                                    'options': ___context.values.options,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/select/Select":83,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/stack");
var Page_1 = require("../Page");
var _getValues = function () { return [
    { label: 'Asus', value: 'Asus' },
    { label: 'MSI', value: 'MSI' },
    { label: 'MSI', value: 'MSI' },
    { label: 'Gigabyte', value: 'Gigabyte' }
]; };
var _getText = function (m) { return m.map(function (_a) {
    var label = _a.label;
    return label;
}).join(','); };
var StackPage = /** @class */ (function (_super) {
    __extends(StackPage, _super);
    function StackPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            values: _getValues(),
            text: _getText(_getValues()),
            decorator: function (m) { return m.label; }
        };
        _this.onChange = function (_a) {
            var value = _a.value;
            if (value.length === 0)
                _this.values.values = _getValues();
            _this.values.text = _getText(_this.values.values);
            _this.view.invalidate();
        };
        return _this;
    }
    return StackPage;
}(Page_1.Page));
exports.StackPage = StackPage;

},{"../Page":2,"./wml/stack":30}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var stack_1 = require("@package/self/control/stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {},
                        ww: {
                            'size': 4
                        }
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("Members: "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "selected"
                                }
                            }, [___wml.domify(___context.values.text)], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(stack_1.Stack, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "stack",
                                    'value': ___context.values.values,
                                    'decorator': ___context.values.decorator,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/stack":89,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/switch");
var Page_1 = require("../Page");
var SwitchPage = /** @class */ (function (_super) {
    __extends(SwitchPage, _super);
    function SwitchPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.value = true;
        _this.onChange = function (_a) {
            var value = _a.value;
            _this.view.findById('content')
                .map(function (e) {
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.appendChild(document.createTextNode(value === true ?
                    'on' :
                    (value === false ? 'off' : 'error')));
            });
        };
        return _this;
    }
    return SwitchPage;
}(Page_1.Page));
exports.SwitchPage = SwitchPage;

},{"../Page":2,"./wml/switch":32}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Switch_1 = require("@package/self/control/switch/Switch");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The switch is "), ___wml.node('b', {
                                html: {},
                                wml: {
                                    'id': "content"
                                }
                            }, [___wml.text("untouched")], ___view), ___wml.text(".")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Switch_1.Switch, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "switch",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/switch/Switch":91,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.users = [
    {
        "_id": "59f1334ccc21ff728cf7f3ce",
        "index": 0,
        "guid": "fd94cd52-e7f1-44ab-a74f-05604eee46dd",
        "isActive": false,
        "balance": "$2,849.93",
        "picture": "http://placehold.it/32x32",
        "age": 34,
        "eyeColor": "green",
        "name": "Johns Lewis",
        "gender": "male",
        "company": "PROFLEX",
        "email": "johnslewis@proflex.com",
        "phone": "+1 (925) 409-3400",
        "address": "874 Grove Street, Edgewater, Georgia, 8112",
        "about": "Ex esse dolore et sint sint proident nostrud ut officia. Do nulla mollit dolore ut aute excepteur deserunt laboris ut proident. Ullamco est deserunt ex commodo veniam duis elit excepteur velit ullamco deserunt culpa do est.\r\n",
        "registered": "2015-02-22T10:25:32 +04:00",
        "latitude": 56.278862,
        "longitude": -79.459101,
        "tags": [
            "labore",
            "proident",
            "aliqua",
            "amet",
            "amet",
            "officia",
            "enim"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Mason Noble"
            },
            {
                "id": 1,
                "name": "Coffey Mendez"
            },
            {
                "id": 2,
                "name": "Dionne Cole"
            }
        ],
        "greeting": "Hello, Johns Lewis! You have 5 unread messages.",
        "favoriteFruit": "banana"
    },
    {
        "_id": "59f1334c09dc1bcdc5732491",
        "index": 1,
        "guid": "33255995-0431-4271-9876-37eabc117a7b",
        "isActive": false,
        "balance": "$2,167.40",
        "picture": "http://placehold.it/32x32",
        "age": 23,
        "eyeColor": "blue",
        "name": "Williamson Gregory",
        "gender": "male",
        "company": "NETAGY",
        "email": "williamsongregory@netagy.com",
        "phone": "+1 (910) 462-3918",
        "address": "158 Sedgwick Street, Glasgow, Utah, 5498",
        "about": "Excepteur sit nisi et velit. Laboris minim id duis ad qui cupidatat. Est Lorem quis duis Lorem laboris velit laboris non excepteur et velit voluptate qui. Dolore qui anim exercitation veniam incididunt laboris labore. Id minim labore amet sunt excepteur tempor proident.\r\n",
        "registered": "2016-04-25T04:25:24 +04:00",
        "latitude": 54.457833,
        "longitude": 122.803765,
        "tags": [
            "tempor",
            "exercitation",
            "et",
            "elit",
            "ex",
            "cillum",
            "laboris"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Navarro Reeves"
            },
            {
                "id": 1,
                "name": "Stanton Vincent"
            },
            {
                "id": 2,
                "name": "Alexis Guzman"
            }
        ],
        "greeting": "Hello, Williamson Gregory! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334c9d799789bc494a3c",
        "index": 2,
        "guid": "158ffa5d-15da-4a9f-a1da-0a48b76b8226",
        "isActive": false,
        "balance": "$1,289.35",
        "picture": "http://placehold.it/32x32",
        "age": 33,
        "eyeColor": "green",
        "name": "Dalton House",
        "gender": "male",
        "company": "EYEWAX",
        "email": "daltonhouse@eyewax.com",
        "phone": "+1 (959) 550-2263",
        "address": "116 Howard Avenue, Rossmore, New York, 6302",
        "about": "Elit eu ipsum pariatur duis mollit ex quis. Amet nulla exercitation laboris minim fugiat tempor in aliqua nisi nostrud aute. Duis minim esse irure irure fugiat sit nulla et tempor nisi cillum proident id adipisicing. Eu elit magna Lorem irure labore. Aliquip id sint veniam adipisicing. Amet eiusmod mollit reprehenderit reprehenderit dolore.\r\n",
        "registered": "2017-02-28T08:53:00 +04:00",
        "latitude": -25.679774,
        "longitude": 29.374781,
        "tags": [
            "qui",
            "cillum",
            "anim",
            "irure",
            "non",
            "commodo",
            "deserunt"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Carmela Wilcox"
            },
            {
                "id": 1,
                "name": "Elba Garza"
            },
            {
                "id": 2,
                "name": "Garrison Church"
            }
        ],
        "greeting": "Hello, Dalton House! You have 1 unread messages.",
        "favoriteFruit": "apple"
    },
    {
        "_id": "59f1334cd1518c3a44d69fff",
        "index": 3,
        "guid": "5109bc50-9a8e-4184-aba0-6740dc00b606",
        "isActive": true,
        "balance": "$3,891.83",
        "picture": "http://placehold.it/32x32",
        "age": 22,
        "eyeColor": "blue",
        "name": "Ray Wilkins",
        "gender": "male",
        "company": "EXPOSA",
        "email": "raywilkins@exposa.com",
        "phone": "+1 (812) 414-3258",
        "address": "837 Bedford Avenue, Harleigh, South Carolina, 2323",
        "about": "Est amet quis eu proident ipsum veniam sit. Irure labore ad consectetur ullamco sit ipsum proident. Ad pariatur irure nisi irure commodo aliquip nisi eu anim irure dolor dolor veniam quis.\r\n",
        "registered": "2015-09-17T04:52:42 +04:00",
        "latitude": 34.354801,
        "longitude": -168.303952,
        "tags": [
            "nisi",
            "laboris",
            "incididunt",
            "amet",
            "aute",
            "quis",
            "mollit"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Olivia Russo"
            },
            {
                "id": 1,
                "name": "Rita Tyler"
            },
            {
                "id": 2,
                "name": "Lorie Walker"
            }
        ],
        "greeting": "Hello, Ray Wilkins! You have 1 unread messages.",
        "favoriteFruit": "strawberry"
    },
    {
        "_id": "59f1334c6901bda003e52fa6",
        "index": 4,
        "guid": "0ab33477-b152-4b12-af35-f5b9254d5c2a",
        "isActive": true,
        "balance": "$3,730.71",
        "picture": "http://placehold.it/32x32",
        "age": 27,
        "eyeColor": "brown",
        "name": "Madden Hatfield",
        "gender": "male",
        "company": "ZOGAK",
        "email": "maddenhatfield@zogak.com",
        "phone": "+1 (832) 552-2294",
        "address": "530 Clermont Avenue, Bethpage, Virgin Islands, 5607",
        "about": "Commodo tempor anim tempor deserunt laboris qui eu reprehenderit consequat. Non laborum ullamco qui proident. Est cupidatat do dolor excepteur est nostrud laborum. Eu excepteur ex commodo aliquip adipisicing excepteur. Et reprehenderit laboris reprehenderit aute ut excepteur deserunt nostrud velit. Ullamco est sit fugiat irure aliqua aliquip proident. Voluptate ad culpa dolor id enim tempor laborum.\r\n",
        "registered": "2016-04-10T03:37:17 +04:00",
        "latitude": 80.888876,
        "longitude": 117.84337,
        "tags": [
            "occaecat",
            "nisi",
            "est",
            "ad",
            "nostrud",
            "eu",
            "dolore"
        ],
        "friends": [
            {
                "id": 0,
                "name": "Vincent Gay"
            },
            {
                "id": 1,
                "name": "Rosario Forbes"
            },
            {
                "id": 2,
                "name": "Baxter Green"
            }
        ],
        "greeting": "Hello, Madden Hatfield! You have 4 unread messages.",
        "favoriteFruit": "banana"
    }
];

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Page_1 = require("../Page");
var table_1 = require("./wml/table");
var data_1 = require("./data");
var columns = [
    { name: 'index', heading: '#' },
    { name: 'name', heading: 'Name' },
    { name: 'balance', heading: 'Balance' }
];
var TablePage = /** @class */ (function (_super) {
    __extends(TablePage, _super);
    function TablePage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new table_1.Main(_this);
        _this.values = {
            users: data_1.users,
            columns: columns,
            onCellClicked: function (e) {
                var span = document.createElement('span');
                span.appendChild(document.createTextNode("You clicked " + e.column + e.rowNumber + "!"));
                e.cell.setContent({ render: function () { return span; } });
            }
        };
        return _this;
    }
    return TablePage;
}(Page_1.Page));
exports.TablePage = TablePage;

},{"../Page":2,"./data":33,"./wml/table":35}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Table_1 = require("@package/self/table/Table");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(Table_1.Table, {
                            html: {},
                            wml: {},
                            ww: {
                                'selectable': true,
                                'data': ___context.values.users,
                                'columns': ___context.values.columns,
                                'onCellClicked': ___context.values.onCellClicked
                            }
                        }, [], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/grid/Grid":109,"@package/self/table/Table":160,"@quenk/wml":167}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/tabs");
var Page_1 = require("../Page");
var TabsPage = /** @class */ (function (_super) {
    __extends(TabsPage, _super);
    function TabsPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.tab = 'First';
        _this.content = 'First Tab';
        _this.clicked = function (_a) {
            var name = _a.name;
            _this.tab = name;
            _this.content = name + " Tab";
            _this.view.invalidate();
        };
        return _this;
    }
    return TabsPage;
}(Page_1.Page));
exports.TabsPage = TabsPage;

},{"../Page":2,"./wml/tabs":37}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var Tabs_1 = require("@package/self/control/tabs/Tabs");
;
var Tab_1 = require("@package/self/control/tabs/Tab");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.widget(Tabs_1.Tabs, {
                            html: {},
                            wml: {}
                        }, [___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "First"),
                                    'text': "First",
                                    'name': "First",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view), ___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "Second"),
                                    'text': "Second",
                                    'name': "Second",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view), ___wml.widget(Tab_1.Tab, {
                                html: {},
                                wml: {},
                                ww: {
                                    'active': (___context.tab === "Third"),
                                    'text': "Third",
                                    'name': "Third",
                                    'onClick': ___context.clicked
                                }
                            }, [], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {
                                'id': "content"
                            }
                        }, [___wml.domify(___context.content)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/tabs/Tab":94,"@package/self/control/tabs/Tabs":96,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var Page_1 = require("../Page");
var TextFieldPage = /** @class */ (function (_super) {
    __extends(TextFieldPage, _super);
    function TextFieldPage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.id = 'text';
        _this.view = new views.Main(_this);
        _this.onChange = function (_a) {
            var value = _a.value;
            (value === 'invalid') ?
                _this.get(_this.id, function (c) {
                    return c.setError('This control is now invalid!');
                }) :
                (value === 'valid') ?
                    _this.get(_this.id, function (c) {
                        return c.setSuccess('This control is now valid!');
                    }) :
                    (value === 'warn') ?
                        _this.get(_this.id, function (c) {
                            return c.setWarning('This control now has a warning!');
                        }) :
                        (value === 'reset') ?
                            _this.get(_this.id, function (c) {
                                return c.reset();
                            }) :
                            _this
                                .view
                                .findById('content')
                                .map(function (e) {
                                while (e.lastChild)
                                    e.removeChild(e.lastChild);
                                e.appendChild(document.createTextNode(value));
                            });
        };
        return _this;
    }
    return TextFieldPage;
}(Page_1.Page));
exports.TextFieldPage = TextFieldPage;

},{"../Page":2,"./wml/text-field":39}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid_1 = require("@package/self/layout/grid/Grid");
;
var TextField_1 = require("@package/self/control/text-field/TextField");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Grid_1.Grid, {
                html: {},
                wml: {}
            }, [___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The value of the input is:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {
                                'id': "content"
                            }
                        }, [___wml.domify("(Nothing)")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {
                                    'id': "text"
                                },
                                ww: {
                                    'name': "text",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Success")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'success': "This textfield has a success",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Warning")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'warning': "This textfield has a warning.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.node('strong', {
                                html: {},
                                wml: {}
                            }, [___wml.text("Error")], ___view)], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'error': "This textfield has an error.",
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view), ___wml.widget(Grid_1.Row, {
                    html: {},
                    wml: {}
                }, [___wml.widget(Grid_1.Column, {
                        html: {},
                        wml: {}
                    }, [___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.text("The one uses rows to render a text area:")], ___view), ___wml.node('p', {
                            html: {},
                            wml: {}
                        }, [___wml.widget(TextField_1.TextField, {
                                html: {},
                                wml: {},
                                ww: {
                                    'name': "text",
                                    'rows': 3,
                                    'onChange': ___context.onChange
                                }
                            }, [], ___view)], ___view)], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/text-field/TextField":99,"@package/self/layout/grid/Grid":109,"@quenk/wml":167}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Drawer_1 = require("@package/self/layout/drawer/Drawer");
;
var ActionBar_1 = require("@package/self/app/action-bar/ActionBar");
;
;
var IconButton_1 = require("@package/self/control/icon-button/IconButton");
;
var dash_1 = require("@package/self/app/dash");
;
var Main_1 = require("@package/self/layout/main/Main");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Drawer_1.Drawer, {
                html: {},
                wml: {
                    'id': ___context.values.id.layout
                },
                ww: {
                    'drawer': ___context.navigation
                }
            }, [___wml.widget(ActionBar_1.ActionBar, {
                    html: {},
                    wml: {}
                }, [___wml.widget(IconButton_1.IconButton, {
                        html: {},
                        wml: {},
                        ww: {
                            'onClick': ___context.toggleDrawer
                        }
                    }, [___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view), ___wml.widget(dash_1.Dash, {
                            html: {},
                            wml: {}
                        }, [], ___view)], ___view)], ___view), ___wml.widget(Main_1.Main, {
                    html: {},
                    wml: {}
                }, [___wml.domify(___context.content.render())], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/app/action-bar/ActionBar":42,"@package/self/app/dash":47,"@package/self/control/icon-button/IconButton":73,"@package/self/layout/drawer/Drawer":105,"@package/self/layout/main/Main":116,"@quenk/wml":167}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var menu_1 = require("@package/self/nav/menu");
var Navigation = /** @class */ (function (_super) {
    __extends(Navigation, _super);
    function Navigation(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(menu_1.Menu, {
                html: {},
                wml: {}
            }, [___wml.widget(menu_1.Link, {
                    html: {},
                    wml: {
                        'group': "links"
                    },
                    ww: {
                        'active': (___context.page === "home"),
                        'name': "home",
                        'href': "#",
                        'onClick': ___context.navigate,
                        'text': "Home"
                    }
                }, [], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Layout"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "panel",
                            'href': "#/panel",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "panel"),
                            'text': "Panels"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "list-group",
                            'href': "#/list-group",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "list-group"),
                            'text': "List Group"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Table"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "table",
                            'href': "#/table",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "table"),
                            'text': "Table"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Control"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "text-field",
                            'href': "#/text-field",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "text-field"),
                            'text': "Text Field"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "date",
                            'href': "#/date",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "date"),
                            'text': "Date"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "select",
                            'href': "#/select",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "select"),
                            'text': "Select"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "autocomplete",
                            'href': "#/autocomplete",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "autocomplete"),
                            'text': "Autocomplete"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "button-select",
                            'href': "#/button-select",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "button-select"),
                            'text': "Button Select"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "checkbox",
                            'href': "#/checkbox",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "checkbox"),
                            'text': "Checkbox"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "switch",
                            'href': "#/switch",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "switch"),
                            'text': "Switch"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "tabs",
                            'href': "#/tabs",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "tabs"),
                            'text': "Tabs"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "stack",
                            'href': "#/stack",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "stack"),
                            'text': "Stack"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "search-stack",
                            'href': "#/search-stack",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "search-stack"),
                            'text': "Search Stack"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "App"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "busy-indicator",
                            'href': "#/busy-indicator",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "busy-indicator"),
                            'text': "Busy Indicator"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Nav"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "breadcrumbs",
                            'href': "#/breadcrumbs",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "breadcrumbs"),
                            'text': "BreadCrumbs"
                        }
                    }, [], ___view)], ___view), ___wml.widget(menu_1.Header, {
                    html: {},
                    wml: {},
                    ww: {
                        'text': "Menu"
                    }
                }, [], ___view), ___wml.widget(menu_1.SubMenu, {
                    html: {},
                    wml: {}
                }, [___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "menu",
                            'href': "#/menu",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "menu"),
                            'text': "Menu"
                        }
                    }, [], ___view), ___wml.widget(menu_1.Link, {
                        html: {},
                        wml: {
                            'group': "links"
                        },
                        ww: {
                            'name': "button-menu",
                            'href': "#/button-menu",
                            'onClick': ___context.navigate,
                            'active': (___context.page === "button-menu"),
                            'text': "Button Menu"
                        }
                    }, [], ___view)], ___view)], ___view);
        };
        return _this;
    }
    return Navigation;
}(___wml.AppView));
exports.Navigation = Navigation;

},{"@package/self/nav/menu":146,"@quenk/wml":167}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
var action_bar_1 = require("./wml/action_bar");
/**
 * ActionBar provides a bar across the screen that can be
 * used as a toolbar, navigation menu or something simillar.
 */
var ActionBar = /** @class */ (function (_super) {
    __extends(ActionBar, _super);
    function ActionBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new action_bar_1.Main(_this);
        _this.values = {
            id: {
                content: 'content'
            },
            class: {
                root: util.combine([names.ACTION_BAR, names.FIXED_PUSHABLE]),
                content: names.ACTION_BAR_CONTENT
            }
        };
        return _this;
    }
    return ActionBar;
}(Group_1.Group));
exports.ActionBar = ActionBar;

},{"./wml/action_bar":43,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.class.content
                    },
                    wml: {
                        'id': ___context.values.id.content
                    }
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var busy_indicator_1 = require("./wml/busy_indicator");
var util_1 = require("@package/self/common/util");
/**
 * BusyIndicator provides a 'hamburger' menu button.
 */
var BusyIndicator = /** @class */ (function (_super) {
    __extends(BusyIndicator, _super);
    function BusyIndicator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new busy_indicator_1.Main(_this);
        _this.values = {
            class: util_1.concat('loading', _this.attrs.ww ? _this.attrs.ww.class : '')
        };
        return _this;
    }
    return BusyIndicator;
}(wml.Component));
exports.BusyIndicator = BusyIndicator;

},{"./wml/busy_indicator":45,"@package/self/common/util":50,"@quenk/wml":167}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var dash_1 = require("./wml/dash");
/**
 * Dash are literal horizontal dashes.
 *
 * These can be used with app/menu/Button to create 'hamburger' menus.
 */
var Dash = /** @class */ (function (_super) {
    __extends(Dash, _super);
    function Dash() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new dash_1.Main(_this);
        _this.values = {
            class: {
                root: names.DASH
            }
        };
        return _this;
    }
    return Dash;
}(wml_1.Component));
exports.Dash = Dash;

},{"./wml/dash":48,"@package/self/common/names":49,"@quenk/wml":167}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Dash_1 = require("./Dash");
exports.Dash = Dash_1.Dash;

},{"./Dash":46}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('span', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HIDDEN indicates an element should be hidden from sight.
 */
exports.HIDDEN = '-hidden';
/**
 * DISABLED indicates an element should appear to be inaccesible
 */
exports.DISABLED = '-disabled';
/**
 * ON indicates an 'on' state.
 */
exports.ON = '-on';
/**
 * OFF indicates an 'off' state.
 */
exports.OFF = '-off';
/**
 * open indicates an open state in collapsable widgets
 */
exports.OPEN = '-open';
/**
 * PUSHABLE is used by other styles to move an element around.
 */
exports.PUSHABLE = '-pushable';
/**
 * FIXED_PUSHABLE is like PUSHABLE but used for fixed elements.
 */
exports.FIXED_PUSHABLE = '-fixed-pushable';
/**
 * NO_HOVER indicates hover effects should be disabled.
 */
exports.NO_HOVER = '-no-hover';
/**
 * DEFAULT style modifier.
 */
exports.DEFAULT = '-default';
/**
 * PRIMARY style modifier.
 */
exports.PRIMARY = '-primary';
/**
 * SUCCESS style modifier.
 */
exports.SUCCESS = '-success';
/**
 * INFO style modifier.
 */
exports.INFO = '-info';
/**
 * WARNING style modifier.
 */
exports.WARNING = '-warning';
/**
 * DANGER style modifier.
 */
exports.DANGER = '-danger';
exports.LARGE = '-large';
exports.SMALL = '-small';
exports.EXTRA_SMALL = '-extra-small';
exports.ACTIVE = 'active'; //@todo: refactor to flag syntax
exports.DRAWER = 'ww-drawer-layout';
exports.ASIDE = 'ww-drawer';
exports.ASIDE_CONTENT = 'ww-drawer__content';
exports.ASIDE_PUSHABLE = '-drawer-pushable';
exports.ASIDE_PUSHABLE_FIXED = '-drawer-pushable-fixed';
/**
 * ACTION_BAR class name. for the ActionBar root.
 */
exports.ACTION_BAR = 'ww-action-bar';
/**
 * ACTION_BAR_CONTENT class name.
 */
exports.ACTION_BAR_CONTENT = 'ww-action-bar__content';
/**
 * ICON_BUTTON clasess for IconButtons.
 */
exports.ICON_BUTTON = 'ww-icon-button';
/**
 * BUTTON_MENU class name.
 */
exports.BUTTON_MENU = 'ww-button-menu btn-group';
/**
 * BUTTON_MENU_BUTTON class name.
 */
exports.BUTTON_MENU_BUTTON = exports.BUTTON_MENU + "__button";
/**
 * BUTTON_MENU_MENU class name.
 */
exports.BUTTON_MENU_MENU = exports.BUTTON_MENU_BUTTON + "__menu";
/**
 * BUTTON_SELECT
 */
exports.BUTTON_SELECT = 'btn-group';
exports.BUTTON_SELECT_OPTION = exports.BUTTON_SELECT + "__option btn";
exports.MAIN_VIEW = 'ww-main-view';
/**
 * MENU class name.
 */
exports.MENU = 'ww-menu';
/**
 * MENU_ITEM class name.
 */
exports.MENU_ITEM = exports.MENU + "__item";
/**
 * MENU_HEADER class name.
 */
exports.MENU_HEADER = exports.MENU + "__header";
/**
 * MENU_DIVIDER class name.
 */
exports.MENU_DIVIDER = exports.MENU + "__divider";
/**
 * DASH class name.
 */
exports.DASH = 'ww-dash';
/**
 * NAV class name.
 */
exports.NAV = 'ww-nav';
/**
 * NAV_LINK class name.
 */
exports.NAV_LINK = 'ww-nav-link';
/**
 * NAV_MENU class name.
 */
exports.NAV_MENU = 'ww-nav-menu';
/**
 * NAV_MENU_ITEM class name.
 */
exports.NAV_MENU_ITEM = 'ww-nav-menu__item';
/**
 * NAV_MENU_HEADER class name.
 */
exports.NAV_MENU_HEADER = 'ww-nav-menu__header';
/**
 * NAV_MENU_LINK class name.
 */
exports.NAV_MENU_LINK = 'ww-nav-menu__link';
/**
 * NAV_MENU_SUBMENU class name.
 */
exports.NAV_MENU_SUBMENU = 'ww-nav-menu__submenu';
exports.BUTTON = 'ww-button';
exports.BUTTON_GROUP = 'ww-button-group';
//@todo: refactor this to be inline with other class names
exports.GRID = 'container-fluid';
exports.GRID_COLUMN = 'ww-grid-column';
exports.GRID_ROW = 'row';
/**
 * PANEL wrapper class.
 */
exports.PANEL = 'ww-panel';
/**
 * PANEL_HEADER class name.
 */
exports.PANEL_HEADER = 'ww-panel__header';
/**
 * PANEL_BODY class name.
 */
exports.PANEL_BODY = 'ww-panel__body';
/**
 * PANEL_FOOTER class name.
 */
exports.PANEL_FOOTER = 'ww-panel__footer';
/**
 * HEADER class name.
 */
exports.HEADER = 'ww-header';
exports.MODAL = 'ww-modal';
exports.MODAL_DIALOG = 'ww-modal__dialog';
exports.MODAL_CONTENT = 'ww-modal__content';
exports.MODAL_HEADER = 'ww-modal__header';
exports.MODAL_BODY = 'ww-modal__body';
exports.MODAL_FOOTER = 'ww-moadl__footer';
exports.FORM_GROUP = 'form-group';
exports.CONTROL_LABEL = 'control-label';
exports.INPUT = 'form-control';
exports.TEXTAREA = 'form-control';
exports.SELECT = 'form-control';
/**
 * TABS class name.
 */
exports.TABS = 'ww-tabs';
/**
 * TABS_TAB class name.
 */
exports.TABS_TAB = 'ww-tabs__tab';
/**
 * SWITCH class name.
 */
exports.SWITCH = 'ww-switch';
/**
 * SWITCH_SLIDER class name.
 */
exports.SWITCH_SLIDER = 'ww-switch__slider';
/**
 * CHECKBOX class name.
 */
exports.CHECKBOX = 'checkbox';
exports.TABLE = 'table'; //@todo un-bootstrap
/**
 * BREAD_CRUMBS clasess
 */
exports.BREAD_CRUMBS = 'breadcrumb'; //@todo un-bootstrap
/**
 * BREAD_CRUMBS_ITEM class name.
 */
exports.BREAD_CRUMBS_ITEM = exports.BREAD_CRUMBS + "__item";
exports.LIST = 'ww-list';
exports.LIST_ITEM = 'ww-list__item';
/**
 * SEARCH class name.
 */
exports.SEARCH = 'ww-search';
/**
 * SEARCH_INPUT class name.
 */
exports.SEARCH_INPUT = 'ww-search__input';
/**
 * DATE class name.
 */
exports.DATE = 'ww-date';
/**
 * DATE_DAY class name.
 */
exports.DATE_DAY = exports.DATE + "__day";
/**
 * DATE_MONTH class name.
 */
exports.DATE_MONTH = exports.DATE + "_month";
/**
 * DATE_YEAR class name.
 */
exports.DATE_YEAR = exports.DATE + "__year";
/**
 * STACK class name.
 */
exports.STACK = 'ww-stack';
/**
 * STACK_CLOSE class name.
 */
exports.STACK_CLOSE = exports.STACK + "__close";
/**
 * STACK_MEMBER class name.
 */
exports.STACK_MEMBER = exports.STACK + "__member";
/**
 * SEARCH_STACK class name.
 */
exports.SEARCH_STACK = 'ww-search-stack';
/**
 * LIST_GROUP class name.
 */
exports.LIST_GROUP = 'list-group';
/**
 * LIST_GROUP_ITEM class name.
 */
exports.LIST_GROUP_ITEM = 'list-group-item';

},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * combine the members of an array into one string.
 */
exports.combine = function (str, joiner) {
    if (joiner === void 0) { joiner = ' '; }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(joiner);
};
/**
 * concat joins various strings together to form an html class attribute value.
 *
 * Removes empty strings, null and undefined values.
 */
exports.concat = function () {
    var str = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        str[_i] = arguments[_i];
    }
    return str.filter(function (s) { return ((s != null) || s != ''); }).join(' ');
};
/**
 * noop
 */
exports.noop = function () { };
/**
 * replaceContent
 */
exports.replaceContent = function (r, node) {
    while (node.lastChild)
        node.removeChild(node.lastChild);
    node.appendChild(r.render());
};
/**
 * debounce a function so that it is only called once after
 * a period of time.
 */
exports.debounce = function (f, delay) {
    var timer = null;
    return delay === 0 ? f : function (a) {
        if (!timer) {
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
        else {
            clearTimeout(timer);
            timer = window.setTimeout(function () { return f(a); }, delay);
        }
    };
};

},{}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Group is an abstract class providing an api for
 * widgets whose primary purpose is displaying content.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * setContent changes the content value.
     */
    Group.prototype.setContent = function (content) {
        this.content = content;
        this.view.invalidate();
        return this;
    };
    /**
     * removeContent removes existing content.
     */
    Group.prototype.removeContent = function () {
        this.content = null;
        return this;
    };
    return Group;
}(wml_1.Component));
exports.Group = Group;

},{"@quenk/wml":167}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml_1 = require("@quenk/wml");
/**
 * Control
 */
var Control = /** @class */ (function (_super) {
    __extends(Control, _super);
    function Control() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Control;
}(wml_1.Component));
exports.Control = Control;

},{"@quenk/wml":167}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * DefaultDelegate fowards all events to their corresponding
 * function handlers, specifed on the attributes of a control.
 */
var DefaultDelegate = /** @class */ (function () {
    function DefaultDelegate(attrs) {
        var _this = this;
        this.attrs = attrs;
        this.onInput = function (e) {
            return _this.attrs.onInput ? _this.attrs.onInput(e) : null;
        };
        this.onChange = function (e) {
            return _this.attrs.onChange ? _this.attrs.onChange(e) : null;
        };
    }
    return DefaultDelegate;
}());
exports.DefaultDelegate = DefaultDelegate;

},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Event is the parent class of all events generated by controls.
 */
var Event = /** @class */ (function () {
    function Event(name, value) {
        this.name = name;
        this.value = value;
    }
    return Event;
}());
exports.Event = Event;

},{}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Control_1 = require("./Control");
var DefaultDelegate_1 = require("./DefaultDelegate");
var INPUT_SUCCESS = 'has-success';
var INPUT_ERROR = 'has-error';
var INPUT_WARNING = 'has-warning';
var FormControl = /** @class */ (function (_super) {
    __extends(FormControl, _super);
    function FormControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new DefaultDelegate_1.DefaultDelegate(_this.attrs.ww);
        return _this;
    }
    /**
     * isFilled
     */
    //   abstract isFilled(): boolean;
    /**
     * clear
     */
    // abstract clear(): FormControl<V, A>;
    /**
     * isRequired tells if the Input was required.
     * @deprecated
     */
    FormControl.prototype.isRequired = function () {
        return (this.attrs.ww.required);
    };
    /**
     * hasClass queries whether a class exists on the root element on not.
     */
    FormControl.prototype.hasClass = function (cls) {
        return this
            .view
            .findById(this.values.root.id)
            .cata(function () { return false; }, (function (e) {
            return e.className.split(' ').indexOf(cls) === -1;
        }));
    };
    FormControl.prototype.hasError = function () {
        return this.hasClass(INPUT_ERROR);
    };
    FormControl.prototype.hasWarning = function () {
        return this.hasClass(INPUT_WARNING);
    };
    FormControl.prototype.hasSuccess = function () {
        return this.hasClass(INPUT_SUCCESS);
    };
    /**
     * setHelpText sets the message for the message portion of
     * this input.
     */
    FormControl.prototype.setHelpText = function (msg) {
        var _this = this;
        return this
            .view
            .findById(this.values.help.id)
            .map(function (message) {
            var node = document.createTextNode(msg);
            if (message.firstChild) {
                message.replaceChild(node, message.firstChild);
            }
            else {
                message.appendChild(node);
            }
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    FormControl.prototype.setState = function (state) {
        var _this = this;
        return this
            .view
            .findById(this.values.root.id)
            .map(function (e) { return e.classList.add(state); })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * removeState removes the state validation state from the input.
     */
    FormControl.prototype.removeState = function () {
        var _this = this;
        return this
            .view
            .findById(this.values.root.id)
            .map(function (h) {
            h.classList.remove(INPUT_SUCCESS);
            h.classList.remove(INPUT_ERROR);
            h.classList.remove(INPUT_WARNING);
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * state
     */
    FormControl.prototype.state = function () {
        return this.attrs.ww.success ?
            'has-success' :
            this.attrs.ww.error ?
                'has-error' :
                this.attrs.ww.warning ?
                    'has-warning' :
                    '';
    };
    /**
     * setSuccess
     */
    FormControl.prototype.setSuccess = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_SUCCESS);
    };
    /**
     * setError
     */
    FormControl.prototype.setError = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_ERROR);
    };
    /**
     * setWarning
     */
    FormControl.prototype.setWarning = function (message) {
        return this
            .removeState()
            .setHelpText(message)
            .setState(INPUT_WARNING);
    };
    /**
     * reset
     */
    FormControl.prototype.reset = function () {
        var _this = this;
        return this
            .view
            .findById(this.values.help.id)
            .map(function (m) {
            _this.removeState();
            while (m.firstChild)
                m.removeChild(m.firstChild);
            //  this.clear();
        })
            .cata(function () { return _this; }, function () { return _this; });
    };
    /**
     * rendered checks if the input should have a validation state set
     */
    FormControl.prototype.rendered = function () {
        var _a = this.attrs.ww, success = _a.success, error = _a.error, warning = _a.warning;
        if (success)
            this.setSuccess((typeof success === 'string') ? success : '');
        else if (error)
            this.setError((typeof error === 'string') ? error : '');
        else if (warning)
            this.setWarning((typeof warning === 'string') ? warning : '');
    };
    return FormControl;
}(Control_1.Control));
exports.FormControl = FormControl;

},{"./Control":52,"./DefaultDelegate":53}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/autocomplete");
var util_1 = require("@package/self/common/util");
var lurch_1 = require("@package/self/control/lurch");
exports.ESCAPE = 27;
exports.INPUT_ID = 'input';
/**
 * Autocomplate provides an input with a dropdown menu that allows
 * the user to search and select form a list of options.
 */
var Autocomplete = /** @class */ (function (_super) {
    __extends(Autocomplete, _super);
    function Autocomplete() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.template = {
            populated: (_this.attrs.ww.populated) ?
                _this.attrs.ww.populated : views.populated,
            empty: (_this.attrs.ww.empty) ?
                _this.attrs.ww.empty : views.empty
        };
        _this.values = {
            id: {
                root: 'root',
                input: 'input',
                menu: 'menu',
                message: 'mesage',
            },
            class: {
                root: '',
                input: ''
            },
            root: {
                id: 'root',
                class: util_1.concat(names.SEARCH, _this.attrs.ww.class)
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            menu: {
                id: 'menu'
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            input: {
                id: 'input',
                class: util_1.concat('form-control', _this.attrs.ww.inputClass),
                placeholder: _this.attrs.ww.placeholder ?
                    _this.attrs.ww.placeholder : null,
                onKeyDown: _this.onKeyDown,
                onKeyUp: _this.onKeyUp,
                onInput: _this.onInput
            },
            search: {
                delay: _this.attrs.ww.debounce ?
                    _this.attrs.ww.debounce : _this.DEFAULT_DEBOUNCE_TIME,
                results: []
            },
            item: {
                template: _this.template,
                stringify: _this.attrs.ww.stringifier ?
                    _this.attrs.ww.stringifier : _this.stringify,
                click: function (index) {
                    _this
                        .close()
                        .delegate
                        .onSelect(new lurch_1.ItemSelectedEvent(_this.attrs.ww.name, _this.values.search.results[Number(index)]));
                }
            }
        };
        return _this;
    }
    Autocomplete.prototype.clear = function () {
        return this;
    };
    Autocomplete.prototype.open = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.show(); });
        return this;
    };
    Autocomplete.prototype.close = function () {
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.hide(); });
        return this;
    };
    Autocomplete.prototype.update = function (results) {
        var _this = this;
        this.values.search.results = results;
        this
            .view
            .findById(this.values.id.menu)
            .map(function (m) { return m.setContent(new views.Results(_this)).show(); });
        return this;
    };
    return Autocomplete;
}(lurch_1.SearchControl));
exports.Autocomplete = Autocomplete;

},{"./wml/autocomplete":58,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control/lurch":80}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Autocomplete_1 = require("./Autocomplete");
exports.Autocomplete = Autocomplete_1.Autocomplete;
var lurch_1 = require("@package/self/control/lurch");
exports.ItemSelectedEvent = lurch_1.ItemSelectedEvent;
exports.TermChangedEvent = lurch_1.TermChangedEvent;

},{"./Autocomplete":56,"@package/self/control/lurch":80}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Menu_1 = require("@package/self/menu/Menu");
;
var MenuItem_1 = require("@package/self/menu/MenuItem");
;
var Fragment_1 = require("@package/self/layout/fragment/Fragment");
;
;
var wml_1 = require("@package/self/control/wml");
exports.populated = function (option, _index, _options) { return function (___context) { return function (___view) { return ___wml.domify(___context.values.item.stringify(option)); }; }; };
;
exports.empty = function () { return function (___context) { return function (___view) { return ___wml.domify("No results to display."); }; }; };
;
var Results = /** @class */ (function (_super) {
    __extends(Results, _super);
    function Results(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [___wml.map(___context.values.search.results, function _map(option, index) {
                    return ___wml.widget(MenuItem_1.MenuItem, {
                        html: {},
                        wml: {},
                        ww: {
                            'name': ("" + index),
                            'onClick': function () { return ___context.values.item.click(index); }
                        }
                    }, [___wml.domify(___context.values.item.template.populated(option, index, ___context.values.search.results)(___context)(___view))], ___view);
                }, function otherwise() {
                    return ___wml.domify(___context.values.item.template.empty()(___context)(___view));
                })], ___view);
        };
        return _this;
    }
    return Results;
}(___wml.AppView));
exports.Results = Results;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ___wml.node('input', {
                    html: {
                        'type': "text",
                        'class': ___context.values.input.class,
                        'onkeydown': ___context.values.input.onKeyDown,
                        'onkeyup': ___context.values.input.onKeyUp,
                        'oninput': ___context.values.input.onInput,
                        'placeholder': ___context.values.input.placeholder
                    },
                    wml: {
                        'id': ___context.values.input.id
                    }
                }, [], ___view), ___wml.widget(Menu_1.Menu, {
                    html: {},
                    wml: {
                        'id': ___context.values.menu.id
                    },
                    ww: {
                        'hidden': true
                    }
                }, [], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/wml":102,"@package/self/layout/fragment/Fragment":107,"@package/self/menu/Menu":122,"@package/self/menu/MenuItem":123,"@quenk/wml":167}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * ButtonChangedEvent
 */
var ButtonChangedEvent = /** @class */ (function (_super) {
    __extends(ButtonChangedEvent, _super);
    function ButtonChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ButtonChangedEvent;
}(control_1.Event));
exports.ButtonChangedEvent = ButtonChangedEvent;

},{"@package/self/control":75}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
var Maybe_1 = require("afpl/lib/monad/Maybe");
/**
 * ButtonSelect
 */
var ButtonSelect = /** @class */ (function (_super) {
    __extends(ButtonSelect, _super);
    function ButtonSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ButtonSelect.prototype.initialize = function (value) {
        return Maybe_1.Maybe.fromAny(value);
    };
    ButtonSelect.prototype.click = function (value) {
        this.values.select.value = Maybe_1.Maybe.fromAny(value);
        this.delegate.onChange(new ButtonChangedEvent_1.ButtonChangedEvent(this.attrs.ww.name, value));
        this.view.invalidate();
    };
    ButtonSelect.prototype.isSelected = function (v) {
        return this.values.select.value.cata(function () { return false; }, function (value) { return value === v; });
    };
    return ButtonSelect;
}(ButtonSelectGroup_1.ButtonSelectGroup));
exports.ButtonSelect = ButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelectGroup":61,"afpl/lib/monad/Maybe":174}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/button-select");
var control_1 = require("@package/self/control");
var util_1 = require("@package/self/common/util");
/**
 * ButtonSelectGroup
 */
var ButtonSelectGroup = /** @class */ (function (_super) {
    __extends(ButtonSelectGroup, _super);
    function ButtonSelectGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: names.BUTTON_SELECT
            },
            help: {
                id: 'help',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            select: {
                value: _this.initialize(_this.attrs.ww.value),
                options: _this.attrs.ww.options,
                isSelected: function (v) { return _this.isSelected(v); }
            },
            click: function (v) { return function () { return _this.click(v); }; },
            calculateClass: function (_a) {
                var className = _a.className, value = _a.value;
                return util_1.concat(names.BUTTON_SELECT_OPTION, className, (_this.attrs.ww.variant) ? _this.attrs.ww.variant : names.DEFAULT, _this.values.select.isSelected(value) ? names.ACTIVE : '');
            },
        };
        return _this;
    }
    return ButtonSelectGroup;
}(control_1.FormControl));
exports.ButtonSelectGroup = ButtonSelectGroup;

},{"./wml/button-select":64,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control":75}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
var Maybe_1 = require("afpl/lib/monad/Maybe");
/**
 * MultiButtonSelect
 */
var MultiButtonSelect = /** @class */ (function (_super) {
    __extends(MultiButtonSelect, _super);
    function MultiButtonSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiButtonSelect.prototype.initialize = function (v) {
        return Maybe_1.Maybe.fromAny(v).cata(function () { return Maybe_1.Maybe.fromArray([]); }, function (v) { return Maybe_1.Maybe.fromArray(v); });
    };
    MultiButtonSelect.prototype.click = function (v) {
        var _this = this;
        this.values.select.value = this
            .values
            .select
            .value
            .map(function (value) {
            var pos = value.indexOf(v);
            if (pos > -1)
                value.splice(pos, 1);
            else
                value.push(v);
            _this.delegate.onChange(new ButtonChangedEvent_1.ButtonChangedEvent(_this.attrs.ww.name, value.slice()));
            _this.view.invalidate();
            return value;
        })
            .orJust(function () { return [v]; });
    };
    MultiButtonSelect.prototype.isSelected = function (v) {
        return this.values.select.value.cata(function () { return false; }, function (value) { return value.indexOf(v) > -1; });
    };
    return MultiButtonSelect;
}(ButtonSelectGroup_1.ButtonSelectGroup));
exports.MultiButtonSelect = MultiButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelectGroup":61,"afpl/lib/monad/Maybe":174}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonSelectGroup_1 = require("./ButtonSelectGroup");
exports.ButtonSelectGroup = ButtonSelectGroup_1.ButtonSelectGroup;
var ButtonSelect_1 = require("./ButtonSelect");
exports.ButtonSelect = ButtonSelect_1.ButtonSelect;
var ButtonChangedEvent_1 = require("./ButtonChangedEvent");
exports.ButtonChangedEvent = ButtonChangedEvent_1.ButtonChangedEvent;
var MultiButtonSelect_1 = require("./MultiButtonSelect");
exports.MultiButtonSelect = MultiButtonSelect_1.MultiButtonSelect;

},{"./ButtonChangedEvent":59,"./ButtonSelect":60,"./ButtonSelectGroup":61,"./MultiButtonSelect":62}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Button_1 = require("@package/self/control/button/Button");
;
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.map(___context.values.select.options, function _map(opt) {
                    return ___wml.widget(Button_1.Button, {
                        html: {},
                        wml: {},
                        ww: {
                            'class': ___context.values.calculateClass(opt),
                            'active': ___context.values.select.isSelected(opt.value),
                            'onClick': ___context.values.click(opt.value),
                            'text': opt.text
                        }
                    }, [], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/button/Button":65,"@quenk/wml":167}],65:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var G = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var views = require("./wml/button");
var util_1 = require("@package/self/common/util");
/**
 * Group multiple buttons into one element.
 */
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Group(_this);
        _this.values = {
            root: {
                class: util_1.concat('btn-group', (_this.attrs.ww) ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Group;
}(G.Group));
exports.Group = Group;
;
/**
 * Button is an improvement over HTMLButtionElement
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Button(_this);
        _this.values = {
            id: {
                button: 'button'
            },
            button: {
                class: _this.attrs.ww ?
                    util_1.concat(names.BUTTON, _this.attrs.ww.variant || names.DEFAULT, _this.attrs.ww.style, _this.attrs.ww.active ?
                        names.ACTIVE : '', _this.attrs.ww.class) :
                    names.BUTTON,
                type: (_this.attrs.ww && _this.attrs.ww.type) ? _this.attrs.ww.type : 'button',
                name: (_this.attrs.ww && _this.attrs.ww.name) ? _this.attrs.ww.name : '',
                disabled: (_this.attrs.ww && _this.attrs.ww.disabled) ? _this.attrs.ww.disabled : null,
                onclick: (_this.attrs.ww && _this.attrs.ww.onClick) ? _this.attrs.ww.onClick : function () { },
                text: (_this.attrs.ww && _this.attrs.ww.text) ? _this.attrs.ww.text : ''
            }
        };
        return _this;
    }
    /**
     * disable this button.
     */
    Button.prototype.disable = function () {
        this.view.findById(this.values.id.button)
            .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    /**
     * enable this button.
     */
    Button.prototype.enable = function () {
        this.view.findById(this.values.id.button)
            .map(function (b) { return b.removeAttribute('disabled'); });
    };
    Button.prototype.rendered = function () {
        if (this.attrs.ww)
            if (this.attrs.ww.disabled)
                this.view.findById(this.values.id.button)
                    .map(function (b) { return b.setAttribute('disabled', 'disabled'); });
    };
    return Button;
}(G.Group));
exports.Button = Button;

},{"./wml/button":66,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    function Group(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Group;
}(___wml.AppView));
exports.Group = Group;
;
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('button', {
                html: {
                    'type': ___context.values.button.type,
                    'name': ___context.values.button.name,
                    'disabled': ___context.values.button.disabled,
                    'class': ___context.values.button.class,
                    'onclick': ___context.values.button.onclick
                },
                wml: {
                    'id': "button"
                }
            }, [___wml.domify(___context.values.button.text), ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Button;
}(___wml.AppView));
exports.Button = Button;

},{"@quenk/wml":167}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var checkbox_1 = require("./wml/checkbox");
var CheckboxChangedEvent_1 = require("./CheckboxChangedEvent");
/**
 * Checkbox control.
 *
 * This is an alternative to the native checkbox that can be styled.
 */
var Checkbox = /** @class */ (function (_super) {
    __extends(Checkbox, _super);
    function Checkbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new checkbox_1.Main(_this);
        _this.values = {
            class: {
                root: names.CHECKBOX,
            },
            input: {
                name: _this.attrs.ww.name,
                checked: _this.attrs.ww.checked || false,
                onChange: function () {
                    _this.values.input.checked = !_this.values.input.checked;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new CheckboxChangedEvent_1.CheckboxChangedEvent(_this.values.input.name, _this.values.input.checked));
                }
            }
        };
        return _this;
    }
    return Checkbox;
}(wml_1.Component));
exports.Checkbox = Checkbox;

},{"./CheckboxChangedEvent":68,"./wml/checkbox":69,"@package/self/common/names":49,"@quenk/wml":167}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("@package/self/control/Event");
/**
 * CheckboxChangedEvent signals the user has changed the checkbox state.
 */
var CheckboxChangedEvent = /** @class */ (function (_super) {
    __extends(CheckboxChangedEvent, _super);
    function CheckboxChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CheckboxChangedEvent;
}(Event_1.Event));
exports.CheckboxChangedEvent = CheckboxChangedEvent;

},{"@package/self/control/Event":54}],69:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.node('label', {
                    html: {},
                    wml: {}
                }, [___wml.node('input', {
                        html: {
                            'type': "checkbox",
                            'name': ___context.values.input.name,
                            'checked': (___context.values.input.checked || null),
                            'onchange': ___context.values.input.onChange
                        },
                        wml: {}
                    }, [], ___view), ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/date");
var names = require("@package/self/common/names");
var moment = require("moment");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var DateChangedEvent_1 = require("./DateChangedEvent");
exports.format = {
    YYYYDDMM: 'YYYY-MM-DD',
    DD: 'DD',
    MM: 'MM',
    YYYY: 'YYYY'
};
exports.MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
;
var _inputValues = function (id, klass, value, date, cb) { return ({
    id: id,
    class: klass,
    value: value,
    disabled: (date.attrs.ww.disabled === true) ? true : null,
    readOnly: (date.attrs.ww.readOnly === true) ? true : null,
    onInput: function (_a) {
        var value = _a.value;
        cb(value);
        date.date.value = date.calculate();
        date.fireChange();
    }
}); };
var _prefix = function (s, inc) {
    if (inc === void 0) { inc = false; }
    var n = Number(s);
    if (inc)
        n = n + 1;
    if (isNaN(n))
        return '';
    return (n < 10) ? "0" + n : "" + n;
};
/**
 * Date input.
 */
var Date = /** @class */ (function (_super) {
    __extends(Date, _super);
    function Date() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new control_1.DefaultDelegate(_this.attrs.ww);
        _this.date = {
            value: _this.attrs.ww.value ? moment(_this.attrs.ww.value, exports.format.YYYYDDMM) : null,
            sep: '-',
            format: exports.format.YYYYDDMM
        };
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat(names.DATE, 'form-group', _this.attrs.ww.class, _this.state()),
            },
            inline: {
                class: 'form-inline'
            },
            date: {
                months: exports.MONTHS.map(function (label, value) { return ({ label: label, value: _prefix(value + 1) }); }),
                prefix: _prefix
            },
            delegate: _this.delegate,
            day: _inputValues('day', names.DATE_DAY, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.DD) : '', _this, function (v) { return _this.values.day.value = _prefix(v); }),
            month: _inputValues('month', names.DATE_MONTH, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.MM) : '', _this, function (v) { return _this.values.month.value = v; }),
            year: _inputValues('year', names.DATE_YEAR, (_this.date.value && _this.date.value.isValid()) ?
                _this.date.value.format(exports.format.YYYY) : '', _this, function (v) { return _this.values.year.value = v; }),
            name: _this.attrs.ww.name,
            help: {
                id: 'helps',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            }
        };
        return _this;
    }
    /**
     * calculate the date based on the current value of the inputs.
     */
    Date.prototype.calculate = function () {
        var date = [
            this.values.year.value,
            this.values.month.value,
            this.values.day.value
        ].filter(function (d) { return d; });
        return (date.length != 3) ? null : moment(date.join(this.date.sep), moment.ISO_8601);
    };
    ;
    /**
     * fireChange
     * @private
     */
    Date.prototype.fireChange = function () {
        if (this.date.value && this.date.value.isValid())
            this.values.delegate.onChange(new DateChangedEvent_1.DateChangedEvent(this.values.name, this.date.value.format(this.date.format)));
    };
    return Date;
}(control_1.FormControl));
exports.Date = Date;

},{"./DateChangedEvent":71,"./wml/date":72,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/control":75,"moment":181}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("@package/self/control/Event");
/**
 * DateChangedEvent is generated when the date has
 * been changed to a valid date.
 */
var DateChangedEvent = /** @class */ (function (_super) {
    __extends(DateChangedEvent, _super);
    function DateChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DateChangedEvent;
}(Event_1.Event));
exports.DateChangedEvent = DateChangedEvent;

},{"@package/self/control/Event":54}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var select_1 = require("@package/self/control/select");
;
var text_field_1 = require("@package/self/control/text-field");
;
;
var wml_1 = require("@package/self/control/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ___wml.node('div', {
                    html: {
                        'class': ___context.values.inline.class
                    },
                    wml: {}
                }, [___wml.widget(select_1.Select, {
                        html: {},
                        wml: {
                            'id': ___context.values.month.id
                        },
                        ww: {
                            'name': ___context.values.month.id,
                            'onChange': ___context.values.month.onInput,
                            'disabled': ___context.values.month.disabled,
                            'readOnly': ___context.values.month.readOnly,
                            'class': ___context.values.month.class,
                            'options': ___context.values.date.months
                        }
                    }, [___wml.node('option', {
                            html: {
                                'selected': true,
                                'value': "",
                                'disabled': true
                            },
                            wml: {}
                        }, [___wml.text("Month")], ___view)], ___view), ___wml.widget(text_field_1.TextField, {
                        html: {},
                        wml: {
                            'id': ___context.values.day.id
                        },
                        ww: {
                            'name': ___context.values.day.id,
                            'onChange': ___context.values.day.onInput,
                            'value': ___context.values.day.value,
                            'disabled': ___context.values.day.disabled,
                            'readOnly': ___context.values.day.readOnly,
                            'class': ___context.values.day.class,
                            'placeholder': "DD"
                        }
                    }, [], ___view), ___wml.widget(text_field_1.TextField, {
                        html: {},
                        wml: {
                            'id': ___context.values.year.id
                        },
                        ww: {
                            'name': ___context.values.year.id,
                            'onChange': ___context.values.year.onInput,
                            'value': ___context.values.year.value,
                            'disabled': ___context.values.year.disabled,
                            'readOnly': ___context.values.year.readOnly,
                            'class': ___context.values.year.class,
                            'placeholder': "YYYY"
                        }
                    }, [], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/select":85,"@package/self/control/text-field":100,"@package/self/control/wml":102,"@quenk/wml":167}],73:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var icon_button_1 = require("./wml/icon-button");
/**
 * IconButton provides a 'hamburger' menu button.
 */
var IconButton = /** @class */ (function (_super) {
    __extends(IconButton, _super);
    function IconButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new icon_button_1.Main(_this);
        _this.values = {
            class: {
                root: names.ICON_BUTTON
            },
            button: {
                class: util_1.concat(names.ICON_BUTTON, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : ''),
                onClick: (_this.attrs.ww && _this.attrs.ww.onClick) ? _this.attrs.ww.onClick : function () { }
            }
        };
        return _this;
    }
    return IconButton;
}(wml_1.Component));
exports.IconButton = IconButton;

},{"./wml/icon-button":74,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('button', {
                html: {
                    'class': ___context.values.button.class,
                    'onclick': ___context.values.button.onClick
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = require("./Event");
exports.Event = Event_1.Event;
var DefaultDelegate_1 = require("./DefaultDelegate");
exports.DefaultDelegate = DefaultDelegate_1.DefaultDelegate;
var Control_1 = require("./Control");
exports.Control = Control_1.Control;
var FormControl_1 = require("./FormControl");
exports.FormControl = FormControl_1.FormControl;

},{"./Control":52,"./DefaultDelegate":53,"./Event":54,"./FormControl":55}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
var ItemSelectedEvent = /** @class */ (function (_super) {
    __extends(ItemSelectedEvent, _super);
    function ItemSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ItemSelectedEvent;
}(control_1.Event));
exports.ItemSelectedEvent = ItemSelectedEvent;

},{"@package/self/control":75}],77:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@package/self/common/util");
var TermChangedEvent_1 = require("./TermChangedEvent");
var SearchDefaultDelegate_1 = require("./SearchDefaultDelegate");
var control_1 = require("@package/self/control");
exports.ESCAPE = 27;
exports.DEFAULT_DEBOUNCE_TIME = 500;
exports.INPUT_ID = 'input';
/**
 * SearchControl
 */
var SearchControl = /** @class */ (function (_super) {
    __extends(SearchControl, _super);
    function SearchControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.DEFAULT_DEBOUNCE_TIME = exports.DEFAULT_DEBOUNCE_TIME;
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new SearchDefaultDelegate_1.SearchDefaultDelegate(_this.attrs.ww);
        _this.results = [];
        _this.onKeyDown = function (e) { return (e.keyCode !== exports.ESCAPE) ? _this.execute(null) : null; };
        _this.onKeyUp = function (e) {
            var target = e.target;
            if (e.keyCode === exports.ESCAPE) {
                target.blur();
                _this.close();
            }
        };
        _this.onInput = function (e) {
            //For compatability reasons
            e.target.onkeydown = null;
            _this.onKeyDown(e);
        };
        _this.execute = util_1.debounce(function () {
            _this
                .view
                .findById(_this.values.input.id)
                .map(function (_a) {
                var value = _a.value;
                return _this.delegate.onSearch(new TermChangedEvent_1.TermChangedEvent(_this.attrs.ww.name, value));
            });
        }, _this.attrs.ww.debounce || _this.DEFAULT_DEBOUNCE_TIME);
        _this.stringify = function (v) { return String(v); };
        return _this;
    }
    SearchControl.prototype.rendered = function () {
        document.addEventListener('click', this);
    };
    SearchControl.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.id.root)
            .map(function (root) {
            if (!root.contains(e.target))
                _this.close();
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
        });
    };
    return SearchControl;
}(control_1.FormControl));
exports.SearchControl = SearchControl;

},{"./SearchDefaultDelegate":78,"./TermChangedEvent":79,"@package/self/common/util":50,"@package/self/control":75}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * SearchDefaultDelegate fowards all events to their corresponding
 * function handlers, specifed on the attributes of a control.
 */
var SearchDefaultDelegate = /** @class */ (function (_super) {
    __extends(SearchDefaultDelegate, _super);
    function SearchDefaultDelegate(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.attrs = attrs;
        _this.onSearch = function (e) {
            if (_this.attrs.onSearch)
                _this.attrs.onSearch(e);
        };
        _this.onSelect = function (e) {
            if (_this.attrs.onSelect)
                _this.attrs.onSelect(e);
        };
        return _this;
    }
    return SearchDefaultDelegate;
}(control_1.DefaultDelegate));
exports.SearchDefaultDelegate = SearchDefaultDelegate;

},{"@package/self/control":75}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * TermChangedEvent signals the search term has changed.
 */
var TermChangedEvent = /** @class */ (function (_super) {
    __extends(TermChangedEvent, _super);
    function TermChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TermChangedEvent;
}(control_1.Event));
exports.TermChangedEvent = TermChangedEvent;

},{"@package/self/control":75}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SearchControl_1 = require("./SearchControl");
exports.SearchControl = SearchControl_1.SearchControl;
var SearchDefaultDelegate_1 = require("./SearchDefaultDelegate");
exports.SearchDefaultDelegate = SearchDefaultDelegate_1.SearchDefaultDelegate;
var ItemSelectedEvent_1 = require("./ItemSelectedEvent");
exports.ItemSelectedEvent = ItemSelectedEvent_1.ItemSelectedEvent;
var TermChangedEvent_1 = require("./TermChangedEvent");
exports.TermChangedEvent = TermChangedEvent_1.TermChangedEvent;

},{"./ItemSelectedEvent":76,"./SearchControl":77,"./SearchDefaultDelegate":78,"./TermChangedEvent":79}],81:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/search-stack");
var control_1 = require("@package/self/control");
/**
 * SearchStack
 */
var SearchStack = /** @class */ (function (_super) {
    __extends(SearchStack, _super);
    function SearchStack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                input: 'button',
                search: 'search',
                message: 'message'
            },
            root: {
                id: 'root',
                class: names.SEARCH_STACK
            },
            help: {
                id: 'help'
            },
            search: {
                id: 'search',
                name: _this.attrs.ww.name,
                value: '',
                onSearch: function (evt) { if (_this.attrs.ww.onSearch)
                    _this.attrs.ww.onSearch(evt); },
                onSelect: function (_a) {
                    var value = _a.value;
                    return _this.push(value);
                }
            },
            stack: {
                id: 'stack',
                name: _this.attrs.ww.name,
                value: _this.attrs.ww.value,
                decorator: _this.attrs.ww.decorator ? _this.attrs.ww.decorator : function (v) { return String(v); },
                onChange: function (evt) { return _this.delegate.onChange(evt); }
            }
        };
        return _this;
    }
    /**
     * update the list of available options displayed to the user.
     */
    SearchStack.prototype.update = function (list) {
        this
            .view
            .findById(this.values.search.id)
            .map(function (s) { return s.update(list); });
        return this;
    };
    /**
     * push a value onto the stack.
     */
    SearchStack.prototype.push = function (v) {
        this
            .view
            .findById(this.values.stack.id)
            .map(function (s) { return s.push(v); });
        return this;
    };
    return SearchStack;
}(control_1.FormControl));
exports.SearchStack = SearchStack;

},{"./wml/search-stack":82,"@package/self/common/names":49,"@package/self/control":75}],82:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var autocomplete_1 = require("@package/self/control/autocomplete");
;
var stack_1 = require("@package/self/control/stack");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.widget(stack_1.Stack, {
                    html: {},
                    wml: {
                        'id': ___context.values.stack.id
                    },
                    ww: {
                        'name': ___context.values.stack.name,
                        'value': ___context.values.stack.value,
                        'decorator': ___context.values.stack.decorator,
                        'onChange': ___context.values.stack.onChange
                    }
                }, [], ___view), ___wml.widget(autocomplete_1.Autocomplete, {
                    html: {},
                    wml: {
                        'id': ___context.values.search.id
                    },
                    ww: {
                        'name': ___context.values.search.name,
                        'value': ___context.values.search.value,
                        'stringifier': ___context.values.stack.decorator,
                        'onSearch': ___context.values.search.onSearch,
                        'onSelect': ___context.values.search.onSelect
                    }
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/autocomplete":57,"@package/self/control/stack":89,"@quenk/wml":167}],83:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/select");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var SelectChangedEvent_1 = require("./SelectChangedEvent");
/**
 * Select provides a dropdown list for selecting items.
 *
 * Note: Currently this relies on the native select but this
 * is likely to change in the future. Use the native <select>
 * directly if you must have that.
 */
var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat('form-group', _this.attrs.ww.class, _this.state())
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            select: {
                id: 'select',
                name: _this.attrs.ww.name,
                class: 'form-control',
                value: _this.attrs.ww.value || '',
                disabled: (_this.attrs.ww.disabled === true) ? true : null,
                readOnly: (_this.attrs.ww.readOnly === true) ? true : null,
                options: _this.attrs.ww.options || [],
                placeholder: _this.attrs.ww.placeholder || 'Select one.',
                optValue: function (o) { return typeof o === 'string' ? o : o.value; },
                optLabel: function (o) { return typeof o === 'string' ? o : o.label; },
                isSelected: function (s) { return _this.values.select.value === s; },
                onChange: function (e) {
                    var target = e.target;
                    _this
                        .delegate
                        .onChange(new SelectChangedEvent_1.SelectChangedEvent(_this.attrs.ww.name, target.value));
                }
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            }
        };
        return _this;
    }
    return Select;
}(control_1.FormControl));
exports.Select = Select;

},{"./SelectChangedEvent":84,"./wml/select":86,"@package/self/common/util":50,"@package/self/control":75}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
var SelectChangedEvent = /** @class */ (function (_super) {
    __extends(SelectChangedEvent, _super);
    function SelectChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SelectChangedEvent;
}(control_1.Event));
exports.SelectChangedEvent = SelectChangedEvent;

},{"@package/self/control":75}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Select_1 = require("./Select");
exports.Select = Select_1.Select;
var SelectChangedEvent_1 = require("./SelectChangedEvent");
exports.SelectChangedEvent = SelectChangedEvent_1.SelectChangedEvent;

},{"./Select":83,"./SelectChangedEvent":84}],86:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var wml_1 = require("@package/self/control/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ___wml.node('select', {
                    html: {
                        'name': ___context.values.select.name,
                        'onchange': ___context.values.select.onChange,
                        'value': ___context.values.select.value,
                        'disabled': ___context.values.select.disabled,
                        'readonly': ___context.values.select.readOnly,
                        'class': ___context.values.select.class
                    },
                    wml: {
                        'id': ___context.values.select.id
                    }
                }, [___wml.node('option', {
                        html: {
                            'value': "",
                            'disabeld': true
                        },
                        wml: {}
                    }, [___wml.domify(___context.values.select.placeholder)], ___view), ___wml.map(___context.values.select.options, function _map(opt) {
                        return ___wml.node('option', {
                            html: {
                                'value': ___context.values.select.optValue(opt),
                                'selected': ___context.values.select.isSelected(___context.values.select.optValue(opt))
                            },
                            wml: {}
                        }, [___wml.domify(___context.values.select.optLabel(opt))], ___view);
                    }, function otherwise() {
                        return document.createDocumentFragment();
                    }), ___wml.domify(___context.children)], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/wml":102,"@quenk/wml":167}],87:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/stack");
var StackChangedEvent_1 = require("./StackChangedEvent");
/**
 * Stack displays a list of items that can be modified
 * by releasing one or more at a time.
 */
var Stack = /** @class */ (function (_super) {
    __extends(Stack, _super);
    function Stack() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.template = _this.attrs.ww.template ?
            _this.attrs.ww.template : views.content;
        _this.values = {
            id: {
                root: 'root',
                a: 'link'
            },
            class: {
                root: names.STACK,
                close: names.STACK_CLOSE,
                member: names.STACK_MEMBER
            },
            item: {
                template: _this.template,
                close: function (index) { return function () {
                    _this.values.value.splice(Number(index), 1);
                    _this.fire();
                }; },
                decorator: _this.attrs.ww.decorator ? _this.attrs.ww.decorator : function (m) { return String(m); }
            },
            value: _this.attrs.ww.value ? _this.attrs.ww.value : []
        };
        return _this;
    }
    /**
     * push a new member onto the stack.
     */
    Stack.prototype.push = function (m) {
        this.values.value.push(m);
        this.fire();
        return this;
    };
    Stack.prototype.fire = function () {
        if (this.attrs.ww.onChange)
            this.attrs.ww.onChange(new StackChangedEvent_1.StackChangedEvent(this.attrs.ww.name, this.values.value.slice()));
        this.view.invalidate();
    };
    return Stack;
}(wml.Component));
exports.Stack = Stack;

},{"./StackChangedEvent":88,"./wml/stack":90,"@package/self/common/names":49,"@quenk/wml":167}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * StackChangedEvent is generated when the user removes an item from the stack.
 */
var StackChangedEvent = /** @class */ (function (_super) {
    __extends(StackChangedEvent, _super);
    function StackChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StackChangedEvent;
}(control_1.Event));
exports.StackChangedEvent = StackChangedEvent;

},{"@package/self/control":75}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stack_1 = require("./Stack");
exports.Stack = Stack_1.Stack;
var StackChangedEvent_1 = require("./StackChangedEvent");
exports.StackChangedEvent = StackChangedEvent_1.StackChangedEvent;

},{"./Stack":87,"./StackChangedEvent":88}],90:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
exports.content = function (m) { return function (___context) { return function (___view) { return ___wml.node('span', {
    html: {
        'class': ___context.values.class.member
    },
    wml: {}
}, [___wml.domify(___context.values.item.decorator(m))], ___view); }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.map(___context.values.value, function _map(m, index) {
                    return ___wml.node('li', {
                        html: {},
                        wml: {}
                    }, [___wml.domify(___context.values.item.template(m, index, ___context.values.value)(___context)(___view)), ___wml.node('button', {
                            html: {
                                'class': ___context.values.class.close,
                                'onclick': ___context.values.item.close(index)
                            },
                            wml: {}
                        }, [___wml.text("\u00D7")], ___view)], ___view);
                }, function otherwise() {
                    return document.createDocumentFragment();
                })], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var wml_1 = require("@quenk/wml");
var switch_1 = require("./wml/switch");
var SwitchChangedEvent_1 = require("./SwitchChangedEvent");
/**
 * Switch allows the user to select between one or two values.
 */
var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new switch_1.Main(_this);
        _this.values = {
            class: {
                label: names.SWITCH,
                slider: names.SWITCH_SLIDER
            },
            input: {
                name: _this.attrs.ww.name,
                on: _this.attrs.ww.on || false,
                disabled: _this.attrs.ww.disabled ? true : null,
                onChange: function () {
                    _this.values.input.on = !_this.values.input.on;
                    if (_this.attrs.ww.onChange)
                        _this.attrs.ww.onChange(new SwitchChangedEvent_1.SwitchChangedEvent(_this.values.input.name, _this.values.input.on));
                }
            }
        };
        return _this;
    }
    return Switch;
}(wml_1.Component));
exports.Switch = Switch;

},{"./SwitchChangedEvent":92,"./wml/switch":93,"@package/self/common/names":49,"@quenk/wml":167}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * SwitchChangedEvent signals the user has changed the switch.
 */
var SwitchChangedEvent = /** @class */ (function (_super) {
    __extends(SwitchChangedEvent, _super);
    function SwitchChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SwitchChangedEvent;
}(control_1.Event));
exports.SwitchChangedEvent = SwitchChangedEvent;

},{"@package/self/control":75}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('label', {
                html: {
                    'class': ___context.values.class.label
                },
                wml: {}
            }, [___wml.node('input', {
                    html: {
                        'type': "checkbox",
                        'name': ___context.values.input.name,
                        'checked': (___context.values.input.on || null),
                        'disabled': ___context.values.input.disabled,
                        'onchange': ___context.values.input.onChange
                    },
                    wml: {}
                }, [], ___view), ___wml.node('div', {
                    html: {
                        'class': ___context.values.class.slider
                    },
                    wml: {}
                }, [], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/tabs");
var afpl = require("afpl");
var util_1 = require("@package/self/common/util");
var TabClickedEvent_1 = require("./TabClickedEvent");
var wml_1 = require("@quenk/wml");
var _unknown = function (id) {
    return console.warn("Missing element with id " + id + ".");
};
/**
 * Tab provides a single tab item.
 *
 * When a tab is clicked, it attempts to remove the active class from
 * it's siblings and apply it to itself. Therefore the sibling of a
 * tab should always be a Tab.
 */
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Tab(_this);
        _this.values = {
            id: {
                root: 'root',
                a: 'link'
            },
            class: {
                li: util_1.concat(names.TABS_TAB, _this.attrs.ww.active ? names.ACTIVE : '')
            },
            tab: {
                text: _this.attrs.ww.text
            }
        };
        _this.clicked = function (e) {
            e.preventDefault();
            _this
                .view
                .findById(_this.values.id.root)
                .chain(function (root) {
                var parent = root.parentNode;
                var us = parent.children;
                for (var i = 0; i < us.length; i++)
                    us[i].classList.remove(names.ACTIVE);
                return _this
                    .view
                    .findById(_this.values.id.root)
                    .map(function (el) { return el.classList.add(names.ACTIVE); })
                    .orJust(function () { return _unknown(_this.values.id.root); })
                    .chain(function () { return afpl.Maybe.fromAny(_this.attrs.ww.onClick); })
                    .map(function (f) {
                    return f(new TabClickedEvent_1.TabClickedEvent(_this.attrs.ww.name));
                });
            });
        };
        return _this;
    }
    /**
     * click this Tab
     */
    Tab.prototype.click = function () {
        var _this = this;
        this
            .view
            .findById(this.values.id.a)
            .cata(function () { return _unknown(_this.values.id.a); }, function (e) { return e.click(); });
    };
    return Tab;
}(wml_1.Component));
exports.Tab = Tab;

},{"./TabClickedEvent":95,"./wml/tabs":97,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167,"afpl":169}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * TabClickedEvent is fired when a user clicks on a tab.
 *
 * It contains information about the tab that was clicked.
 */
var TabClickedEvent = /** @class */ (function () {
    function TabClickedEvent(name) {
        this.name = name;
    }
    return TabClickedEvent;
}());
exports.TabClickedEvent = TabClickedEvent;

},{}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/tabs");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
/**
 * Tabs acts as a parent container for a group of Tab.
 *
 * Use it to create a tabbed navigation or view for main layout,
 * sub views or forms etc.
 */
var Tabs = /** @class */ (function (_super) {
    __extends(Tabs, _super);
    function Tabs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new view.Tabs(_this);
        _this.values = {
            root: {
                class: util_1.concat(names.TABS, 'nav nav-tabs', _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Tabs;
}(wml_1.Component));
exports.Tabs = Tabs;

},{"./wml/tabs":97,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var Tab = /** @class */ (function (_super) {
    __extends(Tab, _super);
    function Tab(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.li
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.node('a', {
                    html: {
                        'href': "#",
                        'onclick': ___context.clicked
                    },
                    wml: {
                        'id': ___context.values.id.a
                    }
                }, [(___context.values.tab.text) ? ___wml.domify(___context.values.tab.text) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Tab;
}(___wml.AppView));
exports.Tab = Tab;
;
var Tabs = /** @class */ (function (_super) {
    __extends(Tabs, _super);
    function Tabs(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Tabs;
}(___wml.AppView));
exports.Tabs = Tabs;

},{"@quenk/wml":167}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = require("@package/self/control");
/**
 * TextChangedEvent
 */
var TextChangedEvent = /** @class */ (function (_super) {
    __extends(TextChangedEvent, _super);
    function TextChangedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextChangedEvent;
}(control_1.Event));
exports.TextChangedEvent = TextChangedEvent;

},{"@package/self/control":75}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/text-field");
var util_1 = require("@package/self/common/util");
var control_1 = require("@package/self/control");
var TextChangedEvent_1 = require("./TextChangedEvent");
/**
 * TextField
 */
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                id: 'root',
                class: util_1.concat('form-group', _this.attrs.ww.class, _this.state()),
            },
            help: {
                id: 'message',
                success: _this.attrs.ww.success,
                error: _this.attrs.ww.error,
                warning: _this.attrs.ww.warning
            },
            label: {
                id: _this.attrs.ww.name,
                text: _this.attrs.ww.label || ''
            },
            input: {
                id: 'input',
                class: 'form-control',
                name: _this.attrs.ww.name,
                type: _this.attrs.ww.type || 'text',
                placeholder: _this.attrs.ww.placeholder || '',
                value: _this.attrs.ww.value || '',
                disabled: (_this.attrs.ww.disabled === true) ? true : null,
                readOnly: (_this.attrs.ww.readOnly === true) ? true : null,
                rows: _this.attrs.ww.rows || 1,
                onInput: function (e) { return _this.delegate.onChange(new TextChangedEvent_1.TextChangedEvent(_this.attrs.ww.name, e.target.value)); }
            }
        };
        return _this;
    }
    return TextField;
}(control_1.FormControl));
exports.TextField = TextField;

},{"./TextChangedEvent":98,"./wml/text-field":101,"@package/self/common/util":50,"@package/self/control":75}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextField_1 = require("./TextField");
exports.TextField = TextField_1.TextField;
var TextChangedEvent_1 = require("./TextChangedEvent");
exports.TextChangedEvent = TextChangedEvent_1.TextChangedEvent;

},{"./TextChangedEvent":98,"./TextField":99}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var wml_1 = require("@package/self/control/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(wml_1.label(___context.values.label.id, ___context.values.label.text)(___view)), ((___context.values.input.rows === 1)) ? ___wml.node('input', {
                    html: {
                        'name': ___context.values.input.name,
                        'type': ___context.values.input.type,
                        'placeholder': ___context.values.input.placeholder,
                        'oninput': ___context.values.input.onInput,
                        'value': ___context.values.input.value,
                        'disabled': ___context.values.input.disabled,
                        'readonly': ___context.values.input.readOnly,
                        'class': ___context.values.input.class
                    },
                    wml: {
                        'id': "input"
                    }
                }, [], ___view) : ___wml.node('textarea', {
                    html: {
                        'name': ___context.values.input.name,
                        'placeholder': ___context.values.input.placeholder,
                        'oninput': ___context.values.input.onInput,
                        'disabled': ___context.values.input.disabled,
                        'readonly': ___context.values.input.readOnly,
                        'rows': ___context.values.input.rows,
                        'class': ___context.values.input.class
                    },
                    wml: {
                        'id': "input"
                    }
                }, [___wml.domify(___context.values.input.value)], ___view), ___wml.domify(wml_1.message(___context.values.help.id, ___context.values.help)(___view))], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/control/wml":102,"@quenk/wml":167}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
exports.label = function (id, text) { return function (___view) { return ___wml.node('label', {
    html: {
        'for': id,
        'class': "control-label"
    },
    wml: {}
}, [___wml.domify(text)], ___view); }; };
;
exports.message = function (id, m) { return function (___view) { return (m.success) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.success)], ___view) : (m.error) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.error)], ___view) : (m.warning) ? ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [___wml.domify(m.warning)], ___view) : ___wml.node('span', {
    html: {
        'class': "help-text"
    },
    wml: {
        'id': id
    }
}, [], ___view); }; };

},{"@quenk/wml":167}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var Group_1 = require("@package/self/content/Group");
var aside_1 = require("./wml/aside");
/**
 * Aside provides a widget for displaying navigation and other sidebar content.
 *
 * It's api allows for toggling between hidden and shown states as well as querying the
 * current state.
 *
 * This widget's style intentionally gives it a high z-index so that it appears in-front
 * of other content. Adjust the respective style variables to change.
 */
var Aside = /** @class */ (function (_super) {
    __extends(Aside, _super);
    function Aside() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * values is a hash of values used in the template
         */
        _this.values = {
            id: {
                root: 'aside',
            },
            class: {
                root: names.ASIDE,
                content: names.ASIDE_CONTENT
            },
            attrs: {
                content: 'ww:content'
            },
            content: (_this.attrs.ww && _this.attrs.ww.content) ? _this.attrs.ww.content : null
        };
        _this.view = new aside_1.Main(_this);
        return _this;
    }
    Aside.prototype._getDrawerDOM = function (f) {
        return this.view.findById(this.values.id.root).cata(function () { return null; }, f);
    };
    /**
     * visible queries whether the Drawer is visible or not.
     */
    Aside.prototype.visible = function () {
        return !this._getDrawerDOM(function (e) { return e.classList.contains(names.HIDDEN); });
    };
    /**
     * hide the drawer.
     */
    Aside.prototype.hide = function () {
        if (this.visible())
            this._getDrawerDOM(function (e) { return e.classList.add(names.HIDDEN); });
    };
    /**
     * showDrawer shows the drawer
     */
    Aside.prototype.show = function () {
        if (!this.visible())
            this._getDrawerDOM(function (e) { return e.classList.remove(names.HIDDEN); });
    };
    /**
     * toggle the visibility of this Drawer
     */
    Aside.prototype.toggle = function () {
        this._getDrawerDOM(function (e) { return e.classList.toggle(names.HIDDEN); });
    };
    return Aside;
}(Group_1.Group));
exports.Aside = Aside;

},{"./wml/aside":104,"@package/self/common/names":49,"@package/self/content/Group":51}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.node('div', {
                    html: {
                        'class': ___context.values.class.content
                    },
                    wml: {}
                }, [(___context.values.content) ? ___wml.domify(___context.values.content.render()) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Group_1 = require("@package/self/content/Group");
var names = require("@package/self/common/names");
var drawer_1 = require("./wml/drawer");
;
/**
 * Drawer provides a 2 column application layout with the first typically used as navaigation
 * and the second main application content.
 *
 * ```wml
 *
 *  <Drawer
 *   wml:id="layout"
 *   content={{this.getContent()}} />
 *
 * ```
 */
var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new drawer_1.Main(_this);
        /**
         * values is a hash of values used in the template.
         */
        _this.values = {
            id: {
                root: 'content',
                drawer: 'drawer'
            },
            class: {
                root: names.DRAWER,
            },
            attrs: {
                DRAWER: 'ww:drawer',
                CONTENT: 'ww:content'
            },
            aside: {
                content: (_this.attrs.ww && _this.attrs.ww.drawer) ? _this.attrs.ww.drawer : null
            },
            content: (_this.attrs.ww && _this.attrs.ww.content) ? _this.attrs.ww.content : null
        };
        return _this;
    }
    Drawer.prototype._getAside = function (f) {
        return this.view.findById(this.values.id.drawer).cata(function () { return null; }, f);
    };
    Drawer.prototype._combine = function (classes) {
        return classes.join(' ');
    };
    /**
     * drawerVisible queries whether the Aside is visible or not.
     */
    Drawer.prototype.drawerVisible = function () {
        return this._getAside(function (a) { return a.visible(); });
    };
    /**
     * hideDrawer hides the drawer.
     */
    Drawer.prototype.hideDrawer = function () {
        return this._getAside(function (a) { return a.hide(); });
    };
    /**
     * showDrawer shows the drawer
     */
    Drawer.prototype.showDrawer = function () {
        return this._getAside(function (a) { return a.show(); });
    };
    /**
     * toggle the visibility of the Aside.
     */
    Drawer.prototype.toggleDrawer = function () {
        return this._getAside(function (a) { return a.toggle(); });
    };
    return Drawer;
}(Group_1.Group));
exports.Drawer = Drawer;

},{"./wml/drawer":106,"@package/self/common/names":49,"@package/self/content/Group":51}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Aside_1 = require("@package/self/layout/aside/Aside");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {
                    'id': ___context.values.id.root
                }
            }, [___wml.widget(Aside_1.Aside, {
                    html: {},
                    wml: {
                        'id': ___context.values.id.drawer
                    },
                    ww: {
                        'content': ___context.values.aside.content
                    }
                }, [], ___view), (___context.content) ? ___wml.domify(___context.content) : (___context.values.content) ? ___wml.domify(___context.values.content.render()) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/layout/aside/Aside":103,"@quenk/wml":167}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/views");
var wml_1 = require("@quenk/wml");
var Fragment = /** @class */ (function (_super) {
    __extends(Fragment, _super);
    function Fragment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(null);
        return _this;
    }
    Fragment.prototype.render = function () {
        var frag = document.createDocumentFragment();
        this.children.forEach(function (c) { return frag.appendChild(c); });
        return frag;
    };
    return Fragment;
}(wml_1.Component));
exports.Fragment = Fragment;

},{"./wml/views":108,"@quenk/wml":167}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('fragment', {
                html: {},
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/grid");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
;
/**
 * Grid
 */
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Grid(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.GRID, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Grid;
}(wml_1.Component));
exports.Grid = Grid;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Row(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.GRID_ROW, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Row;
}(wml_1.Component));
exports.Row = Row;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Column(_this);
        _this.values = {
            class: {
                root: _this.attrs.ww ? util_1.concat(_this.attrs.ww.size ?
                    "col-md-" + _this.attrs.ww.size : 'col-md-12', _this.attrs.ww.class) : 'col-md-12'
            }
        };
        return _this;
    }
    return Column;
}(wml_1.Component));
exports.Column = Column;

},{"./wml/grid":110,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],110:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('section', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Grid;
}(___wml.AppView));
exports.Grid = Grid;
;
var Row = /** @class */ (function (_super) {
    __extends(Row, _super);
    function Row(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Row;
}(___wml.AppView));
exports.Row = Row;
;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Column;
}(___wml.AppView));
exports.Column = Column;

},{"@quenk/wml":167}],111:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var views = require("./wml/list-group");
var names = require("@package/self/common/names");
/**
 * ListGroup is used to create a vertical list of content.
 *
 * Children must be ListGroupItems.
 */
var ListGroup = /** @class */ (function (_super) {
    __extends(ListGroup, _super);
    function ListGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: names.LIST_GROUP
            }
        };
        return _this;
    }
    return ListGroup;
}(wml.Component));
exports.ListGroup = ListGroup;

},{"./wml/list-group":115,"@package/self/common/names":49,"@quenk/wml":167}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/list-group-item");
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
/**
 * ListGroupItem
 */
var ListGroupItem = /** @class */ (function (_super) {
    __extends(ListGroupItem, _super);
    function ListGroupItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            root: {
                class: names.LIST_GROUP_ITEM
            }
        };
        return _this;
    }
    return ListGroupItem;
}(wml.Component));
exports.ListGroupItem = ListGroupItem;

},{"./wml/list-group-item":114,"@package/self/common/names":49,"@quenk/wml":167}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ListGroup_1 = require("./ListGroup");
exports.ListGroup = ListGroup_1.ListGroup;
var ListGroupItem_1 = require("./ListGroupItem");
exports.ListGroupItem = ListGroupItem_1.ListGroupItem;

},{"./ListGroup":111,"./ListGroupItem":112}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],116:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/main");
var names = require("@package/self/common/names");
var util_1 = require("@package/self/common/util");
var Group_1 = require("@package/self/content/Group");
/**
 * Main provides a container for the main content of an application.
 */
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.MAIN_VIEW, names.PUSHABLE, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Main;
}(Group_1.Group));
exports.Main = Main;

},{"./wml/main":117,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/content/Group":51}],117:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],118:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/panel");
var wml_1 = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Panel(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL, _this.attrs.ww ?
                    _this.attrs.ww.style : names.DEFAULT, _this.attrs.ww ?
                    _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Panel;
}(wml_1.Component));
exports.Panel = Panel;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Header(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Header;
}(wml_1.Component));
exports.Header = Header;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Body(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_BODY, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Body;
}(wml_1.Component));
exports.Body = Body;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Footer(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.PANEL_FOOTER, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Footer;
}(wml_1.Component));
exports.Footer = Footer;

},{"./wml/panel":119,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Panel;
}(___wml.AppView));
exports.Panel = Panel;
;
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Header;
}(___wml.AppView));
exports.Header = Header;
;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    function Body(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Body;
}(___wml.AppView));
exports.Body = Body;
;
var Footer = /** @class */ (function (_super) {
    __extends(Footer, _super);
    function Footer(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Footer;
}(___wml.AppView));
exports.Footer = Footer;

},{"@quenk/wml":167}],120:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/divider");
var wml = require("@quenk/wml");
/**
 * Divider
 */
var Divider = /** @class */ (function (_super) {
    __extends(Divider, _super);
    function Divider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: names.MENU_DIVIDER
            }
        };
        return _this;
    }
    return Divider;
}(wml.Component));
exports.Divider = Divider;

},{"./wml/divider":129,"@package/self/common/names":49,"@quenk/wml":167}],121:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/header");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Header
 */
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.MENU_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Header;
}(wml.Component));
exports.Header = Header;

},{"./wml/header":130,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],122:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var util_1 = require("@package/self/common/util");
var menu_1 = require("./wml/menu");
/**
 * Menu
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new menu_1.Main(_this);
        _this.values = {
            id: {
                root: 'root',
                target: 'menu'
            },
            class: {
                root: util_1.concat(names.MENU, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.hidden) ?
                    names.HIDDEN : '')
            },
            content: _this.children,
            click: {
                hideOnClick: (_this.attrs.ww && (_this.attrs.ww.hideOnClick != null)) ?
                    _this.attrs.ww.hideOnClick : true,
                hideOnExternalClick: (_this.attrs.ww && (_this.attrs.ww.hideOnExternalClick != null)) ?
                    _this.attrs.ww.hideOnExternalClick : true
            }
        };
        return _this;
    }
    /**
     * isHidden
     */
    Menu.prototype.isHidden = function () {
        return this.view.findById(this.values.id.root)
            .cata(function () { return false; }, function (e) { return e.classList.contains(names.HIDDEN); });
    };
    /**
     * hide the menu.
     */
    Menu.prototype.hide = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.add(names.HIDDEN);
        });
        return this;
    };
    /**
     * show this menu.
     */
    Menu.prototype.show = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.remove(names.HIDDEN);
        });
        return this;
    };
    /**
     * toggle this menu's visibility
     */
    Menu.prototype.toggle = function () {
        this.view.findById(this.values.id.root)
            .map(function (e) {
            return e.classList.toggle(names.HIDDEN);
        });
        return this;
    };
    /**
     * setContent of this menu.
     */
    Menu.prototype.setContent = function (view) {
        this.values.content = [view.render()];
        this.view.invalidate();
        return this;
    };
    Menu.prototype.handleEvent = function (e) {
        var _this = this;
        this
            .view
            .findById(this.values.id.root)
            .map(function (root) {
            if (!document.body.contains(root))
                document.removeEventListener('click', _this);
            if ((!root.contains(e.target)) && _this.values.click.hideOnExternalClick)
                _this.hide();
        });
    };
    Menu.prototype.rendered = function () {
        //window.addEventListener('click', this);
    };
    return Menu;
}(wml.Component));
exports.Menu = Menu;

},{"./wml/menu":132,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/menu-item");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
var MenuItemClickedEvent_1 = require("./MenuItemClickedEvent");
/**
 * MenuItem
 */
var MenuItem = /** @class */ (function (_super) {
    __extends(MenuItem, _super);
    function MenuItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.disabled) ?
                    names.DISABLED : null)
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null,
            clicked: function () { return (_this.attrs.ww && _this.attrs.ww.onClick) ?
                _this.attrs.ww.onClick(new MenuItemClickedEvent_1.MenuItemClickedEvent(_this.attrs.ww.name)) : function () { }; }
        };
        return _this;
    }
    return MenuItem;
}(wml.Component));
exports.MenuItem = MenuItem;

},{"./MenuItemClickedEvent":124,"./wml/menu-item":131,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MenuItemClickedEvent indicates a menu item has been clicked.
 */
var MenuItemClickedEvent = /** @class */ (function () {
    function MenuItemClickedEvent(name) {
        this.name = name;
    }
    return MenuItemClickedEvent;
}());
exports.MenuItemClickedEvent = MenuItemClickedEvent;

},{}],125:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/button-menu");
var util_1 = require("@package/self/common/util");
/**
 * ButtonMenu
 */
var ButtonMenu = /** @class */ (function (_super) {
    __extends(ButtonMenu, _super);
    function ButtonMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this._buttonTemplate = _this.attrs.ww.buttonTemplate ?
            _this.attrs.ww.buttonTemplate : views.button;
        _this.values = {
            id: {
                root: 'root',
                target: 'menu'
            },
            root: {
                class: util_1.concat(names.BUTTON_MENU, (_this.attrs.ww && _this.attrs.ww.class) ?
                    _this.attrs.ww.class : '')
            },
            button: {
                text: _this.attrs.ww.text ? _this.attrs.ww.text : '',
                template: _this._buttonTemplate,
                class: names.BUTTON_MENU_BUTTON,
                onClick: function () { _this.view.findById(_this.values.menu.id).map(function (m) { return m.toggle(); }); }
            },
            menu: {
                id: 'menu',
                content: _this.attrs.ww.content ? _this.attrs.ww.content : _this.children
            }
        };
        return _this;
    }
    /**
     * hide the menu.
     */
    ButtonMenu.prototype.hide = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.hide(); });
        return this;
    };
    /**
     * show the menu.
     */
    ButtonMenu.prototype.show = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.show(); });
        return this;
    };
    /**
     * toggle the menu.
     */
    ButtonMenu.prototype.toggle = function () {
        this.view.findById(this.values.menu.id)
            .map(function (m) { return m.toggle(); });
        return this;
    };
    /**
     * setContent of this menu.
     */
    ButtonMenu.prototype.setContent = function (view) {
        this.values.menu.content = [view.render()];
        this.view.invalidate();
        return this;
    };
    return ButtonMenu;
}(wml.Component));
exports.ButtonMenu = ButtonMenu;

},{"./wml/button-menu":127,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonMenu_1 = require("./ButtonMenu");
exports.ButtonMenu = ButtonMenu_1.ButtonMenu;

},{"./ButtonMenu":125}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Menu_1 = require("@package/self/menu/Menu");
;
exports.button = function () { return function (___context) { return function (___view) { return ___wml.node('button', {
    html: {
        'class': ___context.values.button.class,
        'type': "button",
        'onclick': ___context.values.button.onClick
    },
    wml: {}
}, [___wml.domify(___context.values.button.text)], ___view); }; }; };
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('div', {
                html: {
                    'class': ___context.values.root.class
                },
                wml: {}
            }, [___wml.domify(___context.values.button.template()(___context)(___view)), ___wml.widget(Menu_1.Menu, {
                    html: {},
                    wml: {
                        'id': ___context.values.menu.id
                    },
                    ww: {
                        'hidden': true
                    }
                }, [___wml.domify(___context.values.menu.content)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@package/self/menu/Menu":122,"@quenk/wml":167}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Divider_1 = require("./Divider");
exports.Divider = Divider_1.Divider;
var Header_1 = require("./Header");
exports.Header = Header_1.Header;
var MenuItem_1 = require("./MenuItem");
exports.MenuItem = MenuItem_1.MenuItem;
var MenuItemClickedEvent_1 = require("./MenuItemClickedEvent");
exports.MenuItemClickedEvent = MenuItemClickedEvent_1.MenuItemClickedEvent;
var Menu_1 = require("./Menu");
exports.Menu = Menu_1.Menu;

},{"./Divider":120,"./Header":121,"./Menu":122,"./MenuItem":123,"./MenuItemClickedEvent":124}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],130:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],131:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root,
                    'onclick': ___context.values.clicked
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],132:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.values.content)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/breadcrumbs");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
;
/**
 * BreadCrumb
 */
var BreadCrumbs = /** @class */ (function (_super) {
    __extends(BreadCrumbs, _super);
    function BreadCrumbs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.BreadCrumbs(_this);
        _this.values = {
            class: {
                root: util_1.concat(names.BREAD_CRUMBS, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return BreadCrumbs;
}(wml_1.Component));
exports.BreadCrumbs = BreadCrumbs;

},{"./wml/breadcrumbs":135,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/breadcrumbs");
var wml_1 = require("@quenk/wml");
/**
 * Item for breadcrumb lists.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Item(_this);
        _this.values = {
            class: {
                root: names.BREAD_CRUMBS_ITEM
            }
        };
        return _this;
    }
    return Item;
}(wml_1.Component));
exports.Item = Item;

},{"./wml/breadcrumbs":135,"@package/self/common/names":49,"@quenk/wml":167}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var BreadCrumbs = /** @class */ (function (_super) {
    __extends(BreadCrumbs, _super);
    function BreadCrumbs(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ol', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return BreadCrumbs;
}(___wml.AppView));
exports.BreadCrumbs = BreadCrumbs;
;
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Item;
}(___wml.AppView));
exports.Item = Item;

},{"@quenk/wml":167}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wml = require("@quenk/wml");
var names = require("@package/self/common/names");
var views = require("./wml/link");
var LinkClickedEvent_1 = require("./LinkClickedEvent");
var util_1 = require("@package/self/common/util");
/**
 * Link generates an <a> element.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        /**
         * name assigned to this Link.
         */
        _this.name = (_this.attrs.ww && _this.attrs.ww.name) ?
            _this.attrs.ww.name : '';
        /**
         * title assigned to this Link.
         */
        _this.title = (_this.attrs.ww && _this.attrs.ww.title) ?
            _this.attrs.ww.title : '';
        /**
         * href assigned to this link
         */
        _this.href = (_this.attrs.ww && _this.attrs.ww.href) ?
            _this.attrs.ww.href : '';
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_LINK, _this.attrs.ww ? _this.attrs.ww.class : '', (_this.attrs.ww && _this.attrs.ww.active) ?
                    names.ACTIVE : '')
            },
            a: {
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : null,
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : null,
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : ''
            }
        };
        _this.clicked = function (e) {
            if (_this.attrs.ww) {
                var _a = _this.attrs.ww, name_1 = _a.name, href = _a.href, onClick = _a.onClick;
                if (!href)
                    e.preventDefault();
                if (onClick)
                    onClick(new LinkClickedEvent_1.LinkClickedEvent(name_1, href));
            }
        };
        return _this;
    }
    /**
      * activate this nav list Item.
      */
    Link.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Link.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Link;
}(wml.Component));
exports.Link = Link;

},{"./LinkClickedEvent":137,"./wml/link":139,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * LinkClickedEvent indicates a link has been clicked.
 */
var LinkClickedEvent = /** @class */ (function () {
    function LinkClickedEvent(name, href) {
        this.name = name;
        this.href = href;
    }
    return LinkClickedEvent;
}());
exports.LinkClickedEvent = LinkClickedEvent;

},{}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Link_1 = require("./Link");
exports.Link = Link_1.Link;
var LinkClickedEvent_1 = require("./LinkClickedEvent");
exports.LinkClickedEvent = LinkClickedEvent_1.LinkClickedEvent;

},{"./Link":136,"./LinkClickedEvent":137}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('a', {
                html: {
                    'class': ___context.values.class.root,
                    'href': ___context.values.a.href,
                    'title': ___context.values.a.title,
                    'onclick': ___context.clicked
                },
                wml: {}
            }, [(___context.values.a.text) ? ___wml.domify(___context.values.a.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/header");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Header can be used to display non-clickable heading text in a nav list.
 */
var Header = /** @class */ (function (_super) {
    __extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            item: {
                class: ''
            },
            span: {
                class: util_1.concat(names.NAV_MENU_HEADER, _this.attrs.ww ? _this.attrs.ww.class : '')
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    return Header;
}(wml.Component));
exports.Header = Header;

},{"./wml/header":147,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var views = require("./wml/item");
var wml = require("@quenk/wml");
var util_1 = require("@package/self/common/util");
/**
 * Item wraps content in a navigation list.
 *
 * Items should not have any siblings that are not other Items.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: {
                root: 'root'
            },
            class: {
                root: util_1.concat(names.NAV_MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? names.ACTIVE : null)
            },
            text: (_this.attrs.ww && _this.attrs.ww.text) ?
                _this.attrs.ww.text : null
        };
        return _this;
    }
    /**
     * activate this nav list Item.
     */
    Item.prototype.activate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) {
            w.classList.remove(names.ACTIVE);
            w.classList.add(names.ACTIVE);
        });
    };
    /**
     * inactivate this nav list item.
     */
    Item.prototype.inactivate = function () {
        this.view.findById(this.values.id.root)
            .map(function (w) { return w.classList.remove(names.ACTIVE); });
    };
    return Item;
}(wml.Component));
exports.Item = Item;

},{"./wml/item":148,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * ItemClickedEvent is fired when the user clicks on an item in
 * a nav list.
 */
var ItemClickedEvent = /** @class */ (function () {
    function ItemClickedEvent(name) {
        this.name = name;
    }
    return ItemClickedEvent;
}());
exports.ItemClickedEvent = ItemClickedEvent;

},{}],143:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var link = require("@package/self/nav/link");
var names = require("@package/self/common/names");
var views = require("./wml/link");
var util_1 = require("@package/self/common/util");
/**
 * Link provides a link entry into a nav menu.
 */
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            id: { root: '' },
            class: { root: '' },
            item: {
                class: util_1.concat(names.NAV_MENU_ITEM, (_this.attrs.ww && _this.attrs.ww.active) ? names.ACTIVE : '')
            },
            a: {
                class: util_1.concat((_this.attrs.ww && _this.attrs.ww.active) ?
                    names.ACTIVE : ''),
                title: (_this.attrs.ww && _this.attrs.ww.title) ?
                    _this.attrs.ww.title : '',
                name: (_this.attrs.ww && _this.attrs.ww.name) ?
                    _this.attrs.ww.name : '',
                href: (_this.attrs.ww && _this.attrs.ww.href) ?
                    _this.attrs.ww.href : '#',
                active: (_this.attrs.ww && _this.attrs.ww.active) ?
                    _this.attrs.ww.active : false,
                text: (_this.attrs.ww && _this.attrs.ww.text) ?
                    _this.attrs.ww.text : '',
                onClick: (_this.attrs.ww && _this.attrs.ww.onClick) ?
                    _this.attrs.ww.onClick : null
            }
        };
        return _this;
    }
    return Link;
}(link.Link));
exports.Link = Link;

},{"./wml/link":149,"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/nav/link":138}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var util = require("@package/self/common/util");
var views = require("./wml/menu");
var wml = require("@quenk/wml");
/**
 * Menu of navigation links.
 */
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        _this.values = {
            class: {
                root: util.concat(names.NAV_MENU, _this.attrs.ww ? _this.attrs.ww.class : '')
            }
        };
        return _this;
    }
    return Menu;
}(wml.Component));
exports.Menu = Menu;

},{"./wml/menu":150,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var views = require("./wml/sub-menu");
var Menu_1 = require("./Menu");
/**
 * SubMenu is used for nested menus.
 */
var SubMenu = /** @class */ (function (_super) {
    __extends(SubMenu, _super);
    function SubMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.view = new views.Main(_this);
        return _this;
    }
    return SubMenu;
}(Menu_1.Menu));
exports.SubMenu = SubMenu;

},{"./Menu":144,"./wml/sub-menu":151}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Item_1 = require("./Item");
exports.Item = Item_1.Item;
var ItemClickedEvent_1 = require("./ItemClickedEvent");
exports.ItemClickedEvent = ItemClickedEvent_1.ItemClickedEvent;
var Menu_1 = require("./Menu");
exports.Menu = Menu_1.Menu;
var SubMenu_1 = require("./SubMenu");
exports.SubMenu = SubMenu_1.SubMenu;
var Header_1 = require("./Header");
exports.Header = Header_1.Header;
var Link_1 = require("./Link");
exports.Link = Link_1.Link;

},{"./Header":140,"./Item":141,"./ItemClickedEvent":142,"./Link":143,"./Menu":144,"./SubMenu":145}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Item_1 = require("../Item");
;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {},
                ww: {
                    'class': ___context.values.item.class
                }
            }, [___wml.node('span', {
                    html: {
                        'class': ___context.values.span.class
                    },
                    wml: {}
                }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@quenk/wml":167}],148:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('li', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [(___context.values.text) ? ___wml.domify(___context.values.text) : ___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var link_1 = require("@package/self/nav/link");
;
;
var Item_1 = require("../Item");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {},
                ww: {
                    'class': ___context.values.item.class
                }
            }, [___wml.widget(link_1.Link, {
                    html: {},
                    wml: {},
                    ww: {
                        'class': ___context.values.a.class,
                        'name': ___context.values.a.name,
                        'title': ___context.values.a.title,
                        'href': ___context.values.a.href,
                        'text': ___context.values.a.text,
                        'active': ___context.values.a.active,
                        'onClick': ___context.values.a.onClick
                    }
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@package/self/nav/link":138,"@quenk/wml":167}],150:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.node('ul', {
                html: {
                    'class': ___context.values.class.root
                },
                wml: {}
            }, [___wml.domify(___context.children)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"@quenk/wml":167}],151:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
;
var Item_1 = require("../Item");
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Item_1.Item, {
                html: {},
                wml: {}
            }, [___wml.node('ul', {
                    html: {
                        'class': ___context.values.class.root
                    },
                    wml: {}
                }, [___wml.domify(___context.children)], ___view)], ___view);
        };
        return _this;
    }
    return Main;
}(___wml.AppView));
exports.Main = Main;

},{"../Item":141,"@quenk/wml":167}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * AllSelectedEvent is triggered when the user selects all the fields on the table.
 */
var AllSelectedEvent = /** @class */ (function () {
    function AllSelectedEvent(value) {
        this.value = value;
    }
    return AllSelectedEvent;
}());
exports.AllSelectedEvent = AllSelectedEvent;

},{}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Cell wraps around a <td> to provide an easier to use api.
 */
var Cell = /** @class */ (function () {
    function Cell(element) {
        this.element = element;
    }
    /**
     * setContent chanages the content of the Cell's <td> element.
     */
    Cell.prototype.setContent = function (r) {
        while (this.element.lastChild)
            this.element.removeChild(this.element.lastChild);
        this.element.appendChild(r.render());
        return this;
    };
    return Cell;
}());
exports.Cell = Cell;

},{}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * CellClickedEvent is triggered when the whitespace of a cell is clicked.
 */
var CellClickedEvent = /** @class */ (function () {
    function CellClickedEvent(value, column, rowData, rowNumber, cell) {
        this.value = value;
        this.column = column;
        this.rowData = rowData;
        this.rowNumber = rowNumber;
        this.cell = cell;
    }
    return CellClickedEvent;
}());
exports.CellClickedEvent = CellClickedEvent;

},{}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * DefaultDelegate will handle table events if no Delegate is
 * specified.
 *
 * It passes it's events onto registered callbacks.
 */
var DefaultDelegate = /** @class */ (function () {
    function DefaultDelegate(table) {
        this.table = table;
    }
    DefaultDelegate.prototype.onAllSelected = function (e) {
        if (this.table.attrs.ww.onAllSelected)
            this.table.attrs.ww.onAllSelected(e);
    };
    DefaultDelegate.prototype.onCellClicked = function (e) {
        if (this.table.attrs.ww.onCellClicked)
            this.table.attrs.ww.onCellClicked(e);
    };
    DefaultDelegate.prototype.onHeadingClicked = function (e) {
        if (this.table.attrs.ww.onHeadingClicked)
            this.table.attrs.ww.onHeadingClicked(e);
    };
    DefaultDelegate.prototype.onRowClicked = function (e) {
        if (this.table.attrs.ww.onRowClicked)
            this.table.attrs.ww.onRowClicked(e);
    };
    DefaultDelegate.prototype.onRowSelected = function (e) {
        if (this.table.attrs.ww.onRowSelected)
            this.table.attrs.ww.onRowSelected(e);
    };
    return DefaultDelegate;
}());
exports.DefaultDelegate = DefaultDelegate;

},{}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HeadingClicked is triggered when the user clicks on
 * one of the column headings.
 */
var HeadingClickedEvent = /** @class */ (function () {
    function HeadingClickedEvent(field) {
        this.field = field;
    }
    return HeadingClickedEvent;
}());
exports.HeadingClickedEvent = HeadingClickedEvent;

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RowClickedEvent is triggered when the user clicks on whitespace in
 * the row of a table.
 */
var RowClickedEvent = /** @class */ (function () {
    function RowClickedEvent(value, row, data) {
        this.value = value;
        this.row = row;
        this.data = data;
    }
    return RowClickedEvent;
}());
exports.RowClickedEvent = RowClickedEvent;

},{}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var RowClickedEvent_1 = require("./RowClickedEvent");
/**
 * RowSelectedEvent is triggered when the checkbox (if displayed) is clicked
 * on for a row.
 */
var RowSelectedEvent = /** @class */ (function (_super) {
    __extends(RowSelectedEvent, _super);
    function RowSelectedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RowSelectedEvent;
}(RowClickedEvent_1.RowClickedEvent));
exports.RowSelectedEvent = RowSelectedEvent;

},{"./RowClickedEvent":157}],159:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DefaultDelegate_1 = require("./DefaultDelegate");
var SortDelegate = /** @class */ (function (_super) {
    __extends(SortDelegate, _super);
    function SortDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SortDelegate.prototype.onHeadingClicked = function (e) {
        this.table.sort(e.field);
        _super.prototype.onHeadingClicked.call(this, e);
    };
    return SortDelegate;
}(DefaultDelegate_1.DefaultDelegate));
exports.SortDelegate = SortDelegate;

},{"./DefaultDelegate":155}],160:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var names = require("@package/self/common/names");
var view = require("./wml/table");
var util_1 = require("@package/self/common/util");
var wml_1 = require("@quenk/wml");
var property_seek_1 = require("property-seek");
var CellClickedEvent_1 = require("./CellClickedEvent");
var RowClickedEvent_1 = require("./RowClickedEvent");
var RowSelectedEvent_1 = require("./RowSelectedEvent");
var HeadingClickedEvent_1 = require("./HeadingClickedEvent");
var AllSelectedEvent_1 = require("./AllSelectedEvent");
var SortDelegate_1 = require("./SortDelegate");
var Cell_1 = require("./Cell");
var _1 = require(".");
/**
 * Table provides a smarter html table.
 *
 * @todo split sort and select api into own table widgets.
 */
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.originalData = _this.attrs.ww.data;
        _this.view = new view.Table(_this);
        _this.delegate = _this.attrs.ww.delegate ?
            _this.attrs.ww.delegate : new SortDelegate_1.SortDelegate(_this);
        _this.values = {
            id: {
                root: 'root',
            },
            class: {
                root: util_1.concat(names.TABLE, _this.attrs.ww.class),
                row: _this.attrs.ww.rowClass || '',
                cell: _this.attrs.ww.cellClass || '',
                heading: _this.attrs.ww.headingClass || ''
            },
            fragment: {
                empty: _this.attrs.ww.empty
            },
            options: {
                selectable: _this.attrs.ww.selectable
            },
            table: {
                thead: {
                    th: {
                        onclick: function (field) { return function () {
                            return _this.delegate.onHeadingClicked(new HeadingClickedEvent_1.HeadingClickedEvent(field));
                        }; },
                        onSelect: function () {
                            return _this.delegate.onAllSelected(new AllSelectedEvent_1.AllSelectedEvent(_this.originalData));
                        }
                    }
                },
                tbody: {
                    tr: {
                        class: _this.attrs.ww.rowClass,
                        onclick: function (row, index, data) { return function () {
                            return _this.delegate.onRowClicked(new RowClickedEvent_1.RowClickedEvent(row, index, data));
                        }; },
                        onSelect: function (row, index, data) { return function () {
                            return _this.delegate.onRowSelected(new RowSelectedEvent_1.RowSelectedEvent(row, index, data));
                        }; }
                    },
                    td: {
                        id: function (column, rowNumber) { return column + "," + rowNumber; },
                        class: _this.attrs.ww.cellClass,
                        onclick: function (value, column, rowData, rowNumber) {
                            return function (e) {
                                return _this
                                    .delegate
                                    .onCellClicked(new CellClickedEvent_1.CellClickedEvent(value, column, rowData, rowNumber, new Cell_1.Cell(e.target)));
                            };
                        }
                    }
                }
            },
            sortedOn: '',
            data: _this.originalData.slice(),
            columns: _this.attrs.ww.columns,
            arrow: ''
        };
        return _this;
    }
    /**
     * modifyBody allows a function to modify the contents
     * of the <tbody>
     */
    Table.prototype.modifyBody = function (f) {
        this.view.findById('body').map(f);
        return this;
    };
    Table.prototype.sort = function (name) {
        var columns = this.attrs.ww ? this.attrs.ww.columns ? this.attrs.ww.columns : [] : [];
        var field = columns.reduce(function (p, c) { return p ? p : (c.name === name ? c : null); });
        var sortOn;
        var strategy;
        if (!field)
            throw new Error("Table#sort: unknown field '" + name + "'");
        sortOn = field.sortAs || name;
        strategy = field.strategy || _1.stringSort;
        if (this.values.sortedOn === name) {
            this.values.data = this.values.data.reverse();
            this.values.arrow = (this.values.arrow === _1.ASC_ARROW) ? _1.DESC_ARROW : _1.ASC_ARROW;
        }
        else {
            this.values.arrow = _1.DESC_ARROW;
            this.values.data = this
                .originalData
                .slice()
                .sort(function (a, b) { return strategy(property_seek_1.get(sortOn, a), property_seek_1.get(sortOn, b)); });
        }
        this.values.sortedOn = name;
        this.view.invalidate();
        return this;
    };
    /**
     * update the data the table displays
     */
    Table.prototype.update = function (data) {
        this.originalData = data.slice();
        this.values.data = data.slice();
        (this.values.sortedOn === '') ? this.view.invalidate() : this.sort(this.values.sortedOn);
        return this;
    };
    /**
     * cellAt produces a Cell instance for the coordinates passed (if found).
     */
    Table.prototype.cellAt = function (column, row) {
        return this
            .view
            .findById("" + column + row)
            .map(function (e) { return new Cell_1.Cell(e); });
    };
    /**
     * prepend adds one or more new data rows to the begining of the table.
     */
    Table.prototype.prepend = function (data) {
        var _this = this;
        var d = Array.isArray(data) ? data : [data];
        this.modifyBody(function (e) {
            var dom = view.rows(d, _this.values.columns)(_this)(_this.view);
            if (e.children.length === 0)
                e.appendChild(dom);
            else
                e.replaceChild(dom, e.firstChild);
        });
        return this;
    };
    /**
     * append adds one or more new data rows to the end of the table.
     */
    Table.prototype.append = function (data) {
        var _this = this;
        var d = Array.isArray(data) ? data : [data];
        this.modifyBody(function (e) {
            return e.appendChild(view.rows(d, _this.values.columns)(_this)(_this.view));
        });
        return this;
    };
    /**
     * prependRow prepends customisable DOM content to the
     * begining of the table body.
     *
     * NOTE: This DOM content of must be between <tr> elements.
     */
    Table.prototype.prependRow = function (renderer) {
        this.modifyBody(function (e) {
            if (e.firstChild == null)
                e.appendChild(renderer.render());
            else
                e.replaceChild(renderer.render(), e.firstChild);
        });
        return this;
    };
    /**
     * appendRow appends customisable DOM content to the
     * begining of the table body.
     *
     * NOTE: This DOM content of must be between <tr> elements.
     */
    Table.prototype.appendRow = function (renderer) {
        this.modifyBody(function (e) {
            e.appendChild(renderer.render());
        });
        return this;
    };
    /**
     * removeRow will remove an entire row from the table given its index.
     */
    Table.prototype.removeRow = function (index) {
        this.modifyBody(function (e) {
            for (var i = 0; i <= e.rows.length; i++)
                if (i === index)
                    e.rows[i].parentNode.removeChild(e.rows[i]);
        });
        return this;
    };
    return Table;
}(wml_1.Component));
exports.Table = Table;

},{".":161,"./AllSelectedEvent":152,"./Cell":153,"./CellClickedEvent":154,"./HeadingClickedEvent":156,"./RowClickedEvent":157,"./RowSelectedEvent":158,"./SortDelegate":159,"./wml/table":162,"@package/self/common/names":49,"@package/self/common/util":50,"@quenk/wml":167,"property-seek":182}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AllSelectedEvent_1 = require("./AllSelectedEvent");
exports.AllSelectedEvent = AllSelectedEvent_1.AllSelectedEvent;
var CellClickedEvent_1 = require("./CellClickedEvent");
exports.CellClickedEvent = CellClickedEvent_1.CellClickedEvent;
var RowClickedEvent_1 = require("./RowClickedEvent");
exports.RowClickedEvent = RowClickedEvent_1.RowClickedEvent;
var HeadingClickedEvent_1 = require("./HeadingClickedEvent");
exports.HeadingClickedEvent = HeadingClickedEvent_1.HeadingClickedEvent;
var Table_1 = require("./Table");
exports.Table = Table_1.Table;
var Cell_1 = require("./Cell");
exports.Cell = Cell_1.Cell;
exports.ASC_ARROW = '\u21e7';
exports.DESC_ARROW = '\u21e9';
exports.dateSort = function (a, b) {
    var na = new Date(a).getTime();
    var nb = new Date(b).getTime();
    return na > nb ? -1 : na < nb ? 1 : 0;
};
exports.stringSort = function (a, b) {
    var la = String(a).replace(/\s+/, '').toLowerCase();
    var lb = String(b).replace(/\s+/, '').toLowerCase();
    return (la > lb) ? -1 : (la < lb) ? 1 : 0;
};
exports.naturalSort = function (a, b) {
    if (a === void 0) { a = ''; }
    if (b === void 0) { b = ''; }
    //Source: http://stackoverflow.com/questions/4340227/sort-mixed-alpha-numeric-array
    var reA = /[^a-zA-Z]/g;
    var reN = /[^0-9]/g;
    var AInt = parseInt(a, 10);
    var BInt = parseInt(b, 10);
    if (isNaN(AInt) && isNaN(BInt)) {
        var aA = a.replace(reA, '');
        var bA = b.replace(reA, '');
        if (aA === bA) {
            var aN = parseInt(a.replace(reN, ''), 10);
            var bN = parseInt(b.replace(reN, ''), 10);
            return aN === bN ? 0 : aN > bN ? -1 : 1;
        }
        else {
            return aA > bA ? -1 : 1;
        }
    }
    else if (isNaN(AInt)) {
        return -1; //to make alphanumeric sort first return -1 here
    }
    else if (isNaN(BInt)) {
        return 1; //to make alphanumeric sort first return 1 here
    }
    else {
        return AInt > BInt ? -1 : 1;
    }
};
exports.numberSort = function (a, b) {
    var na = parseFloat(a);
    var nb = parseFloat(b);
    na = (isNaN(a)) ? -Infinity : a;
    nb = (isNaN(b)) ? -Infinity : b;
    return (na > nb) ? -1 : (na < nb) ? 1 : 0;
};

},{"./AllSelectedEvent":152,"./Cell":153,"./CellClickedEvent":154,"./HeadingClickedEvent":156,"./RowClickedEvent":157,"./Table":160}],162:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ___wml = require("@quenk/wml");
var names = require("@package/self/common/names");
;
var util_1 = require("@package/self/common/util");
;
var property_seek_1 = require("property-seek");
;
var Fragment_1 = require("@package/self/layout/fragment/Fragment");
;
exports.allSelectedCheckbox = function () { return function (___context) { return function (___view) { return ___wml.node('th', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': ___context.values.table.thead.th.onSelect
        },
        wml: {}
    }, [], ___view)], ___view); }; }; };
;
exports.headings = function (columns) { return function (___context) { return function (___view) { return ___wml.map(columns, function _map(field) {
    return (field.sortAs) ? ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.class.heading, ((___context.values.sortedOn === field.name)) ? names.ACTIVE : ""),
            'onclick': ___context.values.table.thead.th.onclick(field.name)
        },
        wml: {}
    }, [___wml.domify(field.heading), ((___context.values.sortedOn === field.name)) ? ___wml.domify(___context.values.arrow) : ___wml.domify("")], ___view) : ___wml.node('th', {
        html: {
            'class': util_1.concat(___context.values.class.heading, ((___context.values.sortedOn === field.name)) ? names.ACTIVE : ""),
            'onclick': ___context.values.table.thead.th.onclick(field.name)
        },
        wml: {}
    }, [___wml.domify(field.heading), ___wml.domify(((___context.values.sortedOn === field.name)) ? ___context.values.arrow : "")], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.thead = function (columns) { return function (___context) { return function (___view) { return ___wml.node('tr', {
    html: {},
    wml: {}
}, [(___context.values.options.selectable) ? ___wml.box(___wml.domify(exports.allSelectedCheckbox()(___context)(___view)), ___wml.domify(exports.headings(columns)(___context)(___view))) : ___wml.domify(exports.headings(columns)(___context)(___view))], ___view); }; }; };
;
exports.rowSelectCheckbox = function (row, index) { return function (___context) { return function (___view) { return (___context.values.options.selectable) ? ___wml.node('td', {
    html: {},
    wml: {}
}, [___wml.node('input', {
        html: {
            'type': "checkbox",
            'onclick': ___context.values.table.tbody.tr.onSelect(row, index, ___context.values.data)
        },
        wml: {}
    }, [], ___view)], ___view) : ___wml.domify(""); }; }; };
;
exports.cells = function (rowData, rowNumber, columns) { return function (___context) { return function (___view) { return ___wml.box((___context.values.options.selectable) ? ___wml.domify(exports.rowSelectCheckbox(rowData, rowNumber)(___context)(___view)) : ___wml.domify(""), ___wml.map(columns, function _map(field) {
    return ___wml.node('td', {
        html: {
            'class': ___context.values.table.tbody.td.class,
            'onclick': ___context.values.table.tbody.td.onclick(property_seek_1.get(field.name, rowData), field.name, rowData, rowNumber)
        },
        wml: {
            'id': ___context.values.table.tbody.td.id(field.name, rowNumber)
        }
    }, [(field.fragment) ? ___wml.domify(field.fragment(property_seek_1.get(field.name, rowData), field.name, rowData)(___view)) : ___wml.domify(property_seek_1.get(field.name, rowData))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
})); }; }; };
;
exports.rows = function (data, columns) { return function (___context) { return function (___view) { return ___wml.map(data, function _map(rowData, index) {
    return ___wml.node('tr', {
        html: {
            'class': ___context.values.table.tbody.tr.class,
            'onclick': ___context.values.table.tbody.tr.onclick(rowData, index, data)
        },
        wml: {}
    }, [___wml.domify(exports.cells(rowData, index, columns)(___context)(___view))], ___view);
}, function otherwise() {
    return document.createDocumentFragment();
}); }; }; };
;
exports.table = function () { return function (___context) { return function (___view) { return ___wml.node('table', {
    html: {
        'class': ___context.values.class.root
    },
    wml: {
        'id': ___context.values.id.root
    }
}, [___wml.node('thead', {
        html: {},
        wml: {
            'id': "head"
        }
    }, [___wml.domify(exports.thead(___context.values.columns)(___context)(___view))], ___view), ___wml.node('tbody', {
        html: {},
        wml: {
            'id': "body"
        }
    }, [___wml.domify(exports.rows(___context.values.data, ___context.values.columns)(___context)(___view))], ___view)], ___view); }; }; };
;
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table(context) {
        var _this = _super.call(this, context) || this;
        _this.template = function (___context, ___view) {
            return ___wml.widget(Fragment_1.Fragment, {
                html: {},
                wml: {}
            }, [((___context.values.data.length === 0)) ? (___context.values.fragment.empty) ? ___wml.domify(___context.values.fragment.empty.render()) : ___wml.domify(exports.table()(___context)(___view)) : ___wml.domify(exports.table()(___context)(___view))], ___view);
        };
        return _this;
    }
    return Table;
}(___wml.AppView));
exports.Table = Table;

},{"@package/self/common/names":49,"@package/self/common/util":50,"@package/self/layout/fragment/Fragment":107,"@quenk/wml":167,"property-seek":182}],163:[function(require,module,exports){
"use strict";
/**
 * Types corresponding to the WML AST.
 */
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * Module is what a wml file compiles to.
 *
 * A module contains a list of imports and exported symbols.
 * All declarations in wml are exported. There is no such thing
 * as private here.
 */
var Module = /** @class */ (function () {
    function Module(imports, exports, main, location) {
        this.imports = imports;
        this.exports = exports;
        this.main = main;
        this.location = location;
        this.type = 'module';
    }
    return Module;
}());
exports.Module = Module;
/**
 * ImportStatement
 */
var ImportStatement = /** @class */ (function () {
    function ImportStatement(member, module, location) {
        this.member = member;
        this.module = module;
        this.location = location;
        this.type = 'import-statement';
    }
    return ImportStatement;
}());
exports.ImportStatement = ImportStatement;
/**
 * AliasedMember
 * @property {Identifier} alias - The identifier introduced to scope.
 * @property {Identifier} member - The identifier that is aliased.
 */
var AliasedMember = /** @class */ (function () {
    function AliasedMember(member, alias, location) {
        this.member = member;
        this.alias = alias;
        this.location = location;
        this.type = 'aliased-member';
    }
    return AliasedMember;
}());
exports.AliasedMember = AliasedMember;
/**
 * AggregateMember
 */
var AggregateMember = /** @class */ (function () {
    function AggregateMember(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'qualified-member';
    }
    return AggregateMember;
}());
exports.AggregateMember = AggregateMember;
/**
 * CompositeMember
 * @property {...Identifier|Aliased_Member} members
 */
var CompositeMember = /** @class */ (function () {
    function CompositeMember(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'composite-member';
    }
    return CompositeMember;
}());
exports.CompositeMember = CompositeMember;
var TypedMain = /** @class */ (function () {
    function TypedMain(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'typed-main';
    }
    return TypedMain;
}());
exports.TypedMain = TypedMain;
var UntypedMain = /** @class */ (function () {
    function UntypedMain(tag, location) {
        this.tag = tag;
        this.location = location;
        this.type = 'untyped-main';
    }
    return UntypedMain;
}());
exports.UntypedMain = UntypedMain;
var ExportStatement = /** @class */ (function () {
    function ExportStatement(members, module, location) {
        this.members = members;
        this.module = module;
        this.location = location;
        this.type = 'export-statement';
    }
    return ExportStatement;
}());
exports.ExportStatement = ExportStatement;
/**
 * ViewStatement
 */
var ViewStatement = /** @class */ (function () {
    function ViewStatement(id, typeClasses, context, parameters, tag, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.tag = tag;
        this.location = location;
        this.type = 'view-statement';
    }
    return ViewStatement;
}());
exports.ViewStatement = ViewStatement;
var FunStatement = /** @class */ (function () {
    function FunStatement(id, typeClasses, context, parameters, body, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.context = context;
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'fun-statement';
    }
    return FunStatement;
}());
exports.FunStatement = FunStatement;
/**
 * TypeClass
 */
var TypeClass = /** @class */ (function () {
    function TypeClass(id, constraint, location) {
        this.id = id;
        this.constraint = constraint;
        this.location = location;
        this.type = 'type-class';
    }
    return TypeClass;
}());
exports.TypeClass = TypeClass;
var Type = /** @class */ (function () {
    function Type(id, typeClasses, list, location) {
        this.id = id;
        this.typeClasses = typeClasses;
        this.list = list;
        this.location = location;
        this.type = 'type';
    }
    return Type;
}());
exports.Type = Type;
var TypedParameter = /** @class */ (function () {
    function TypedParameter(id, hint, location) {
        this.id = id;
        this.hint = hint;
        this.location = location;
        this.type = 'typed-parameter';
    }
    return TypedParameter;
}());
exports.TypedParameter = TypedParameter;
var UntypedParameter = /** @class */ (function () {
    function UntypedParameter(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'untyped-parameter';
    }
    return UntypedParameter;
}());
exports.UntypedParameter = UntypedParameter;
var Node = /** @class */ (function () {
    function Node(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'node';
    }
    return Node;
}());
exports.Node = Node;
var Widget = /** @class */ (function () {
    function Widget(open, attributes, children, close) {
        this.open = open;
        this.attributes = attributes;
        this.children = children;
        this.close = close;
        this.type = 'widget';
    }
    return Widget;
}());
exports.Widget = Widget;
var Attribute = /** @class */ (function () {
    function Attribute(namespace, name, value, location) {
        this.namespace = namespace;
        this.name = name;
        this.value = value;
        this.location = location;
        this.type = 'attribute';
    }
    return Attribute;
}());
exports.Attribute = Attribute;
var Interpolation = /** @class */ (function () {
    function Interpolation(expression, filters, location) {
        this.expression = expression;
        this.filters = filters;
        this.location = location;
        this.type = 'interpolation';
    }
    return Interpolation;
}());
exports.Interpolation = Interpolation;
var ForStatement = /** @class */ (function () {
    function ForStatement(variable, index, all, list, body, otherwise, location) {
        this.variable = variable;
        this.index = index;
        this.all = all;
        this.list = list;
        this.body = body;
        this.otherwise = otherwise;
        this.location = location;
        this.type = 'for-statement';
    }
    return ForStatement;
}());
exports.ForStatement = ForStatement;
var IfStatement = /** @class */ (function () {
    function IfStatement(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'if-statement';
    }
    return IfStatement;
}());
exports.IfStatement = IfStatement;
var ElseClause = /** @class */ (function () {
    function ElseClause(children, location) {
        this.children = children;
        this.location = location;
        this.type = 'else-clause';
    }
    return ElseClause;
}());
exports.ElseClause = ElseClause;
var ElseIfClause = /** @class */ (function () {
    function ElseIfClause(condition, then, elseClause, location) {
        this.condition = condition;
        this.then = then;
        this.elseClause = elseClause;
        this.location = location;
        this.type = 'else-if-clause';
    }
    return ElseIfClause;
}());
exports.ElseIfClause = ElseIfClause;
var Characters = /** @class */ (function () {
    function Characters(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'characters';
    }
    return Characters;
}());
exports.Characters = Characters;
var IfThenExpression = /** @class */ (function () {
    function IfThenExpression(condition, iftrue, iffalse, location) {
        this.condition = condition;
        this.iftrue = iftrue;
        this.iffalse = iffalse;
        this.location = location;
        this.type = 'if-then-expression';
    }
    return IfThenExpression;
}());
exports.IfThenExpression = IfThenExpression;
var BinaryExpression = /** @class */ (function () {
    function BinaryExpression(left, operator, right, location) {
        this.left = left;
        this.operator = operator;
        this.right = right;
        this.location = location;
        this.type = 'binary-expression';
    }
    return BinaryExpression;
}());
exports.BinaryExpression = BinaryExpression;
var UnaryExpression = /** @class */ (function () {
    function UnaryExpression(operator, expression) {
        this.operator = operator;
        this.expression = expression;
        this.type = 'unary-expression';
    }
    return UnaryExpression;
}());
exports.UnaryExpression = UnaryExpression;
var ViewConstruction = /** @class */ (function () {
    function ViewConstruction(cons, context, location) {
        this.cons = cons;
        this.context = context;
        this.location = location;
        this.type = 'view-construction';
    }
    return ViewConstruction;
}());
exports.ViewConstruction = ViewConstruction;
var FunApplication = /** @class */ (function () {
    function FunApplication(target, typeArgs, context, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.context = context;
        this.args = args;
        this.location = location;
        this.type = 'fun-application';
    }
    return FunApplication;
}());
exports.FunApplication = FunApplication;
var ConstructExpression = /** @class */ (function () {
    function ConstructExpression(cons, args, location) {
        this.cons = cons;
        this.args = args;
        this.location = location;
        this.type = 'construct-expression';
    }
    return ConstructExpression;
}());
exports.ConstructExpression = ConstructExpression;
var CallExpression = /** @class */ (function () {
    function CallExpression(target, typeArgs, args, location) {
        this.target = target;
        this.typeArgs = typeArgs;
        this.args = args;
        this.location = location;
        this.type = 'call-expression';
    }
    return CallExpression;
}());
exports.CallExpression = CallExpression;
/**
 * MemberExpression
 */
var MemberExpression = /** @class */ (function () {
    function MemberExpression(target, member, location) {
        this.target = target;
        this.member = member;
        this.location = location;
    }
    return MemberExpression;
}());
exports.MemberExpression = MemberExpression;
var ReadExpression = /** @class */ (function () {
    function ReadExpression(target, path, hint, defaults, location) {
        this.target = target;
        this.path = path;
        this.hint = hint;
        this.defaults = defaults;
        this.location = location;
        this.type = 'read-expression';
    }
    return ReadExpression;
}());
exports.ReadExpression = ReadExpression;
var FunctionExpression = /** @class */ (function () {
    function FunctionExpression(parameters, body, location) {
        this.parameters = parameters;
        this.body = body;
        this.location = location;
        this.type = 'function-expression';
    }
    return FunctionExpression;
}());
exports.FunctionExpression = FunctionExpression;
var List = /** @class */ (function () {
    function List(members, location) {
        this.members = members;
        this.location = location;
        this.type = 'list';
    }
    return List;
}());
exports.List = List;
var Record = /** @class */ (function () {
    function Record(properties, location) {
        this.properties = properties;
        this.location = location;
        this.type = 'record';
    }
    return Record;
}());
exports.Record = Record;
var Property = /** @class */ (function () {
    function Property(key, value, location) {
        this.key = key;
        this.value = value;
        this.location = location;
        this.type = 'property';
    }
    return Property;
}());
exports.Property = Property;
var StringLiteral = /** @class */ (function () {
    function StringLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'string';
    }
    return StringLiteral;
}());
exports.StringLiteral = StringLiteral;
var NumberLiteral = /** @class */ (function () {
    function NumberLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'number-literal';
    }
    return NumberLiteral;
}());
exports.NumberLiteral = NumberLiteral;
var BooleanLiteral = /** @class */ (function () {
    function BooleanLiteral(value, location) {
        this.value = value;
        this.location = location;
        this.type = 'boolean-literal';
    }
    return BooleanLiteral;
}());
exports.BooleanLiteral = BooleanLiteral;
var ContextProperty = /** @class */ (function () {
    function ContextProperty(member, location) {
        this.member = member;
        this.location = location;
        this.type = 'context-property';
    }
    return ContextProperty;
}());
exports.ContextProperty = ContextProperty;
var ContextVariable = /** @class */ (function () {
    function ContextVariable(location) {
        this.location = location;
        this.type = 'context-variable';
    }
    return ContextVariable;
}());
exports.ContextVariable = ContextVariable;
var UnqualifiedConstructor = /** @class */ (function () {
    function UnqualifiedConstructor(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-constructor';
    }
    return UnqualifiedConstructor;
}());
exports.UnqualifiedConstructor = UnqualifiedConstructor;
var QualifiedConstructor = /** @class */ (function () {
    function QualifiedConstructor(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-constructor';
    }
    return QualifiedConstructor;
}());
exports.QualifiedConstructor = QualifiedConstructor;
var UnqualifiedIdentifier = /** @class */ (function () {
    function UnqualifiedIdentifier(id, location) {
        this.id = id;
        this.location = location;
        this.type = 'unqualified-identifier';
    }
    return UnqualifiedIdentifier;
}());
exports.UnqualifiedIdentifier = UnqualifiedIdentifier;
/**
 * QualifiedIdentifier
 */
var QualifiedIdentifier = /** @class */ (function () {
    function QualifiedIdentifier(qualifier, member, location) {
        this.qualifier = qualifier;
        this.member = member;
        this.location = location;
        this.type = 'qualified-identifier';
    }
    return QualifiedIdentifier;
}());
exports.QualifiedIdentifier = QualifiedIdentifier;

},{}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path='Parser.d.ts' />
var Parser = require("./Parser");
var nodes = require("./AST");
var afpl = require("afpl");
var jsfmt = require("js-beautify");
var TypeScript = require("./TypeScript");
var afpl_1 = require("afpl");
var defaultOptions = {
    debug: false,
    main: 'Main',
    module: '@quenk/wml',
};
/**
 * parse a string as WML returning either an error or an AST.
 */
exports.parse = function (str, ast) {
    if (ast === void 0) { ast = nodes; }
    Parser.parser.yy = { ast: ast };
    try {
        return afpl_1.Either.right(Parser.parser.parse(str));
    }
    catch (e) {
        return afpl_1.Either.left(e);
    }
};
/**
 * pretty up the output.
 */
exports.pretty = function (doit) { return function (s) {
    return doit ? jsfmt(s, {}) : s;
}; };
/**
 * compile a string of WML turning it into typescript code.
 */
exports.compile = function (src, options) {
    if (options === void 0) { options = {}; }
    var opts = afpl.util.merge(defaultOptions, options);
    return exports.parse(src)
        .map(function (m) { return TypeScript.code(m, opts); })
        .map(exports.pretty(options.pretty));
};

},{"./AST":163,"./Parser":165,"./TypeScript":166,"afpl":169,"js-beautify":177}],165:[function(require,module,exports){

/* parser generated by jison 0.6.1-203 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var Parser = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   no try..catch: ................... false
    //   no default resolve on conflict:    false
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main(): 
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3,
  ebnf: true
},
symbols_: {
  "!": 16,
  "!=": 60,
  "$accept": 0,
  "$end": 1,
  "%}": 30,
  "&&": 61,
  "(": 7,
  ")": 8,
  "*": 3,
  "+": 21,
  ",": 6,
  "-": 23,
  ".": 17,
  "/": 22,
  "/>": 38,
  ":": 12,
  ";": 20,
  "<": 13,
  "</": 37,
  "<=": 58,
  "=": 9,
  "==": 59,
  "=>": 50,
  ">": 14,
  ">=": 57,
  "?": 18,
  "@": 19,
  "AS": 27,
  "CHARACTERS": 47,
  "CONSTRUCTOR": 56,
  "ELSE": 44,
  "ENDFOR": 43,
  "ENDFUN": 36,
  "ENDIF": 46,
  "ENDMAIN": 31,
  "ENDVIEW": 34,
  "EOF": 1,
  "EXPORT": 32,
  "FALSE": 54,
  "FOR": 41,
  "FROM": 26,
  "FUN": 35,
  "IDENTIFIER": 55,
  "IF": 45,
  "IMPORT": 25,
  "IN": 42,
  "INSTANCEOF": 63,
  "MAIN": 29,
  "NUMBER_LITERAL": 52,
  "STRING_LITERAL": 51,
  "THEN": 48,
  "TRUE": 53,
  "VIEW": 33,
  "[": 10,
  "\\\\": 49,
  "]": 11,
  "^": 24,
  "aggregate_member": 69,
  "aliased_member": 68,
  "argument_list": 105,
  "arguments": 104,
  "attribute": 94,
  "attribute_value": 95,
  "attribute_value_group": 155,
  "attributes": 93,
  "binary_expression": 108,
  "binary_operator": 138,
  "binary_operator_group": 161,
  "boolean_literal": 129,
  "call_expression": 117,
  "characters": 103,
  "child": 89,
  "child_group": 150,
  "children": 88,
  "composite_member": 70,
  "cons": 132,
  "construct_expression": 116,
  "context_property": 130,
  "context_type": 80,
  "context_variable": 131,
  "control": 99,
  "control_group": 156,
  "else_clause": 102,
  "end_main": 74,
  "error": 2,
  "export": 76,
  "export_statement": 77,
  "exports": 75,
  "expression": 106,
  "filter": 98,
  "filters": 97,
  "for_statement": 100,
  "fun_application": 112,
  "fun_statement": 79,
  "fun_target": 113,
  "function_expression": 121,
  "identifier": 135,
  "if_expression": 107,
  "if_statement": 101,
  "import_member": 67,
  "import_statement": 66,
  "import_statement_option": 139,
  "imports": 65,
  "interpolation": 96,
  "list": 126,
  "literal": 122,
  "literal_group": 159,
  "main": 73,
  "main_option": 143,
  "main_option2": 144,
  "main_option3": 145,
  "main_option4": 146,
  "member": 72,
  "member_expression": 118,
  "member_group": 142,
  "member_list": 71,
  "member_list_group": 140,
  "member_list_group2": 141,
  "module": 64,
  "node": 91,
  "node_option": 151,
  "node_option2": 152,
  "number_literal": 128,
  "parameter": 87,
  "parameter_list": 86,
  "parameters": 85,
  "properties": 124,
  "property": 125,
  "property_group": 160,
  "qualified_constructor": 133,
  "qualified_identifier": 136,
  "read_expression": 119,
  "readable_expression": 120,
  "readable_expression_group": 158,
  "record": 123,
  "simple_expression": 110,
  "simple_expression_group": 157,
  "string_literal": 127,
  "tag": 90,
  "type": 84,
  "type_arg_list": 115,
  "type_arguments": 114,
  "type_class": 83,
  "type_class_list": 82,
  "type_classes": 81,
  "type_option": 149,
  "unary_expression": 109,
  "unqualified_constructor": 134,
  "unqualified_identifier": 137,
  "view_construction": 111,
  "view_statement": 78,
  "view_statement_option": 147,
  "view_statement_option2": 148,
  "widget": 92,
  "widget_option": 153,
  "widget_option2": 154,
  "{": 4,
  "{%": 28,
  "{{": 39,
  "|": 15,
  "||": 62,
  "}": 5,
  "}}": 40
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "*",
  4: "{",
  5: "}",
  6: ",",
  7: "(",
  8: ")",
  9: "=",
  10: "[",
  11: "]",
  12: ":",
  13: "<",
  14: ">",
  15: "|",
  16: "!",
  17: ".",
  18: "?",
  19: "@",
  20: ";",
  21: "+",
  22: "/",
  23: "-",
  24: "^",
  25: "IMPORT",
  26: "FROM",
  27: "AS",
  28: "{%",
  29: "MAIN",
  30: "%}",
  31: "ENDMAIN",
  32: "EXPORT",
  33: "VIEW",
  34: "ENDVIEW",
  35: "FUN",
  36: "ENDFUN",
  37: "</",
  38: "/>",
  39: "{{",
  40: "}}",
  41: "FOR",
  42: "IN",
  43: "ENDFOR",
  44: "ELSE",
  45: "IF",
  46: "ENDIF",
  47: "CHARACTERS",
  48: "THEN",
  49: "\\\\",
  50: "=>",
  51: "STRING_LITERAL",
  52: "NUMBER_LITERAL",
  53: "TRUE",
  54: "FALSE",
  55: "IDENTIFIER",
  56: "CONSTRUCTOR",
  57: ">=",
  58: "<=",
  59: "==",
  60: "!=",
  61: "&&",
  62: "||",
  63: "INSTANCEOF"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [64, 7],
  65,
  65,
  66,
  s,
  [67, 3],
  s,
  [68, 4, 1],
  71,
  72,
  73,
  73,
  74,
  75,
  75,
  s,
  [76, 3],
  77,
  78,
  s,
  [79, 16],
  80,
  81,
  82,
  82,
  s,
  [83, 4],
  s,
  [84, 3],
  85,
  85,
  86,
  86,
  87,
  87,
  88,
  88,
  89,
  90,
  90,
  s,
  [91, 4],
  s,
  [92, 4],
  93,
  93,
  s,
  [94, 4],
  95,
  96,
  96,
  97,
  s,
  [97, 4, 1],
  s,
  [100, 5],
  101,
  102,
  102,
  103,
  104,
  104,
  105,
  105,
  s,
  [106, 7],
  107,
  s,
  [108, 4],
  109,
  s,
  [109, 4, 1],
  s,
  [112, 3],
  s,
  [113, 3],
  114,
  115,
  115,
  116,
  s,
  [117, 8],
  s,
  [118, 10],
  s,
  [119, 10],
  120,
  120,
  121,
  121,
  122,
  123,
  123,
  124,
  124,
  125,
  126,
  s,
  [126, 4, 1],
  s,
  [129, 4, 1],
  132,
  133,
  133,
  134,
  135,
  135,
  136,
  s,
  [136, 4, 1],
  139,
  140,
  140,
  141,
  141,
  142,
  142,
  143,
  143,
  144,
  144,
  145,
  145,
  146,
  146,
  147,
  147,
  148,
  148,
  149,
  149,
  s,
  [150, 5],
  151,
  151,
  152,
  152,
  153,
  153,
  154,
  154,
  155,
  155,
  156,
  156,
  s,
  [157, 10],
  s,
  [158, 4],
  s,
  [159, 5],
  160,
  160,
  s,
  [161, 14]
]),
  rule: u([
  4,
  3,
  3,
  2,
  3,
  2,
  2,
  1,
  2,
  5,
  s,
  [1, 3],
  s,
  [3, 3],
  1,
  3,
  1,
  11,
  c,
  [4, 3],
  2,
  s,
  [1, 3],
  6,
  13,
  11,
  10,
  10,
  9,
  10,
  9,
  9,
  8,
  9,
  8,
  8,
  7,
  8,
  7,
  7,
  6,
  c,
  [31, 5],
  c,
  [4, 3],
  2,
  4,
  c,
  [53, 3],
  c,
  [46, 3],
  1,
  c,
  [40, 5],
  8,
  7,
  4,
  3,
  c,
  [4, 4],
  c,
  [68, 3],
  c,
  [19, 4],
  3,
  4,
  1,
  c,
  [80, 3],
  10,
  12,
  14,
  14,
  16,
  18,
  6,
  7,
  7,
  1,
  c,
  [42, 4],
  s,
  [1, 6],
  3,
  6,
  3,
  5,
  5,
  7,
  2,
  4,
  1,
  4,
  6,
  5,
  5,
  4,
  c,
  [111, 4],
  c,
  [75, 3],
  c,
  [127, 4],
  3,
  2,
  5,
  c,
  [136, 3],
  s,
  [3, 6],
  5,
  3,
  6,
  8,
  6,
  8,
  c,
  [4, 4],
  10,
  8,
  c,
  [76, 3],
  c,
  [154, 3],
  c,
  [106, 4],
  c,
  [5, 3],
  s,
  [1, 3],
  c,
  [110, 4],
  c,
  [99, 4],
  c,
  [5, 5],
  0,
  s,
  [1, 7],
  0,
  c,
  [10, 3],
  c,
  [4, 10],
  c,
  [19, 13],
  s,
  [1, 39]
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : module $end */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 1];
    this._$ = yylstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 1:
    /*! Production::    module : imports exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 2:
    /*! Production::    module : imports exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 3:
    /*! Production::    module : imports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 4:
    /*! Production::    module : imports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module(yyvstack[yysp - 1], [], null, this._$); 
    return this.$;
    break;

case 5:
    /*! Production::    module : exports main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 6:
    /*! Production::    module : exports EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], yyvstack[yysp - 1], null, this._$); 
    return this.$;
    break;

case 7:
    /*! Production::    module : main EOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Module([], [], yyvstack[yysp - 1], this._$); 
    return this.$;
    break;

case 8:
    /*! Production::    imports : import_statement */
case 85:
    /*! Production::    filters : filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =  [yyvstack[yysp]];
    break;

case 9:
    /*! Production::    imports : imports import_statement */
case 24:
    /*! Production::    exports : exports export */
case 64:
    /*! Production::    children : children child */
case 77:
    /*! Production::    attributes : attributes attribute */
case 86:
    /*! Production::    filters : filters filter */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    break;

case 10:
    /*! Production::    import_statement : IMPORT import_member FROM string_literal import_statement_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ImportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 11:
    /*! Production::    import_member : aggregate_member */
case 12:
    /*! Production::    import_member : aliased_member */
case 13:
    /*! Production::    import_member : composite_member */
case 19:
    /*! Production::    member : member_group */
case 25:
    /*! Production::    export : export_statement */
case 26:
    /*! Production::    export : view_statement */
case 162:
    /*! Production::    literal : literal_group */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp];
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 14:
    /*! Production::    aliased_member : member AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AliasedMember(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 15:
    /*! Production::    aggregate_member : "*" AS member */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.AggregateMember(yyvstack[yysp], this._$);
    break;

case 16:
    /*! Production::    composite_member : "{" member_list "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CompositeMember(yyvstack[yysp - 1], this._$);
    break;

case 17:
    /*! Production::    member_list : member_list_group */
case 23:
    /*! Production::    exports : export */
case 48:
    /*! Production::    type_class_list : type_class */
case 59:
    /*! Production::    parameter_list : parameter */
case 63:
    /*! Production::    children : child */
case 76:
    /*! Production::    attributes : attribute */
case 101:
    /*! Production::    argument_list : expression */
case 127:
    /*! Production::    type_arg_list : type */
case 165:
    /*! Production::    properties : property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp]];
    break;

case 18:
    /*! Production::    member_list : member_list "," member_list_group2 */
case 49:
    /*! Production::    type_class_list : type_class_list "," type_class */
case 60:
    /*! Production::    parameter_list : parameter_list "," parameter */
case 102:
    /*! Production::    argument_list : argument_list "," expression */
case 128:
    /*! Production::    type_arg_list : type_arg_list "," type */
case 166:
    /*! Production::    properties : properties "," property */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 2].concat(yyvstack[yysp]);
    break;

case 20:
    /*! Production::    main : "{%" MAIN main_option main_option2 "(" type ")" main_option3 "%}" tag main_option4 */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedMain(yyvstack[yysp - 8], yyvstack[yysp - 7]||[], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 21:
    /*! Production::    main : tag */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedMain(yyvstack[yysp], this._$);
    break;

case 22:
    /*! Production::    end_main : "{%" ENDMAIN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-):
    this.$ = yyvstack[yysp - 2];
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,-,-,LT,LA,-,-)
    break;

case 27:
    /*! Production::    export : fun_statement */
case 65:
    /*! Production::    child : child_group */
case 66:
    /*! Production::    tag : node */
case 67:
    /*! Production::    tag : widget */
case 82:
    /*! Production::    attribute_value : attribute_value_group */
case 88:
    /*! Production::    control : control_group */
case 103:
    /*! Production::    expression : if_expression */
case 104:
    /*! Production::    expression : binary_expression */
case 106:
    /*! Production::    expression : simple_expression */
case 107:
    /*! Production::    expression : read_expression */
case 108:
    /*! Production::    expression : function_expression */
case 117:
    /*! Production::    simple_expression : simple_expression_group */
case 123:
    /*! Production::    fun_target : identifier */
case 124:
    /*! Production::    fun_target : context_property */
case 158:
    /*! Production::    readable_expression : readable_expression_group */
case 176:
    /*! Production::    cons : qualified_constructor */
case 177:
    /*! Production::    cons : unqualified_constructor */
case 181:
    /*! Production::    identifier : qualified_identifier */
case 182:
    /*! Production::    identifier : unqualified_identifier */
case 186:
    /*! Production::    binary_operator : binary_operator_group */
case 188:
    /*! Production::    import_statement_option : ";" */
case 189:
    /*! Production::    member_list_group : member */
case 190:
    /*! Production::    member_list_group : aliased_member */
case 191:
    /*! Production::    member_list_group2 : member */
case 192:
    /*! Production::    member_list_group2 : aliased_member */
case 193:
    /*! Production::    member_group : unqualified_identifier */
case 194:
    /*! Production::    member_group : unqualified_constructor */
case 196:
    /*! Production::    main_option : unqualified_constructor */
case 198:
    /*! Production::    main_option2 : type_classes */
case 200:
    /*! Production::    main_option3 : parameters */
case 202:
    /*! Production::    main_option4 : end_main */
case 204:
    /*! Production::    view_statement_option : type_classes */
case 206:
    /*! Production::    view_statement_option2 : parameters */
case 208:
    /*! Production::    type_option : type_classes */
case 209:
    /*! Production::    child_group : tag */
case 210:
    /*! Production::    child_group : interpolation */
case 211:
    /*! Production::    child_group : control */
case 212:
    /*! Production::    child_group : characters */
case 213:
    /*! Production::    child_group : identifier */
case 215:
    /*! Production::    node_option : children */
case 217:
    /*! Production::    node_option2 : children */
case 219:
    /*! Production::    widget_option : children */
case 221:
    /*! Production::    widget_option2 : children */
case 222:
    /*! Production::    attribute_value_group : interpolation */
case 223:
    /*! Production::    attribute_value_group : literal */
case 224:
    /*! Production::    control_group : for_statement */
case 225:
    /*! Production::    control_group : if_statement */
case 226:
    /*! Production::    simple_expression_group : view_construction */
case 227:
    /*! Production::    simple_expression_group : fun_application */
case 228:
    /*! Production::    simple_expression_group : construct_expression */
case 229:
    /*! Production::    simple_expression_group : call_expression */
case 230:
    /*! Production::    simple_expression_group : member_expression */
case 231:
    /*! Production::    simple_expression_group : literal */
case 232:
    /*! Production::    simple_expression_group : context_property */
case 233:
    /*! Production::    simple_expression_group : cons */
case 234:
    /*! Production::    simple_expression_group : identifier */
case 235:
    /*! Production::    simple_expression_group : context_variable */
case 236:
    /*! Production::    readable_expression_group : string_literal */
case 237:
    /*! Production::    readable_expression_group : member_expression */
case 238:
    /*! Production::    readable_expression_group : context_property */
case 239:
    /*! Production::    readable_expression_group : call_expression */
case 240:
    /*! Production::    literal_group : record */
case 241:
    /*! Production::    literal_group : list */
case 242:
    /*! Production::    literal_group : string_literal */
case 243:
    /*! Production::    literal_group : number_literal */
case 244:
    /*! Production::    literal_group : boolean_literal */
case 245:
    /*! Production::    property_group : unqualified_identifier */
case 246:
    /*! Production::    property_group : string_literal */
case 247:
    /*! Production::    binary_operator_group : ">" */
case 248:
    /*! Production::    binary_operator_group : ">=" */
case 249:
    /*! Production::    binary_operator_group : "<" */
case 250:
    /*! Production::    binary_operator_group : "<=" */
case 251:
    /*! Production::    binary_operator_group : "==" */
case 252:
    /*! Production::    binary_operator_group : "!=" */
case 253:
    /*! Production::    binary_operator_group : "+" */
case 254:
    /*! Production::    binary_operator_group : "/" */
case 255:
    /*! Production::    binary_operator_group : "-" */
case 256:
    /*! Production::    binary_operator_group : "=" */
case 257:
    /*! Production::    binary_operator_group : "&&" */
case 258:
    /*! Production::    binary_operator_group : "||" */
case 259:
    /*! Production::    binary_operator_group : "^" */
case 260:
    /*! Production::    binary_operator_group : INSTANCEOF */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp];
    break;

case 28:
    /*! Production::    export_statement : "{%" EXPORT composite_member FROM string_literal "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ExportStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 29:
    /*! Production::    view_statement : "{%" VIEW unqualified_constructor view_statement_option "(" type ")" view_statement_option2 "%}" tag "{%" ENDVIEW "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 12, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewStatement(yyvstack[yysp - 10], yyvstack[yysp - 9]||[], yyvstack[yysp - 7], yyvstack[yysp - 5]||[], yyvstack[yysp - 3], this._$);
    break;

case 30:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 10, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 8], yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 31:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 32:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], yyvstack[yysp - 6], null, yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 33:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], null, [], yyvstack[yysp - 3], this._$);
    break;

case 34:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 7], [], yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 35:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], [], yyvstack[yysp - 5], [], yyvstack[yysp - 3], this._$);
    break;

case 36:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6],[],null,yyvstack[yysp - 5],yyvstack[yysp - 3],this._$);
    break;

case 37:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "%}" children "{%" ENDFUN "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5],[],null,[],yyvstack[yysp - 3],this._$);
    break;

case 38:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 8, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 39:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 40:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], yyvstack[yysp - 4], null, yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 41:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier type_classes "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], yyvstack[yysp - 3], null, [], yyvstack[yysp - 1], this._$);
    break;

case 42:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 5], [], yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 43:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier context_type "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4], [], yyvstack[yysp - 3], [], yyvstack[yysp - 1], this._$);
    break;

case 44:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier parameters "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 4],[],null,yyvstack[yysp - 3],yyvstack[yysp - 1],this._$);
    break;

case 45:
    /*! Production::    fun_statement : "{%" FUN unqualified_identifier "=" child "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunStatement(yyvstack[yysp - 3],[],null,[],yyvstack[yysp - 1],this._$);
    break;

case 46:
    /*! Production::    context_type : "(" type ")" */
case 47:
    /*! Production::    type_classes : "[" type_class_list "]" */
case 58:
    /*! Production::    parameters : "(" parameter_list ")" */
case 100:
    /*! Production::    arguments : "(" argument_list ")" */
case 109:
    /*! Production::    expression : "(" expression ")" */
case 125:
    /*! Production::    fun_target : "(" expression ")" */
case 126:
    /*! Production::    type_arguments : "[" type_arg_list "]" */
case 159:
    /*! Production::    readable_expression : "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1];
    break;

case 50:
    /*! Production::    type_class : unqualified_identifier */
case 52:
    /*! Production::    type_class : unqualified_constructor */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp], null, this._$);
    break;

case 51:
    /*! Production::    type_class : unqualified_identifier ":" type */
case 53:
    /*! Production::    type_class : unqualified_constructor ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypeClass(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 54:
    /*! Production::    type : cons type_option */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 1], yyvstack[yysp]||[], false, this._$);
    break;

case 55:
    /*! Production::    type : cons type_classes "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 3], yyvstack[yysp - 2], true, this._$);
    break;

case 56:
    /*! Production::    type : cons "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Type(yyvstack[yysp - 2], [], true, this._$);
    break;

case 57:
    /*! Production::    parameters : "(" ")" */
case 99:
    /*! Production::    arguments : "(" ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [];
    break;

case 61:
    /*! Production::    parameter : unqualified_identifier ":" type */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.TypedParameter(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 62:
    /*! Production::    parameter : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UntypedParameter(yyvstack[yysp], this._$);
    break;

case 68:
    /*! Production::    node : "<" identifier attributes ">" node_option "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 69:
    /*! Production::    node : "<" identifier ">" node_option2 "</" identifier ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 70:
    /*! Production::    node : "<" identifier attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 71:
    /*! Production::    node : "<" identifier "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Node(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 72:
    /*! Production::    widget : "<" cons attributes ">" widget_option "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 6], yyvstack[yysp - 5], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 73:
    /*! Production::    widget : "<" cons ">" widget_option2 "</" cons ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 5], [], yyvstack[yysp - 3]||[], yyvstack[yysp - 1], this._$);
    break;

case 74:
    /*! Production::    widget : "<" cons attributes "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 2], yyvstack[yysp - 1], [], yyvstack[yysp - 2], this._$);
    break;

case 75:
    /*! Production::    widget : "<" cons "/>" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Widget(yyvstack[yysp - 1], [], [], yyvstack[yysp - 1], this._$);
    break;

case 78:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 79:
    /*! Production::    attribute : unqualified_identifier "=" attribute_value */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ =
    new yy.ast.Attribute(new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 80:
    /*! Production::    attribute : unqualified_identifier ":" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(yyvstack[yysp - 2], yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 81:
    /*! Production::    attribute : unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Attribute(
    new yy.ast.UnqualifiedIdentifier('html', this._$),
    yyvstack[yysp], new yy.ast.BooleanLiteral(true, this._$), this._$);
    break;

case 83:
    /*! Production::    interpolation : "{{" expression "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 1], [], this._$);
    break;

case 84:
    /*! Production::    interpolation : "{{" expression filters "}}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Interpolation(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 87:
    /*! Production::    filter : "|" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp]
    break;

case 89:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 7], null, null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 90:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 11, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 9], yyvstack[yysp - 7], null, yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 91:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], [], this._$);
    break;

case 92:
    /*! Production::    for_statement : "{%" FOR parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 13, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 11], null, null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 93:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 15, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 13], yyvstack[yysp - 11], null, yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 3], this._$);
    break;

case 94:
    /*! Production::    for_statement : "{%" FOR parameter "," parameter "," parameter IN expression "%}" children "{%" ELSE "%}" children "{%" ENDFOR "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 17, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ForStatement(yyvstack[yysp - 15], yyvstack[yysp - 13], null, yyvstack[yysp - 11], yyvstack[yysp - 9], yyvstack[yysp - 3], this._$);
    break;

case 95:
    /*! Production::    if_statement : "{%" IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfStatement(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 96:
    /*! Production::    else_clause : "{%" ELSE "%}" children "{%" ENDIF "%}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseClause(yyvstack[yysp - 3], this._$);
    break;

case 97:
    /*! Production::    else_clause : "{%" ELSE IF expression "%}" children else_clause */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ElseIfClause(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 98:
    /*! Production::    characters : CHARACTERS */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Characters(yyvstack[yysp], this._$);
    break;

case 105:
    /*! Production::    expression : unary_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ =yyvstack[yysp];
    break;

case 110:
    /*! Production::    if_expression : IF expression THEN expression ELSE expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.IfThenExpression(yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 111:
    /*! Production::    binary_expression : simple_expression binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 112:
    /*! Production::    binary_expression : simple_expression binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 113:
    /*! Production::    binary_expression : "(" expression ")" binary_operator simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 114:
    /*! Production::    binary_expression : "(" expression ")" binary_operator "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BinaryExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 115:
    /*! Production::    unary_expression : "!" simple_expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 116:
    /*! Production::    unary_expression : "!" "(" expression ")" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnaryExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 118:
    /*! Production::    view_construction : "<" cons arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ViewConstruction(yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 119:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 120:
    /*! Production::    fun_application : "<" fun_target type_arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], yyvstack[yysp - 2], [], yyvstack[yysp - 1], this._$);
    break;

case 121:
    /*! Production::    fun_application : "<" fun_target arguments arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 3], [], yyvstack[yysp - 2], yyvstack[yysp - 1], this._$);
    break;

case 122:
    /*! Production::    fun_application : "<" fun_target arguments ">" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunApplication(yyvstack[yysp - 2], [], [], yyvstack[yysp - 1], this._$);
    break;

case 129:
    /*! Production::    construct_expression : cons arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ConstructExpression(yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 130:
    /*! Production::    call_expression : identifier type_arguments arguments */
case 132:
    /*! Production::    call_expression : context_property type_arguments arguments */
case 134:
    /*! Production::    call_expression : member_expression type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 131:
    /*! Production::    call_expression : identifier arguments */
case 133:
    /*! Production::    call_expression : context_property arguments */
case 135:
    /*! Production::    call_expression : member_expression arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 1], [], yyvstack[yysp], this._$);
    break;

case 136:
    /*! Production::    call_expression : "(" expression ")" type_arguments arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp], this._$);
    break;

case 137:
    /*! Production::    call_expression : "(" expression ")" arguments */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.CallExpression(yyvstack[yysp - 2], [], yyvstack[yysp], this._$);
    break;

case 138:
    /*! Production::    member_expression : qualified_identifier "." unqualified_identifier */
case 139:
    /*! Production::    member_expression : qualified_constructor "." unqualified_identifier */
case 140:
    /*! Production::    member_expression : context_variable "." unqualified_identifier */
case 141:
    /*! Production::    member_expression : context_property "." unqualified_identifier */
case 142:
    /*! Production::    member_expression : list "." unqualified_identifier */
case 143:
    /*! Production::    member_expression : record "." unqualified_identifier */
case 144:
    /*! Production::    member_expression : string_literal "." unqualified_identifier */
case 145:
    /*! Production::    member_expression : call_expression "." unqualified_identifier */
case 147:
    /*! Production::    member_expression : member_expression "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 146:
    /*! Production::    member_expression : "(" expression ")" "." unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.MemberExpression(yyvstack[yysp - 3], yyvstack[yysp], this._$);
    break;

case 148:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "]" */
case 150:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "]" */
case 152:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "]" */
case 154:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], null, this._$);
    break;

case 149:
    /*! Production::    read_expression : identifier "[" readable_expression AS type "?" expression "]" */
case 151:
    /*! Production::    read_expression : context_variable "[" readable_expression AS type "?" expression "]" */
case 153:
    /*! Production::    read_expression : context_property "[" readable_expression AS type "?" expression "]" */
case 155:
    /*! Production::    read_expression : member_expression "[" readable_expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], yyvstack[yysp - 1], this._$);
    break;

case 156:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "?" expression "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 9, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 9], yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], this._$);
    break;

case 157:
    /*! Production::    read_expression : "(" expression ")" "[" expression AS type "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 7, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ReadExpression(yyvstack[yysp - 7], yyvstack[yysp - 5], yyvstack[yysp - 3], null, this._$);
    break;

case 160:
    /*! Production::    function_expression : "\\" parameter_list "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 161:
    /*! Production::    function_expression : "=>" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.FunctionExpression([], yyvstack[yysp], this._$);
    break;

case 163:
    /*! Production::    record : "{" "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record([], this._$);
    break;

case 164:
    /*! Production::    record : "{" properties "}" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Record(yyvstack[yysp - 1], this._$);
    break;

case 167:
    /*! Production::    property : property_group ":" expression */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.Property(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 168:
    /*! Production::    list : "[" "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List([], this._$);
    break;

case 169:
    /*! Production::    list : "[" argument_list "]" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.List(yyvstack[yysp - 1], this._$);
    break;

case 170:
    /*! Production::    string_literal : STRING_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.StringLiteral(yyvstack[yysp].slice(1, yyvstack[yysp].length - 1, this._$));
    break;

case 171:
    /*! Production::    number_literal : NUMBER_LITERAL */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.NumberLiteral(yyvstack[yysp], this._$);
    break;

case 172:
    /*! Production::    boolean_literal : TRUE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(true, this._$);
    break;

case 173:
    /*! Production::    boolean_literal : FALSE */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.BooleanLiteral(false, this._$);
    break;

case 174:
    /*! Production::    context_property : "@" unqualified_identifier */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextProperty(yyvstack[yysp], this._$)
    break;

case 175:
    /*! Production::    context_variable : "@" */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.ContextVariable(this._$);
    break;

case 178:
    /*! Production::    qualified_constructor : IDENTIFIER "." CONSTRUCTOR */
case 179:
    /*! Production::    qualified_constructor : CONSTRUCTOR "." CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedConstructor(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 180:
    /*! Production::    unqualified_constructor : CONSTRUCTOR */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedConstructor(yyvstack[yysp], this._$);
    break;

case 183:
    /*! Production::    qualified_identifier : IDENTIFIER "." IDENTIFIER */
case 184:
    /*! Production::    qualified_identifier : CONSTRUCTOR "." IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.QualifiedIdentifier(yyvstack[yysp - 2], yyvstack[yysp], this._$);
    break;

case 185:
    /*! Production::    unqualified_identifier : IDENTIFIER */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,LU,LUbA)
    
    
    this.$ = new yy.ast.UnqualifiedIdentifier(yyvstack[yysp], this._$);
    break;

case 187:
    /*! Production::    import_statement_option : %epsilon */
case 195:
    /*! Production::    main_option : %epsilon */
case 197:
    /*! Production::    main_option2 : %epsilon */
case 199:
    /*! Production::    main_option3 : %epsilon */
case 201:
    /*! Production::    main_option4 : %epsilon */
case 203:
    /*! Production::    view_statement_option : %epsilon */
case 205:
    /*! Production::    view_statement_option2 : %epsilon */
case 207:
    /*! Production::    type_option : %epsilon */
case 214:
    /*! Production::    node_option : %epsilon */
case 216:
    /*! Production::    node_option2 : %epsilon */
case 218:
    /*! Production::    widget_option : %epsilon */
case 220:
    /*! Production::    widget_option2 : %epsilon */

    // default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
    // END of default action (generated by JISON mode classic/merge :: VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = undefined;
    break;

}
},
table: bt({
  len: u([
  15,
  1,
  14,
  11,
  1,
  0,
  0,
  4,
  0,
  12,
  s,
  [0, 5],
  8,
  c,
  [13, 4],
  c,
  [3, 3],
  0,
  5,
  s,
  [2, 3],
  c,
  [8, 4],
  1,
  1,
  9,
  s,
  [0, 5],
  6,
  6,
  s,
  [0, 4],
  29,
  29,
  c,
  [20, 4],
  4,
  0,
  1,
  4,
  7,
  2,
  6,
  6,
  2,
  0,
  3,
  0,
  5,
  23,
  c,
  [44, 3],
  c,
  [5, 3],
  2,
  2,
  c,
  [55, 3],
  6,
  c,
  [51, 3],
  5,
  4,
  2,
  21,
  20,
  10,
  c,
  [46, 5],
  8,
  c,
  [28, 3],
  1,
  21,
  s,
  [0, 7],
  43,
  s,
  [0, 4],
  10,
  1,
  2,
  2,
  17,
  23,
  c,
  [21, 7],
  c,
  [64, 4],
  3,
  1,
  6,
  c,
  [48, 4],
  c,
  [3, 3],
  5,
  21,
  20,
  20,
  1,
  1,
  0,
  2,
  9,
  c,
  [66, 3],
  c,
  [115, 4],
  3,
  c,
  [38, 3],
  5,
  c,
  [107, 3],
  0,
  0,
  26,
  c,
  [61, 3],
  43,
  33,
  0,
  28,
  26,
  29,
  29,
  4,
  c,
  [70, 4],
  25,
  0,
  26,
  27,
  28,
  27,
  s,
  [25, 3],
  12,
  0,
  45,
  8,
  s,
  [0, 5],
  1,
  1,
  3,
  43,
  c,
  [42, 4],
  c,
  [12, 5],
  21,
  5,
  c,
  [71, 3],
  5,
  c,
  [176, 3],
  1,
  c,
  [86, 3],
  c,
  [85, 4],
  c,
  [4, 4],
  20,
  1,
  3,
  c,
  [84, 5],
  7,
  7,
  6,
  1,
  1,
  5,
  1,
  c,
  [10, 3],
  c,
  [82, 3],
  s,
  [0, 14],
  c,
  [54, 3],
  43,
  15,
  15,
  14,
  11,
  24,
  2,
  0,
  45,
  20,
  2,
  24,
  c,
  [209, 3],
  c,
  [4, 4],
  2,
  0,
  c,
  [4, 5],
  s,
  [2, 4],
  c,
  [98, 3],
  43,
  c,
  [13, 4],
  c,
  [3, 3],
  c,
  [262, 3],
  2,
  1,
  17,
  5,
  1,
  c,
  [117, 4],
  4,
  c,
  [96, 8],
  c,
  [4, 4],
  c,
  [182, 3],
  c,
  [29, 4],
  c,
  [294, 4],
  c,
  [46, 3],
  31,
  43,
  1,
  7,
  1,
  2,
  c,
  [251, 3],
  c,
  [301, 4],
  s,
  [1, 3],
  c,
  [47, 3],
  c,
  [7, 4],
  c,
  [34, 7],
  c,
  [274, 5],
  c,
  [10, 3],
  2,
  3,
  c,
  [122, 3],
  0,
  6,
  43,
  43,
  3,
  21,
  c,
  [62, 5],
  1,
  c,
  [74, 8],
  c,
  [3, 3],
  c,
  [387, 5],
  33,
  45,
  c,
  [350, 4],
  15,
  6,
  0,
  6,
  c,
  [355, 3],
  c,
  [393, 4],
  c,
  [49, 3],
  c,
  [58, 6],
  21,
  0,
  4,
  4,
  c,
  [38, 5],
  c,
  [17, 3],
  15,
  0,
  43,
  1,
  22,
  c,
  [163, 5],
  6,
  c,
  [444, 6],
  21,
  43,
  c,
  [70, 3],
  4,
  c,
  [67, 6],
  c,
  [53, 3],
  43,
  c,
  [101, 3],
  c,
  [4, 4],
  c,
  [358, 3],
  c,
  [196, 3],
  c,
  [23, 3],
  15,
  c,
  [140, 4],
  1,
  4,
  21,
  43,
  21,
  43,
  1,
  1,
  c,
  [141, 6],
  1,
  c,
  [201, 3],
  20,
  c,
  [158, 5],
  21,
  4,
  21,
  c,
  [143, 3],
  c,
  [44, 3],
  c,
  [320, 3],
  3,
  c,
  [14, 3],
  c,
  [20, 3],
  c,
  [415, 4],
  c,
  [11, 3],
  1,
  20,
  c,
  [128, 4]
]),
  symbol: u([
  13,
  25,
  28,
  64,
  65,
  66,
  73,
  s,
  [75, 5, 1],
  90,
  91,
  92,
  1,
  1,
  c,
  [17, 3],
  c,
  [15, 11],
  13,
  28,
  73,
  c,
  [11, 8],
  29,
  32,
  33,
  35,
  3,
  4,
  55,
  56,
  s,
  [67, 4, 1],
  72,
  134,
  137,
  142,
  55,
  56,
  s,
  [132, 6, 1],
  c,
  [36, 12],
  1,
  7,
  10,
  56,
  134,
  143,
  4,
  70,
  56,
  134,
  55,
  137,
  26,
  27,
  27,
  55,
  56,
  68,
  71,
  c,
  [43, 3],
  140,
  142,
  14,
  38,
  55,
  93,
  94,
  137,
  c,
  [6, 6],
  s,
  [5, 7, 1],
  13,
  14,
  15,
  17,
  s,
  [21, 4, 1],
  27,
  30,
  38,
  40,
  44,
  48,
  55,
  s,
  [57, 7, 1],
  c,
  [29, 29],
  c,
  [94, 3],
  81,
  144,
  26,
  c,
  [5, 3],
  147,
  7,
  9,
  10,
  30,
  80,
  81,
  85,
  51,
  127,
  55,
  56,
  c,
  [139, 6],
  c,
  [6, 4],
  5,
  6,
  5,
  6,
  27,
  c,
  [100, 3],
  94,
  137,
  13,
  28,
  37,
  39,
  47,
  55,
  56,
  s,
  [88, 5, 1],
  96,
  99,
  100,
  101,
  103,
  c,
  [167, 3],
  150,
  152,
  156,
  9,
  12,
  c,
  [30, 3],
  c,
  [33, 26],
  154,
  156,
  55,
  56,
  55,
  56,
  7,
  55,
  56,
  82,
  83,
  134,
  137,
  51,
  127,
  7,
  7,
  9,
  30,
  80,
  85,
  c,
  [5, 3],
  85,
  9,
  30,
  13,
  28,
  c,
  [47, 18],
  156,
  c,
  [21, 6],
  c,
  [20, 14],
  8,
  55,
  56,
  84,
  86,
  87,
  c,
  [281, 3],
  c,
  [279, 3],
  20,
  25,
  28,
  139,
  c,
  [258, 3],
  c,
  [155, 3],
  141,
  142,
  c,
  [113, 21],
  151,
  156,
  37,
  c,
  [24, 7],
  c,
  [69, 14],
  s,
  [4, 6, 3],
  45,
  s,
  [49, 8, 1],
  s,
  [106, 7, 1],
  s,
  [116, 4, 1],
  121,
  122,
  123,
  s,
  [126, 12, 1],
  157,
  159,
  13,
  14,
  17,
  28,
  30,
  c,
  [67, 5],
  17,
  41,
  45,
  55,
  137,
  4,
  10,
  39,
  c,
  [52, 4],
  95,
  96,
  c,
  [40, 6],
  155,
  159,
  c,
  [120, 21],
  153,
  c,
  [120, 23],
  c,
  [188, 3],
  c,
  [88, 3],
  6,
  11,
  6,
  11,
  12,
  c,
  [3, 3],
  30,
  c,
  [15, 6],
  c,
  [257, 47],
  c,
  [300, 45],
  86,
  87,
  c,
  [394, 3],
  c,
  [46, 39],
  c,
  [20, 20],
  30,
  8,
  6,
  8,
  6,
  8,
  10,
  11,
  18,
  42,
  50,
  81,
  149,
  6,
  8,
  12,
  42,
  50,
  c,
  [5, 3],
  17,
  c,
  [18, 4],
  14,
  17,
  c,
  [20, 3],
  c,
  [527, 3],
  c,
  [233, 24],
  c,
  [7, 3],
  15,
  40,
  97,
  98,
  5,
  6,
  8,
  9,
  c,
  [621, 4],
  c,
  [620, 6],
  c,
  [619, 3],
  c,
  [618, 7],
  138,
  161,
  c,
  [388, 43],
  c,
  [43, 47],
  19,
  c,
  [39, 6],
  c,
  [35, 6],
  c,
  [33, 16],
  c,
  [768, 10],
  c,
  [147, 16],
  104,
  114,
  c,
  [173, 4],
  c,
  [795, 12],
  c,
  [28, 10],
  c,
  [822, 17],
  c,
  [55, 14],
  c,
  [29, 27],
  c,
  [387, 4],
  c,
  [192, 43],
  c,
  [304, 8],
  c,
  [130, 22],
  c,
  [183, 21],
  c,
  [127, 27],
  c,
  [209, 19],
  c,
  [1003, 8],
  c,
  [1062, 18],
  c,
  [55, 14],
  c,
  [25, 71],
  7,
  19,
  55,
  56,
  113,
  130,
  c,
  [222, 6],
  c,
  [263, 3],
  11,
  c,
  [264, 12],
  s,
  [105, 8, 1],
  c,
  [265, 22],
  51,
  55,
  124,
  125,
  127,
  137,
  160,
  s,
  [55, 3],
  c,
  [321, 45],
  9,
  c,
  [1151, 3],
  c,
  [660, 24],
  c,
  [36, 3],
  8,
  17,
  55,
  56,
  c,
  [1149, 3],
  c,
  [890, 6],
  c,
  [6, 6],
  8,
  c,
  [850, 43],
  c,
  [845, 62],
  c,
  [62, 68],
  c,
  [21, 15],
  36,
  c,
  [1173, 3],
  87,
  137,
  c,
  [931, 7],
  11,
  c,
  [1370, 6],
  c,
  [215, 6],
  56,
  c,
  [1387, 3],
  c,
  [36, 3],
  14,
  15,
  40,
  98,
  c,
  [832, 76],
  8,
  48,
  c,
  [718, 45],
  7,
  c,
  [154, 3],
  15,
  17,
  c,
  [530, 5],
  c,
  [809, 6],
  c,
  [15, 18],
  c,
  [14, 9],
  8,
  c,
  [27, 8],
  c,
  [98, 3],
  19,
  51,
  c,
  [198, 3],
  115,
  117,
  118,
  120,
  c,
  [82, 3],
  c,
  [80, 8],
  158,
  7,
  104,
  4,
  c,
  [50, 3],
  c,
  [579, 41],
  c,
  [71, 7],
  c,
  [69, 8],
  133,
  c,
  [67, 4],
  c,
  [1474, 3],
  c,
  [93, 23],
  55,
  137,
  c,
  [95, 4],
  c,
  [28, 26],
  6,
  50,
  55,
  137,
  55,
  137,
  c,
  [4, 8],
  7,
  104,
  7,
  10,
  104,
  114,
  c,
  [267, 43],
  55,
  137,
  6,
  11,
  5,
  6,
  12,
  6,
  42,
  30,
  c,
  [1603, 17],
  c,
  [665, 5],
  14,
  7,
  30,
  85,
  145,
  c,
  [4, 3],
  148,
  c,
  [549, 86],
  c,
  [24, 24],
  c,
  [3, 3],
  30,
  11,
  14,
  c,
  [467, 47],
  c,
  [1261, 25],
  c,
  [1494, 45],
  c,
  [1994, 4],
  115,
  c,
  [13, 3],
  27,
  6,
  11,
  c,
  [54, 43],
  17,
  27,
  7,
  10,
  17,
  27,
  104,
  114,
  c,
  [6, 6],
  17,
  27,
  s,
  [17, 3],
  c,
  [394, 4],
  6,
  8,
  c,
  [10, 3],
  27,
  27,
  c,
  [73, 43],
  14,
  c,
  [451, 3],
  14,
  104,
  8,
  c,
  [50, 43],
  51,
  55,
  c,
  [1169, 4],
  c,
  [1720, 86],
  c,
  [965, 3],
  c,
  [505, 21],
  14,
  30,
  c,
  [467, 25],
  c,
  [443, 4],
  c,
  [4, 4],
  30,
  c,
  [196, 5],
  c,
  [949, 29],
  c,
  [137, 15],
  84,
  c,
  [138, 7],
  s,
  [115, 5, 1],
  c,
  [682, 19],
  7,
  104,
  44,
  c,
  [939, 15],
  c,
  [1328, 13],
  c,
  [13, 12],
  c,
  [2243, 7],
  14,
  104,
  14,
  30,
  6,
  42,
  c,
  [170, 14],
  102,
  c,
  [679, 7],
  c,
  [15, 3],
  c,
  [4, 4],
  c,
  [171, 5],
  30,
  c,
  [88, 15],
  c,
  [290, 43],
  27,
  6,
  c,
  [2708, 3],
  c,
  [632, 3],
  c,
  [630, 5],
  c,
  [626, 7],
  81,
  104,
  149,
  c,
  [66, 43],
  11,
  18,
  c,
  [565, 6],
  11,
  18,
  11,
  18,
  11,
  18,
  14,
  c,
  [368, 21],
  c,
  [435, 46],
  41,
  44,
  45,
  1,
  28,
  74,
  146,
  28,
  30,
  c,
  [276, 7],
  c,
  [2260, 90],
  c,
  [43, 82],
  c,
  [599, 21],
  42,
  30,
  45,
  31,
  34,
  c,
  [420, 15],
  c,
  [301, 3],
  s,
  [11, 3],
  41,
  43,
  44,
  c,
  [1093, 7],
  c,
  [306, 58],
  c,
  [64, 64],
  30,
  30,
  c,
  [45, 45],
  c,
  [1313, 42],
  11,
  c,
  [154, 21],
  c,
  [243, 25],
  41,
  45,
  46,
  c,
  [1446, 41],
  c,
  [135, 37],
  c,
  [811, 7],
  41,
  43,
  c,
  [112, 23],
  c,
  [137, 3],
  c,
  [71, 22],
  30,
  c,
  [51, 24],
  c,
  [47, 21],
  c,
  [45, 3],
  30
]),
  type: u([
  s,
  [2, 3],
  s,
  [0, 12],
  1,
  s,
  [2, 4],
  s,
  [0, 10],
  c,
  [13, 11],
  s,
  [2, 9],
  c,
  [17, 10],
  c,
  [36, 22],
  c,
  [7, 3],
  0,
  2,
  c,
  [4, 4],
  c,
  [45, 11],
  c,
  [10, 6],
  c,
  [6, 9],
  s,
  [2, 58],
  c,
  [69, 7],
  c,
  [91, 7],
  c,
  [101, 4],
  c,
  [139, 10],
  c,
  [36, 13],
  c,
  [200, 14],
  c,
  [195, 14],
  c,
  [33, 32],
  c,
  [11, 5],
  c,
  [100, 7],
  c,
  [5, 4],
  c,
  [250, 16],
  c,
  [46, 13],
  c,
  [20, 17],
  c,
  [268, 13],
  c,
  [293, 11],
  c,
  [146, 30],
  c,
  [22, 20],
  c,
  [53, 23],
  c,
  [43, 26],
  c,
  [103, 18],
  c,
  [120, 47],
  c,
  [83, 15],
  c,
  [210, 8],
  c,
  [257, 46],
  c,
  [43, 42],
  c,
  [25, 23],
  c,
  [89, 27],
  c,
  [254, 25],
  c,
  [600, 31],
  c,
  [122, 21],
  c,
  [52, 26],
  c,
  [388, 59],
  c,
  [43, 40],
  c,
  [76, 37],
  c,
  [225, 42],
  c,
  [55, 53],
  c,
  [743, 4],
  c,
  [235, 60],
  c,
  [128, 36],
  c,
  [1000, 55],
  s,
  [2, 106],
  c,
  [220, 24],
  s,
  [0, 29],
  c,
  [32, 8],
  c,
  [556, 60],
  c,
  [782, 23],
  c,
  [905, 11],
  c,
  [1400, 21],
  c,
  [804, 47],
  c,
  [845, 48],
  c,
  [62, 76],
  c,
  [642, 17],
  c,
  [215, 14],
  c,
  [1118, 15],
  c,
  [832, 85],
  c,
  [718, 41],
  c,
  [15, 29],
  c,
  [762, 20],
  c,
  [79, 18],
  c,
  [579, 49],
  c,
  [36, 17],
  c,
  [1474, 19],
  c,
  [26, 10],
  c,
  [28, 32],
  c,
  [1912, 8],
  c,
  [16, 7],
  c,
  [664, 46],
  c,
  [45, 26],
  c,
  [1979, 10],
  c,
  [84, 10],
  c,
  [549, 81],
  c,
  [1798, 34],
  c,
  [1185, 65],
  c,
  [1451, 50],
  c,
  [82, 23],
  c,
  [128, 34],
  c,
  [735, 8],
  c,
  [1412, 31],
  c,
  [73, 30],
  c,
  [3, 6],
  c,
  [50, 45],
  c,
  [1485, 61],
  c,
  [543, 30],
  c,
  [505, 28],
  c,
  [443, 64],
  c,
  [822, 44],
  c,
  [777, 12],
  c,
  [351, 11],
  c,
  [257, 13],
  c,
  [13, 12],
  c,
  [332, 9],
  c,
  [1351, 24],
  c,
  [4, 8],
  c,
  [2053, 78],
  c,
  [48, 8],
  c,
  [571, 55],
  c,
  [1525, 30],
  c,
  [435, 45],
  c,
  [7, 9],
  c,
  [2260, 99],
  c,
  [43, 81],
  c,
  [356, 33],
  c,
  [1975, 33],
  c,
  [115, 63],
  c,
  [515, 61],
  c,
  [45, 36],
  c,
  [1313, 43],
  c,
  [111, 25],
  c,
  [917, 38],
  c,
  [2991, 43],
  c,
  [88, 52],
  c,
  [2975, 32],
  c,
  [232, 38]
]),
  state: u([
  1,
  2,
  5,
  4,
  3,
  6,
  10,
  11,
  12,
  8,
  13,
  14,
  19,
  17,
  16,
  c,
  [10, 7],
  20,
  22,
  c,
  [8, 6],
  28,
  30,
  29,
  31,
  33,
  37,
  36,
  35,
  41,
  44,
  45,
  40,
  42,
  43,
  48,
  c,
  [22, 7],
  53,
  52,
  54,
  55,
  56,
  63,
  60,
  62,
  37,
  36,
  61,
  35,
  64,
  67,
  68,
  69,
  67,
  68,
  76,
  75,
  80,
  79,
  82,
  81,
  83,
  87,
  89,
  c,
  [44, 3],
  90,
  c,
  [4, 3],
  95,
  68,
  97,
  98,
  100,
  13,
  14,
  101,
  102,
  108,
  109,
  103,
  104,
  42,
  43,
  99,
  96,
  106,
  95,
  68,
  118,
  c,
  [18, 13],
  117,
  106,
  124,
  125,
  127,
  126,
  128,
  130,
  131,
  134,
  140,
  c,
  [24, 13],
  106,
  141,
  c,
  [14, 13],
  142,
  144,
  146,
  145,
  44,
  45,
  147,
  150,
  154,
  153,
  37,
  36,
  152,
  35,
  156,
  c,
  [43, 13],
  155,
  106,
  158,
  c,
  [44, 13],
  s,
  [159, 5, 1],
  s,
  [176, 4, 1],
  173,
  164,
  165,
  180,
  186,
  185,
  187,
  192,
  193,
  172,
  171,
  181,
  184,
  45,
  170,
  182,
  43,
  169,
  189,
  201,
  202,
  s,
  [204, 5, 1],
  192,
  193,
  203,
  189,
  210,
  c,
  [69, 13],
  209,
  c,
  [69, 15],
  212,
  c,
  [111, 3],
  219,
  c,
  [4, 3],
  220,
  225,
  c,
  [151, 14],
  226,
  c,
  [14, 13],
  229,
  c,
  [29, 14],
  230,
  c,
  [14, 13],
  144,
  146,
  147,
  231,
  c,
  [32, 14],
  232,
  c,
  [14, 13],
  c,
  [113, 14],
  239,
  238,
  c,
  [16, 14],
  245,
  42,
  43,
  247,
  248,
  250,
  251,
  266,
  c,
  [205, 27],
  267,
  c,
  [28, 27],
  268,
  c,
  [24, 4],
  270,
  c,
  [22, 6],
  271,
  273,
  c,
  [22, 3],
  272,
  c,
  [22, 4],
  276,
  275,
  283,
  282,
  287,
  286,
  288,
  146,
  147,
  289,
  c,
  [59, 27],
  291,
  293,
  299,
  301,
  298,
  44,
  45,
  300,
  42,
  43,
  305,
  306,
  c,
  [39, 27],
  308,
  309,
  312,
  311,
  310,
  313,
  147,
  314,
  c,
  [35, 27],
  c,
  [210, 14],
  317,
  44,
  45,
  319,
  127,
  126,
  320,
  c,
  [341, 3],
  321,
  c,
  [4, 3],
  325,
  c,
  [283, 14],
  326,
  c,
  [14, 13],
  327,
  c,
  [29, 14],
  328,
  c,
  [312, 27],
  331,
  c,
  [43, 14],
  332,
  c,
  [43, 27],
  c,
  [14, 14],
  338,
  147,
  c,
  [634, 4],
  341,
  c,
  [139, 3],
  342,
  42,
  43,
  345,
  346,
  c,
  [199, 27],
  347,
  c,
  [332, 21],
  351,
  c,
  [50, 27],
  287,
  286,
  283,
  282,
  276,
  275,
  357,
  354,
  361,
  359,
  353,
  364,
  363,
  358,
  360,
  362,
  145,
  184,
  45,
  365,
  182,
  43,
  355,
  366,
  368,
  c,
  [337, 28],
  361,
  359,
  369,
  c,
  [45, 5],
  370,
  c,
  [43, 4],
  372,
  c,
  [61, 4],
  373,
  c,
  [61, 12],
  374,
  375,
  c,
  [19, 4],
  376,
  c,
  [19, 12],
  377,
  378,
  s,
  [380, 7, 1],
  388,
  387,
  389,
  c,
  [89, 27],
  293,
  398,
  c,
  [757, 9],
  399,
  44,
  45,
  402,
  401,
  404,
  403,
  405,
  c,
  [309, 14],
  406,
  c,
  [309, 41],
  c,
  [14, 14],
  419,
  c,
  [117, 27],
  424,
  423,
  420,
  251,
  425,
  c,
  [32, 27],
  357,
  354,
  c,
  [378, 3],
  430,
  c,
  [324, 33],
  435,
  c,
  [34, 27],
  437,
  438,
  441,
  c,
  [30, 27],
  442,
  c,
  [671, 3],
  443,
  c,
  [32, 27],
  444,
  c,
  [28, 27],
  445,
  147,
  446,
  c,
  [290, 14],
  c,
  [248, 14],
  459,
  c,
  [529, 21],
  357,
  461,
  c,
  [82, 6],
  354,
  c,
  [83, 13],
  462,
  c,
  [83, 7],
  463,
  464,
  424,
  423,
  466,
  c,
  [243, 3],
  467,
  c,
  [4, 3],
  469,
  c,
  [4, 3],
  470,
  c,
  [4, 3],
  471,
  c,
  [4, 3],
  472,
  c,
  [91, 8],
  478,
  c,
  [92, 6],
  480,
  13,
  14,
  481,
  13,
  14,
  424,
  423,
  486,
  c,
  [159, 27],
  239,
  291,
  238,
  488,
  c,
  [379, 29],
  498,
  c,
  [190, 14],
  499,
  c,
  [45, 27],
  500,
  147,
  503,
  502,
  508,
  c,
  [136, 3],
  509,
  c,
  [36, 27],
  510,
  c,
  [28, 27],
  511,
  c,
  [28, 27],
  512,
  c,
  [1052, 41],
  424,
  423,
  528,
  c,
  [179, 14],
  529,
  c,
  [59, 27],
  530,
  c,
  [43, 14],
  531,
  c,
  [43, 27],
  534,
  c,
  [130, 41],
  c,
  [14, 14],
  542,
  c,
  [99, 14],
  545,
  c,
  [15, 14],
  547,
  c,
  [541, 28],
  c,
  [14, 22],
  553,
  c,
  [15, 6],
  555,
  c,
  [58, 28],
  563,
  c,
  [29, 28]
]),
  mode: u([
  s,
  [1, 26],
  2,
  2,
  c,
  [17, 17],
  s,
  [2, 8],
  c,
  [11, 11],
  s,
  [2, 18],
  c,
  [29, 19],
  1,
  c,
  [75, 3],
  c,
  [78, 13],
  c,
  [92, 8],
  c,
  [7, 8],
  c,
  [16, 7],
  c,
  [114, 16],
  c,
  [152, 24],
  c,
  [47, 6],
  c,
  [46, 8],
  c,
  [54, 20],
  c,
  [135, 10],
  c,
  [23, 14],
  c,
  [51, 16],
  c,
  [77, 9],
  s,
  [1, 55],
  c,
  [104, 9],
  c,
  [7, 6],
  c,
  [6, 13],
  c,
  [104, 14],
  c,
  [261, 10],
  c,
  [151, 18],
  c,
  [246, 41],
  c,
  [372, 29],
  c,
  [377, 21],
  c,
  [27, 50],
  c,
  [122, 18],
  c,
  [472, 27],
  s,
  [2, 31],
  c,
  [33, 33],
  c,
  [36, 21],
  c,
  [231, 30],
  c,
  [25, 62],
  c,
  [370, 44],
  c,
  [45, 4],
  c,
  [541, 60],
  c,
  [560, 26],
  c,
  [62, 59],
  c,
  [731, 12],
  c,
  [13, 17],
  c,
  [249, 16],
  s,
  [1, 96],
  c,
  [725, 5],
  c,
  [270, 62],
  c,
  [355, 5],
  c,
  [1023, 7],
  c,
  [179, 48],
  c,
  [417, 8],
  c,
  [135, 63],
  c,
  [483, 82],
  c,
  [408, 9],
  c,
  [44, 60],
  c,
  [467, 16],
  c,
  [79, 23],
  c,
  [251, 33],
  c,
  [707, 83],
  c,
  [224, 40],
  s,
  [1, 143]
]),
  goto: u([
  15,
  9,
  7,
  18,
  c,
  [4, 3],
  21,
  15,
  7,
  s,
  [23, 5, 1],
  32,
  34,
  38,
  39,
  46,
  47,
  49,
  15,
  7,
  50,
  51,
  195,
  195,
  39,
  34,
  39,
  38,
  57,
  58,
  59,
  38,
  39,
  65,
  66,
  38,
  70,
  71,
  38,
  s,
  [185, 10],
  72,
  s,
  [185, 18],
  s,
  [180, 10],
  73,
  s,
  [180, 18],
  74,
  197,
  77,
  78,
  203,
  77,
  86,
  85,
  77,
  84,
  88,
  38,
  39,
  38,
  39,
  91,
  92,
  189,
  189,
  59,
  93,
  94,
  38,
  15,
  112,
  216,
  105,
  107,
  110,
  111,
  114,
  113,
  s,
  [81, 3],
  115,
  116,
  c,
  [15, 3],
  220,
  c,
  [15, 4],
  s,
  [119, 5, 1],
  38,
  39,
  88,
  129,
  86,
  133,
  132,
  137,
  136,
  135,
  139,
  138,
  15,
  112,
  c,
  [23, 4],
  c,
  [6, 6],
  143,
  148,
  149,
  187,
  187,
  151,
  187,
  187,
  38,
  39,
  15,
  112,
  214,
  c,
  [17, 4],
  157,
  15,
  112,
  217,
  c,
  [8, 4],
  191,
  166,
  190,
  188,
  168,
  183,
  167,
  174,
  175,
  88,
  194,
  195,
  196,
  46,
  47,
  185,
  185,
  197,
  s,
  [185, 7],
  198,
  199,
  200,
  38,
  191,
  190,
  105,
  c,
  [23, 4],
  15,
  112,
  218,
  c,
  [43, 4],
  211,
  15,
  112,
  221,
  c,
  [8, 4],
  213,
  149,
  215,
  214,
  50,
  50,
  216,
  52,
  52,
  217,
  218,
  213,
  149,
  137,
  222,
  221,
  224,
  223,
  c,
  [106, 12],
  228,
  227,
  c,
  [120, 13],
  c,
  [158, 3],
  c,
  [14, 10],
  15,
  233,
  c,
  [6, 4],
  234,
  235,
  237,
  236,
  207,
  207,
  240,
  s,
  [207, 4],
  62,
  62,
  241,
  62,
  62,
  s,
  [185, 3],
  242,
  s,
  [180, 5],
  243,
  s,
  [180, 3],
  191,
  191,
  59,
  244,
  15,
  112,
  215,
  c,
  [40, 4],
  110,
  111,
  249,
  246,
  s,
  [106, 3],
  261,
  106,
  254,
  252,
  106,
  258,
  259,
  260,
  264,
  s,
  [106, 5],
  253,
  255,
  256,
  257,
  262,
  263,
  265,
  c,
  [183, 15],
  c,
  [15, 16],
  269,
  190,
  188,
  183,
  c,
  [11, 6],
  234,
  234,
  277,
  234,
  234,
  274,
  s,
  [234, 20],
  s,
  [235, 4],
  278,
  s,
  [235, 4],
  279,
  s,
  [235, 16],
  232,
  232,
  277,
  232,
  232,
  280,
  s,
  [232, 4],
  281,
  s,
  [232, 16],
  230,
  230,
  277,
  230,
  230,
  284,
  s,
  [230, 4],
  285,
  s,
  [230, 16],
  38,
  c,
  [133, 15],
  s,
  [229, 8],
  290,
  s,
  [229, 16],
  233,
  233,
  277,
  s,
  [233, 22],
  s,
  [181, 10],
  292,
  s,
  [181, 16],
  s,
  [175, 19],
  38,
  s,
  [175, 7],
  s,
  [176, 10],
  294,
  s,
  [176, 16],
  s,
  [241, 8],
  295,
  s,
  [241, 16],
  s,
  [240, 8],
  296,
  s,
  [240, 16],
  s,
  [242, 8],
  297,
  s,
  [242, 16],
  302,
  303,
  c,
  [358, 5],
  304,
  c,
  [226, 12],
  307,
  88,
  38,
  119,
  121,
  c,
  [247, 16],
  315,
  s,
  [80, 3],
  316,
  15,
  112,
  219,
  c,
  [554, 6],
  318,
  242,
  38,
  39,
  213,
  149,
  213,
  149,
  322,
  324,
  323,
  c,
  [521, 13],
  c,
  [6, 12],
  329,
  c,
  [6, 4],
  330,
  c,
  [19, 13],
  333,
  c,
  [6, 4],
  334,
  15,
  335,
  c,
  [7, 4],
  336,
  337,
  c,
  [650, 3],
  208,
  208,
  339,
  s,
  [208, 4],
  340,
  c,
  [78, 4],
  120,
  122,
  110,
  111,
  343,
  249,
  344,
  c,
  [500, 16],
  348,
  c,
  [500, 9],
  349,
  350,
  c,
  [28, 15],
  c,
  [438, 4],
  352,
  c,
  [435, 8],
  c,
  [478, 4],
  352,
  c,
  [475, 8],
  c,
  [543, 4],
  352,
  c,
  [529, 11],
  c,
  [525, 7],
  191,
  356,
  190,
  183,
  88,
  46,
  47,
  277,
  191,
  166,
  367,
  c,
  [101, 14],
  c,
  [24, 5],
  371,
  38,
  c,
  [32, 7],
  38,
  277,
  c,
  [9, 9],
  237,
  379,
  s,
  [38, 6],
  277,
  277,
  352,
  c,
  [125, 15],
  38,
  391,
  390,
  392,
  393,
  394,
  396,
  395,
  397,
  c,
  [846, 7],
  213,
  149,
  400,
  137,
  199,
  137,
  205,
  c,
  [240, 13],
  407,
  c,
  [6, 4],
  408,
  15,
  409,
  c,
  [7, 4],
  410,
  411,
  199,
  200,
  15,
  412,
  c,
  [10, 4],
  413,
  414,
  199,
  200,
  415,
  199,
  200,
  416,
  417,
  418,
  c,
  [83, 15],
  109,
  109,
  277,
  109,
  261,
  421,
  109,
  254,
  252,
  109,
  422,
  c,
  [793, 4],
  s,
  [109, 5],
  c,
  [793, 22],
  426,
  213,
  149,
  427,
  429,
  428,
  c,
  [21, 15],
  297,
  236,
  277,
  352,
  285,
  237,
  277,
  352,
  281,
  238,
  290,
  239,
  279,
  295,
  296,
  277,
  352,
  391,
  431,
  432,
  294,
  73,
  433,
  434,
  c,
  [39, 15],
  436,
  277,
  277,
  439,
  440,
  c,
  [20, 15],
  88,
  c,
  [495, 16],
  c,
  [237, 16],
  c,
  [209, 6],
  447,
  448,
  449,
  15,
  450,
  c,
  [9, 4],
  451,
  452,
  199,
  200,
  453,
  199,
  200,
  454,
  455,
  199,
  200,
  456,
  457,
  458,
  191,
  460,
  c,
  [420, 9],
  c,
  [56, 16],
  277,
  465,
  116,
  116,
  277,
  116,
  352,
  116,
  116,
  422,
  s,
  [116, 5],
  c,
  [564, 4],
  468,
  c,
  [5, 4],
  213,
  149,
  277,
  473,
  474,
  475,
  477,
  476,
  15,
  479,
  c,
  [297, 5],
  15,
  482,
  199,
  200,
  483,
  484,
  485,
  112,
  112,
  277,
  112,
  352,
  112,
  112,
  422,
  s,
  [112, 5],
  c,
  [75, 15],
  487,
  207,
  277,
  233,
  240,
  207,
  s,
  [233, 14],
  c,
  [35, 15],
  489,
  490,
  277,
  352,
  422,
  159,
  s,
  [491, 7, 1],
  c,
  [178, 6],
  c,
  [144, 16],
  199,
  501,
  200,
  201,
  s,
  [504, 4, 1],
  213,
  149,
  c,
  [1131, 31],
  c,
  [15, 29],
  15,
  513,
  c,
  [92, 4],
  s,
  [514, 6, 1],
  114,
  114,
  277,
  114,
  352,
  114,
  114,
  422,
  s,
  [114, 5],
  521,
  520,
  s,
  [522, 4, 1],
  199,
  526,
  527,
  200,
  c,
  [127, 21],
  c,
  [21, 21],
  532,
  533,
  c,
  [17, 15],
  535,
  536,
  15,
  537,
  c,
  [40, 4],
  538,
  15,
  539,
  c,
  [7, 4],
  540,
  541,
  c,
  [55, 6],
  199,
  543,
  544,
  c,
  [86, 7],
  199,
  200,
  546,
  c,
  [609, 7],
  548,
  c,
  [6, 4],
  549,
  550,
  15,
  551,
  c,
  [8, 4],
  552,
  c,
  [333, 6],
  199,
  554,
  c,
  [39, 8],
  556,
  557,
  200,
  558,
  15,
  559,
  c,
  [11, 4],
  560,
  561,
  199,
  562,
  c,
  [22, 7],
  564,
  15,
  565,
  c,
  [29, 5],
  566,
  200,
  567
])
}),
defaultActions: bda({
  idx: u([
  5,
  6,
  8,
  s,
  [10, 5, 1],
  18,
  19,
  21,
  22,
  23,
  29,
  30,
  31,
  s,
  [35, 5, 1],
  s,
  [42, 4, 1],
  49,
  50,
  51,
  53,
  61,
  63,
  66,
  67,
  71,
  74,
  76,
  80,
  s,
  [88, 4, 1],
  94,
  95,
  s,
  [98, 7, 1],
  s,
  [106, 4, 1],
  116,
  s,
  [119, 4, 1],
  125,
  143,
  146,
  150,
  151,
  152,
  154,
  158,
  160,
  161,
  162,
  164,
  165,
  169,
  176,
  177,
  178,
  180,
  189,
  s,
  [192, 5, 1],
  s,
  [202, 7, 1],
  214,
  218,
  234,
  235,
  236,
  238,
  246,
  248,
  s,
  [251, 15, 1],
  268,
  276,
  283,
  s,
  [287, 4, 2],
  300,
  301,
  304,
  306,
  307,
  309,
  311,
  312,
  319,
  320,
  321,
  330,
  s,
  [334, 4, 2],
  341,
  s,
  [343, 5, 1],
  355,
  357,
  366,
  367,
  372,
  374,
  375,
  377,
  378,
  s,
  [380, 6, 1],
  390,
  392,
  s,
  [398, 4, 2],
  408,
  410,
  413,
  416,
  417,
  418,
  424,
  428,
  431,
  435,
  436,
  s,
  [439, 5, 1],
  447,
  451,
  454,
  456,
  457,
  459,
  463,
  464,
  467,
  473,
  474,
  478,
  483,
  484,
  485,
  488,
  s,
  [489, 5, 2],
  502,
  503,
  506,
  s,
  [521, 5, 1],
  532,
  533,
  535,
  541,
  549,
  552,
  553,
  558,
  560,
  564,
  567
]),
  goto: u([
  8,
  23,
  21,
  25,
  26,
  27,
  66,
  67,
  4,
  9,
  6,
  24,
  7,
  11,
  12,
  13,
  19,
  193,
  194,
  185,
  180,
  181,
  182,
  176,
  177,
  2,
  3,
  5,
  196,
  17,
  190,
  71,
  76,
  75,
  1,
  198,
  204,
  170,
  15,
  14,
  16,
  70,
  77,
  63,
  65,
  s,
  [209, 5, 1],
  88,
  98,
  224,
  225,
  74,
  183,
  178,
  184,
  179,
  48,
  57,
  59,
  10,
  188,
  18,
  192,
  64,
  103,
  104,
  105,
  107,
  108,
  117,
  226,
  227,
  228,
  231,
  162,
  243,
  244,
  171,
  172,
  173,
  79,
  82,
  222,
  223,
  240,
  241,
  242,
  47,
  28,
  45,
  46,
  58,
  54,
  83,
  85,
  186,
  s,
  [247, 14, 1],
  115,
  131,
  133,
  135,
  161,
  129,
  174,
  123,
  124,
  168,
  101,
  163,
  165,
  245,
  246,
  49,
  51,
  53,
  41,
  43,
  44,
  60,
  56,
  61,
  69,
  84,
  86,
  87,
  111,
  158,
  127,
  130,
  99,
  140,
  141,
  132,
  147,
  134,
  145,
  138,
  139,
  142,
  143,
  144,
  169,
  164,
  78,
  73,
  200,
  206,
  39,
  40,
  42,
  37,
  55,
  68,
  137,
  126,
  100,
  160,
  118,
  122,
  125,
  102,
  166,
  167,
  72,
  38,
  33,
  35,
  36,
  113,
  146,
  136,
  128,
  120,
  121,
  95,
  31,
  32,
  34,
  110,
  s,
  [148, 4, 2],
  119,
  20,
  202,
  30,
  157,
  s,
  [149, 4, 2],
  22,
  29,
  89,
  156,
  90,
  96,
  97,
  92,
  91,
  93,
  94
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable && typeof this.trace === 'function') {
        this.trace(str);
        hash.destroy(); // destroy... well, *almost*!
    } else {
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack
    var lstack = new Array(128);        // location stack
    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks
    var yyloc;

    var yylineno;


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 568 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function copy_yylloc(loc) {
        var rv = shallow_copy(loc);
        if (rv && rv.range) {
            rv.range = rv.range.slice(0);
        }
        return rv;
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = shallow_copy(l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        rv = shallow_copy(l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: copy_yylloc(lexer.yylloc),
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function lex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        yyloc = lexer.yylloc;
        lstack[sp] = yyloc;
        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    retval = this.parseError(p.errStr, p, this.JisonParserError);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p, this.JisonParserError);
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = copy_yylloc(lexer.yylloc);
                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;


                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;






                




                continue;

            // reduce:
            case 2:
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }

                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = this.parseError(p.errStr, p, this.JisonParserError);
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;


/* lexer generated by jison-lex 0.6.1-203 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... true
//   location assignment: ............. true
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.options.trackPosition) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        var pre = this.match;
        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).' + pos_str,
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      var error_size = loc.last_line - loc.first_line;
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');

      //var show_context = (error_size < 5 || context_loc);
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));

      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');

        if (lno === loc.first_line) {
          var offset = loc.first_column + 2;

          var len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );

          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno === loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, loc.last_column + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        } else if (lno > loc.first_line && lno < loc.last_line) {
          var offset = 2 + 1;
          var len = Math.max(2, line.length + 1);
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;

        console.log('clip off: ', {
          start: clip_start,
          end: clip_end,
          len: clip_end - clip_start + 1,
          arr: nonempty_line_indexes,
          rv
        });

        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var pos_str = '';

          if (typeof this.showPosition === 'function') {
            pos_str = this.showPosition();

            if (pos_str && pos_str[0] !== '\n') {
              pos_str = '\n' + pos_str;
            }
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!' + pos_str,
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var pos_str = '';

        if (typeof this.showPosition === 'function') {
          pos_str = this.showPosition();

          if (pos_str && pos_str[0] !== '\n') {
            pos_str = '\n' + pos_str;
          }
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.' + pos_str,
          this.options.lexerErrorsAreRecoverable
        );

        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time:
          if (!this.match.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.options.pre_lex === 'function') {
        r = this.options.pre_lex.call(this);
      }

      while (!r) {
        r = this.next();
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      flex: true,
      trackPosition: true,
      parseActionsUseYYMERGELOCATIONINFO: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: * */
        /*! Rule::       \s+ */
        return;

        break;

      case 5:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 6:
        /*! Conditions:: INITIAL */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 7:
        /*! Conditions:: INITIAL */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 8:
        /*! Conditions:: INITIAL */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 17:
        /*! Conditions:: TAG */
        /*! Rule::       \/> */
        this.popState();

        return 38;
        break;

      case 19:
        /*! Conditions:: TAG */
        /*! Rule::       > */
        this.begin('CHILDREN');

        return 14;
        break;

      case 20:
        /*! Conditions:: TAG */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 23:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 24:
        /*! Conditions:: CHILDREN */
        /*! Rule::       \{% */
        this.begin('CONTROL');

        return 28;
        break;

      case 25:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <!-- */
        this.begin('COMMENT');

        return;
        break;

      case 26:
        /*! Conditions:: CHILDREN */
        /*! Rule::       <\/ */
        this.begin('TAG');

        return 37;
        break;

      case 27:
        /*! Conditions:: CHILDREN */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 57:
        /*! Conditions:: CONTROL */
        /*! Rule::       = */
        this.popState();

        this.begin('CONTROL_CHILD');
        return 9;
        break;

      case 60:
        /*! Conditions:: CONTROL */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 63:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       < */
        this.begin('TAG');

        return 13;
        break;

      case 64:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       \{\{ */
        this.begin('EXPRESSION');

        return 39;
        break;

      case 65:
        /*! Conditions:: CONTROL_CHILD */
        /*! Rule::       %\} */
        this.popState();

        return 30;
        break;

      case 83:
        /*! Conditions:: EXPRESSION */
        /*! Rule::       \}\} */
        this.popState();

        return 40;
        break;

      case 86:
        /*! Conditions:: COMMENT */
        /*! Rule::       (.|\r|\n)*?--> */
        this.popState();

        return;
        break;

      case 115:
        /*! Conditions:: INITIAL */
        /*! Rule::       . */
        console.log('', yy_.yytext);

        /* `flex` lexing mode: the last resort rule! */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       import */
      1: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       from */
      2: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       using */
      3: 'USING',

      /*! Conditions:: INITIAL */
      /*! Rule::       as */
      4: 27,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Constructor} */
      9: 56,

      /*! Conditions:: INITIAL */
      /*! Rule::       {Identifier} */
      10: 55,

      /*! Conditions:: INITIAL */
      /*! Rule::       \{ */
      11: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \} */
      12: 5,

      /*! Conditions:: TAG */
      /*! Rule::       true */
      13: 53,

      /*! Conditions:: TAG */
      /*! Rule::       false */
      14: 54,

      /*! Conditions:: TAG */
      /*! Rule::       {Constructor} */
      15: 56,

      /*! Conditions:: TAG */
      /*! Rule::       {Identifier} */
      16: 55,

      /*! Conditions:: TAG */
      /*! Rule::       \/ */
      18: 'NOSE',

      /*! Conditions:: TAG */
      /*! Rule::       \{ */
      21: 4,

      /*! Conditions:: TAG */
      /*! Rule::       \} */
      22: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \{ */
      28: 4,

      /*! Conditions:: CHILDREN */
      /*! Rule::       \} */
      29: 5,

      /*! Conditions:: CHILDREN */
      /*! Rule::       [^/<>{%}]+ */
      30: 47,

      /*! Conditions:: CONTROL */
      /*! Rule::       main */
      31: 29,

      /*! Conditions:: CONTROL */
      /*! Rule::       endmain */
      32: 31,

      /*! Conditions:: CONTROL */
      /*! Rule::       macro */
      33: 'MACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       endmacro */
      34: 'ENDMACRO',

      /*! Conditions:: CONTROL */
      /*! Rule::       for */
      35: 41,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfor */
      36: 43,

      /*! Conditions:: CONTROL */
      /*! Rule::       if */
      37: 45,

      /*! Conditions:: CONTROL */
      /*! Rule::       endif */
      38: 46,

      /*! Conditions:: CONTROL */
      /*! Rule::       else */
      39: 44,

      /*! Conditions:: CONTROL */
      /*! Rule::       elseif */
      40: 'ELSEIF',

      /*! Conditions:: CONTROL */
      /*! Rule::       in */
      41: 42,

      /*! Conditions:: CONTROL */
      /*! Rule::       case */
      42: 'CASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       endcase */
      43: 'ENDCASE',

      /*! Conditions:: CONTROL */
      /*! Rule::       export */
      44: 32,

      /*! Conditions:: CONTROL */
      /*! Rule::       from */
      45: 26,

      /*! Conditions:: CONTROL */
      /*! Rule::       view */
      46: 33,

      /*! Conditions:: CONTROL */
      /*! Rule::       using */
      47: 'USING',

      /*! Conditions:: CONTROL */
      /*! Rule::       endview */
      48: 34,

      /*! Conditions:: CONTROL */
      /*! Rule::       instanceof */
      49: 63,

      /*! Conditions:: CONTROL */
      /*! Rule::       this */
      50: 'THIS',

      /*! Conditions:: CONTROL */
      /*! Rule::       fun */
      51: 35,

      /*! Conditions:: CONTROL */
      /*! Rule::       endfun */
      52: 36,

      /*! Conditions:: CONTROL */
      /*! Rule::       as */
      53: 27,

      /*! Conditions:: CONTROL */
      /*! Rule::       :: */
      54: '::',

      /*! Conditions:: CONTROL */
      /*! Rule::       @ */
      55: 19,

      /*! Conditions:: CONTROL */
      /*! Rule::       \(\) */
      56: '()',

      /*! Conditions:: CONTROL */
      /*! Rule::       {Constructor} */
      58: 56,

      /*! Conditions:: CONTROL */
      /*! Rule::       {Identifier} */
      59: 55,

      /*! Conditions:: CONTROL */
      /*! Rule::       \{ */
      61: 4,

      /*! Conditions:: CONTROL */
      /*! Rule::       \} */
      62: 5,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Constructor} */
      66: 56,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       {Identifier} */
      67: 55,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \{ */
      68: 4,

      /*! Conditions:: CONTROL_CHILD */
      /*! Rule::       \} */
      69: 5,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \| */
      70: 15,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       => */
      71: 50,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       -> */
      72: '->',

      /*! Conditions:: EXPRESSION */
      /*! Rule::       @ */
      73: 19,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       instanceof */
      74: 63,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       true */
      75: 53,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       false */
      76: 54,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       if */
      77: 45,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       then */
      78: 48,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       else */
      79: 44,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       as */
      80: 27,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Constructor} */
      81: 56,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       {Identifier} */
      82: 55,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \{ */
      84: 4,

      /*! Conditions:: EXPRESSION */
      /*! Rule::       \} */
      85: 5,

      /*! Conditions:: * */
      /*! Rule::       {NumberLiteral} */
      87: 52,

      /*! Conditions:: * */
      /*! Rule::       {StringLiteral} */
      88: 51,

      /*! Conditions:: * */
      /*! Rule::       > */
      89: 14,

      /*! Conditions:: * */
      /*! Rule::       < */
      90: 13,

      /*! Conditions:: * */
      /*! Rule::       \( */
      91: 7,

      /*! Conditions:: * */
      /*! Rule::       \) */
      92: 8,

      /*! Conditions:: * */
      /*! Rule::       \[ */
      93: 10,

      /*! Conditions:: * */
      /*! Rule::       \] */
      94: 11,

      /*! Conditions:: * */
      /*! Rule::       ; */
      95: 20,

      /*! Conditions:: * */
      /*! Rule::       : */
      96: 12,

      /*! Conditions:: * */
      /*! Rule::       = */
      97: 9,

      /*! Conditions:: * */
      /*! Rule::       == */
      98: 59,

      /*! Conditions:: * */
      /*! Rule::       != */
      99: 60,

      /*! Conditions:: * */
      /*! Rule::       >= */
      100: 57,

      /*! Conditions:: * */
      /*! Rule::       <= */
      101: 58,

      /*! Conditions:: * */
      /*! Rule::       \+ */
      102: 21,

      /*! Conditions:: * */
      /*! Rule::       - */
      103: 23,

      /*! Conditions:: * */
      /*! Rule::       \* */
      104: 3,

      /*! Conditions:: * */
      /*! Rule::       \/ */
      105: 22,

      /*! Conditions:: * */
      /*! Rule::       \\ */
      106: 49,

      /*! Conditions:: * */
      /*! Rule::       && */
      107: 61,

      /*! Conditions:: * */
      /*! Rule::       \|\| */
      108: 62,

      /*! Conditions:: * */
      /*! Rule::       \^ */
      109: 24,

      /*! Conditions:: * */
      /*! Rule::       ! */
      110: 16,

      /*! Conditions:: * */
      /*! Rule::       , */
      111: 6,

      /*! Conditions:: * */
      /*! Rule::       \? */
      112: 18,

      /*! Conditions:: * */
      /*! Rule::       \. */
      113: 17,

      /*! Conditions:: * */
      /*! Rule::       $ */
      114: 1
    },

    rules: [
      /*   0: */  /^(?:\s+)/,
      /*   1: */  /^(?:import)/,
      /*   2: */  /^(?:from)/,
      /*   3: */  /^(?:using)/,
      /*   4: */  /^(?:as)/,
      /*   5: */  /^(?:\{%)/,
      /*   6: */  /^(?:<!--)/,
      /*   7: */  /^(?:<)/,
      /*   8: */  /^(?:\{\{)/,
      /*   9: */  /^(?:([A-Z][\w$\-]*))/,
      /*  10: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  11: */  /^(?:\{)/,
      /*  12: */  /^(?:\})/,
      /*  13: */  /^(?:true)/,
      /*  14: */  /^(?:false)/,
      /*  15: */  /^(?:([A-Z][\w$\-]*))/,
      /*  16: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  17: */  /^(?:\/>)/,
      /*  18: */  /^(?:\/)/,
      /*  19: */  /^(?:>)/,
      /*  20: */  /^(?:\{\{)/,
      /*  21: */  /^(?:\{)/,
      /*  22: */  /^(?:\})/,
      /*  23: */  /^(?:\{\{)/,
      /*  24: */  /^(?:\{%)/,
      /*  25: */  /^(?:<!--)/,
      /*  26: */  /^(?:<\/)/,
      /*  27: */  /^(?:<)/,
      /*  28: */  /^(?:\{)/,
      /*  29: */  /^(?:\})/,
      /*  30: */  /^(?:[^\/<>{%}]+)/,
      /*  31: */  /^(?:main)/,
      /*  32: */  /^(?:endmain)/,
      /*  33: */  /^(?:macro)/,
      /*  34: */  /^(?:endmacro)/,
      /*  35: */  /^(?:for)/,
      /*  36: */  /^(?:endfor)/,
      /*  37: */  /^(?:if)/,
      /*  38: */  /^(?:endif)/,
      /*  39: */  /^(?:else)/,
      /*  40: */  /^(?:elseif)/,
      /*  41: */  /^(?:in)/,
      /*  42: */  /^(?:case)/,
      /*  43: */  /^(?:endcase)/,
      /*  44: */  /^(?:export)/,
      /*  45: */  /^(?:from)/,
      /*  46: */  /^(?:view)/,
      /*  47: */  /^(?:using)/,
      /*  48: */  /^(?:endview)/,
      /*  49: */  /^(?:instanceof)/,
      /*  50: */  /^(?:this)/,
      /*  51: */  /^(?:fun)/,
      /*  52: */  /^(?:endfun)/,
      /*  53: */  /^(?:as)/,
      /*  54: */  /^(?:::)/,
      /*  55: */  /^(?:@)/,
      /*  56: */  /^(?:\(\))/,
      /*  57: */  /^(?:=)/,
      /*  58: */  /^(?:([A-Z][\w$\-]*))/,
      /*  59: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  60: */  /^(?:%\})/,
      /*  61: */  /^(?:\{)/,
      /*  62: */  /^(?:\})/,
      /*  63: */  /^(?:<)/,
      /*  64: */  /^(?:\{\{)/,
      /*  65: */  /^(?:%\})/,
      /*  66: */  /^(?:([A-Z][\w$\-]*))/,
      /*  67: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  68: */  /^(?:\{)/,
      /*  69: */  /^(?:\})/,
      /*  70: */  /^(?:\|)/,
      /*  71: */  /^(?:=>)/,
      /*  72: */  /^(?:->)/,
      /*  73: */  /^(?:@)/,
      /*  74: */  /^(?:instanceof)/,
      /*  75: */  /^(?:true)/,
      /*  76: */  /^(?:false)/,
      /*  77: */  /^(?:if)/,
      /*  78: */  /^(?:then)/,
      /*  79: */  /^(?:else)/,
      /*  80: */  /^(?:as)/,
      /*  81: */  /^(?:([A-Z][\w$\-]*))/,
      /*  82: */  /^(?:([$_a-z][\w$\-]*))/,
      /*  83: */  /^(?:\}\})/,
      /*  84: */  /^(?:\{)/,
      /*  85: */  /^(?:\})/,
      /*  86: */  /^(?:(.|\r|\n)*?-->)/,
      /*  87: */  /^(?:((?:([-]?(?:[-]?([0]|((?:[1-9])(?:\d+)*)))\.(?:\d+)*(?:(?:[Ee])(?:[+-]?\d+))?)|(\.(?:\d+)(?:(?:[Ee])(?:[+-]?\d+))?)|((?:[-]?([0]|((?:[1-9])(?:\d+)*)))(?:(?:[Ee])(?:[+-]?\d+))?))|(?:[0][Xx](?:[\dA-Fa-f])+)|(?:[0](?:[0-7])+)))/,
      /*  88: */  /^(?:(("(?:([^\n\r"\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*")|('(?:([^\n\r'\\]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*')|(`(?:([^\n\r\\`]+)|(\\(?:(?:(?:["'\\bfnrtv])|(?:[^\d"'\\bfnrt-vx]))|(?:(?:[1-7][0-7]{0,2}|[0-7]{2,3}))|(?:[x](?:[\dA-Fa-f]){2})|(?:[u](?:[\dA-Fa-f]){4})))|(?:\\(\r\n|\r|\n)))*`)))/,
      /*  89: */  /^(?:>)/,
      /*  90: */  /^(?:<)/,
      /*  91: */  /^(?:\()/,
      /*  92: */  /^(?:\))/,
      /*  93: */  /^(?:\[)/,
      /*  94: */  /^(?:\])/,
      /*  95: */  /^(?:;)/,
      /*  96: */  /^(?::)/,
      /*  97: */  /^(?:=)/,
      /*  98: */  /^(?:==)/,
      /*  99: */  /^(?:!=)/,
      /* 100: */  /^(?:>=)/,
      /* 101: */  /^(?:<=)/,
      /* 102: */  /^(?:\+)/,
      /* 103: */  /^(?:-)/,
      /* 104: */  /^(?:\*)/,
      /* 105: */  /^(?:\/)/,
      /* 106: */  /^(?:\\)/,
      /* 107: */  /^(?:&&)/,
      /* 108: */  /^(?:\|\|)/,
      /* 109: */  /^(?:\^)/,
      /* 110: */  /^(?:!)/,
      /* 111: */  /^(?:,)/,
      /* 112: */  /^(?:\?)/,
      /* 113: */  /^(?:\.)/,
      /* 114: */  /^(?:$)/,
      /* 115: */  /^(?:.)/
    ],

    conditions: {
      'CHILDREN': {
        rules: [
          0,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'COMMENT': {
        rules: [
          0,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'CONTROL': {
        rules: [
          0,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'EXPRESSION': {
        rules: [
          0,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'CONTROL_CHILD': {
        rules: [
          0,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'TAG': {
        rules: [
          0,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114
        ],

        inclusive: false
      },

      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = Parser;
  exports.Parser = Parser.Parser;
  exports.parse = function () {
    return Parser.parse.apply(Parser, arguments);
  };
  
}

},{}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nodes = require("./AST");
var afpl = require("afpl");
var CONTEXT = '___context';
var VIEW = '___view';
var WML = '___wml';
var prims = ['String', 'Boolean', 'Number', 'Object', 'Undefined', 'Null', 'Void', 'Never', 'Any'];
/**
 * Types and functions for generating typescript program text.
 */
var _throwNotKnown = function (n) {
    throw new Error("Unsupported AST node " + (typeof n === 'object' ? n.constructor.name : n) + "!");
};
var noop = function () { return "function () {}"; };
/**
 * view template.
 */
exports.view = function (id, typeClasses, params, ctx, tag) {
    return "export class " + id + typeClasses + " extends " + WML + ".AppView<" + ctx + "> {\n\n    constructor(context: " + ctx + (params ? ',' + params : '') + ") {\n\n        super(context);\n\n        this.template = (" + CONTEXT + ":" + ctx + ", " + VIEW + ":" + WML + ".AppView<" + ctx + ">) =>\n          " + (tag ? tag : '<Node>document.createDocumentFragment()') + ";\n\n       }\n\n     }\n";
};
/**
 * code turns an AST into typescript code.
 */
exports.code = function (n, o) { return exports.module2TS(n, o); };
/**
 * module2TS converts a module to a typescript module.
 */
exports.module2TS = function (n, _a) {
    var module = _a.module;
    return "\nimport * as " + WML + " from '" + module + "';\n" + n.imports.map(exports.importStatement2TS).join(';\n') + "\n\n" + n.exports.map(exports.exports2TS).join(';\n') + "\n\n" + (n.main ? exports.main2TS(n.main) : '') + "\n";
};
/**
 * exports2TS converts various exports to typescript.
 */
exports.exports2TS = function (n) {
    if (n instanceof nodes.ExportStatement)
        return exports.exportStatement2TS(n);
    else if (n instanceof nodes.FunStatement)
        return exports.funStatement2TS(n);
    else if (n instanceof nodes.ViewStatement)
        return exports.viewStatement2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * importStatement2TS converts an import statement.
 */
exports.importStatement2TS = function (n) {
    return "import " + exports.importMember2TS(n.member) + " from '" + n.module.value + "'; ";
};
/**
 * importMember2TS converts the members of an import to typescript.
 */
exports.importMember2TS = function (n) {
    if (n instanceof nodes.AggregateMember)
        return exports.aggregateMember2TS(n);
    else if (n instanceof nodes.AliasedMember)
        return exports.aliasedMember2TS(n);
    else if (n instanceof nodes.CompositeMember)
        return exports.compositeMember2TS(n);
    else
        return _throwNotKnown;
};
/**
 * aliasedMember2TS converts a member alias to typescript.
 */
exports.aliasedMember2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.member) + " as " + exports.identifierOrConstructor2TS(n.alias) + " ";
};
/**
 * aggregateMember2TS converts a qualified member to typescript.
 */
exports.aggregateMember2TS = function (n) {
    return "* as " + exports.identifierOrConstructor2TS(n.id) + " ";
};
/**
 * compositeMember2TS coverts to typescript.
 */
exports.compositeMember2TS = function (n) {
    return '{' + (n.members.map(function (m) { return (m instanceof nodes.AliasedMember) ?
        exports.aliasedMember2TS(m) :
        exports.identifierOrConstructor2TS(m); }).join(',')) + '}';
};
/**
 * main2TS converts to typescript.
 */
exports.main2TS = function (n) {
    return (n instanceof nodes.TypedMain) ?
        exports.typedMain2TS(n) :
        exports.untypedMain2TS(n);
};
/**
 * typedMain2TS converts a typed main file to typescript.
 */
exports.typedMain2TS = function (n) {
    return exports.view(n.id ? exports.unqualifiedIdentifier2TS(n.id) : 'Main', exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
/**
 * untypedMain2TS converts an untyped main file to typescript.
 */
exports.untypedMain2TS = function (n) {
    return exports.view('Main', '', '', 'void', exports.tag2TS(n.tag));
};
/**
 * exportStatement2TS converts an export statement to typescript.
 */
exports.exportStatement2TS = function (n) {
    return "export " + exports.compositeMember2TS(n.members) + " from '" + n.module.value + "';\n";
};
/**
 * viewStatement2TS converts a view statement into a typescript class.
 */
exports.viewStatement2TS = function (n) {
    return exports.view(exports.constructor2TS(n.id), exports.typeClasses2TS(n.typeClasses), n.parameters.map(exports.parameter2TS).join(','), exports.type2TS(n.context), exports.tag2TS(n.tag));
};
var _funContext = function (n) { return "(" + CONTEXT + ":" + exports.type2TS(n) + ")=>"; };
var _funView = function () { return "(" + VIEW + ":" + WML + ".View)=>"; };
/**
 * funStatement2TS converts a function statement to typescript.
 */
exports.funStatement2TS = function (n) {
    return "export const " + exports.unqualifiedIdentifier2TS(n.id) + " = " +
        (exports.typeClasses2TS(n.typeClasses) + "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>") +
        ((n.context != null) ? _funContext(n.context) : '') +
        _funView() +
        ((Array.isArray(n.body) ? exports.children2TS(n.body) : exports.child2TS(n.body)) + ";");
};
/**
 * typeClasses2TS converts a list of typeclasses into the a list of typescript typeclasses.
 */
exports.typeClasses2TS = function (ns) {
    return (ns.length === 0) ? '' : "< " + ns.map(exports.typeClass2TS).join(',') + ">";
};
/**
 * typeClass2TS converts a typeclass into a typescript typeclass.
 */
exports.typeClass2TS = function (n) {
    return exports.identifierOrConstructor2TS(n.id) + " " +
        ((n.constraint ? 'extends ' + exports.type2TS(n.constraint) : '') + " ");
};
var _toPrim = function (typ) {
    return prims.indexOf(typ) > -1 ? typ.toLowerCase() : typ;
};
/**
 * type2TS converts a type hint to a typescript type hint.
 */
exports.type2TS = function (n) {
    return _toPrim(exports.identifierOrConstructor2TS(n.id)) + " " +
        (exports.typeClasses2TS(n.typeClasses) + " " + (n.list ? '[]' : ''));
};
/**
 * parameter2TS converts a parameter to a typescript parameter.
 */
exports.parameter2TS = function (n) {
    return (n instanceof nodes.TypedParameter) ? exports.typedParameter2TS(n) :
        (n instanceof nodes.UntypedParameter) ? exports.untypedParameter2TS(n) :
            _throwNotKnown;
};
/**
 * typedParameter2TS converts a typed parameter into a non-any typescript parameter.
 */
exports.typedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + ":" + exports.type2TS(n.hint) + " ";
};
/**
 * untypedParameter2TS converts an type inferred parameter to a typescript parameter.
 */
exports.untypedParameter2TS = function (n) {
    return exports.identifier2TS(n.id) + " ";
};
/**
 * children2TS converts a list of children to typescript.
 */
exports.children2TS = function (list) {
    return (list.length === 0) ? 'document.createDocumentFragment();' :
        (list.length === 1) ? exports.child2TS(list[0]) :
            WML + ".box(" + list.map(function (l) { return exports.child2TS(l); }).join(',') + ") ";
};
/**
 * child2TS converts children to typescript.
 */
exports.child2TS = function (n) {
    if ((n instanceof nodes.Node) || (n instanceof nodes.Widget))
        return exports.tag2TS(n);
    else if (n instanceof nodes.Interpolation)
        return WML + ".domify(" + exports.interpolation2TS(n) + ") ";
    else if (n instanceof nodes.IfStatement)
        return exports.ifStatement2TS(n);
    else if (n instanceof nodes.ForStatement)
        return exports.forStatement2TS(n);
    else if (n instanceof nodes.Characters)
        return exports.characters2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * tag2TS converts a tag (node/widget) to typescript.
 */
exports.tag2TS = function (n) {
    var children = n.children.map(exports.child2TS);
    var attrs = exports.attrs2String(exports.groupAttrs(n.attributes));
    var name = exports.identifierOrConstructor2TS(n.open);
    return (n.type === 'widget') ? WML + ".widget(" + name + ", " + attrs + ", [" + children + "], " + VIEW + ")" :
        WML + ".node('" + name + "', " + attrs + ", [" + children + "], " + VIEW + ") ";
};
/**
 * attrs2String
 */
exports.attrs2String = function (attrs) { return '{' +
    (Object.keys(attrs).map(function (ns) { return ns + " : { " + attrs[ns].join(',') + " } "; })) + '}'; };
/**
 * groupAttrs groups attributes according to their namespace.
 */
exports.groupAttrs = function (ns) { return ns.reduce(function (p, c) {
    return afpl.util.merge(p, (_a = {},
        _a[c.namespace.id || 'html'] = (p[c.namespace.id || 'html'] || []).concat(exports.attribute2TS(c)),
        _a));
    var _a;
}, { html: [], wml: [] }); };
/**
 * attribute2Value
 */
exports.attribute2TS = function (n) {
    return "'" + exports.unqualifiedIdentifier2TS(n.name) + "' : " + exports.attributeValue2TS(n.value) + " ";
};
/**
 * attributeValue2TS converts an attribute value to typescript.
 */
exports.attributeValue2TS = function (n) {
    return (n instanceof nodes.Interpolation) ? exports.interpolation2TS(n) : exports.literal2TS(n);
};
/**
 * interpolation2TS converts interpolation expressions to typescript.
 */
exports.interpolation2TS = function (n) {
    return n.filters.reduce(function (p, c) { return exports.expression2TS(c) + " (" + p + ")"; }, exports.expression2TS(n.expression));
};
/**
 * forStatement2TS converts a for statement to typescript.
 */
exports.forStatement2TS = function (n) {
    return WML + ".map(" + exports.expression2TS(n.list) + ", function _map" +
        ("(" + [n.variable, n.index, n.all].filter(function (x) { return x; }).map(exports.parameter2TS).join(',') + ") ") +
        ("{ return " + exports.children2TS(n.body) + " }, ") +
        ("function otherwise() { return " + exports.children2TS(n.otherwise) + " }) ");
};
/**
 * ifStatement2TS converts an if statement to typescript.
 */
exports.ifStatement2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ")? " +
        (exports.children2TS(n.then) + ":") +
        ("" + (n.elseClause ? else2TS(n.elseClause) : noop()));
};
var else2TS = function (n) {
    return (n instanceof nodes.ElseClause) ? exports.children2TS(n.children) :
        (n instanceof nodes.ElseIfClause) ? exports.ifStatement2TS(n) :
            _throwNotKnown(n);
};
/**
 * characters2TS converts character text to a typescript string.
 */
exports.characters2TS = function (n) { return WML + ".text(`" + n.value + "`)"; };
/**
 * expression2TS converts a wml expression to a typescript expression.
 */
exports.expression2TS = function (n) {
    if (n instanceof nodes.IfThenExpression)
        return exports.ifThenExpression2TS(n);
    else if (n instanceof nodes.BinaryExpression)
        return exports.binaryExpression2TS(n);
    else if (n instanceof nodes.UnaryExpression)
        return exports.unaryExpression2TS(n);
    else if (n instanceof nodes.ViewConstruction)
        return exports.viewConstruction2TS(n);
    else if (n instanceof nodes.FunApplication)
        return exports.funApplication2TS(n);
    else if (n instanceof nodes.ConstructExpression)
        return exports.constructExpression2TS(n);
    else if (n instanceof nodes.CallExpression)
        return exports.callExpression2TS(n);
    else if (n instanceof nodes.MemberExpression)
        return exports.memberExpression2TS(n);
    else if (n instanceof nodes.ReadExpression)
        return exports.readExpression2TS(n);
    else if (n instanceof nodes.FunctionExpression)
        return exports.functionExpression2TS(n);
    else if (n instanceof nodes.Record)
        return exports.record2TS(n);
    else if (n instanceof nodes.List)
        return exports.list2TS(n);
    else if (n instanceof nodes.BooleanLiteral)
        return exports.boolean2TS(n);
    else if (n instanceof nodes.NumberLiteral)
        return exports.number2TS(n);
    else if (n instanceof nodes.StringLiteral)
        return exports.string2TS(n);
    else if (n instanceof nodes.ContextProperty)
        return exports.contextProperty2TS(n);
    else if (n instanceof nodes.QualifiedConstructor)
        return exports.qualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedConstructor)
        return exports.unqualifiedConstructor2TS(n);
    else if (n instanceof nodes.UnqualifiedIdentifier)
        return exports.unqualifiedIdentifier2TS(n);
    else if (n instanceof nodes.QualifiedIdentifier)
        return exports.qualifiedIdentifier2TS(n);
    else if (n instanceof nodes.ContextVariable)
        return exports.contextVariable2TS(n);
    else
        _throwNotKnown(n);
};
/**
 * ifThenExpression2TS converts an if-then-else expression to typescript.
 */
exports.ifThenExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.condition) + ") ? " + exports.expression2TS(n.iftrue) + " : " + exports.expression2TS(n.iffalse) + " ";
};
/**
 * binaryExpression2TS converts a binary expression to typescript.
 */
exports.binaryExpression2TS = function (n) {
    return "(" + exports.expression2TS(n.left) + " " + exports.convertOperator(n.operator) + " " + exports.expression2TS(n.right) + ") ";
};
/**
 * convertOperator for strictness.
 */
exports.convertOperator = function (op) {
    return (op === '==') ? '===' :
        (op === '!=') ? '!==' :
            op;
};
/**
 * unaryExpression2TS converts a unary expression to typescript.
 */
exports.unaryExpression2TS = function (n) {
    return n.operator + " (" + exports.expression2TS(n.expression) + ")";
};
/**
 * viewConstruction2TS convers a view construction to typescript.
 */
exports.viewConstruction2TS = function (n) {
    return "(new " + exports.constructor2TS(n.cons) + "(" + exports.args2TS(n.context) + ")).render()";
};
var _applyFun = function (context) {
    return (context.length > 0 ? "(" + exports.args2TS(context) + ")" : '') + ("(" + VIEW + ")");
};
/**
 * funApplication2TS converts a fun application to typescript.
 */
exports.funApplication2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " " +
        ("(" + exports.args2TS(n.args) + ")" + _applyFun(n.context));
};
/**
 * constructExpression2TS converts a construct expression to a typescript new expression.
 */
exports.constructExpression2TS = function (n) {
    return "new " + exports.constructor2TS(n.cons) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * callExpression2TS converts a call expression (apply) to a typescript invocation.
 */
exports.callExpression2TS = function (n) {
    return exports.expression2TS(n.target) + " " + exports.typeArgs2TS(n.typeArgs) + " (" + exports.args2TS(n.args) + ")";
};
/**
 * typeArgs2TS converts passed type arguments to typescript
 */
exports.typeArgs2TS = function (ns) {
    return ns.length === 0 ? '' : "< " + ns.map(exports.type2TS).join(',') + ">";
};
/**
 * args2TS converts a list of arguments to a typescript argument tupple.
 */
exports.args2TS = function (ns) {
    return (ns.length === 0) ? '' : ns.map(exports.expression2TS).join(',');
};
/**
 * memberExpression2TS converts a member expression into a typescript member expression.
 */
exports.memberExpression2TS = function (n) {
    return exports.expression2TS(n.target) + "." + exports.identifier2TS(n.member) + " ";
};
/**
 * readExpression2TS converts a read expression to side effect full property look up.
 *
 * NOTE: this part of the language is most likely to change.
 */
exports.readExpression2TS = function (n) {
    return WML + ".read < " + exports.type2TS(n.hint) + ">(" + exports.expression2TS(n.path) + ", " + exports.expression2TS(n.target) + " " +
        ((n.defaults ? ',' + exports.expression2TS(n.defaults) : '') + ")");
};
/**
 * functionExpression2TS converts a function expression to a typescript function expression.
 */
exports.functionExpression2TS = function (n) {
    return "(" + n.parameters.map(exports.parameter2TS).join(',') + ")=>" +
        ("" + exports.expression2TS(n.body));
};
/**
 * literal2TS converts literals.
 */
exports.literal2TS = function (n) {
    return (n instanceof nodes.BooleanLiteral) ? exports.boolean2TS(n) :
        (n instanceof nodes.StringLiteral) ? exports.string2TS(n) :
            (n instanceof nodes.NumberLiteral) ? exports.number2TS(n) :
                (n instanceof nodes.Record) ? exports.record2TS(n) :
                    (n instanceof nodes.List) ? exports.list2TS(n) :
                        _throwNotKnown(n);
};
/**
 * boolean2TS converts a boolean literal to a typescript boolean literal.
 */
exports.boolean2TS = function (n) { return n.value + " "; };
/**
 * string2TS converts a string literal to a typescript string literal.
 */
exports.string2TS = function (n) { return "`" + n.value + "`"; };
/**
 * number2TS converts a number literal to a typecript number literal.
 */
exports.number2TS = function (n) { return "" + parseFloat(n.value); };
/**
 * record2TS converts a record to a typescript object literal.
 */
exports.record2TS = function (n) {
    return "{" + n.properties.map(exports.property2TS).join(',') + "}";
};
/**
 * list2TS converts a list to a typescript array literal.
 */
exports.list2TS = function (n) {
    return "[" + n.members.map(exports.expression2TS).join(',') + "]";
};
/**
 * property2TS converts a property of a a record to typescript.
 */
exports.property2TS = function (n) {
    return "'" + exports.key2TS(n.key) + "' : " + exports.expression2TS(n.value);
};
/**
 * key2TS converts a single key on a record.
 */
exports.key2TS = function (n) {
    return (n instanceof nodes.StringLiteral) ? exports.string2TS(n) : exports.identifier2TS(n);
};
/**
 * contextProperty2TS turns property access on the context to regular TS
 * property access.
 */
exports.contextProperty2TS = function (n) {
    return CONTEXT + "." + exports.identifier2TS(n.member);
};
/**
 * contextVariable2TS turns the context variable into the context identifier.
 */
exports.contextVariable2TS = function (_) { return "" + CONTEXT; };
/**
 * identifierOrConstructor2TS
 */
exports.identifierOrConstructor2TS = function (n) {
    if ((n instanceof nodes.UnqualifiedIdentifier) ||
        (n instanceof nodes.QualifiedIdentifier))
        return exports.identifier2TS(n);
    else if ((n instanceof nodes.UnqualifiedConstructor) ||
        (n instanceof nodes.QualifiedConstructor))
        return exports.constructor2TS(n);
    else
        return _throwNotKnown(n);
};
/**
 * constructor2TS turns a constructor to a typescript identifier.
 *
 * Remember constructors are proper cased.
 */
exports.constructor2TS = function (n) {
    return (n instanceof nodes.QualifiedConstructor) ? exports.qualifiedConstructor2TS(n) :
        (n instanceof nodes.UnqualifiedConstructor) ? exports.unqualifiedConstructor2TS(n) :
            _throwNotKnown(n);
};
/**
 * unqualifiedConstructor2TS converts an unqualified constructor to typescript
 */
exports.unqualifiedConstructor2TS = function (n) { return "" + n.id; };
/**
 * qualifiedConstructor converts a qualified constructor to typescript.
 */
exports.qualifiedConstructor2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * identifier2TS turns an identifier to a typescript identifier.
 */
exports.identifier2TS = function (n) {
    return (n instanceof nodes.QualifiedIdentifier) ? exports.qualifiedIdentifier2TS(n) :
        (n instanceof nodes.UnqualifiedIdentifier) ? exports.unqualifiedIdentifier2TS(n) :
            _throwNotKnown(n);
};
/**
 * qualifiedIdentifier2TS converts a qualified identifier to typescript
 */
exports.qualifiedIdentifier2TS = function (n) {
    return n.qualifier + "." + n.member;
};
/**
 * unqualifiedIdentifier2TS converts an unqualified identifier to typescript
 */
exports.unqualifiedIdentifier2TS = function (n) { return "" + n.id; };

},{"./AST":163,"afpl":169}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property = require("property-seek");
var Maybe_1 = require("afpl/lib/monad/Maybe");
var Compiler_1 = require("./Compiler");
exports.parse = Compiler_1.parse;
exports.compile = Compiler_1.compile;
;
/**
 * Component is an abstract Widget implementation
 * that can be used instead of manually implementing the whole interface.
 *
 */
var Component = /** @class */ (function () {
    /**
     * attrs is the attributes this Component excepts.
     */
    /**
     * children is an array of content passed to this Component.
     */
    function Component(attrs, children) {
        this.attrs = attrs;
        this.children = children;
    }
    Component.prototype.rendered = function () { };
    Component.prototype.removed = function () { };
    Component.prototype.render = function () { return this.view.render(); };
    return Component;
}());
exports.Component = Component;
;
/**
 * read a value form an object.
 *
 * This is an alternative to regular property access that will throw exceptions
 * if any of the values in the part are null.
 * @param {string} path - The path to look up on the object.
 * @param {object} o - The object
 * @param {A} [defaultValue] - This value is returned if the value is not set.
 * @private
 */
exports.read = function (path, o, defaultValue) {
    var ret = property.get(path.split(':').join('.'), o);
    return (ret != null) ? ret : defaultValue;
};
/**
 * @private
 */
var adopt = function (child, e) {
    switch (typeof child) {
        case 'string':
        case 'number':
        case 'boolean':
            e.appendChild(document.createTextNode('' + child));
        case 'object':
            e.appendChild(child);
            break;
        default:
            throw new TypeError("Can not adopt child " + child + " of type " + typeof child);
    }
};
/**
 * @private
 */
exports.box = function () {
    var content = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        content[_i] = arguments[_i];
    }
    var frag = document.createDocumentFragment();
    content.forEach(function (c) { return frag.appendChild(c); });
    return frag;
};
/**
 * @private
 */
exports.domify = function (a) {
    if (a instanceof Array) {
        return exports.box.apply(null, a.map(exports.domify));
    }
    else if ((typeof a === 'string') ||
        (typeof a === 'number') ||
        (typeof a === 'boolean')) {
        return exports.text(a);
    }
    else if (a instanceof Node) {
        return a;
    }
    else if (a == null) {
        return document.createDocumentFragment();
    }
    else {
        throw new TypeError("Can not use '" + a + "'(typeof " + typeof a + ") as Content!");
    }
};
/**
 * text creates a new TextNode.
 * @private
 */
exports.text = function (value) {
    return document.createTextNode('' + value);
};
/**
 * node is called to create a regular DOM node
 * @private
 */
exports.node = function (tag, attributes, children, view) {
    var e = document.createElement(tag);
    if (typeof attributes['html'] === 'object')
        Object.keys(attributes['html']).forEach(function (key) {
            var value = attributes['html'][key];
            if (typeof value === 'function') {
                e[key] = value;
            }
            else if (typeof value === 'string') {
                if (value !== '')
                    e.setAttribute(key, value);
            }
            else if (typeof value === 'boolean') {
                e.setAttribute(key, "" + value);
            }
        });
    children.forEach(function (c) { return adopt(c, e); });
    var id = attributes['wml'].id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, e);
    if (group)
        view.registerByGroup(group, e);
    return e;
};
/**
 * widget creates and renders a new wml widget instance.
 * @param {function} Construtor
 * @param {object} attributes
 * @param {array<string|number|Widget>} children
 * @param {View} view
 * @private
 * @return {Widget}
 */
exports.widget = function (Constructor, attributes, children, view) {
    var childs = [];
    var w;
    children.forEach(function (child) { return (child instanceof Array) ?
        childs.push.apply(childs, child) : childs.push(child); });
    w = new Constructor(attributes, childs);
    var id = attributes.wml.id;
    var group = attributes.wml.group;
    if (id)
        view.registerById(id, w);
    if (group)
        view.registerByGroup(group, w);
    view.registerWidget(w);
    return w.render();
};
/**
 * ifthen provides an if then expression
 * @private
 */
exports.ifthen = function (predicate, positive, negative) {
    return (predicate) ? positive() : negative();
};
/**
 * forE provides a for expression
 * @private
 */
exports.map = function (collection, cb, cb2) {
    var frag = document.createDocumentFragment();
    if (collection instanceof Array) {
        if (collection.length > 0)
            collection.forEach(function (v, k, a) { return frag.appendChild(cb(v, k, a)); });
        else
            frag.appendChild(cb2());
    }
    else if (typeof collection === 'object') {
        var l = Object.keys(collection);
        if (l.length > 0)
            l.forEach(function (k) { return frag.appendChild(cb(collection[k], k, collection)); });
        else
            frag.appendChild(cb2());
    }
    return frag;
};
/**
 * AppView is the concrete implementation of a View.
 *
 * @property {<C>} context - The context the view is rendered in.
 */
var AppView = /** @class */ (function () {
    function AppView(context) {
        this.context = context;
        this.ids = {};
        this.groups = {};
        this.widgets = [];
    }
    AppView.prototype.registerWidget = function (w) {
        this.widgets.push(w);
        return this;
    };
    AppView.prototype.registerById = function (id, w) {
        if (this.ids.hasOwnProperty(id))
            throw new Error("Duplicate id '" + id + "' detected!");
        this.ids[id] = w;
        return this;
    };
    AppView.prototype.registerByGroup = function (group, e) {
        this.groups[group] = this.groups[group] || [];
        this.groups[group].push(e);
        return this;
    };
    AppView.prototype.findById = function (id) {
        return Maybe_1.Maybe
            .fromAny(this.ids[id])
            .orElse(function () {
            console.warn("The id '" + id + "' is missing!");
            return Maybe_1.Maybe.nothing();
        });
    };
    AppView.prototype.findGroupByName = function (name) {
        return Maybe_1.Maybe.fromArray(this.groups.hasOwnProperty(name) ? this.groups[name] : []);
    };
    AppView.prototype.invalidate = function () {
        var childs;
        var realFirstChildIndex = -1;
        var tree = (this._fragRoot) ? this._fragRoot : this.tree;
        var parent = tree.parentNode;
        if (tree == null)
            throw new ReferenceError('invalidate(): Cannot invalidate a view that has not been rendered!');
        if (tree.parentNode == null)
            throw new ReferenceError('invalidate(): Attempt to invalidate a view that has not been inserted to DOM!');
        childs = tree.parentNode.children;
        // for some reason tree occasionally ends up with a null parentNode
        // when we attempt to call replaceChild. Noticeably after doing work on an array.
        // We do this to use the index instead of passing the reference directly.
        for (var i = 0; i < childs.length; i++)
            if (childs[i] === tree)
                realFirstChildIndex = i;
        // just in case we never got the index.
        if (realFirstChildIndex === -1)
            throw new Error('invaldiate(): Cannot invalidate view, DOM tree appears to have no parent!');
        parent.replaceChild(this.render(), parent.children[realFirstChildIndex]);
    };
    AppView.prototype.render = function () {
        this.ids = {};
        this.widgets.forEach(function (w) { return w.removed(); });
        this.widgets = [];
        this._fragRoot = null;
        this.tree = this.template(this.context, this);
        this.ids['root'] = (this.ids['root']) ? this.ids['root'] : this.tree;
        if (this.tree.nodeName === (document.createDocumentFragment()).nodeName)
            this._fragRoot = this.tree.firstChild;
        this.widgets.forEach(function (w) { return w.rendered(); });
        return this.tree;
    };
    return AppView;
}());
exports.AppView = AppView;

},{"./Compiler":164,"afpl/lib/monad/Maybe":174,"property-seek":182}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.f1 = function (f) { return f; };
exports.f2 = function (f) { return function (a) { return function (b) { return f(a, b); }; }; };
exports.f3 = function (f) {
    return function (a) { return function (b) { return function (c) { return f(a, b, c); }; }; };
};
exports.f4 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return f(a, b, c, d); }; }; }; };
};
exports.f5 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return f(a, b, c, d, e); }; }; }; }; };
};
exports.f6 = function (f) {
    return function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return function (_f) { return f(a, b, c, d, e, _f); }; }; }; }; }; };
};

},{}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
exports.util = util;
var curry = require("./curry");
exports.curry = curry;
var Identity_1 = require("./monad/Identity");
exports.Identity = Identity_1.Identity;
var Maybe_1 = require("./monad/Maybe");
exports.Maybe = Maybe_1.Maybe;
var Either_1 = require("./monad/Either");
exports.Either = Either_1.Either;
var State_1 = require("./monad/State");
exports.State = State_1.State;
var Free_1 = require("./monad/Free");
exports.Free = Free_1.Free;
var IO_1 = require("./monad/IO");
exports.IO = IO_1.IO;

},{"./curry":168,"./monad/Either":170,"./monad/Free":171,"./monad/IO":172,"./monad/Identity":173,"./monad/Maybe":174,"./monad/State":175,"./util":176}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * left wraps a value on the left side.
 */
exports.left = function (a) { return new Left(a); };
/**
 * right wraps a value on the right side.
 */
exports.right = function (b) { return new Right(b); };
/**
 * fromBoolean constructs an Either using a boolean value.
 */
exports.fromBoolean = function (b) {
    return b ? exports.right(true) : exports.left(false);
};
/**
 * Either monad implementation
 */
var Either = (function () {
    function Either() {
    }
    Either.prototype.of = function (v) {
        return new Right(v);
    };
    Either.left = exports.left;
    Either.right = exports.right;
    Either.fromBoolean = exports.fromBoolean;
    return Either;
}());
exports.Either = Either;
var Left = (function (_super) {
    __extends(Left, _super);
    function Left(l) {
        var _this = _super.call(this) || this;
        _this.l = l;
        return _this;
    }
    Left.prototype.map = function (_) {
        return new Left(this.l);
    };
    Left.prototype.mapLeft = function (f) {
        return new Left(f(this.l));
    };
    Left.prototype.bimap = function (f, _) {
        return exports.left(f(this.l));
    };
    Left.prototype.chain = function (_) {
        return new Left(this.l);
    };
    Left.prototype.orElse = function (f) {
        return f(this.l);
    };
    Left.prototype.orRight = function (f) {
        return new Right(f(this.l));
    };
    Left.prototype.ap = function (_) {
        return new Left(this.l);
    };
    Left.prototype.takeLeft = function () {
        return this.l;
    };
    Left.prototype.takeRight = function () {
        throw new TypeError("Not right!");
    };
    Left.prototype.cata = function (f, _) {
        return f(this.l);
    };
    return Left;
}(Either));
exports.Left = Left;
var Right = (function (_super) {
    __extends(Right, _super);
    function Right(r) {
        var _this = _super.call(this) || this;
        _this.r = r;
        return _this;
    }
    Right.prototype.map = function (f) {
        return new Right(f(this.r));
    };
    Right.prototype.mapLeft = function (_) {
        return new Right(this.r);
    };
    Right.prototype.bimap = function (_, g) {
        return exports.right(g(this.r));
    };
    Right.prototype.chain = function (f) {
        return f(this.r);
    };
    /**
     * orElse returns the result of f if the Either is left.
     */
    Right.prototype.orElse = function (_) {
        return this;
    };
    Right.prototype.orRight = function (_) {
        return this;
    };
    /**
     * ap
     */
    Right.prototype.ap = function (e) {
        var _this = this;
        return e.map(function (f) { return f(_this.r); });
    };
    /**
      * takeLeft extracts the left value of an Either, throwing an error if the Either is right.
      */
    Right.prototype.takeLeft = function () {
        throw new TypeError("Not left!");
    };
    Right.prototype.takeRight = function () {
        return this.r;
    };
    /**
     * cata
     */
    Right.prototype.cata = function (_, g) {
        return g(this.r);
    };
    return Right;
}(Either));
exports.Right = Right;

},{}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var Either_1 = require("./Either");
/**
 * free wraps a value in a free
 */
exports.free = function (a) { return new Return(a); };
/**
 * suspend lifts a function into a Free monad to mimic tail call recursion.
 */
exports.suspend = function (f) { return new Suspend(util_1.compose(exports.free, f)); };
/**
 * liftF lifts a Functor into a Free.
 */
exports.liftF = function (f) { return new Suspend(f.map(exports.free)); };
/**
 * Free is a Free monad that also implements a Free Applicative (almost).
 *
 * Inspired by https://cwmyers.github.io/monet.js/#free
 */
var Free = (function () {
    function Free() {
    }
    /**
     * of
     */
    Free.prototype.of = function (a) {
        return new Return(a);
    };
    /**
     * map
     */
    Free.prototype.map = function (f) {
        return this.chain(function (a) { return exports.free(f(a)); });
    };
    /**
     * chain
     */
    Free.prototype.chain = function (g) {
        if (this instanceof Suspend) {
            var f_1 = this.f;
            return (typeof f_1 === 'function') ?
                new Suspend(function (x) { return f_1(x).chain(g); }) :
                new Suspend(f_1.map(function (free) { return free.chain(g); }));
        }
        else if (this instanceof Return) {
            g(this.a);
        }
    };
    /**
     * resume the next stage of the computation
     */
    Free.prototype.resume = function () {
        if (this instanceof Suspend) {
            return Either_1.left(this.f);
        }
        else if (this instanceof Return) {
            return Either_1.right(this.a);
        }
    };
    /**
     * hoist
    hoist<B>(func: (fb: Functor<B>) => Functor<B>): Free<F, A> {

        if (this instanceof Suspend) {

            return new Suspend((func(this.f))
                .map((fr: Free<F, B>) => fr.hoist<any>(func)))
        } else {

            return this;

        }

    }
    */
    /**
     * cata
     */
    Free.prototype.cata = function (f, g) {
        return this.resume().cata(f, g);
    };
    /**
     * go runs the computation to completion using f to extract each stage.
     * @summmary go :: Free<F<*>, A> →  (F<Free<F,A>> →  Free<F,A>) →  A
     */
    Free.prototype.go = function (f) {
        if (this instanceof Suspend) {
            var r = this.resume();
            while (r instanceof Either_1.Left)
                r = (f(r.takeLeft())).resume();
            return r.takeRight();
        }
        else if (this instanceof Return) {
            return this.a;
        }
    };
    /**
     * run the Free chain to completion
     * @summary run :: Free<A→ A,A> →  A
     */
    Free.prototype.run = function () {
        return this.go(function (next) { return next(); });
    };
    Free.free = exports.free;
    Free.suspend = exports.suspend;
    Free.liftF = exports.liftF;
    return Free;
}());
exports.Free = Free;
var Suspend = (function (_super) {
    __extends(Suspend, _super);
    function Suspend(f) {
        var _this = _super.call(this) || this;
        _this.f = f;
        return _this;
    }
    return Suspend;
}(Free));
exports.Suspend = Suspend;
var Return = (function (_super) {
    __extends(Return, _super);
    function Return(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    return Return;
}(Free));
exports.Return = Return;

},{"../util":176,"./Either":170}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * wrapIO a value in the IO monad
 */
exports.wrapIO = function (a) { return new IO(function () { return a; }); };
/**
 * safeIO accepts a function that has side effects and wrapIOs it in an IO Monad.
 */
exports.safeIO = function (f) { return new IO(f); };
exports.pure = exports.wrapIO;
exports.suspend = exports.safeIO;
/**
 * IO monadic type for containing interactions with the 'real world'.
 */
var IO = (function () {
    function IO(effect) {
        this.effect = effect;
    }
    IO.prototype.of = function (v) {
        return new IO(function () { return v; });
    };
    IO.prototype.map = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()); });
    };
    IO.prototype.mapIn = function (b) {
        return this.map(function () { return b; });
    };
    /**
     * chain
     */
    IO.prototype.chain = function (f) {
        var _this = this;
        return new IO(function () { return f(_this.effect()).run(); });
    };
    IO.prototype.chainIn = function (b) {
        return this.chain(function () { return exports.wrapIO(b); });
    };
    /**
     * run
     */
    IO.prototype.run = function () {
        return this.effect();
    };
    IO.safeIO = exports.safeIO;
    IO.pure = exports.pure;
    IO.suspend = exports.suspend;
    IO.chain = function (f) { return function (m) { return m.chain(f); }; };
    return IO;
}());
exports.IO = IO;

},{}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Identity
 */
var Identity = (function () {
    function Identity(a) {
        this.a = a;
    }
    /**
     * of
     */
    Identity.prototype.of = function (a) {
        return new Identity(a);
    };
    /**
     * map
     */
    Identity.prototype.map = function (f) {
        return new Identity(f(this.get()));
    };
    /**
     * chain
     */
    Identity.prototype.chain = function (f) {
        return f(this.get());
    };
    /**
     * ap
     */
    Identity.prototype.ap = function (i) {
        var _this = this;
        return i.map(function (f) { return f(_this.get()); });
    };
    /**
     * get the value of an Identity
     * @summary get :: Identity<A> →  A
     */
    Identity.prototype.get = function () {
        return this.a;
    };
    return Identity;
}());
exports.Identity = Identity;

},{}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("./Either");
/**
 * just wraps a value in a Just
 */
exports.just = function (a) { return new Just(a); };
;
/**
 * nothing constructs nothing
 */
exports.nothing = function () { return new Nothing(); };
/**
 * fromAny constructs a Maybe from a value that may be null.
 */
exports.fromAny = function (a) { return a == null ? exports.nothing() : exports.just(a); };
/**
 * fromArray checks an array to see if it's empty (or full of nulls)
 * and returns a Maybe.
 */
exports.fromArray = function (a) {
    return ((a.length === 0) || (a.reduce(function (c, v) { return (v == null) ? c + 1 : c; }, 0) === a.length)) ?
        exports.nothing() : exports.just(a);
};
/**
 * fromOBject uses Object.keys to turn see if an object has any own properties.
 */
exports.fromObject = function (o) {
    return Object.keys(o).length === 0 ? exports.nothing() : exports.just(o);
};
/**
 * fromString constructs nothing if the string is empty or just otherwise.
 */
exports.fromString = function (s) {
    return (s === '') ? exports.nothing() : exports.just(s);
};
/**
 * fromBoolean constructs nothing if b is false, just otherwise
 */
exports.fromBoolean = function (b) {
    return (b === false) ? exports.nothing() : exports.just(b);
};
/**
 * fromNumber constructs nothing if n is 0 just otherwise.
 */
exports.fromNumber = function (n) {
    return (n === 0) ? exports.nothing() : exports.just(n);
};
/**
 * Maybe
 */
var Maybe = (function () {
    function Maybe() {
    }
    Maybe.prototype.of = function (a) {
        return new Just(a);
    };
    Maybe.just = exports.just;
    Maybe.nothing = exports.nothing;
    Maybe.fromAny = exports.fromAny;
    Maybe.fromObject = exports.fromObject;
    Maybe.fromArray = exports.fromArray;
    Maybe.fromString = exports.fromString;
    Maybe.fromBoolean = exports.fromBoolean;
    Maybe.fromNumber = exports.fromNumber;
    return Maybe;
}());
exports.Maybe = Maybe;
/**
 * Nothing
 */
var Nothing = (function (_super) {
    __extends(Nothing, _super);
    function Nothing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Nothing.prototype.map = function (_) {
        return new Nothing();
    };
    Nothing.prototype.chain = function (_) {
        return new Nothing();
    };
    Nothing.prototype.get = function () {
        throw new TypeError('Cannot get anything from Nothing!');
    };
    Nothing.prototype.orElse = function (f) {
        return f();
    };
    /**
     * orJust will turn Nothing into Just, wrapping the value specified.
     */
    Nothing.prototype.orJust = function (f) {
        return exports.just(f());
    };
    /**
     * cata applies the corresponding function to the Maybe
     */
    Nothing.prototype.cata = function (f, _g) {
        return f();
    };
    Nothing.prototype.toEither = function () {
        return Either_1.left(undefined);
    };
    return Nothing;
}(Maybe));
exports.Nothing = Nothing;
/**
 * Just
 */
var Just = (function (_super) {
    __extends(Just, _super);
    function Just(a) {
        var _this = _super.call(this) || this;
        _this.a = a;
        return _this;
    }
    Just.prototype.map = function (f) {
        return new Just(f(this.a));
    };
    Just.prototype.join = function () {
        return this.a;
    };
    Just.prototype.chain = function (f) {
        return f(this.a);
    };
    Just.prototype.get = function () {
        return this.a;
    };
    Just.prototype.orElse = function (_f) {
        return this;
    };
    Just.prototype.orJust = function (_f) {
        return this;
    };
    Just.prototype.cata = function (_f, g) {
        return g(this.a);
    };
    Just.prototype.toEither = function () {
        return Either_1.right(this.a);
    };
    return Just;
}(Maybe));
exports.Just = Just;

},{"./Either":170}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * get the state from the internals of the monad
 */
exports.get = function () { return new State(function (s) { return ([s, s]); }); };
/**
 * put
 */
exports.put = function (s) { return new State(function () { return ([null, s]); }); };
/**
 * modify the state
 * @summary  (S →  S) →  State<S →  {A, S} >
 */
exports.modify = function (f) { return exports.get().chain(function (s) { return exports.put(f(s)); }); };
/**
 * gets applies a function to the state putting using the result
 * as the result of the computation.
 * @summary (S →  A) →  State<S →  {A, S}>
 */
exports.gets = function (f) { return exports.get().chain(function (s) { return exports.state(f(s)); }); };
/**
 * state create a new State monad
 */
exports.state = function (a) { return new State(function (s) { return ([a, s]); }); };
/**
 * State is a monadic class that we use to hold information that changes
 * during computation.
 *
 * This implementation is influenced by:
 * @link https://en.wikipedia.org/wiki/Monad_(functional_programming)#State_monads
 * @property {s →  (a, s)} a
 */
var State = (function () {
    function State(f) {
        this.f = f;
    }
    /**
     * of wraps a value in the State monad.
     * @summary A →  State<S→ {A,S}>
     */
    State.prototype.of = function (a) {
        return new State(function (s) { return ([a, s]); });
    };
    /**
     * map
     * @summary State<S → {A,S}> →  (A →  B) →  State<S →  {C, S}>
     */
    State.prototype.map = function (f) {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return [f(a), s];
        });
    };
    /**
     * join replaces the outer State with an inner State
     */
    State.prototype.join = function () {
        var _this = this;
        return new State(function (xs) {
            var _a = _this.run(xs), a = _a[0], s = _a[1];
            return a.run(s);
        });
    };
    /**
     * chain
     */
    State.prototype.chain = function (f) {
        return this.map(f).join();
    };
    /**
     * evaluate the State returning the final value
     */
    State.prototype.evaluate = function (s) {
        return this.run(s)[0];
    };
    /**
     * execute the State returning the final state.
     */
    State.prototype.execute = function (s) {
        return this.run(s)[1];
    };
    /**
     * run the State yielding the final value and state.
     * @summary State<S→ {A<S}> →  S →  {A,S}
     */
    State.prototype.run = function (s) {
        return this.f(s);
    };
    State.get = exports.get;
    State.put = exports.put;
    State.modify = exports.modify;
    State.gets = exports.gets;
    State.state = exports.state;
    return State;
}());
exports.State = State;

},{}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
;
/**
 * identity is the famed identity function.
 */
exports.identity = function (a) { return a; };
/**
 * merge two objects easily
 */
exports.merge = function () {
    var o = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        o[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, [{}].concat(o));
};
/**
 * fuse is the deep version of merge
 */
exports.fuse = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.reduce(function (o, c) {
        if (c === void 0) { c = {}; }
        return exports.reduce(c, function (co, cc, k) {
            return Array.isArray(cc) ?
                (Array.isArray(co[k]) ?
                    exports.merge(co, (_a = {}, _a[k] = (co[k]).map(exports.copy).concat(cc.map(exports.copy)), _a)) :
                    exports.merge(co, (_b = {}, _b[k] = cc.map(exports.copy), _b))) :
                typeof cc !== 'object' ?
                    exports.merge(co, (_c = {}, _c[k] = cc, _c)) :
                    exports.merge(co, (_d = {},
                        _d[k] = (typeof co[k] !== 'object') ?
                            exports.merge(co[k], cc) :
                            exports.fuse(co[k], cc),
                        _d));
            var _a, _b, _c, _d;
        }, o);
    }, {});
};
exports.copy = function (o) {
    return (Array.isArray(o)) ?
        o.map(exports.copy) :
        (typeof o === 'object') ?
            exports.reduce(o, function (p, c, k) {
                return exports.merge(p, (_a = {}, _a[k] = exports.copy(c), _a));
                var _a;
            }, {}) : o;
};
/**
 * reduce an object's keys (in no guaranteed order)
 */
exports.reduce = function (o, f, accum) {
    return Object.keys(o).reduce(function (p, k) { return f(p, o[k], k, o); }, accum);
};
/**
 * map over an object (in no guaranteed oreder)
 */
exports.map = function (o, f) {
    return Object.keys(o).map((function (k) { return f(o[k], k, o); }));
};
/**
 * compose two functions into one.
 */
exports.compose = function (f, g) { return function (x) { return f(g(x)); }; };
/**
 * fling removes a key from an object
 * @param {string} key
 * @param {object} object
 * @return {Object}
 * @summary {(string,Object) →  Object}
 */
exports.fling = function (s, o) {
    if ((o == null) || (o.constructor !== Object))
        throw new TypeError('fling(): only works with object literals!');
    return Object.keys(o).reduce(function (o2, k) {
        return k === s ? o2 : exports.merge(o2, (_a = {},
            _a[k] = o[k],
            _a));
        var _a;
    }, {});
};
/**
 * head returns the item at index 0 of an array
 * @param {Array} list
 * @return {*}
 * @summary { Array →  * }
 */
exports.head = function (list) { return list[0]; };
/**
 * tail returns the last item in an array
 * @param {Array} list
 * @return {*}
 * @summary {Array →  *}
 */
exports.tail = function (list) { return list[list.length - 1]; };
/**
 * constant given a value, return a function that always returns this value.
 * @summary constant X →  * →  X
 *
 */
exports.constant = function (a) { return function () { return a; }; };
/**
 * f1 partial application.
 */
exports.f1 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return f.apply(null, args.concat(a)); };
};
/**
 * f2 partial application
 */
exports.f2 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return f.apply(null, args.concat(a, aa)); }; };
};
/**
 * f3 partial application
 */
exports.f3 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return f.apply(null, args.concat(a, aa, aaa)); }; }; };
};
/**
 * f4 partial application
 */
exports.f4 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa));
    }; }; }; };
};
/**
 * f5 partial application
 */
exports.f5 = function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (a) { return function (aa) { return function (aaa) { return function (aaaa) { return function (aaaaa) {
        return f.apply(null, args.concat(a, aa, aaa, aaaa, aaaaa));
    }; }; }; }; };
};
/**
 * except copies an object removing a single key.
 */
exports.except = function (keys, o) {
    return exports.reduce(o, function (p, c, k) {
        return keys.indexOf(k) > -1 ? p : exports.merge(p, (_a = {}, _a[k] = c, _a));
        var _a;
    }, {});
};

},{}],177:[function(require,module,exports){
/*
  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
    // the default is js
    var beautify = function(src, config) {
        return js_beautify.js_beautify(src, config);
    };

    // short aliases
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;

    // legacy aliases
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;

    return beautify;
}

if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([
        "./lib/beautify",
        "./lib/beautify-css",
        "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
    });
} else {
    (function(mod) {
        var js_beautify = require('./lib/beautify');
        var css_beautify = require('./lib/beautify-css');
        var html_beautify = require('./lib/beautify-html');

        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

    })(module);
}
},{"./lib/beautify":180,"./lib/beautify-css":178,"./lib/beautify-html":179}],178:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
        http://jsbeautifier.org/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                         — indentation size,
        indent_char (space)                     — character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {
var legacy_beautify_css =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);
var Output = __webpack_require__(3).Output;


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

function Beautifier(source_text, options) {
    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'css');

    source_text = source_text || '';

    var newlinesFromLastWSEat = 0;
    var indentSize = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    var indentCharacter = options.indent_char || ' ';
    var preserve_newlines = (options.preserve_newlines === undefined) ? false : options.preserve_newlines;
    var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
    var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
    var space_around_combinator = (options.space_around_combinator === undefined) ? false : options.space_around_combinator;
    space_around_combinator = space_around_combinator || ((options.space_around_selector_separator === undefined) ? false : options.space_around_selector_separator);
    var eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indentCharacter = '\t';
        indentSize = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (source_text && lineBreak.test(source_text || '')) {
            eol = source_text.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    source_text = source_text.replace(allLineBreaks, '\n');

    // tokenizer
    var whiteRe = /^\s+$/;

    var pos = -1,
        ch;
    var parenLevel = 0;

    function next() {
        ch = source_text.charAt(++pos);
        return ch || '';
    }

    function peek(skipWhitespace) {
        var result = '';
        var prev_pos = pos;
        if (skipWhitespace) {
            eatWhitespace();
        }
        result = source_text.charAt(pos + 1) || '';
        pos = prev_pos - 1;
        next();
        return result;
    }

    function eatString(endChars) {
        var start = pos;
        while (next()) {
            if (ch === "\\") {
                next();
            } else if (endChars.indexOf(ch) !== -1) {
                break;
            } else if (ch === "\n") {
                break;
            }
        }
        return source_text.substring(start, pos + 1);
    }

    function peekString(endChar) {
        var prev_pos = pos;
        var str = eatString(endChar);
        pos = prev_pos - 1;
        next();
        return str;
    }

    function eatWhitespace(preserve_newlines_local) {
        var result = 0;
        while (whiteRe.test(peek())) {
            next();
            if (ch === '\n' && preserve_newlines_local && preserve_newlines) {
                output.add_new_line(true);
                result++;
            }
        }
        newlinesFromLastWSEat = result;
        return result;
    }

    function skipWhitespace() {
        var result = '';
        if (ch && whiteRe.test(ch)) {
            result = ch;
        }
        while (whiteRe.test(next())) {
            result += ch;
        }
        return result;
    }

    function eatComment() {
        var start = pos;
        var singleLine = peek() === "/";
        next();
        while (next()) {
            if (!singleLine && ch === "*" && peek() === "/") {
                next();
                break;
            } else if (singleLine && ch === "\n") {
                return source_text.substring(start, pos);
            }
        }

        return source_text.substring(start, pos) + ch;
    }


    function lookBack(str) {
        return source_text.substring(pos - str.length, pos).toLowerCase() ===
            str;
    }

    // Nested pseudo-class if we are insideRule
    // and the next special character found opens
    // a new block
    function foundNestedPseudoClass() {
        var openParen = 0;
        for (var i = pos + 1; i < source_text.length; i++) {
            var ch = source_text.charAt(i);
            if (ch === "{") {
                return true;
            } else if (ch === '(') {
                // pseudoclasses can contain ()
                openParen += 1;
            } else if (ch === ')') {
                if (openParen === 0) {
                    return false;
                }
                openParen -= 1;
            } else if (ch === ";" || ch === "}") {
                return false;
            }
        }
        return false;
    }

    // printer
    var baseIndentString = '';
    var preindent_index = 0;
    if (source_text && source_text.length) {
        while ((source_text.charAt(preindent_index) === ' ' ||
                source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = source_text.substring(0, preindent_index);
        js_source_text = source_text.substring(preindent_index);
    }


    var singleIndent = new Array(indentSize + 1).join(indentCharacter);
    var indentLevel;
    var nestedLevel;
    var output;

    function print_string(output_string) {
        if (output.just_added_newline()) {
            output.set_indent(indentLevel);
        }
        output.add_token(output_string);
    }

    function preserveSingleSpace(isAfterSpace) {
        if (isAfterSpace) {
            output.space_before_token = true;
        }
    }

    function indent() {
        indentLevel++;
    }

    function outdent() {
        if (indentLevel > 0) {
            indentLevel--;
        }
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        // reset
        output = new Output(singleIndent, baseIndentString);
        indentLevel = 0;
        nestedLevel = 0;

        pos = -1;
        ch = null;
        parenLevel = 0;

        var insideRule = false;
        var insidePropertyValue = false;
        var enteringConditionalGroup = false;
        var top_ch = '';
        var last_top_ch = '';

        while (true) {
            var whitespace = skipWhitespace();
            var isAfterSpace = whitespace !== '';
            var isAfterNewline = whitespace.indexOf('\n') !== -1;
            last_top_ch = top_ch;
            top_ch = ch;

            if (!ch) {
                break;
            } else if (ch === '/' && peek() === '*') { /* css comment */
                var header = indentLevel === 0;

                if (isAfterNewline || header) {
                    output.add_new_line();
                }

                print_string(eatComment());
                output.add_new_line();
                if (header) {
                    output.add_new_line(true);
                }
            } else if (ch === '/' && peek() === '/') { // single line comment
                if (!isAfterNewline && last_top_ch !== '{') {
                    output.trim(true);
                }
                output.space_before_token = true;
                print_string(eatComment());
                output.add_new_line();
            } else if (ch === '@') {
                preserveSingleSpace(isAfterSpace);

                // deal with less propery mixins @{...}
                if (peek() === '{') {
                    print_string(eatString('}'));
                } else {
                    print_string(ch);

                    // strip trailing space, if present, for hash property checks
                    var variableOrRule = peekString(": ,;{}()[]/='\"");

                    if (variableOrRule.match(/[ :]$/)) {
                        // we have a variable or pseudo-class, add it and insert one space before continuing
                        next();
                        variableOrRule = eatString(": ").replace(/\s$/, '');
                        print_string(variableOrRule);
                        output.space_before_token = true;
                    }

                    variableOrRule = variableOrRule.replace(/\s$/, '');

                    // might be a nesting at-rule
                    if (variableOrRule in this.NESTED_AT_RULE) {
                        nestedLevel += 1;
                        if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                            enteringConditionalGroup = true;
                        }
                    }
                }
            } else if (ch === '#' && peek() === '{') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString('}'));
            } else if (ch === '{') {
                if (peek(true) === '}') {
                    eatWhitespace();
                    next();
                    output.space_before_token = true;
                    print_string("{}");
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                        output.add_new_line(true);
                    }
                } else {
                    indent();
                    output.space_before_token = true;
                    print_string(ch);
                    if (!eatWhitespace(true)) {
                        output.add_new_line();
                    }

                    // when entering conditional groups, only rulesets are allowed
                    if (enteringConditionalGroup) {
                        enteringConditionalGroup = false;
                        insideRule = (indentLevel > nestedLevel);
                    } else {
                        // otherwise, declarations are also allowed
                        insideRule = (indentLevel >= nestedLevel);
                    }
                }
            } else if (ch === '}') {
                outdent();
                output.add_new_line();
                print_string(ch);
                insideRule = false;
                insidePropertyValue = false;
                if (nestedLevel) {
                    nestedLevel--;
                }

                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }

                if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
                    output.add_new_line(true);
                }
            } else if (ch === ":") {
                eatWhitespace();
                if ((insideRule || enteringConditionalGroup) &&
                    !(lookBack("&") || foundNestedPseudoClass()) &&
                    !lookBack("(")) {
                    // 'property: value' delimiter
                    // which could be in a conditional group query
                    print_string(':');
                    if (!insidePropertyValue) {
                        insidePropertyValue = true;
                        output.space_before_token = true;
                    }
                } else {
                    // sass/less parent reference don't use a space
                    // sass nested pseudo-class don't use a space

                    // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
                    if (lookBack(" ")) {
                        output.space_before_token = true;
                    }
                    if (peek() === ":") {
                        // pseudo-element
                        next();
                        print_string("::");
                    } else {
                        // pseudo-class
                        print_string(':');
                    }
                }
            } else if (ch === '"' || ch === '\'') {
                preserveSingleSpace(isAfterSpace);
                print_string(eatString(ch));
            } else if (ch === ';') {
                insidePropertyValue = false;
                print_string(ch);
                if (!eatWhitespace(true)) {
                    output.add_new_line();
                }
            } else if (ch === '(') { // may be a url
                if (lookBack("url")) {
                    print_string(ch);
                    eatWhitespace();
                    if (next()) {
                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
                            print_string(eatString(')'));
                        } else {
                            pos--;
                        }
                    }
                } else {
                    parenLevel++;
                    preserveSingleSpace(isAfterSpace);
                    print_string(ch);
                    eatWhitespace();
                }
            } else if (ch === ')') {
                print_string(ch);
                parenLevel--;
            } else if (ch === ',') {
                print_string(ch);
                if (!eatWhitespace(true) && selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
                    output.add_new_line();
                } else {
                    output.space_before_token = true;
                }
            } else if ((ch === '>' || ch === '+' || ch === '~') &&
                !insidePropertyValue && parenLevel < 1) {
                //handle combinator spacing
                if (space_around_combinator) {
                    output.space_before_token = true;
                    print_string(ch);
                    output.space_before_token = true;
                } else {
                    print_string(ch);
                    eatWhitespace();
                    // squash extra whitespace
                    if (ch && whiteRe.test(ch)) {
                        ch = '';
                    }
                }
            } else if (ch === ']') {
                print_string(ch);
            } else if (ch === '[') {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            } else if (ch === '=') { // no whitespace before or after
                eatWhitespace();
                print_string('=');
                if (whiteRe.test(ch)) {
                    ch = '';
                }

            } else {
                preserveSingleSpace(isAfterSpace);
                print_string(ch);
            }
        }

        var sweetCode = output.get_code(end_with_newline, eol);

        return sweetCode;
    };

    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    this.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        // also in CONDITIONAL_GROUP_RULE below
        "@media": true,
        "@supports": true,
        "@document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
}

module.exports = css_beautify;

/***/ })
/******/ ]);
var css_beautify = legacy_beautify_css;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return {
            css_beautify: css_beautify
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    exports.css_beautify = css_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.css_beautify = css_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.css_beautify = css_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],179:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)  — indent <head> and <body> sections,
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to pre tag) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/

(function() {
var legacy_beautify_html =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

var mergeOpts = __webpack_require__(2).mergeOpts;
var acorn = __webpack_require__(1);


var lineBreak = acorn.lineBreak;
var allLineBreaks = acorn.allLineBreaks;

// function trim(s) {
//     return s.replace(/^\s+|\s+$/g, '');
// }

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

function rtrim(s) {
    return s.replace(/\s+$/g, '');
}

function Beautifier(html_source, options, js_beautify, css_beautify) {
    //Wrapper function to invoke all the necessary constructors and deal with the output.
    html_source = html_source || '';

    var multi_parser,
        indent_inner_html,
        indent_body_inner_html,
        indent_head_inner_html,
        indent_size,
        indent_character,
        wrap_line_length,
        brace_style,
        unformatted,
        content_unformatted,
        preserve_newlines,
        max_preserve_newlines,
        indent_handlebars,
        wrap_attributes,
        wrap_attributes_indent_size,
        is_wrap_attributes_force,
        is_wrap_attributes_force_expand_multiline,
        is_wrap_attributes_force_aligned,
        end_with_newline,
        extra_liners,
        eol;

    options = options || {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'html');

    // backwards compatibility to 1.3.4
    if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
        (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
        options.wrap_line_length = options.max_char;
    }

    indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
    indent_body_inner_html = (options.indent_body_inner_html === undefined) ? true : options.indent_body_inner_html;
    indent_head_inner_html = (options.indent_head_inner_html === undefined) ? true : options.indent_head_inner_html;
    indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
    indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
    brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
    wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
    unformatted = options.unformatted || [
        // https://www.w3.org/TR/html5/dom.html#phrasing-content
        'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
        'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
        'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
        'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
        'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
        'video', 'wbr', 'text',
        // prexisting - not sure of full effect of removing, leaving in
        'acronym', 'address', 'big', 'dt', 'ins', 'strike', 'tt',
    ];
    content_unformatted = options.content_unformatted || [
        'pre',
    ];
    preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    max_preserve_newlines = preserve_newlines ?
        (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) :
        0;
    indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
    wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
    wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);
    is_wrap_attributes_force = wrap_attributes.substr(0, 'force'.length) === 'force';
    is_wrap_attributes_force_expand_multiline = (wrap_attributes === 'force-expand-multiline');
    is_wrap_attributes_force_aligned = (wrap_attributes === 'force-aligned');
    end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    extra_liners = (typeof options.extra_liners === 'object') && options.extra_liners ?
        options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
        options.extra_liners.split(',') : 'head,body,/html'.split(',');
    eol = options.eol ? options.eol : 'auto';

    if (options.indent_with_tabs) {
        indent_character = '\t';
        indent_size = 1;
    }

    if (eol === 'auto') {
        eol = '\n';
        if (html_source && lineBreak.test(html_source || '')) {
            eol = html_source.match(lineBreak)[0];
        }
    }

    eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    // HACK: newline parsing inconsistent. This brute force normalizes the input.
    html_source = html_source.replace(allLineBreaks, '\n');

    function Parser() {

        this.pos = 0; //Parser position
        this.token = '';
        this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
        this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
            parent: 'parent1',
            parentcount: 1,
            parent1: ''
        };
        this.tag_type = '';
        this.token_text = this.last_token = this.last_text = this.token_type = '';
        this.newlines = 0;
        this.indent_content = indent_inner_html;
        this.indent_body_inner_html = indent_body_inner_html;
        this.indent_head_inner_html = indent_head_inner_html;

        this.Utils = { //Uilities made available to the various functions
            whitespace: "\n\r\t ".split(''),

            single_token: options.void_elements || [
                // HTLM void elements - aka self-closing tags - aka singletons
                // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
                'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
                'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
                // NOTE: Optional tags - are not understood.
                // https://www.w3.org/TR/html5/syntax.html#optional-tags
                // The rules for optional tags are too complex for a simple list
                // Also, the content of these tags should still be indented in many cases.
                // 'li' is a good exmple.

                // Doctype and xml elements
                '!doctype', '?xml',
                // ?php tag
                '?php',
                // other tags that were in this list, keeping just in case
                'basefont', 'isindex'
            ],
            extra_liners: extra_liners, //for tags that need a line of whitespace before them
            in_array: function(what, arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (what === arr[i]) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Return true if the given text is composed entirely of whitespace.
        this.is_whitespace = function(text) {
            for (var n = 0; n < text.length; n++) {
                if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
                    return false;
                }
            }
            return true;
        };

        this.traverse_whitespace = function() {
            var input_char = '';

            input_char = this.input.charAt(this.pos);
            if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                this.newlines = 0;
                while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
                        this.newlines += 1;
                    }

                    this.pos++;
                    input_char = this.input.charAt(this.pos);
                }
                return true;
            }
            return false;
        };

        // Append a space to the given content (string array) or, if we are
        // at the wrap_line_length, append a newline/indentation.
        // return true if a newline was added, false if a space was added
        this.space_or_wrap = function(content) {
            if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
                this.print_newline(false, content);
                this.print_indentation(content);
                return true;
            } else {
                this.line_char_count++;
                content.push(' ');
                return false;
            }
        };

        this.get_content = function() { //function to capture regular content between tags
            var input_char = '',
                content = [],
                handlebarsStarted = 0;

            while (this.input.charAt(this.pos) !== '<' || handlebarsStarted === 2) {
                if (this.pos >= this.input.length) {
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                if (handlebarsStarted < 2 && this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                    continue;
                }

                input_char = this.input.charAt(this.pos);

                if (indent_handlebars) {
                    if (input_char === '{') {
                        handlebarsStarted += 1;
                    } else if (handlebarsStarted < 2) {
                        handlebarsStarted = 0;
                    }

                    if (input_char === '}' && handlebarsStarted > 0) {
                        if (handlebarsStarted-- === 0) {
                            break;
                        }
                    }
                    // Handlebars parsing is complicated.
                    // {{#foo}} and {{/foo}} are formatted tags.
                    // {{something}} should get treated as content, except:
                    // {{else}} specifically behaves like {{#if}} and {{/if}}
                    var peek3 = this.input.substr(this.pos, 3);
                    if (peek3 === '{{#' || peek3 === '{{/') {
                        // These are tags and not content.
                        break;
                    } else if (peek3 === '{{!') {
                        return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
                    } else if (this.input.substr(this.pos, 2) === '{{') {
                        if (this.get_tag(true) === '{{else}}') {
                            break;
                        }
                    }
                }

                this.pos++;
                this.line_char_count++;
                content.push(input_char); //letter at-a-time (or string) inserted to an array
            }
            return content.length ? content.join('') : '';
        };

        this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
            if (this.pos === this.input.length) {
                return ['', 'TK_EOF'];
            }
            var content = '';
            var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
            reg_match.lastIndex = this.pos;
            var reg_array = reg_match.exec(this.input);
            var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
            if (this.pos < end_script) { //get everything in between the script tags
                content = this.input.substring(this.pos, end_script);
                this.pos = end_script;
            }
            return content;
        };

        this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
            if (this.tags[tag + 'count']) { //check for the existence of this tag type
                this.tags[tag + 'count']++;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            } else { //otherwise initialize this tag type
                this.tags[tag + 'count'] = 1;
                this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
            }
            this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
            this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
        };

        this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
            if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
                var temp_parent = this.tags.parent; //check to see if it's a closable tag.
                while (temp_parent) { //till we reach '' (the initial value);
                    if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
                        break;
                    }
                    temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
                }
                if (temp_parent) { //if we caught something
                    this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
                    this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
                }
                delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
                delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
                if (this.tags[tag + 'count'] === 1) {
                    delete this.tags[tag + 'count'];
                } else {
                    this.tags[tag + 'count']--;
                }
            }
        };

        this.indent_to_tag = function(tag) {
            // Match the indentation level to the last use of this tag, but don't remove it.
            if (!this.tags[tag + 'count']) {
                return;
            }
            var temp_parent = this.tags.parent;
            while (temp_parent) {
                if (tag + this.tags[tag + 'count'] === temp_parent) {
                    break;
                }
                temp_parent = this.tags[temp_parent + 'parent'];
            }
            if (temp_parent) {
                this.indent_level = this.tags[tag + this.tags[tag + 'count']];
            }
        };

        this.get_tag = function(peek) { //function to get a full tag and parse its type
            var input_char = '',
                content = [],
                comment = '',
                space = false,
                first_attr = true,
                has_wrapped_attrs = false,
                tag_start, tag_end,
                tag_start_char,
                orig_pos = this.pos,
                orig_line_char_count = this.line_char_count,
                is_tag_closed = false,
                tail;

            peek = peek !== undefined ? peek : false;

            do {
                if (this.pos >= this.input.length) {
                    if (peek) {
                        this.pos = orig_pos;
                        this.line_char_count = orig_line_char_count;
                    }
                    return content.length ? content.join('') : ['', 'TK_EOF'];
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
                    space = true;
                    continue;
                }

                if (input_char === "'" || input_char === '"') {
                    input_char += this.get_unformatted(input_char);
                    space = true;
                }

                if (input_char === '=') { //no space before =
                    space = false;
                }
                tail = this.input.substr(this.pos - 1);
                if (is_wrap_attributes_force_expand_multiline && has_wrapped_attrs && !is_tag_closed && (input_char === '>' || input_char === '/')) {
                    if (tail.match(/^\/?\s*>/)) {
                        space = false;
                        is_tag_closed = true;
                        this.print_newline(false, content);
                        this.print_indentation(content);
                    }
                }
                if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
                    //no space after = or before >
                    var wrapped = this.space_or_wrap(content);
                    var indentAttrs = wrapped && input_char !== '/' && !is_wrap_attributes_force;
                    space = false;

                    if (is_wrap_attributes_force && input_char !== '/') {
                        var force_first_attr_wrap = false;
                        if (is_wrap_attributes_force_expand_multiline && first_attr) {
                            var is_only_attribute = tail.match(/^\S*(="([^"]|\\")*")?\s*\/?\s*>/) !== null;
                            force_first_attr_wrap = !is_only_attribute;
                        }
                        if (!first_attr || force_first_attr_wrap) {
                            this.print_newline(false, content);
                            this.print_indentation(content);
                            indentAttrs = true;
                        }
                    }
                    if (indentAttrs) {
                        has_wrapped_attrs = true;

                        //indent attributes an auto, forced, or forced-align line-wrap
                        var alignment_size = wrap_attributes_indent_size;
                        if (is_wrap_attributes_force_aligned) {
                            alignment_size = content.indexOf(' ') + 1;
                        }

                        for (var count = 0; count < alignment_size; count++) {
                            // only ever further indent with spaces since we're trying to align characters
                            content.push(' ');
                        }
                    }
                    if (first_attr) {
                        for (var i = 0; i < content.length; i++) {
                            if (content[i] === ' ') {
                                first_attr = false;
                                break;
                            }
                        }
                    }
                }

                if (indent_handlebars && tag_start_char === '<') {
                    // When inside an angle-bracket tag, put spaces around
                    // handlebars not inside of strings.
                    if ((input_char + this.input.charAt(this.pos)) === '{{') {
                        input_char += this.get_unformatted('}}');
                        if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
                            input_char = ' ' + input_char;
                        }
                        space = true;
                    }
                }

                if (input_char === '<' && !tag_start_char) {
                    tag_start = this.pos - 1;
                    tag_start_char = '<';
                }

                if (indent_handlebars && !tag_start_char) {
                    if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
                        if (input_char === '#' || input_char === '/' || input_char === '!') {
                            tag_start = this.pos - 3;
                        } else {
                            tag_start = this.pos - 2;
                        }
                        tag_start_char = '{';
                    }
                }

                this.line_char_count++;
                content.push(input_char); //inserts character at-a-time (or string)

                if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
                    // We treat all comments as literals, even more than preformatted tags
                    // we just look for the appropriate close tag
                    content = [this.get_comment(tag_start)];
                    break;
                }

                if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
                    break;
                }
            } while (input_char !== '>');

            var tag_complete = content.join('');
            var tag_index;
            var tag_offset;

            // must check for space first otherwise the tag could have the first attribute included, and
            // then not un-indent correctly
            if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
                tag_index = tag_complete.indexOf(' ');
            } else if (tag_complete.indexOf('\n') !== -1) { //if there's a line break, thats where the tag name ends
                tag_index = tag_complete.indexOf('\n');
            } else if (tag_complete.charAt(0) === '{') {
                tag_index = tag_complete.indexOf('}');
            } else { //otherwise go with the tag ending
                tag_index = tag_complete.indexOf('>');
            }
            if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
                tag_offset = 1;
            } else {
                tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
            }
            var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
            if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
                this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
                if (!peek) {
                    this.tag_type = 'SINGLE';
                }
            } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
                if (!peek) {
                    this.indent_to_tag('if');
                    this.tag_type = 'HANDLEBARS_ELSE';
                    this.indent_content = true;
                    this.traverse_whitespace();
                }
            } else if (this.is_unformatted(tag_check, unformatted) ||
                this.is_unformatted(tag_check, content_unformatted)) {
                // do not reformat the "unformatted" or "content_unformatted" tags
                comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
                content.push(comment);
                tag_end = this.pos - 1;
                this.tag_type = 'SINGLE';
            } else if (tag_check === 'script' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 &&
                        tag_complete.search(/\b(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'SCRIPT';
                }
            } else if (tag_check === 'style' &&
                (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
                if (!peek) {
                    this.record_tag(tag_check);
                    this.tag_type = 'STYLE';
                }
            } else if (tag_check.charAt(0) === '!') { //peek for <! comment
                // for comments content is already correct.
                if (!peek) {
                    this.tag_type = 'SINGLE';
                    this.traverse_whitespace();
                }
            } else if (!peek) {
                if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
                    this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
                    this.tag_type = 'END';
                } else { //otherwise it's a start-tag
                    this.record_tag(tag_check); //push it on the tag stack
                    if (tag_check.toLowerCase() !== 'html') {
                        this.indent_content = true;
                    }
                    this.tag_type = 'START';
                }

                // Allow preserving of newlines after a start or end tag
                if (this.traverse_whitespace()) {
                    this.space_or_wrap(content);
                }

                if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
                    this.print_newline(false, this.output);
                    if (this.output.length && this.output[this.output.length - 2] !== '\n') {
                        this.print_newline(true, this.output);
                    }
                }
            }

            if (peek) {
                this.pos = orig_pos;
                this.line_char_count = orig_line_char_count;
            }

            return content.join(''); //returns fully formatted tag
        };

        this.get_comment = function(start_pos) { //function to return comment content in its entirety
            // this is will have very poor perf, but will work for now.
            var comment = '',
                delimiter = '>',
                matched = false;

            this.pos = start_pos;
            var input_char = this.input.charAt(this.pos);
            this.pos++;

            while (this.pos <= this.input.length) {
                comment += input_char;

                // only need to check for the delimiter if the last chars match
                if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
                    comment.indexOf(delimiter) !== -1) {
                    break;
                }

                // only need to search for custom delimiter for the first few characters
                if (!matched && comment.length < 10) {
                    if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
                        delimiter = '<![endif]>';
                        matched = true;
                    } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
                        delimiter = ']]>';
                        matched = true;
                    } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
                        delimiter = ']>';
                        matched = true;
                    } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
                        delimiter = '-->';
                        matched = true;
                    } else if (comment.indexOf('{{!--') === 0) { // {{!-- handlebars comment
                        delimiter = '--}}';
                        matched = true;
                    } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
                        if (comment.length === 5 && comment.indexOf('{{!--') === -1) {
                            delimiter = '}}';
                            matched = true;
                        }
                    } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
                        delimiter = '?>';
                        matched = true;
                    } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
                        delimiter = '%>';
                        matched = true;
                    }
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;
            }

            return comment;
        };

        function tokenMatcher(delimiter) {
            var token = '';

            var add = function(str) {
                var newToken = token + str.toLowerCase();
                token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);
            };

            var doesNotMatch = function() {
                return token.indexOf(delimiter) === -1;
            };

            return {
                add: add,
                doesNotMatch: doesNotMatch
            };
        }

        this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety
            if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
                return '';
            }
            var input_char = '';
            var content = '';
            var space = true;

            var delimiterMatcher = tokenMatcher(delimiter);

            do {

                if (this.pos >= this.input.length) {
                    return content;
                }

                input_char = this.input.charAt(this.pos);
                this.pos++;

                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    if (!space) {
                        this.line_char_count--;
                        continue;
                    }
                    if (input_char === '\n' || input_char === '\r') {
                        content += '\n';
                        /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            */
                        this.line_char_count = 0;
                        continue;
                    }
                }
                content += input_char;
                delimiterMatcher.add(input_char);
                this.line_char_count++;
                space = true;

                if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
                    // Handlebars expressions in strings should also be unformatted.
                    content += this.get_unformatted('}}');
                    // Don't consider when stopping for delimiters.
                }
            } while (delimiterMatcher.doesNotMatch());

            return content;
        };

        this.get_token = function() { //initial handler for token-retrieval
            var token;

            if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
                var type = this.last_token.substr(7);
                token = this.get_contents_to(type);
                if (typeof token !== 'string') {
                    return token;
                }
                return [token, 'TK_' + type];
            }
            if (this.current_mode === 'CONTENT') {
                token = this.get_content();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    return [token, 'TK_CONTENT'];
                }
            }

            if (this.current_mode === 'TAG') {
                token = this.get_tag();
                if (typeof token !== 'string') {
                    return token;
                } else {
                    var tag_name_type = 'TK_TAG_' + this.tag_type;
                    return [token, tag_name_type];
                }
            }
        };

        this.get_full_indent = function(level) {
            level = this.indent_level + level || 0;
            if (level < 1) {
                return '';
            }

            return Array(level + 1).join(this.indent_string);
        };

        this.is_unformatted = function(tag_check, unformatted) {
            //is this an HTML5 block-level link?
            if (!this.Utils.in_array(tag_check, unformatted)) {
                return false;
            }

            if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
                return true;
            }

            //at this point we have an  tag; is its first child something we want to remain
            //unformatted?
            var next_tag = this.get_tag(true /* peek. */ );

            // test next_tag to see if it is just html tag (no external content)
            var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

            // if next_tag comes back but is not an isolated tag, then
            // let's treat the 'a' tag as having content
            // and respect the unformatted option
            if (!tag || this.Utils.in_array(tag[1], unformatted)) {
                return true;
            } else {
                return false;
            }
        };

        this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

            this.input = js_source || ''; //gets the input for the Parser

            // HACK: newline parsing inconsistent. This brute force normalizes the input.
            this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n');

            this.output = [];
            this.indent_character = indent_character;
            this.indent_string = '';
            this.indent_size = indent_size;
            this.brace_style = brace_style;
            this.indent_level = 0;
            this.wrap_line_length = wrap_line_length;
            this.line_char_count = 0; //count to see if wrap_line_length was exceeded

            for (var i = 0; i < this.indent_size; i++) {
                this.indent_string += this.indent_character;
            }

            this.print_newline = function(force, arr) {
                this.line_char_count = 0;
                if (!arr || !arr.length) {
                    return;
                }
                if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
                    if ((arr[arr.length - 1] !== '\n')) {
                        arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
                    }
                    arr.push('\n');
                }
            };

            this.print_indentation = function(arr) {
                for (var i = 0; i < this.indent_level; i++) {
                    arr.push(this.indent_string);
                    this.line_char_count += this.indent_string.length;
                }
            };

            this.print_token = function(text) {
                // Avoid printing initial whitespace.
                if (this.is_whitespace(text) && !this.output.length) {
                    return;
                }
                if (text || text !== '') {
                    if (this.output.length && this.output[this.output.length - 1] === '\n') {
                        this.print_indentation(this.output);
                        text = ltrim(text);
                    }
                }
                this.print_token_raw(text);
            };

            this.print_token_raw = function(text) {
                // If we are going to print newlines, truncate trailing
                // whitespace, as the newlines will represent the space.
                if (this.newlines > 0) {
                    text = rtrim(text);
                }

                if (text && text !== '') {
                    if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
                        // unformatted tags can grab newlines as their last character
                        this.output.push(text.slice(0, -1));
                        this.print_newline(false, this.output);
                    } else {
                        this.output.push(text);
                    }
                }

                for (var n = 0; n < this.newlines; n++) {
                    this.print_newline(n > 0, this.output);
                }
                this.newlines = 0;
            };

            this.indent = function() {
                this.indent_level++;
            };

            this.unindent = function() {
                if (this.indent_level > 0) {
                    this.indent_level--;
                }
            };
        };
        return this;
    }

    /*_____________________--------------------_____________________*/

    this.beautify = function() {
        multi_parser = new Parser(); //wrapping functions Parser
        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values
        while (true) {
            var t = multi_parser.get_token();
            multi_parser.token_text = t[0];
            multi_parser.token_type = t[1];

            if (multi_parser.token_type === 'TK_EOF') {
                break;
            }

            switch (multi_parser.token_type) {
                case 'TK_TAG_START':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) &&
                            (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {

                            multi_parser.indent();
                        }

                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_STYLE':
                case 'TK_TAG_SCRIPT':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_END':
                    //Print new line only if the tag has no content and has child
                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
                        var tag_name = (multi_parser.token_text.match(/\w+/) || [])[0];
                        var tag_extracted_from_last_output = null;
                        if (multi_parser.output.length) {
                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
                        }
                        if (tag_extracted_from_last_output === null ||
                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
                            multi_parser.print_newline(false, multi_parser.output);
                        }
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_SINGLE':
                    // Don't add a newline before elements that should remain unformatted.
                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_ELSE':
                    // Don't add a newline if opening {{#if}} tag is on the current line
                    var foundIfOnCurrentLine = false;
                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
                        if (multi_parser.output[lastCheckedOutput] === '\n') {
                            break;
                        } else {
                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {
                                foundIfOnCurrentLine = true;
                                break;
                            }
                        }
                    }
                    if (!foundIfOnCurrentLine) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_COMMENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_CONTENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_STYLE':
                case 'TK_SCRIPT':
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_newline(false, multi_parser.output);
                        var text = multi_parser.token_text,
                            _beautifier,
                            script_indent_level = 1;
                        if (multi_parser.token_type === 'TK_SCRIPT') {
                            _beautifier = typeof js_beautify === 'function' && js_beautify;
                        } else if (multi_parser.token_type === 'TK_STYLE') {
                            _beautifier = typeof css_beautify === 'function' && css_beautify;
                        }

                        if (options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (options.indent_scripts === "separate") {
                            script_indent_level = -multi_parser.indent_level;
                        }

                        var indentation = multi_parser.get_full_indent(script_indent_level);
                        if (_beautifier) {

                            // call the Beautifier if avaliable
                            var Child_options = function() {
                                this.eol = '\n';
                            };
                            Child_options.prototype = options;
                            var child_options = new Child_options();
                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
                        } else {
                            // simply indent the string otherwise
                            var white = text.match(/^\s*/)[0];
                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
                            text = text.replace(/^\s*/, indentation)
                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
                                .replace(/\s+$/, '');
                        }
                        if (text) {
                            multi_parser.print_token_raw(text);
                            multi_parser.print_newline(true, multi_parser.output);
                        }
                    }
                    multi_parser.current_mode = 'TAG';
                    break;
                default:
                    // We should not be getting here but we don't want to drop input on the floor
                    // Just output the text and move on
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_token(multi_parser.token_text);
                    }
                    break;
            }
            multi_parser.last_token = multi_parser.token_type;
            multi_parser.last_text = multi_parser.token_text;
        }
        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

        // establish end_with_newline
        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };
}

module.exports.Beautifier = Beautifier;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(0).Beautifier;

function style_html(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
}

module.exports = style_html;

/***/ })
/******/ ]);
var style_html = legacy_beautify_html;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define(["require", "./beautify", "./beautify-css"], function(requireamd) {
        var js_beautify = requireamd("./beautify");
        var css_beautify = requireamd("./beautify-css");

        return {
            html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
            }
        };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var html_beautify = require("beautify").html_beautify`.
    var js_beautify = require('./beautify.js');
    var css_beautify = require('./beautify-css.js');

    exports.html_beautify = function(html_source, options) {
        return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
    };
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.html_beautify = function(html_source, options) {
        return style_html(html_source, options, window.js_beautify, window.css_beautify);
    };
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.html_beautify = function(html_source, options) {
        return style_html(html_source, options, global.js_beautify, global.css_beautify);
    };
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./beautify-css.js":178,"./beautify.js":180}],180:[function(require,module,exports){
(function (global){
/*jshint curly:false, eqeqeq:true, laxbreak:true, noempty:false */
/* AUTO-GENERATED. DO NOT MODIFY. */
/* see js/src/javascript/index.js */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {
var legacy_beautify_js =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* jshint curly: false */
// This section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


// Test whether a given character code starts an identifier.

exports.isIdentifierStart = function(code) {
    // permit $ (36) and @ (64). @ is used in ES7 decorators.
    if (code < 65) return code === 36 || code === 64;
    // 65 through 91 are uppercase letters.
    if (code < 91) return true;
    // permit _ (95).
    if (code < 97) return code === 95;
    // 97 through 123 are lowercase letters.
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
};

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var mergeOpts = __webpack_require__(3).mergeOpts;
var acorn = __webpack_require__(0);
var Output = __webpack_require__(4).Output;
var Tokenizer = __webpack_require__(7).Tokenizer;

function remove_redundant_indentation(output, frame) {
    // This implementation is effective but has some issues:
    //     - can cause line wrap to happen too soon due to indent removal
    //           after wrap points are calculated
    // These issues are minor compared to ugly indentation.

    if (frame.multiline_frame ||
        frame.mode === MODE.ForInitializer ||
        frame.mode === MODE.Conditional) {
        return;
    }

    // remove one indent from each line inside this section
    var start_index = frame.start_line_index;

    output.remove_indent(start_index);
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function ltrim(s) {
    return s.replace(/^\s+/g, '');
}

// function rtrim(s) {
//     return s.replace(/\s+$/g, '');
// }


function generateMapFromStrings(list) {
    var result = {};
    for (var x = 0; x < list.length; x++) {
        // make the mapped names underscored instead of dash
        result[list[x].replace(/-/g, '_')] = list[x];
    }
    return result;
}

function sanitizeOperatorPosition(opPosition) {
    opPosition = opPosition || OPERATOR_POSITION.before_newline;

    if (!in_array(opPosition, validPositionValues)) {
        throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
            validPositionValues +
            "\nYou passed in: '" + opPosition + "'");
    }

    return opPosition;
}

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
    BlockStatement: 'BlockStatement', // 'BLOCK'
    Statement: 'Statement', // 'STATEMENT'
    ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
    ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
    ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
    Conditional: 'Conditional', //'(COND-EXPRESSION)',
    Expression: 'Expression' //'(EXPRESSION)'
};

function Beautifier(js_source_text, options) {
    "use strict";
    var output;
    var tokens = [],
        token_pos;
    var tokenizer;
    var current_token;
    var last_type, last_last_text, indent_string;
    var flags, previous_flags, flag_store;
    var prefix;

    var handlers, opt;
    var baseIndentString = '';

    handlers = {
        'TK_START_EXPR': handle_start_expr,
        'TK_END_EXPR': handle_end_expr,
        'TK_START_BLOCK': handle_start_block,
        'TK_END_BLOCK': handle_end_block,
        'TK_WORD': handle_word,
        'TK_RESERVED': handle_word,
        'TK_SEMICOLON': handle_semicolon,
        'TK_STRING': handle_string,
        'TK_EQUALS': handle_equals,
        'TK_OPERATOR': handle_operator,
        'TK_COMMA': handle_comma,
        'TK_BLOCK_COMMENT': handle_block_comment,
        'TK_COMMENT': handle_comment,
        'TK_DOT': handle_dot,
        'TK_UNKNOWN': handle_unknown,
        'TK_EOF': handle_eof
    };

    function create_flags(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
            next_indent_level = flags_base.indentation_level;
            if (!output.just_added_newline() &&
                flags_base.line_indent_level > next_indent_level) {
                next_indent_level = flags_base.line_indent_level;
            }
        }

        var next_flags = {
            mode: mode,
            parent: flags_base,
            last_text: flags_base ? flags_base.last_text : '', // last token text
            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
            declaration_statement: false,
            declaration_assignment: false,
            multiline_frame: false,
            inline_frame: false,
            if_block: false,
            else_block: false,
            do_block: false,
            do_while: false,
            import_block: false,
            in_case_statement: false, // switch(..){ INSIDE HERE }
            in_case: false, // we're on the exact line with "case 0:"
            case_body: false, // the indented case-action block
            indentation_level: next_indent_level,
            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
            start_line_index: output.get_line_number(),
            ternary_depth: 0
        };
        return next_flags;
    }

    // Some interpreters have unexpected results with foo = baz || bar;
    options = options ? options : {};

    // Allow the setting of language/file-type specific options
    // with inheritance of overall settings
    options = mergeOpts(options, 'js');

    opt = {};

    // compatibility, re
    if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
        options.brace_style = "expand";
    } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
        options.brace_style = "collapse,preserve-inline";
    } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
        options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
    } else if (!options.brace_style) //Nothing exists to set it
    {
        options.brace_style = "collapse";
    }


    var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
    opt.brace_style = brace_style_split[0];
    opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
    opt.indent_char = options.indent_char ? options.indent_char : ' ';
    opt.eol = options.eol ? options.eol : 'auto';
    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
    opt.unindent_chained_methods = (options.unindent_chained_methods === undefined) ? false : options.unindent_chained_methods;
    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
    opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
    opt.e4x = (options.e4x === undefined) ? false : options.e4x;
    opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
    opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
    opt.operator_position = sanitizeOperatorPosition(options.operator_position);

    // For testing of beautify ignore:start directive
    opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

    // force opt.space_after_anon_function to true if opt.jslint_happy
    if (opt.jslint_happy) {
        opt.space_after_anon_function = true;
    }

    if (options.indent_with_tabs) {
        opt.indent_char = '\t';
        opt.indent_size = 1;
    }

    if (opt.eol === 'auto') {
        opt.eol = '\n';
        if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
            opt.eol = js_source_text.match(acorn.lineBreak)[0];
        }
    }

    opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

    //----------------------------------
    indent_string = '';
    while (opt.indent_size > 0) {
        indent_string += opt.indent_char;
        opt.indent_size -= 1;
    }

    var preindent_index = 0;
    if (js_source_text && js_source_text.length) {
        while ((js_source_text.charAt(preindent_index) === ' ' ||
                js_source_text.charAt(preindent_index) === '\t')) {
            preindent_index += 1;
        }
        baseIndentString = js_source_text.substring(0, preindent_index);
        js_source_text = js_source_text.substring(preindent_index);
    }

    last_type = 'TK_START_BLOCK'; // last token type
    last_last_text = ''; // pre-last token text
    output = new Output(indent_string, baseIndentString);

    // If testing the ignore directive, start with output disable set to true
    output.raw = opt.test_output_raw;


    // Stack of parsing/formatting states, including MODE.
    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
    // and formatted output.  This makes the beautifier less accurate than full parsers
    // but also far more tolerant of syntax errors.
    //
    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
    // most full parsers would die, but the beautifier gracefully falls back to
    // MODE.BlockStatement and continues on.
    flag_store = [];
    set_mode(MODE.BlockStatement);

    this.beautify = function() {

        /*jshint onevar:true */
        var sweet_code;
        tokenizer = new Tokenizer(js_source_text, opt, indent_string);
        tokens = tokenizer.tokenize();
        token_pos = 0;

        current_token = get_token();
        while (current_token) {
            handlers[current_token.type]();

            last_last_text = flags.last_text;
            last_type = current_token.type;
            flags.last_text = current_token.text;

            token_pos += 1;
            current_token = get_token();
        }

        sweet_code = output.get_code(opt.end_with_newline, opt.eol);

        return sweet_code;
    };

    function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
        var newlines = local_token.newlines;
        var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
        var temp_token = current_token;

        for (var h = 0; h < local_token.comments_before.length; h++) {
            // The cleanest handling of inline comments is to treat them as though they aren't there.
            // Just continue formatting and the behavior should be logical.
            // Also ignore unknown tokens.  Again, this should result in better behavior.
            current_token = local_token.comments_before[h];
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
            handlers[current_token.type](preserve_statement_flags);
        }
        current_token = temp_token;

        if (keep_whitespace) {
            for (var i = 0; i < newlines; i += 1) {
                print_newline(i > 0, preserve_statement_flags);
            }
        } else {
            if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
                newlines = opt.max_preserve_newlines;
            }

            if (opt.preserve_newlines) {
                if (local_token.newlines > 1) {
                    print_newline(false, preserve_statement_flags);
                    for (var j = 1; j < newlines; j += 1) {
                        print_newline(true, preserve_statement_flags);
                    }
                }
            }
        }

    }

    // we could use just string.split, but
    // IE doesn't like returning empty strings
    function split_linebreaks(s) {
        //return s.split(/\x0d\x0a|\x0a/);

        s = s.replace(acorn.allLineBreaks, '\n');
        var out = [],
            idx = s.indexOf("\n");
        while (idx !== -1) {
            out.push(s.substring(0, idx));
            s = s.substring(idx + 1);
            idx = s.indexOf("\n");
        }
        if (s.length) {
            out.push(s);
        }
        return out;
    }

    var newline_restricted_tokens = ['break', 'continue', 'return', 'throw', 'yield'];

    function allow_wrap_or_preserved_newline(force_linewrap) {
        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

        // Never wrap the first token on a line
        if (output.just_added_newline()) {
            return;
        }

        var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
        var operatorLogicApplies = in_array(flags.last_text, tokenizer.positionable_operators) || in_array(current_token.text, tokenizer.positionable_operators);

        if (operatorLogicApplies) {
            var shouldPrintOperatorNewline = (
                    in_array(flags.last_text, tokenizer.positionable_operators) &&
                    in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
                ) ||
                in_array(current_token.text, tokenizer.positionable_operators);
            shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }

        if (shouldPreserveOrForce) {
            print_newline(false, true);
        } else if (opt.wrap_line_length) {
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
                // These tokens should never have a newline inserted
                // between them and the following expression.
                return;
            }
            var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
                (output.space_before_token ? 1 : 0);
            if (proposed_line_length >= opt.wrap_line_length) {
                print_newline(false, true);
            }
        }
    }

    function print_newline(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                var next_token = get_token(1);
                while (flags.mode === MODE.Statement &&
                    !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
                    !flags.do_block) {
                    restore_mode();
                }
            }
        }

        if (output.add_new_line(force_newline)) {
            flags.multiline_frame = true;
        }
    }

    function print_token_line_indentation() {
        if (output.just_added_newline()) {
            if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
                output.current_line.push(current_token.whitespace_before);
                output.space_before_token = false;
            } else if (output.set_indent(flags.indentation_level)) {
                flags.line_indent_level = flags.indentation_level;
            }
        }
    }

    function print_token(printable_token) {
        if (output.raw) {
            output.add_raw_token(current_token);
            return;
        }

        if (opt.comma_first && last_type === 'TK_COMMA' &&
            output.just_added_newline()) {
            if (output.previous_line.last() === ',') {
                var popped = output.previous_line.pop();
                // if the comma was already at the start of the line,
                // pull back onto that line and reprint the indentation
                if (output.previous_line.is_empty()) {
                    output.previous_line.push(popped);
                    output.trim(true);
                    output.current_line.pop();
                    output.trim();
                }

                // add the comma in front of the next token
                print_token_line_indentation();
                output.add_token(',');
                output.space_before_token = true;
            }
        }

        printable_token = printable_token || current_token.text;
        print_token_line_indentation();
        output.add_token(printable_token);
    }

    function indent() {
        flags.indentation_level += 1;
    }

    function deindent() {
        if (flags.indentation_level > 0 &&
            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
            flags.indentation_level -= 1;

        }
    }

    function set_mode(mode) {
        if (flags) {
            flag_store.push(flags);
            previous_flags = flags;
        } else {
            previous_flags = create_flags(null, mode);
        }

        flags = create_flags(previous_flags, mode);
    }

    function is_array(mode) {
        return mode === MODE.ArrayLiteral;
    }

    function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
    }

    function restore_mode() {
        if (flag_store.length > 0) {
            previous_flags = flags;
            flags = flag_store.pop();
            if (previous_flags.mode === MODE.Statement && !opt.unindent_chained_methods) {
                remove_redundant_indentation(output, previous_flags);
            }
        }
    }

    function start_of_object_property() {
        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
            (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
    }

    function start_of_statement() {
        if (
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens) && !current_token.wanted_newline) ||
            (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
                !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
            (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
            (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
                !flags.in_case &&
                !(current_token.text === '--' || current_token.text === '++') &&
                last_last_text !== 'function' &&
                current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
            (flags.mode === MODE.ObjectLiteral && (
                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
        ) {

            set_mode(MODE.Statement);
            if (!opt.unindent_chained_methods) {
                indent();
            }

            handle_whitespace_and_comments(current_token, true);

            // Issue #276:
            // If starting a new statement with [if, for, while, do], push to a new line.
            // if (a) if (b) if(c) d(); else e(); else f();
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline(
                    current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
            }

            return true;
        }
        return false;
    }

    function all_lines_start_with(lines, c) {
        for (var i = 0; i < lines.length; i++) {
            var line = trim(lines[i]);
            if (line.charAt(0) !== c) {
                return false;
            }
        }
        return true;
    }

    function each_line_matches_indent(lines, indent) {
        var i = 0,
            len = lines.length,
            line;
        for (; i < len; i++) {
            line = lines[i];
            // allow empty lines to pass through
            if (line && line.indexOf(indent) !== 0) {
                return false;
            }
        }
        return true;
    }

    function is_special_word(word) {
        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
    }

    function get_token(offset) {
        var index = token_pos + (offset || 0);
        return (index < 0 || index >= tokens.length) ? null : tokens[index];
    }

    function handle_start_expr() {
        // The conditional starts the statement if appropriate.
        if (!start_of_statement()) {
            handle_whitespace_and_comments(current_token);
        }

        var next_mode = MODE.Expression;
        if (current_token.text === '[') {

            if (last_type === 'TK_WORD' || flags.last_text === ')') {
                // this is array index specifier, break immediately
                // a[x], fn()[x]
                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, tokenizer.line_starters)) {
                    output.space_before_token = true;
                }
                set_mode(next_mode);
                print_token();
                indent();
                if (opt.space_in_paren) {
                    output.space_before_token = true;
                }
                return;
            }

            next_mode = MODE.ArrayLiteral;
            if (is_array(flags.mode)) {
                if (flags.last_text === '[' ||
                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                    // ], [ goes to new line
                    // }, [ goes to new line
                    if (!opt.keep_array_indentation) {
                        print_newline();
                    }
                }
            }

        } else {
            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                next_mode = MODE.ForInitializer;
            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                next_mode = MODE.Conditional;
            } else {
                // next_mode = MODE.Expression;
            }
        }

        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
            print_newline();
        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
            allow_wrap_or_preserved_newline(current_token.wanted_newline);
            // do nothing on (( and )( and ][ and ]( and .(
        } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
            output.space_before_token = true;
        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            // function() vs function ()
            // yield*() vs yield* ()
            // function*() vs function* ()
            if (opt.space_after_anon_function) {
                output.space_before_token = true;
            }
        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, tokenizer.line_starters) || flags.last_text === 'catch')) {
            if (opt.space_before_conditional) {
                output.space_before_token = true;
            }
        }

        // Should be a space between await and an IIFE, or async and an arrow function
        if (current_token.text === '(' && last_type === 'TK_RESERVED' && in_array(flags.last_word, ['await', 'async'])) {
            output.space_before_token = true;
        }

        // Support of this kind of newline preservation.
        // a = (b &&
        //     (c || d));
        if (current_token.text === '(') {
            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }
        }

        // Support preserving wrapped arrow function expressions
        // a.b('c',
        //     () => d.e
        // )
        if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
            allow_wrap_or_preserved_newline();
        }

        set_mode(next_mode);
        print_token();
        if (opt.space_in_paren) {
            output.space_before_token = true;
        }

        // In all cases, if we newline while inside an expression it should be indented.
        indent();
    }

    function handle_end_expr() {
        // statements inside expressions are not valid syntax, but...
        // statements must all be closed when their container closes
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        handle_whitespace_and_comments(current_token);

        if (flags.multiline_frame) {
            allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
        }

        if (opt.space_in_paren) {
            if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
                // () [] no inner space in empty parens like these, ever, ref #320
                output.trim();
                output.space_before_token = false;
            } else {
                output.space_before_token = true;
            }
        }
        if (current_token.text === ']' && opt.keep_array_indentation) {
            print_token();
            restore_mode();
        } else {
            restore_mode();
            print_token();
        }
        remove_redundant_indentation(output, previous_flags);

        // do {} while () // no statement required after
        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
            previous_flags.mode = MODE.Expression;
            flags.do_block = false;
            flags.do_while = false;

        }
    }

    function handle_start_block() {
        handle_whitespace_and_comments(current_token);

        // Check if this is should be treated as a ObjectLiteral
        var next_token = get_token(1);
        var second_token = get_token(2);
        if (second_token && (
                (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
                (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
            )) {
            // We don't support TypeScript,but we didn't break it for a very long time.
            // We'll try to keep not breaking it.
            if (!in_array(last_last_text, ['class', 'interface'])) {
                set_mode(MODE.ObjectLiteral);
            } else {
                set_mode(MODE.BlockStatement);
            }
        } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
            // arrow function: (param1, paramN) => { statements }
            set_mode(MODE.BlockStatement);
        } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
            (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
        ) {
            // Detecting shorthand function syntax is difficult by scanning forward,
            //     so check the surrounding context.
            // If the block is being returned, imported, export default, passed as arg,
            //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
            set_mode(MODE.ObjectLiteral);
        } else {
            set_mode(MODE.BlockStatement);
        }

        var empty_braces = !next_token.comments_before.length && next_token.text === '}';
        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
            last_type === 'TK_END_EXPR';

        if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
        {
            // search forward for a newline wanted inside this block
            var index = 0;
            var check_token = null;
            flags.inline_frame = true;
            do {
                index += 1;
                check_token = get_token(index);
                if (check_token.wanted_newline) {
                    flags.inline_frame = false;
                    break;
                }
            } while (check_token.type !== 'TK_EOF' &&
                !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
        }

        if ((opt.brace_style === "expand" ||
                (opt.brace_style === "none" && current_token.wanted_newline)) &&
            !flags.inline_frame) {
            if (last_type !== 'TK_OPERATOR' &&
                (empty_anonymous_function ||
                    last_type === 'TK_EQUALS' ||
                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                output.space_before_token = true;
            } else {
                print_newline(false, true);
            }
        } else { // collapse || inline_frame
            if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
                if (last_type === 'TK_COMMA' || opt.space_in_paren) {
                    output.space_before_token = true;
                }

                if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
                    allow_wrap_or_preserved_newline();
                    previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
                    flags.multiline_frame = false;
                }
            }
            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
                    print_newline();
                } else {
                    output.space_before_token = true;
                }
            }
        }
        print_token();
        indent();
    }

    function handle_end_block() {
        // statements must all be closed when their container closes
        handle_whitespace_and_comments(current_token);

        while (flags.mode === MODE.Statement) {
            restore_mode();
        }

        var empty_braces = last_type === 'TK_START_BLOCK';

        if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
            output.space_before_token = true;
        } else if (opt.brace_style === "expand") {
            if (!empty_braces) {
                print_newline();
            }
        } else {
            // skip {}
            if (!empty_braces) {
                if (is_array(flags.mode) && opt.keep_array_indentation) {
                    // we REALLY need a newline here, but newliner would skip that
                    opt.keep_array_indentation = false;
                    print_newline();
                    opt.keep_array_indentation = true;

                } else {
                    print_newline();
                }
            }
        }
        restore_mode();
        print_token();
    }

    function handle_word() {
        if (current_token.type === 'TK_RESERVED') {
            if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
                current_token.type = 'TK_WORD';
            } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
                current_token.type = 'TK_WORD';
            } else if (flags.mode === MODE.ObjectLiteral) {
                var next_token = get_token(1);
                if (next_token.text === ':') {
                    current_token.type = 'TK_WORD';
                }
            }
        }

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
                flags.declaration_statement = true;
            }
        } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
            last_type !== 'TK_EQUALS' &&
            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
            handle_whitespace_and_comments(current_token);
            print_newline();
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.do_block && !flags.do_while) {
            if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
                // do {} ## while ()
                output.space_before_token = true;
                print_token();
                output.space_before_token = true;
                flags.do_while = true;
                return;
            } else {
                // do {} should always have while as the next word.
                // if we don't see the expected while, recover
                print_newline();
                flags.do_block = false;
            }
        }

        // if may be followed by else, or not
        // Bare/inline ifs are tricky
        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
        if (flags.if_block) {
            if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
                flags.else_block = true;
            } else {
                while (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                flags.if_block = false;
                flags.else_block = false;
            }
        }

        if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
            print_newline();
            if (flags.case_body || opt.jslint_happy) {
                // switch cases following one another
                deindent();
                flags.case_body = false;
            }
            print_token();
            flags.in_case = true;
            flags.in_case_statement = true;
            return;
        }

        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
                allow_wrap_or_preserved_newline();
            }
        }

        if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
            if (in_array(flags.last_text, ['}', ';']) ||
                (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
                // make sure there is a nice clean space of at least one blank line
                // before a new function definition
                if (!output.just_added_blankline() && !current_token.comments_before.length) {
                    print_newline();
                    print_newline(true);
                }
            }
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                if (last_type === 'TK_RESERVED' && (
                        in_array(flags.last_text, ['get', 'set', 'new', 'export', 'async']) ||
                        in_array(flags.last_text, newline_restricted_tokens))) {
                    output.space_before_token = true;
                } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
                    output.space_before_token = true;
                } else {
                    print_newline();
                }
            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                // foo = function
                output.space_before_token = true;
            } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
                // (function
            } else {
                print_newline();
            }

            print_token();
            flags.last_word = current_token.text;
            return;
        }

        prefix = 'NONE';

        if (last_type === 'TK_END_BLOCK') {

            if (previous_flags.inline_frame) {
                prefix = 'SPACE';
            } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
                prefix = 'NEWLINE';
            } else {
                if (opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) {
                    prefix = 'NEWLINE';
                } else {
                    prefix = 'SPACE';
                    output.space_before_token = true;
                }
            }
        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
            // TODO: Should this be for STATEMENT as well?
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_STRING') {
            prefix = 'NEWLINE';
        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
            (flags.last_text === '*' &&
                (in_array(last_last_text, ['function', 'yield']) ||
                    (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
            prefix = 'SPACE';
        } else if (last_type === 'TK_START_BLOCK') {
            if (flags.inline_frame) {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }
        } else if (last_type === 'TK_END_EXPR') {
            output.space_before_token = true;
            prefix = 'NEWLINE';
        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
            if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
                prefix = 'SPACE';
            } else {
                prefix = 'NEWLINE';
            }

        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
            if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
                    opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) &&
                !flags.inline_frame) {
                print_newline();
            } else {
                output.trim(true);
                var line = output.current_line;
                // If we trimmed and there's something other than a close block before us
                // put a newline back in.  Handles '} // comment' scenario.
                if (line.last() !== '}') {
                    print_newline();
                }
                output.space_before_token = true;
            }
        } else if (prefix === 'NEWLINE') {
            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // no newline between 'return nnn'
                output.space_before_token = true;
            } else if (last_type !== 'TK_END_EXPR') {
                if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                    // no need to force newline on 'var': for (var x = 0...)
                    if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                        // no newline for } else if {
                        output.space_before_token = true;
                    } else {
                        print_newline();
                    }
                }
            } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, tokenizer.line_starters) && flags.last_text !== ')') {
                print_newline();
            }
        } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
            print_newline(); // }, in lists get a newline treatment
        } else if (prefix === 'SPACE') {
            output.space_before_token = true;
        }
        print_token();
        flags.last_word = current_token.text;

        if (current_token.type === 'TK_RESERVED') {
            if (current_token.text === 'do') {
                flags.do_block = true;
            } else if (current_token.text === 'if') {
                flags.if_block = true;
            } else if (current_token.text === 'import') {
                flags.import_block = true;
            } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
                flags.import_block = false;
            }
        }
    }

    function handle_semicolon() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // Semicolon can be the start (and end) of a statement
            output.space_before_token = false;
        } else {
            handle_whitespace_and_comments(current_token);
        }

        var next_token = get_token(1);
        while (flags.mode === MODE.Statement &&
            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
            !flags.do_block) {
            restore_mode();
        }

        // hacky but effective for the moment
        if (flags.import_block) {
            flags.import_block = false;
        }
        print_token();
    }

    function handle_string() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
            // One difference - strings want at least a space before
            output.space_before_token = true;
        } else {
            handle_whitespace_and_comments(current_token);
            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
                output.space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
        }
        print_token();
    }

    function handle_equals() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token);
        }

        if (flags.declaration_statement) {
            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
            flags.declaration_assignment = true;
        }
        output.space_before_token = true;
        print_token();
        output.space_before_token = true;
    }

    function handle_comma() {
        handle_whitespace_and_comments(current_token, true);

        print_token();
        output.space_before_token = true;
        if (flags.declaration_statement) {
            if (is_expression(flags.parent.mode)) {
                // do not break on comma, for(var a = 1, b = 2)
                flags.declaration_assignment = false;
            }

            if (flags.declaration_assignment) {
                flags.declaration_assignment = false;
                print_newline(false, true);
            } else if (opt.comma_first) {
                // for comma-first, we want to allow a newline before the comma
                // to turn into a newline after the comma, which we will fixup later
                allow_wrap_or_preserved_newline();
            }
        } else if (flags.mode === MODE.ObjectLiteral ||
            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
            if (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (!flags.inline_frame) {
                print_newline();
            }
        } else if (opt.comma_first) {
            // EXPR or DO_BLOCK
            // for comma-first, we want to allow a newline before the comma
            // to turn into a newline after the comma, which we will fixup later
            allow_wrap_or_preserved_newline();
        }
    }

    function handle_operator() {
        var isGeneratorAsterisk = current_token.text === '*' &&
            ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
                (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
            );
        var isUnary = in_array(current_token.text, ['-', '+']) && (
            in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
            in_array(flags.last_text, tokenizer.line_starters) ||
            flags.last_text === ','
        );

        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            var preserve_statement_flags = !isGeneratorAsterisk;
            handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            // "return" had a special handling in TK_WORD. Now we need to return the favor
            output.space_before_token = true;
            print_token();
            return;
        }

        // hack for actionscript's import .*;
        if (current_token.text === '*' && last_type === 'TK_DOT') {
            print_token();
            return;
        }

        if (current_token.text === '::') {
            // no spaces around exotic namespacing syntax operator
            print_token();
            return;
        }

        // Allow line wrapping between operators when operator_position is
        //   set to before or preserve
        if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
            allow_wrap_or_preserved_newline();
        }

        if (current_token.text === ':' && flags.in_case) {
            flags.case_body = true;
            indent();
            print_token();
            print_newline();
            flags.in_case = false;
            return;
        }

        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ':') {
            if (flags.ternary_depth === 0) {
                // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                space_before = false;
            } else {
                flags.ternary_depth -= 1;
                in_ternary = true;
            }
        } else if (current_token.text === '?') {
            flags.ternary_depth += 1;
        }

        // let's handle the operator_position option prior to any conflicting logic
        if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, tokenizer.positionable_operators)) {
            var isColon = current_token.text === ':';
            var isTernaryColon = (isColon && in_ternary);
            var isOtherColon = (isColon && !in_ternary);

            switch (opt.operator_position) {
                case OPERATOR_POSITION.before_newline:
                    // if the current token is : and it's not a ternary statement then we set space_before to false
                    output.space_before_token = !isOtherColon;

                    print_token();

                    if (!isColon || isTernaryColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.after_newline:
                    // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
                    //   then print a newline.

                    output.space_before_token = true;

                    if (!isColon || isTernaryColon) {
                        if (get_token(1).wanted_newline) {
                            print_newline(false, true);
                        } else {
                            allow_wrap_or_preserved_newline();
                        }
                    } else {
                        output.space_before_token = false;
                    }

                    print_token();

                    output.space_before_token = true;
                    return;

                case OPERATOR_POSITION.preserve_newline:
                    if (!isOtherColon) {
                        allow_wrap_or_preserved_newline();
                    }

                    // if we just added a newline, or the current token is : and it's not a ternary statement,
                    //   then we set space_before to false
                    space_before = !(output.just_added_newline() || isOtherColon);

                    output.space_before_token = space_before;
                    print_token();
                    output.space_before_token = true;
                    return;
            }
        }

        if (isGeneratorAsterisk) {
            allow_wrap_or_preserved_newline();
            space_before = false;
            var next_token = get_token(1);
            space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
        } else if (current_token.text === '...') {
            allow_wrap_or_preserved_newline();
            space_before = last_type === 'TK_START_BLOCK';
            space_after = false;
        } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
            // unary operators (and binary +/- pretending to be unary) special cases

            space_before = false;
            space_after = false;

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
                print_newline(false, true);
            }

            if (flags.last_text === ';' && is_expression(flags.mode)) {
                // for (;; ++i)
                //        ^^^
                space_before = true;
            }

            if (last_type === 'TK_RESERVED') {
                space_before = true;
            } else if (last_type === 'TK_END_EXPR') {
                space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
            } else if (last_type === 'TK_OPERATOR') {
                // a++ + ++b;
                // a - -b
                space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
                // + and - are not unary when preceeded by -- or ++ operator
                // a-- + b
                // a * +b
                // a - -b
                if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
                    space_after = true;
                }
            }


            if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
                (flags.last_text === '{' || flags.last_text === ';')) {
                // { foo; --i }
                // foo(); --bar;
                print_newline();
            }
        }

        output.space_before_token = output.space_before_token || space_before;
        print_token();
        output.space_before_token = space_after;
    }

    function handle_block_comment(preserve_statement_flags) {
        if (output.raw) {
            output.add_raw_token(current_token);
            if (current_token.directives && current_token.directives.preserve === 'end') {
                // If we're testing the raw output behavior, do not allow a directive to turn it off.
                output.raw = opt.test_output_raw;
            }
            return;
        }

        if (current_token.directives) {
            print_newline(false, preserve_statement_flags);
            print_token();
            if (current_token.directives.preserve === 'start') {
                output.raw = true;
            }
            print_newline(false, true);
            return;
        }

        // inline block
        if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
            return;
        }

        var lines = split_linebreaks(current_token.text);
        var j; // iterator for this case
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;

        // block comment starts with a new line
        print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
            javadoc = all_lines_start_with(lines.slice(1), '*');
            starless = each_line_matches_indent(lines.slice(1), lastIndent);
        }

        // first line always indented
        print_token(lines[0]);
        for (j = 1; j < lines.length; j++) {
            print_newline(false, true);
            if (javadoc) {
                // javadoc: reformat and re-indent
                print_token(' ' + ltrim(lines[j]));
            } else if (starless && lines[j].length > lastIndentLength) {
                // starless: re-indent non-empty content, avoiding trim
                print_token(lines[j].substring(lastIndentLength));
            } else {
                // normal comments output raw
                output.add_token(lines[j]);
            }
        }

        // for comments of more than one line, make sure there's a new line after
        print_newline(false, preserve_statement_flags);
    }

    function handle_comment(preserve_statement_flags) {
        if (current_token.wanted_newline) {
            print_newline(false, preserve_statement_flags);
        } else {
            output.trim(true);
        }

        output.space_before_token = true;
        print_token();
        print_newline(false, preserve_statement_flags);
    }

    function handle_dot() {
        if (start_of_statement()) {
            // The conditional starts the statement if appropriate.
        } else {
            handle_whitespace_and_comments(current_token, true);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            output.space_before_token = true;
        } else {
            // allow preserved newlines before dots in general
            // force newlines on dots after close paren when break_chained - for bar().baz()
            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
        }

        print_token();
    }

    function handle_unknown(preserve_statement_flags) {
        print_token();

        if (current_token.text[current_token.text.length - 1] === '\n') {
            print_newline(false, preserve_statement_flags);
        }
    }

    function handle_eof() {
        // Unwind any open statements
        while (flags.mode === MODE.Statement) {
            restore_mode();
        }
        handle_whitespace_and_comments(current_token);
    }
}

module.exports.Beautifier = Beautifier;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function InputScanner(input) {
    var _input = input;
    var _input_length = _input.length;
    var _position = 0;

    this.back = function() {
        _position -= 1;
    };

    this.hasNext = function() {
        return _position < _input_length;
    };

    this.next = function() {
        var val = null;
        if (this.hasNext()) {
            val = _input.charAt(_position);
            _position += 1;
        }
        return val;
    };

    this.peek = function(index) {
        var val = null;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charAt(index);
        }
        return val;
    };

    this.peekCharCode = function(index) {
        var val = 0;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
            val = _input.charCodeAt(index);
        }
        return val;
    };

    this.test = function(pattern, index) {
        index = index || 0;
        pattern.lastIndex = _position + index;
        return pattern.test(_input);
    };

    this.testChar = function(pattern, index) {
        var val = this.peek(index);
        return val !== null && pattern.test(val);
    };

    this.match = function(pattern) {
        pattern.lastIndex = _position;
        var pattern_match = pattern.exec(_input);
        if (pattern_match && pattern_match.index === _position) {
            _position += pattern_match[0].length;
        } else {
            pattern_match = null;
        }
        return pattern_match;
    };
}


module.exports.InputScanner = InputScanner;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
        if (name !== targetType) {
            finalOpts[name] = allOptions[name];
        }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
        for (name in allOptions[targetType]) {
            finalOpts[name] = allOptions[targetType][name];
        }
    }
    return finalOpts;
}

module.exports.mergeOpts = mergeOpts;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function OutputLine(parent) {
    var _character_count = 0;
    // use indent_count as a marker for lines that have preserved indentation
    var _indent_count = -1;

    var _items = [];
    var _empty = true;

    this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
    };

    this.get_character_count = function() {
        return _character_count;
    };

    this.is_empty = function() {
        return _empty;
    };

    this.last = function() {
        if (!this._empty) {
            return _items[_items.length - 1];
        } else {
            return null;
        }
    };

    this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
    };

    this.pop = function() {
        var item = null;
        if (!_empty) {
            item = _items.pop();
            _character_count -= item.length;
            _empty = _items.length === 0;
        }
        return item;
    };

    this.remove_indent = function() {
        if (_indent_count > 0) {
            _indent_count -= 1;
            _character_count -= parent.indent_length;
        }
    };

    this.trim = function() {
        while (this.last() === ' ') {
            _items.pop();
            _character_count -= 1;
        }
        _empty = _items.length === 0;
    };

    this.toString = function() {
        var result = '';
        if (!this._empty) {
            if (_indent_count >= 0) {
                result = parent.indent_cache[_indent_count];
            }
            result += _items.join('');
        }
        return result;
    };
}

function Output(indent_string, baseIndentString) {
    baseIndentString = baseIndentString || '';
    this.indent_cache = [baseIndentString];
    this.baseIndentLength = baseIndentString.length;
    this.indent_length = indent_string.length;
    this.raw = false;

    var lines = [];
    this.baseIndentString = baseIndentString;
    this.indent_string = indent_string;
    this.previous_line = null;
    this.current_line = null;
    this.space_before_token = false;

    this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
    };

    // initialize
    this.add_outputline();


    this.get_line_number = function() {
        return lines.length;
    };

    // Using object instead of string to allow for later expansion of info about each line
    this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
            return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
            if (!this.raw) {
                this.add_outputline();
            }
            return true;
        }

        return false;
    };

    this.get_code = function(end_with_newline, eol) {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');

        if (end_with_newline) {
            sweet_code += '\n';
        }

        if (eol !== '\n') {
            sweet_code = sweet_code.replace(/[\n]/g, eol);
        }

        return sweet_code;
    };

    this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
            while (level >= this.indent_cache.length) {
                this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
            }

            this.current_line.set_indent(level);
            return true;
        }
        this.current_line.set_indent(0);
        return false;
    };

    this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
            this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
    };

    this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
    };

    this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
            this.current_line.push(' ');
        }
        this.space_before_token = false;
    };

    this.remove_indent = function(index) {
        var output_length = lines.length;
        while (index < output_length) {
            lines[index].remove_indent();
            index++;
        }
    };

    this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
            this.current_line.is_empty()) {
            lines.pop();
            this.current_line = lines[lines.length - 1];
            this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
    };

    this.just_added_newline = function() {
        return this.current_line.is_empty();
    };

    this.just_added_blankline = function() {
        if (this.just_added_newline()) {
            if (lines.length === 1) {
                return true; // start of the file and newline = blank
            }

            var line = lines[lines.length - 2];
            return line.is_empty();
        }
        return false;
    };
}

module.exports.Output = Output;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

function Token(type, text, newlines, whitespace_before, parent) {
    this.type = type;
    this.text = text;

    // comments_before are
    // comments that have a new line before them
    // and may or may not have a newline after
    // this is a set of comments before
    this.comments_before = /* inline comment*/ [];


    this.comments_after = []; // no new line before and newline after
    this.newlines = newlines || 0;
    this.wanted_newline = newlines > 0;
    this.whitespace_before = whitespace_before || '';
    this.parent = parent || null;
    this.opened = null;
    this.directives = null;
}

module.exports.Token = Token;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var Beautifier = __webpack_require__(1).Beautifier;

function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
}

module.exports = js_beautify;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

    The MIT License (MIT)

    Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var InputScanner = __webpack_require__(2).InputScanner;
var Token = __webpack_require__(5).Token;
var acorn = __webpack_require__(0);

function trim(s) {
    return s.replace(/^\s+|\s+$/g, '');
}

function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
            return true;
        }
    }
    return false;
}

function Tokenizer(input_string, opts) {

    var whitespace = "\n\r\t ".split('');
    var digit = /[0-9]/;
    var digit_bin = /[01]/;
    var digit_oct = /[01234567]/;
    var digit_hex = /[0123456789abcdefABCDEF]/;

    this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
    var punct = this.positionable_operators.concat(
        // non-positionable operators - these do not follow operator position settings
        '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

    // words which should always start on new line.
    this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
    var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

    //  /* ... */ comment ends with nearest */ or end of file
    var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

    // comment ends just before nearest linefeed or end of file
    var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

    var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
    var directive_pattern = / (\w+)[:](\w+)/g;
    var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

    var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

    var n_newlines, whitespace_before_token, in_html_comment, tokens;
    var input;

    this.tokenize = function() {
        input = new InputScanner(input_string);
        in_html_comment = false;
        tokens = [];

        var next, last;
        var token_values;
        var open = null;
        var open_stack = [];
        var comments = [];

        while (!(last && last.type === 'TK_EOF')) {
            token_values = tokenize_next();
            next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
                if (next.type === 'TK_BLOCK_COMMENT') {
                    next.directives = token_values[2];
                }
                comments.push(next);
                token_values = tokenize_next();
                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
            }

            if (comments.length) {
                next.comments_before = comments;
                comments = [];
            }

            if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
                next.parent = last;
                open_stack.push(open);
                open = next;
            } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
                (open && (
                    (next.text === ']' && open.text === '[') ||
                    (next.text === ')' && open.text === '(') ||
                    (next.text === '}' && open.text === '{')))) {
                next.parent = open.parent;
                next.opened = open;

                open = open_stack.pop();
            }

            tokens.push(next);
            last = next;
        }

        return tokens;
    };

    function get_directives(text) {
        if (!text.match(directives_block_pattern)) {
            return null;
        }

        var directives = {};
        directive_pattern.lastIndex = 0;
        var directive_match = directive_pattern.exec(text);

        while (directive_match) {
            directives[directive_match[1]] = directive_match[2];
            directive_match = directive_pattern.exec(text);
        }

        return directives;
    }

    function tokenize_next() {
        var resulting_string;
        var whitespace_on_this_line = [];

        n_newlines = 0;
        whitespace_before_token = '';

        var c = input.next();

        if (c === null) {
            return ['', 'TK_EOF'];
        }

        var last_token;
        if (tokens.length) {
            last_token = tokens[tokens.length - 1];
        } else {
            // For the sake of tokenizing we can pretend that there was on open brace to start
            last_token = new Token('TK_START_BLOCK', '{');
        }

        while (in_array(c, whitespace)) {

            if (acorn.newline.test(c)) {
                if (!(c === '\n' && input.peek(-2) === '\r')) {
                    n_newlines += 1;
                    whitespace_on_this_line = [];
                }
            } else {
                whitespace_on_this_line.push(c);
            }

            c = input.next();

            if (c === null) {
                return ['', 'TK_EOF'];
            }
        }

        if (whitespace_on_this_line.length) {
            whitespace_before_token = whitespace_on_this_line.join('');
        }

        if (digit.test(c) || (c === '.' && input.testChar(digit))) {
            var allow_decimal = true;
            var allow_e = true;
            var local_digit = digit;

            if (c === '0' && input.testChar(/[XxOoBb]/)) {
                // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
                allow_decimal = false;
                allow_e = false;
                if (input.testChar(/[Bb]/)) {
                    local_digit = digit_bin;
                } else if (input.testChar(/[Oo]/)) {
                    local_digit = digit_oct;
                } else {
                    local_digit = digit_hex;
                }
                c += input.next();
            } else if (c === '.') {
                // Already have a decimal for this literal, don't allow another
                allow_decimal = false;
            } else {
                // we know this first loop will run.  It keeps the logic simpler.
                c = '';
                input.back();
            }

            // Add the digits
            while (input.testChar(local_digit)) {
                c += input.next();

                if (allow_decimal && input.peek() === '.') {
                    c += input.next();
                    allow_decimal = false;
                }

                // a = 1.e-7 is valid, so we test for . then e in one loop
                if (allow_e && input.testChar(/[Ee]/)) {
                    c += input.next();

                    if (input.testChar(/[+-]/)) {
                        c += input.next();
                    }

                    allow_e = false;
                    allow_decimal = false;
                }
            }

            return [c, 'TK_WORD'];
        }

        if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
            if (input.hasNext()) {
                while (acorn.isIdentifierChar(input.peekCharCode())) {
                    c += input.next();
                    if (!input.hasNext()) {
                        break;
                    }
                }
            }

            if (!(last_token.type === 'TK_DOT' ||
                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
                in_array(c, reserved_words)) {
                if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
                    return [c, 'TK_OPERATOR'];
                }
                return [c, 'TK_RESERVED'];
            }

            return [c, 'TK_WORD'];
        }

        if (c === '(' || c === '[') {
            return [c, 'TK_START_EXPR'];
        }

        if (c === ')' || c === ']') {
            return [c, 'TK_END_EXPR'];
        }

        if (c === '{') {
            return [c, 'TK_START_BLOCK'];
        }

        if (c === '}') {
            return [c, 'TK_END_BLOCK'];
        }

        if (c === ';') {
            return [c, 'TK_SEMICOLON'];
        }

        if (c === '/') {
            var comment = '';
            var comment_match;
            // peek for comment /* ... */
            if (input.peek() === '*') {
                input.next();
                comment_match = input.match(block_comment_pattern);
                comment = '/*' + comment_match[0];
                var directives = get_directives(comment);
                if (directives && directives.ignore === 'start') {
                    comment_match = input.match(directives_end_ignore_pattern);
                    comment += comment_match[0];
                }
                comment = comment.replace(acorn.allLineBreaks, '\n');
                return [comment, 'TK_BLOCK_COMMENT', directives];
            }
            // peek for comment // ...
            if (input.peek() === '/') {
                input.next();
                comment_match = input.match(comment_pattern);
                comment = '//' + comment_match[0];
                return [comment, 'TK_COMMENT'];
            }

        }

        var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

        if (c === '`' || c === "'" || c === '"' || // string
            (
                (c === '/') || // regexp
                (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
            ) && ( // regex and xml can only appear in specific locations during parsing
                (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
                (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
                    last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
                (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                ]))
            )) {

            var sep = c,
                esc = false,
                has_char_escapes = false;

            resulting_string = c;

            if (sep === '/') {
                //
                // handle regexp
                //
                var in_char_class = false;
                while (input.hasNext() &&
                    ((esc || in_char_class || input.peek() !== sep) &&
                        !input.testChar(acorn.newline))) {
                    resulting_string += input.peek();
                    if (!esc) {
                        esc = input.peek() === '\\';
                        if (input.peek() === '[') {
                            in_char_class = true;
                        } else if (input.peek() === ']') {
                            in_char_class = false;
                        }
                    } else {
                        esc = false;
                    }
                    input.next();
                }
            } else if (opts.e4x && sep === '<') {
                //
                // handle e4x xml literals
                //

                var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
                input.back();
                var xmlStr = '';
                var match = input.match(startXmlRegExp);
                if (match) {
                    // Trim root tag to attempt to
                    var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
                    var isCurlyRoot = rootTag.indexOf('{') === 0;
                    var depth = 0;
                    while (match) {
                        var isEndTag = !!match[1];
                        var tagName = match[2];
                        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                        if (!isSingletonTag &&
                            (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
                            if (isEndTag) {
                                --depth;
                            } else {
                                ++depth;
                            }
                        }
                        xmlStr += match[0];
                        if (depth <= 0) {
                            break;
                        }
                        match = input.match(xmlRegExp);
                    }
                    // if we didn't close correctly, keep unformatted.
                    if (!match) {
                        xmlStr += input.match(/[\s\S]*/g)[0];
                    }
                    xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
                    return [xmlStr, "TK_STRING"];
                }
            } else {
                //
                // handle string
                //
                var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
                    // Template strings can travers lines without escape characters.
                    // Other strings cannot
                    var current_char;
                    while (input.hasNext()) {
                        current_char = input.peek();
                        if (!(esc || (current_char !== delimiter &&
                                (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
                            break;
                        }

                        // Handle \r\n linebreaks after escapes or in template strings
                        if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
                            if (current_char === '\r' && input.peek(1) === '\n') {
                                input.next();
                                current_char = input.peek();
                            }
                            resulting_string += '\n';
                        } else {
                            resulting_string += current_char;
                        }

                        if (esc) {
                            if (current_char === 'x' || current_char === 'u') {
                                has_char_escapes = true;
                            }
                            esc = false;
                        } else {
                            esc = current_char === '\\';
                        }

                        input.next();

                        if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
                            if (delimiter === '`') {
                                parse_string('}', allow_unescaped_newlines, '`');
                            } else {
                                parse_string('`', allow_unescaped_newlines, '${');
                            }

                            if (input.hasNext()) {
                                resulting_string += input.next();
                            }
                        }
                    }
                };

                if (sep === '`') {
                    parse_string('`', true, '${');
                } else {
                    parse_string(sep);
                }
            }

            if (has_char_escapes && opts.unescape_strings) {
                resulting_string = unescape_string(resulting_string);
            }

            if (input.peek() === sep) {
                resulting_string += sep;
                input.next();

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                    while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
                        resulting_string += input.next();
                    }
                }
            }
            return [resulting_string, 'TK_STRING'];
        }

        if (c === '#') {

            if (tokens.length === 0 && input.peek() === '!') {
                // shebang
                resulting_string = c;
                while (input.hasNext() && c !== '\n') {
                    c = input.next();
                    resulting_string += c;
                }
                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
            }



            // Spidermonkey-specific sharp variables for circular references
            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
            var sharp = '#';
            if (input.hasNext() && input.testChar(digit)) {
                do {
                    c = input.next();
                    sharp += c;
                } while (input.hasNext() && c !== '#' && c !== '=');
                if (c === '#') {
                    //
                } else if (input.peek() === '[' && input.peek(1) === ']') {
                    sharp += '[]';
                    input.next();
                    input.next();
                } else if (input.peek() === '{' && input.peek(1) === '}') {
                    sharp += '{}';
                    input.next();
                    input.next();
                }
                return [sharp, 'TK_WORD'];
            }
        }

        if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
            input.back();
            var template_match = input.match(template_pattern);
            if (template_match) {
                c = template_match[0];
                c = c.replace(acorn.allLineBreaks, '\n');
                return [c, 'TK_STRING'];
            }
        }

        if (c === '<' && input.match(/\!--/g)) {
            c = '<!--';
            while (input.hasNext() && !input.testChar(acorn.newline)) {
                c += input.next();
            }
            in_html_comment = true;
            return [c, 'TK_COMMENT'];
        }

        if (c === '-' && in_html_comment && input.match(/->/g)) {
            in_html_comment = false;
            return ['-->', 'TK_COMMENT'];
        }

        if (c === '.') {
            if (input.peek() === '.' && input.peek(1) === '.') {
                c += input.next() + input.next();
                return [c, 'TK_OPERATOR'];
            }
            return [c, 'TK_DOT'];
        }

        if (in_array(c, punct)) {
            while (input.hasNext() && in_array(c + input.peek(), punct)) {
                c += input.next();
                if (!input.hasNext()) {
                    break;
                }
            }

            if (c === ',') {
                return [c, 'TK_COMMA'];
            } else if (c === '=') {
                return [c, 'TK_EQUALS'];
            } else {
                return [c, 'TK_OPERATOR'];
            }
        }

        return [c, 'TK_UNKNOWN'];
    }


    function unescape_string(s) {
        // You think that a regex would work for this
        // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
        //         return String.fromCharCode(parseInt(val, 16));
        //     })
        // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
        var out = '',
            escaped = 0;

        var input_scan = new InputScanner(s);
        var matched = null;

        while (input_scan.hasNext()) {
            // Keep any whitespace, non-slash characters
            // also keep slash pairs.
            matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

            if (matched) {
                out += matched[0];
            }

            if (input_scan.peek() === '\\') {
                input_scan.next();
                if (input_scan.peek() === 'x') {
                    matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
                } else if (input_scan.peek() === 'u') {
                    matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
                } else {
                    out += '\\';
                    if (input_scan.hasNext()) {
                        out += input_scan.next();
                    }
                    continue;
                }

                // If there's some error decoding, return the original string
                if (!matched) {
                    return s;
                }

                escaped = parseInt(matched[1], 16);

                if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
                    // we bail out on \x7f..\xff,
                    // leaving whole string escaped,
                    // as it's probably completely binary
                    return s;
                } else if (escaped >= 0x00 && escaped < 0x20) {
                    // leave 0x00...0x1f escaped
                    out += '\\' + matched[0];
                    continue;
                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                    // single-quote, apostrophe, backslash - escape these
                    out += '\\' + String.fromCharCode(escaped);
                } else {
                    out += String.fromCharCode(escaped);
                }
            }
        }

        return out;
    }
}

module.exports.Tokenizer = Tokenizer;

/***/ })
/******/ ]);
var js_beautify = legacy_beautify_js;
/* Footer */
if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
        return { js_beautify: js_beautify };
    });
} else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var js_beautify = require("beautify").js_beautify`.
    exports.js_beautify = js_beautify;
} else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.js_beautify = js_beautify;
} else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.js_beautify = js_beautify;
}

}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],181:[function(require,module,exports){
//! moment.js
//! version : 2.19.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year())) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.19.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function boundary_to_dot(value) {
    return value.split('][').join('.').split('[').join('.');
}
function strip_braces(value) {
    return value.split('[').join('.').split(']').join('');
}
function escape_dots(value) {
    var val = value.split('\'');
    return (val.length < 3) ? val.join('\'') : val.map(function (seg) {
        if (seg.length < 3)
            return seg;
        if ((seg[0] === '.') || (seg[seg.length - 1] === '.'))
            return seg;
        return seg.split('.').join('&&');
    }).join('');
}
function unescape_dots(value) {
    return value.split('&&').join('.');
}
function partify(value) {
    if (!value)
        return;
    return escape_dots(strip_braces(boundary_to_dot('' + value))).split('.');
}
function canClone(o) {
    return (typeof o.__CLONE__ === 'function');
}
function clone(o) {
    if ((typeof o !== 'object') || (o === null))
        return o;
    if (Array.isArray(o))
        return o.map(clone);
    return (canClone(o)) ?
        o.__CLONE__(clone) : (o.constructor !== Object) ? o :
        Object.keys(o).reduce(function (pre, k) {
            pre[k] = (typeof o[k] === 'object') ?
                clone(o[k]) : o[k];
            return pre;
        }, {});
}
function get(path, o) {
    var parts = partify(path);
    var first;
    if (typeof o === 'object') {
        if (parts.length === 1)
            return o[unescape_dots(parts[0])];
        if (parts.length === 0)
            return;
        first = o[parts.shift()];
        return ((typeof o === 'object') && (o !== null)) ?
            parts.reduce(function (target, prop) {
                if (target == null)
                    return target;
                return target[unescape_dots(prop)];
            }, first) : null;
    }
    else {
        throw new TypeError('get(): expects an object got ' + typeof o);
    }
}
exports.get = get;
;
function set(path, value, obj) {
    var parts = partify(path);
    if ((typeof obj !== 'object') || (obj == null)) {
        return clone(obj);
    }
    else {
        return _set(obj, value, parts);
    }
}
exports.set = set;
;
function _set(obj, value, parts) {
    var o;
    var k;
    if (parts.length === 0)
        return value;
    o = ((typeof obj !== 'object') || (obj === null)) ? {} : clone(obj);
    k = unescape_dots(parts[0]);
    o[k] = _set(o[k], value, parts.slice(1));
    return o;
}
function default_1(k, v, o) {
    if (o == null)
        return get(k, v);
    else
        return set(k, v, o);
}
exports.default = default_1;
;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2J1aWxkL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvUGFnZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYXV0b2NvbXBsZXRlL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9hdXRvY29tcGxldGUvd21sL2F1dG9jb21wbGV0ZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnJlYWRjcnVtYnMvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2JyZWFkY3J1bWJzL3dtbC9icmVhZGNydW1icy5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnVzeS1pbmRpY2F0b3IvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2J1c3ktaW5kaWNhdG9yL3dtbC9idXN5LWluZGljYXRvci5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLW1lbnUvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2J1dHRvbi1tZW51L3dtbC9idXR0b24tbWVudS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvYnV0dG9uLXNlbGVjdC93bWwvYnV0dG9uLXNlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvY2hlY2tib3gvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL2NoZWNrYm94L3dtbC9jaGVja2JveC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvZGF0ZS93bWwvZGF0ZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvaG9tZS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvaG9tZS93bWwvaG9tZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbGlzdC1ncm91cC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbGlzdC1ncm91cC93bWwvbGlzdC1ncm91cC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvbWVudS93bWwvbWVudS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvcGFuZWwvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3BhbmVsL3dtbC9wYW5lbC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc2VhcmNoLXN0YWNrL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zZWFyY2gtc3RhY2svd21sL3NlYXJjaC1zdGFjay5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc2VsZWN0L2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3RhY2svaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3N0YWNrL3dtbC9zdGFjay5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvc3dpdGNoL2luZGV4LmpzIiwiZXhhbXBsZS9idWlsZC9wYWdlcy9zd2l0Y2gvd21sL3N3aXRjaC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvZGF0YS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFibGUvaW5kZXguanMiLCJleGFtcGxlL2J1aWxkL3BhZ2VzL3RhYmxlL3dtbC90YWJsZS5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFicy9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGFicy93bWwvdGFicy5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC9pbmRleC5qcyIsImV4YW1wbGUvYnVpbGQvcGFnZXMvdGV4dC1maWVsZC93bWwvdGV4dC1maWVsZC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL2FwcC5qcyIsImV4YW1wbGUvYnVpbGQvd21sL25hdmlnYXRpb24uanMiLCJsaWIvYXBwL2FjdGlvbi1iYXIvQWN0aW9uQmFyLmpzIiwibGliL2FwcC9hY3Rpb24tYmFyL3dtbC9hY3Rpb25fYmFyLmpzIiwibGliL2FwcC9idXN5LWluZGljYXRvci9CdXN5SW5kaWNhdG9yLmpzIiwibGliL2FwcC9idXN5LWluZGljYXRvci93bWwvYnVzeV9pbmRpY2F0b3IuanMiLCJsaWIvYXBwL2Rhc2gvRGFzaC5qcyIsImxpYi9hcHAvZGFzaC9pbmRleC5qcyIsImxpYi9hcHAvZGFzaC93bWwvZGFzaC5qcyIsImxpYi9jb21tb24vbmFtZXMuanMiLCJsaWIvY29tbW9uL3V0aWwuanMiLCJsaWIvY29udGVudC9Hcm91cC5qcyIsImxpYi9jb250cm9sL0NvbnRyb2wuanMiLCJsaWIvY29udHJvbC9EZWZhdWx0RGVsZWdhdGUuanMiLCJsaWIvY29udHJvbC9FdmVudC5qcyIsImxpYi9jb250cm9sL0Zvcm1Db250cm9sLmpzIiwibGliL2NvbnRyb2wvYXV0b2NvbXBsZXRlL0F1dG9jb21wbGV0ZS5qcyIsImxpYi9jb250cm9sL2F1dG9jb21wbGV0ZS9pbmRleC5qcyIsImxpYi9jb250cm9sL2F1dG9jb21wbGV0ZS93bWwvYXV0b2NvbXBsZXRlLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC9CdXR0b25DaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L0J1dHRvblNlbGVjdC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1zZWxlY3QvQnV0dG9uU2VsZWN0R3JvdXAuanMiLCJsaWIvY29udHJvbC9idXR0b24tc2VsZWN0L011bHRpQnV0dG9uU2VsZWN0LmpzIiwibGliL2NvbnRyb2wvYnV0dG9uLXNlbGVjdC9pbmRleC5qcyIsImxpYi9jb250cm9sL2J1dHRvbi1zZWxlY3Qvd21sL2J1dHRvbi1zZWxlY3QuanMiLCJsaWIvY29udHJvbC9idXR0b24vQnV0dG9uLmpzIiwibGliL2NvbnRyb2wvYnV0dG9uL3dtbC9idXR0b24uanMiLCJsaWIvY29udHJvbC9jaGVja2JveC9DaGVja2JveC5qcyIsImxpYi9jb250cm9sL2NoZWNrYm94L0NoZWNrYm94Q2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvY2hlY2tib3gvd21sL2NoZWNrYm94LmpzIiwibGliL2NvbnRyb2wvZGF0ZS9EYXRlLmpzIiwibGliL2NvbnRyb2wvZGF0ZS9EYXRlQ2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvZGF0ZS93bWwvZGF0ZS5qcyIsImxpYi9jb250cm9sL2ljb24tYnV0dG9uL0ljb25CdXR0b24uanMiLCJsaWIvY29udHJvbC9pY29uLWJ1dHRvbi93bWwvaWNvbi1idXR0b24uanMiLCJsaWIvY29udHJvbC9pbmRleC5qcyIsImxpYi9jb250cm9sL2x1cmNoL0l0ZW1TZWxlY3RlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvbHVyY2gvU2VhcmNoQ29udHJvbC5qcyIsImxpYi9jb250cm9sL2x1cmNoL1NlYXJjaERlZmF1bHREZWxlZ2F0ZS5qcyIsImxpYi9jb250cm9sL2x1cmNoL1Rlcm1DaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9sdXJjaC9pbmRleC5qcyIsImxpYi9jb250cm9sL3NlYXJjaC1zdGFjay9TZWFyY2hTdGFjay5qcyIsImxpYi9jb250cm9sL3NlYXJjaC1zdGFjay93bWwvc2VhcmNoLXN0YWNrLmpzIiwibGliL2NvbnRyb2wvc2VsZWN0L1NlbGVjdC5qcyIsImxpYi9jb250cm9sL3NlbGVjdC9TZWxlY3RDaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9zZWxlY3QvaW5kZXguanMiLCJsaWIvY29udHJvbC9zZWxlY3Qvd21sL3NlbGVjdC5qcyIsImxpYi9jb250cm9sL3N0YWNrL1N0YWNrLmpzIiwibGliL2NvbnRyb2wvc3RhY2svU3RhY2tDaGFuZ2VkRXZlbnQuanMiLCJsaWIvY29udHJvbC9zdGFjay9pbmRleC5qcyIsImxpYi9jb250cm9sL3N0YWNrL3dtbC9zdGFjay5qcyIsImxpYi9jb250cm9sL3N3aXRjaC9Td2l0Y2guanMiLCJsaWIvY29udHJvbC9zd2l0Y2gvU3dpdGNoQ2hhbmdlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvc3dpdGNoL3dtbC9zd2l0Y2guanMiLCJsaWIvY29udHJvbC90YWJzL1RhYi5qcyIsImxpYi9jb250cm9sL3RhYnMvVGFiQ2xpY2tlZEV2ZW50LmpzIiwibGliL2NvbnRyb2wvdGFicy9UYWJzLmpzIiwibGliL2NvbnRyb2wvdGFicy93bWwvdGFicy5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvVGV4dENoYW5nZWRFdmVudC5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvVGV4dEZpZWxkLmpzIiwibGliL2NvbnRyb2wvdGV4dC1maWVsZC9pbmRleC5qcyIsImxpYi9jb250cm9sL3RleHQtZmllbGQvd21sL3RleHQtZmllbGQuanMiLCJsaWIvY29udHJvbC93bWwvaW5kZXguanMiLCJsaWIvbGF5b3V0L2FzaWRlL0FzaWRlLmpzIiwibGliL2xheW91dC9hc2lkZS93bWwvYXNpZGUuanMiLCJsaWIvbGF5b3V0L2RyYXdlci9EcmF3ZXIuanMiLCJsaWIvbGF5b3V0L2RyYXdlci93bWwvZHJhd2VyLmpzIiwibGliL2xheW91dC9mcmFnbWVudC9GcmFnbWVudC5qcyIsImxpYi9sYXlvdXQvZnJhZ21lbnQvd21sL3ZpZXdzLmpzIiwibGliL2xheW91dC9ncmlkL0dyaWQuanMiLCJsaWIvbGF5b3V0L2dyaWQvd21sL2dyaWQuanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvTGlzdEdyb3VwLmpzIiwibGliL2xheW91dC9saXN0LWdyb3VwL0xpc3RHcm91cEl0ZW0uanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvaW5kZXguanMiLCJsaWIvbGF5b3V0L2xpc3QtZ3JvdXAvd21sL2xpc3QtZ3JvdXAtaXRlbS5qcyIsImxpYi9sYXlvdXQvbGlzdC1ncm91cC93bWwvbGlzdC1ncm91cC5qcyIsImxpYi9sYXlvdXQvbWFpbi9NYWluLmpzIiwibGliL2xheW91dC9tYWluL3dtbC9tYWluLmpzIiwibGliL2xheW91dC9wYW5lbC9QYW5lbC5qcyIsImxpYi9sYXlvdXQvcGFuZWwvd21sL3BhbmVsLmpzIiwibGliL21lbnUvRGl2aWRlci5qcyIsImxpYi9tZW51L0hlYWRlci5qcyIsImxpYi9tZW51L01lbnUuanMiLCJsaWIvbWVudS9NZW51SXRlbS5qcyIsImxpYi9tZW51L01lbnVJdGVtQ2xpY2tlZEV2ZW50LmpzIiwibGliL21lbnUvYnV0dG9uLW1lbnUvQnV0dG9uTWVudS5qcyIsImxpYi9tZW51L2J1dHRvbi1tZW51L2luZGV4LmpzIiwibGliL21lbnUvYnV0dG9uLW1lbnUvd21sL2J1dHRvbi1tZW51LmpzIiwibGliL21lbnUvaW5kZXguanMiLCJsaWIvbWVudS93bWwvZGl2aWRlci5qcyIsImxpYi9tZW51L3dtbC9oZWFkZXIuanMiLCJsaWIvbWVudS93bWwvbWVudS1pdGVtLmpzIiwibGliL21lbnUvd21sL21lbnUuanMiLCJsaWIvbmF2L2JyZWFkY3J1bWJzL0JyZWFkQ3J1bWJzLmpzIiwibGliL25hdi9icmVhZGNydW1icy9JdGVtLmpzIiwibGliL25hdi9icmVhZGNydW1icy93bWwvYnJlYWRjcnVtYnMuanMiLCJsaWIvbmF2L2xpbmsvTGluay5qcyIsImxpYi9uYXYvbGluay9MaW5rQ2xpY2tlZEV2ZW50LmpzIiwibGliL25hdi9saW5rL2luZGV4LmpzIiwibGliL25hdi9saW5rL3dtbC9saW5rLmpzIiwibGliL25hdi9tZW51L0hlYWRlci5qcyIsImxpYi9uYXYvbWVudS9JdGVtLmpzIiwibGliL25hdi9tZW51L0l0ZW1DbGlja2VkRXZlbnQuanMiLCJsaWIvbmF2L21lbnUvTGluay5qcyIsImxpYi9uYXYvbWVudS9NZW51LmpzIiwibGliL25hdi9tZW51L1N1Yk1lbnUuanMiLCJsaWIvbmF2L21lbnUvaW5kZXguanMiLCJsaWIvbmF2L21lbnUvd21sL2hlYWRlci5qcyIsImxpYi9uYXYvbWVudS93bWwvaXRlbS5qcyIsImxpYi9uYXYvbWVudS93bWwvbGluay5qcyIsImxpYi9uYXYvbWVudS93bWwvbWVudS5qcyIsImxpYi9uYXYvbWVudS93bWwvc3ViLW1lbnUuanMiLCJsaWIvdGFibGUvQWxsU2VsZWN0ZWRFdmVudC5qcyIsImxpYi90YWJsZS9DZWxsLmpzIiwibGliL3RhYmxlL0NlbGxDbGlja2VkRXZlbnQuanMiLCJsaWIvdGFibGUvRGVmYXVsdERlbGVnYXRlLmpzIiwibGliL3RhYmxlL0hlYWRpbmdDbGlja2VkRXZlbnQuanMiLCJsaWIvdGFibGUvUm93Q2xpY2tlZEV2ZW50LmpzIiwibGliL3RhYmxlL1Jvd1NlbGVjdGVkRXZlbnQuanMiLCJsaWIvdGFibGUvU29ydERlbGVnYXRlLmpzIiwibGliL3RhYmxlL1RhYmxlLmpzIiwibGliL3RhYmxlL2luZGV4LmpzIiwibGliL3RhYmxlL3dtbC90YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AcXVlbmsvd21sL2xpYi9BU1QuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvQ29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL0BxdWVuay93bWwvbGliL1R5cGVTY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQHF1ZW5rL3dtbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvY3VycnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvRWl0aGVyLmpzIiwibm9kZV9tb2R1bGVzL2FmcGwvbGliL21vbmFkL0ZyZWUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSU8uanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvSWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvTWF5YmUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvbW9uYWQvU3RhdGUuanMiLCJub2RlX21vZHVsZXMvYWZwbC9saWIvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb3BlcnR5LXNlZWsvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdGhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzMyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwd0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsNklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwcF8xID0gcmVxdWlyZShcIi4vd21sL2FwcFwiKTtcbnZhciBuYXZpZ2F0aW9uXzEgPSByZXF1aXJlKFwiLi93bWwvbmF2aWdhdGlvblwiKTtcbnZhciBob21lXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9ob21lXCIpO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9wYW5lbFwiKTtcbnZhciBsaXN0X2dyb3VwXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9saXN0LWdyb3VwXCIpO1xudmFyIHRhYmxlXzEgPSByZXF1aXJlKFwiLi9wYWdlcy90YWJsZVwiKTtcbnZhciB0ZXh0X2ZpZWxkXzEgPSByZXF1aXJlKFwiLi9wYWdlcy90ZXh0LWZpZWxkXCIpO1xudmFyIGRhdGVfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2RhdGVcIik7XG52YXIgc2VsZWN0XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9zZWxlY3RcIik7XG52YXIgYnV0dG9uX3NlbGVjdF8xID0gcmVxdWlyZShcIi4vcGFnZXMvYnV0dG9uLXNlbGVjdFwiKTtcbnZhciBjaGVja2JveF8xID0gcmVxdWlyZShcIi4vcGFnZXMvY2hlY2tib3hcIik7XG52YXIgc3dpdGNoXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9zd2l0Y2hcIik7XG52YXIgdGFic18xID0gcmVxdWlyZShcIi4vcGFnZXMvdGFic1wiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vcGFnZXMvc3RhY2tcIik7XG52YXIgc2VhcmNoX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9zZWFyY2gtc3RhY2tcIik7XG52YXIgYXV0b2NvbXBsZXRlXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9hdXRvY29tcGxldGVcIik7XG52YXIgYnJlYWRjcnVtYnNfMSA9IHJlcXVpcmUoXCIuL3BhZ2VzL2JyZWFkY3J1bWJzXCIpO1xudmFyIGJ1c3lfaW5kaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9wYWdlcy9idXN5LWluZGljYXRvclwiKTtcbnZhciBtZW51XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9tZW51XCIpO1xudmFyIGJ1dHRvbl9tZW51XzEgPSByZXF1aXJlKFwiLi9wYWdlcy9idXR0b24tbWVudVwiKTtcbnZhciBBcHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogcGFnZSBjdXJyZW50bHkgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWdlID0gJ2hvbWUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogcGFnZXMgdG8gc2hvdyB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZXMgPSB7XG4gICAgICAgICAgICBob21lOiBuZXcgaG9tZV8xLkhvbWVQYWdlKHRoaXMpLFxuICAgICAgICAgICAgcGFuZWw6IG5ldyBwYW5lbF8xLlBhbmVsUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICdsaXN0LWdyb3VwJzogbmV3IGxpc3RfZ3JvdXBfMS5MaXN0R3JvdXBQYWdlKHRoaXMpLFxuICAgICAgICAgICAgdGFibGU6IG5ldyB0YWJsZV8xLlRhYmxlUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICd0ZXh0LWZpZWxkJzogbmV3IHRleHRfZmllbGRfMS5UZXh0RmllbGRQYWdlKHRoaXMpLFxuICAgICAgICAgICAgZGF0ZTogbmV3IGRhdGVfMS5EYXRlUGFnZSh0aGlzKSxcbiAgICAgICAgICAgIHNlbGVjdDogbmV3IHNlbGVjdF8xLlNlbGVjdFBhZ2UodGhpcyksXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IG5ldyBhdXRvY29tcGxldGVfMS5BdXRvY29tcGxldGVQYWdlKHRoaXMpLFxuICAgICAgICAgICAgJ2J1dHRvbi1zZWxlY3QnOiBuZXcgYnV0dG9uX3NlbGVjdF8xLkJ1dHRvblNlbGVjdFBhZ2UodGhpcyksXG4gICAgICAgICAgICB0YWJzOiBuZXcgdGFic18xLlRhYnNQYWdlKHRoaXMpLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBzdGFja18xLlN0YWNrUGFnZSh0aGlzKSxcbiAgICAgICAgICAgIGNoZWNrYm94OiBuZXcgY2hlY2tib3hfMS5DaGVja2JveFBhZ2UodGhpcyksXG4gICAgICAgICAgICAnc3dpdGNoJzogbmV3IHN3aXRjaF8xLlN3aXRjaFBhZ2UodGhpcyksXG4gICAgICAgICAgICAnYnVzeS1pbmRpY2F0b3InOiBuZXcgYnVzeV9pbmRpY2F0b3JfMS5CdXN5SW5kaWNhdG9yUGFnZSh0aGlzKSxcbiAgICAgICAgICAgICdzZWFyY2gtc3RhY2snOiBuZXcgc2VhcmNoX3N0YWNrXzEuU2VhcmNoU3RhY2tQYWdlKHRoaXMpLFxuICAgICAgICAgICAgYnJlYWRjcnVtYnM6IG5ldyBicmVhZGNydW1ic18xLkJyZWFkQ3J1bWJzUGFnZSh0aGlzKSxcbiAgICAgICAgICAgIG1lbnU6IG5ldyBtZW51XzEuTWVudVBhZ2UodGhpcyksXG4gICAgICAgICAgICAnYnV0dG9uLW1lbnUnOiBuZXcgYnV0dG9uX21lbnVfMS5CdXR0b25NZW51UGFnZSh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogbmF2aWdhdGlvbiB2aWV3XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgbmF2aWdhdGlvbl8xLk5hdmlnYXRpb24odGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgdXNlZCB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGxheW91dDogJ2xheW91dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZpZXcgaXMgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24gdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBhcHBfMS5NYWluKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogY29udGVudCBkaXNwbGF5ZWQgYXMgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucGFnZXMuaG9tZS52aWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogdG9nZ2xlRHJhd2VyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmlkLmxheW91dClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvZ2dsZURyYXdlcigpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hdmlnYXRlIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhXG4gICAgICAgICAqIG5hdmlnYXRpb24gbGluay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2aWdhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yb3V0ZShuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcm91dGUgdGhlIG1haW4gY29udGVudCBiYXNlZCBvbiB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICAgKi9cbiAgICBBcHAucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCduYW1lLT4gJywgbmFtZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLnBhZ2VzLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgICAgdGhpcy5wYWdlID0gbmFtZTtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLnBhZ2VzW25hbWVdLnZpZXc7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5pbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBydW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIEFwcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKTtcbiAgICAgICAgd2hpbGUgKHJvb3QubGFzdENoaWxkKVxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChyb290Lmxhc3RDaGlsZCk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodGhpcy52aWV3LnJlbmRlcigpKTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubGF5b3V0KTtcbiAgICAgICAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnIycpWzFdO1xuICAgICAgICBwYXRoID0gcGF0aCA/IHBhdGguc3BsaXQoJy8nKS5qb2luKCcnKSA6ICcnO1xuICAgICAgICB0aGlzLnJvdXRlKHBhdGgpO1xuICAgIH07XG4gICAgQXBwLm1haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBwKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXBwO1xufSgpKTtcbmV4cG9ydHMuQXBwID0gQXBwO1xudmFyIHcgPSB3aW5kb3c7XG53LmFwcCA9IEFwcC5tYWluKCk7XG53LmFwcC5ydW4oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2UoYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIH1cbiAgICBQYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQsIGZuKSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQoaWQpXG4gICAgICAgICAgICAubWFwKGZuKVxuICAgICAgICAgICAgLm9ySnVzdChmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zb2xlLndhcm4oaWQgKyBcIjogaXMgbWlzc2luZ1wiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnZTtcbn0oKSk7XG5leHBvcnRzLlBhZ2UgPSBQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2F1dG9jb21wbGV0ZVwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBBdXRvY29tcGxldGVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdXRvY29tcGxldGVQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1dG9jb21wbGV0ZVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogJ3NlYXJjaCcsXG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIHJlc3VsdHM6IFtcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnR2lnYXMnLCB2YWx1ZTogJ0dpZ2FzJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdBc3VzVGVrJywgdmFsdWU6ICdBc3VzVGVrJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdBc3VzdWdhJywgdmFsdWU6ICdBc3VzdWdhJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdRdWFsY29tbScsIHZhbHVlOiAnUXVhbGNvbW0nIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ1F1YWxpdGF0aXZlJywgdmFsdWU6ICdRdWFsaXRhdHZlJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdBc3VuZGVyJywgdmFsdWU6ICdBc3VuZGVyJyB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uU2VhcmNoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQoX3RoaXMudmFsdWVzLmlkKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGl0ID0gX3RoaXMudmFsdWVzLnJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh2YWx1ZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcy51cGRhdGUoaGl0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlbGVjdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZpbmRCeUlkKCdzZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZS52YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZVBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkF1dG9jb21wbGV0ZVBhZ2UgPSBBdXRvY29tcGxldGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIGF1dG9jb21wbGV0ZV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9hdXRvY29tcGxldGVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCIobm90aGluZylcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGF1dG9jb21wbGV0ZV8xLkF1dG9jb21wbGV0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZ2lmaWVyJzogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25TZWFyY2gnOiBfX19jb250ZXh0Lm9uU2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uU2VsZWN0JzogX19fY29udGV4dC5vblNlbGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b2NvbXBsZXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgYnJlYWRjcnVtYnNfMSA9IHJlcXVpcmUoXCIuL3dtbC9icmVhZGNydW1ic1wiKTtcbnZhciBCcmVhZENydW1ic1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyZWFkQ3J1bWJzUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcmVhZENydW1ic1BhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGJyZWFkY3J1bWJzXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyZWFkQ3J1bWJzUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQnJlYWRDcnVtYnNQYWdlID0gQnJlYWRDcnVtYnNQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIEJyZWFkQ3J1bWJzXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9uYXYvYnJlYWRjcnVtYnMvQnJlYWRDcnVtYnNcIik7XG47XG52YXIgSXRlbV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L2JyZWFkY3J1bWJzL0l0ZW1cIik7XG47XG52YXIgTGlua18xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbmF2L2xpbmsvTGlua1wiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoQnJlYWRDcnVtYnNfMS5CcmVhZENydW1icywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoTGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIk9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoTGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlR3b1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEl0ZW1fMS5JdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoTGlua18xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRocmVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVhZGNydW1icy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1c3lfaW5kaWNhdG9yXzEgPSByZXF1aXJlKFwiLi93bWwvYnVzeS1pbmRpY2F0b3JcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgQnVzeUluZGljYXRvclBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1c3lJbmRpY2F0b3JQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1c3lJbmRpY2F0b3JQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBidXN5X2luZGljYXRvcl8xLk1haW4oX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXN5SW5kaWNhdG9yUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQnVzeUluZGljYXRvclBhZ2UgPSBCdXN5SW5kaWNhdG9yUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgQnVzeUluZGljYXRvcl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvYXBwL2J1c3ktaW5kaWNhdG9yL0J1c3lJbmRpY2F0b3JcIik7XG47XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoQnVzeUluZGljYXRvcl8xLkJ1c3lJbmRpY2F0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVzeS1pbmRpY2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tbWVudVwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBCdXR0b25NZW51UGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uTWVudVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uTWVudVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvbk1lbnVQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5CdXR0b25NZW51UGFnZSA9IEJ1dHRvbk1lbnVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIGJ1dHRvbl9tZW51XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9tZW51L2J1dHRvbi1tZW51XCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL21lbnVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGJ1dHRvbl9tZW51XzEuQnV0dG9uTWVudSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJDbGljayBNZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQub25DbGljayhcIllvdSBjbGlja2VkIG9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiT25lXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQub25DbGljayhcIllvdSBjbGlja2VkIHR3b1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVHdvXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQub25DbGljayhcIllvdSBjbGlja2VkIHRocmVlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJUaHJlZVwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1tZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uLXNlbGVjdFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBCdXR0b25TZWxlY3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25TZWxlY3RQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnQXN1cycsIHZhbHVlOiAnQXN1cycgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAuZmluZEJ5SWQobmFtZSArIFwiLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b25TZWxlY3RQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5CdXR0b25TZWxlY3RQYWdlID0gQnV0dG9uU2VsZWN0UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBidXR0b25fc2VsZWN0XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2J1dHRvbi1zZWxlY3RcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJZb3Ugc2VsZWN0ZWQ6IFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwic2VsZWN0LWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiKE5vbmUpXCIpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChidXR0b25fc2VsZWN0XzEuQnV0dG9uU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwic2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YXJpYW50JzogXCItcHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbnMnOiBfX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBjYW4gYWxzbyB1c2UgTXVsdGlCdXR0b25TZWxlY3QgaW5zdGVhZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJtdWx0aS1jb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihOb25lKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoYnV0dG9uX3NlbGVjdF8xLk11bHRpQnV0dG9uU2VsZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwibXVsdGlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIm11bHRpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFyaWFudCc6IFwiLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJzogX19fY29udGV4dC52YWx1ZXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9jaGVja2JveFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBDaGVja2JveFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoZWNrYm94UGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZmluZEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICdvbicgOlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IGZhbHNlID8gJ29mZicgOiAnZXJyb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENoZWNrYm94UGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuQ2hlY2tib3hQYWdlID0gQ2hlY2tib3hQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIENoZWNrYm94XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2NoZWNrYm94L0NoZWNrYm94XCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIGNoZWNrYm94IGlzIFwiKSwgX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJ1bnRvdWNoZWRcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KENoZWNrYm94XzEuQ2hlY2tib3gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvZGF0ZVwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBEYXRlUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZVBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKCdzZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlLmxhc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERhdGVQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5EYXRlUGFnZSA9IERhdGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIERhdGVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvZGF0ZS9EYXRlXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIGRhdGUgaXMgOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIihOb25lIHNlbGVjdGVkKVwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoRGF0ZV8xLkRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgaG9tZV8xID0gcmVxdWlyZShcIi4vd21sL2hvbWVcIik7XG52YXIgSG9tZVBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhvbWVQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvbWVQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBob21lXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhvbWVQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5Ib21lUGFnZSA9IEhvbWVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2InLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiSW5kZXhcIildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob21lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgbGlzdF9ncm91cF8xID0gcmVxdWlyZShcIi4vd21sL2xpc3QtZ3JvdXBcIik7XG52YXIgTGlzdEdyb3VwUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdEdyb3VwUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0R3JvdXBQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBsaXN0X2dyb3VwXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpc3RHcm91cFBhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLkxpc3RHcm91cFBhZ2UgPSBMaXN0R3JvdXBQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIGxpc3RfZ3JvdXBfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9saXN0LWdyb3VwXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChsaXN0X2dyb3VwXzEuTGlzdEdyb3VwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobGlzdF9ncm91cF8xLkxpc3RHcm91cEl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhpcyBpcyB0aGUgZmlyc3QgaXRlbS5cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGxpc3RfZ3JvdXBfMS5MaXN0R3JvdXBJdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoaXMgaXMgdGhlIHNlY29uZCBpdGVtLlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobGlzdF9ncm91cF8xLkxpc3RHcm91cEl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2gzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIldob2EhXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoaXMgaXMgYSB0aGlyZCBpdGVtIVwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgbWVudV8xID0gcmVxdWlyZShcIi4vd21sL21lbnVcIik7XG52YXIgTWVudVBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbnVQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbnVQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBtZW51XzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lbnVQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5NZW51UGFnZSA9IE1lbnVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL21lbnVcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJIZWFkaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZWQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkJhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJSZWZyZXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuRGl2aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvbWVudVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJRdWl0XCIpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBwYW5lbF8xID0gcmVxdWlyZShcIi4vd21sL3BhbmVsXCIpO1xudmFyIFBhbmVsUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWxQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhbmVsUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgcGFuZWxfMS5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWxQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5QYW5lbFBhZ2UgPSBQYW5lbFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgUGFuZWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9wYW5lbC9QYW5lbFwiKTtcbjtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChQYW5lbF8xLlBhbmVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoUGFuZWxfMS5Cb2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiQm9keSBvbmx5LlwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJzogNFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChQYW5lbF8xLlBhbmVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoUGFuZWxfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJXaXRoIEhlYWRlclwiKV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KFBhbmVsXzEuQm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkxvcmVtIGltcHN1bSBkaWxpdW0gbmV0IHNldC5cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoUGFuZWxfMS5QYW5lbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFBhbmVsXzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiV2l0aCBGb290ZXJcIildLCBfX192aWV3KSwgX19fd21sLndpZGdldChQYW5lbF8xLkJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJMb3JlbSBpbXBzdW0gZGlsaXVtIG5ldCBzZXQuXCIpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoUGFuZWxfMS5Gb290ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJNZWggZm9vdC5cIildLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VhcmNoLXN0YWNrXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIG9wdGlvbnMgPSBbXG4gICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgIHsgbGFiZWw6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FzJywgdmFsdWU6ICdHaWdhcycgfSxcbiAgICB7IGxhYmVsOiAnQXN1c1RlaycsIHZhbHVlOiAnQXN1c1RlaycgfSxcbiAgICB7IGxhYmVsOiAnQXN1c3VnYScsIHZhbHVlOiAnQXN1c3VnYScgfSxcbiAgICB7IGxhYmVsOiAnUXVhbGNvbW0nLCB2YWx1ZTogJ1F1YWxjb21tJyB9LFxuICAgIHsgbGFiZWw6ICdRdWFsaXRhdGl2ZScsIHZhbHVlOiAnUXVhbGl0YXR2ZScgfSxcbiAgICB7IGxhYmVsOiAnQXN1bmRlcicsIHZhbHVlOiAnQXN1bmRlcicgfVxuXTtcbnZhciBTZWFyY2hTdGFja1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlYXJjaFN0YWNrUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hTdGFja1BhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDogJ3NlYXJjaCcsXG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbHVlcy5zZWxlY3RlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubGFiZWw7IH0pLmpvaW4oJywnKTsgfSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBbXSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TZWFyY2ggPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXMudmlldy5maW5kQnlJZChfdGhpcy52YWx1ZXMuaWQpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnVwZGF0ZShvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy52YWx1ZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgodmFsdWUudG9Mb3dlckNhc2UoKSk7IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZWFyY2hTdGFja1BhZ2U7XG59KFBhZ2VfMS5QYWdlKSk7XG5leHBvcnRzLlNlYXJjaFN0YWNrUGFnZSA9IFNlYXJjaFN0YWNrUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBTZWFyY2hTdGFja18xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9zZWFyY2gtc3RhY2svU2VhcmNoU3RhY2tcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZSc6IDZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQoKSldLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFNlYXJjaFN0YWNrXzEuU2VhcmNoU3RhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RlY29yYXRvcic6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmxhYmVsOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvblNlYXJjaCc6IF9fX2NvbnRleHQub25TZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaC1zdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3NlbGVjdFwiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBTZWxlY3RQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3RQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdFBhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ0FzdXMnLCB2YWx1ZTogJ0FzdXMnIH0sXG4gICAgICAgICAgICAgICAgeyBsYWJlbDogJ01TSScsIHZhbHVlOiAnTVNJJyB9LFxuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdHaWdhYnl0ZScsIHZhbHVlOiAnR2lnYWJ5dGUnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgX3RoaXNcbiAgICAgICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgICAgIC5maW5kQnlJZCgnc2VsZWN0ZWQnKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5sYXN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3RQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5TZWxlY3RQYWdlID0gU2VsZWN0UGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBTZWxlY3RfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvc2VsZWN0L1NlbGVjdFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIllvdSBzZWxlY3RlZDogXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCIoTm9uZSlcIildLCBfX192aWV3KSwgX19fd21sLnRleHQoXCIuXCIpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFNlbGVjdF8xLlNlbGVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9ucyc6IF9fX2NvbnRleHQudmFsdWVzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0Lm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zdGFja1wiKTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciBfZ2V0VmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgbGFiZWw6ICdBc3VzJywgdmFsdWU6ICdBc3VzJyB9LFxuICAgIHsgbGFiZWw6ICdNU0knLCB2YWx1ZTogJ01TSScgfSxcbiAgICB7IGxhYmVsOiAnTVNJJywgdmFsdWU6ICdNU0knIH0sXG4gICAgeyBsYWJlbDogJ0dpZ2FieXRlJywgdmFsdWU6ICdHaWdhYnl0ZScgfVxuXTsgfTtcbnZhciBfZ2V0VGV4dCA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbDtcbiAgICByZXR1cm4gbGFiZWw7XG59KS5qb2luKCcsJyk7IH07XG52YXIgU3RhY2tQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFja1BhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2tQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgdmFsdWVzOiBfZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICB0ZXh0OiBfZ2V0VGV4dChfZ2V0VmFsdWVzKCkpLFxuICAgICAgICAgICAgZGVjb3JhdG9yOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5sYWJlbDsgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlcy52YWx1ZXMgPSBfZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZXMudGV4dCA9IF9nZXRUZXh0KF90aGlzLnZhbHVlcy52YWx1ZXMpO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuU3RhY2tQYWdlID0gU3RhY2tQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIHN0YWNrXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3N0YWNrXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemUnOiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJNZW1iZXJzOiBcIiksIF9fX3dtbC5ub2RlKCdiJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBcInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQpXSwgX19fdmlldyksIF9fX3dtbC50ZXh0KFwiLlwiKV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChzdGFja18xLlN0YWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInN0YWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBfX19jb250ZXh0LnZhbHVlcy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb3JhdG9yJzogX19fY29udGV4dC52YWx1ZXMuZGVjb3JhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9zd2l0Y2hcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgU3dpdGNoUGFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZpbmRCeUlkKCdjb250ZW50JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgPT09IHRydWUgP1xuICAgICAgICAgICAgICAgICAgICAnb24nIDpcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSBmYWxzZSA/ICdvZmYnIDogJ2Vycm9yJykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTd2l0Y2hQYWdlO1xufShQYWdlXzEuUGFnZSkpO1xuZXhwb3J0cy5Td2l0Y2hQYWdlID0gU3dpdGNoUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBTd2l0Y2hfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvc3dpdGNoL1N3aXRjaFwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoZSBzd2l0Y2ggaXMgXCIpLCBfX193bWwubm9kZSgnYicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJjb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcInVudG91Y2hlZFwiKV0sIF9fX3ZpZXcpLCBfX193bWwudGV4dChcIi5cIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoU3dpdGNoXzEuU3dpdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInN3aXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VycyA9IFtcbiAgICB7XG4gICAgICAgIFwiX2lkXCI6IFwiNTlmMTMzNGNjYzIxZmY3MjhjZjdmM2NlXCIsXG4gICAgICAgIFwiaW5kZXhcIjogMCxcbiAgICAgICAgXCJndWlkXCI6IFwiZmQ5NGNkNTItZTdmMS00NGFiLWE3NGYtMDU2MDRlZWU0NmRkXCIsXG4gICAgICAgIFwiaXNBY3RpdmVcIjogZmFsc2UsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQyLDg0OS45M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDM0LFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obnMgTGV3aXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIlBST0ZMRVhcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcImpvaG5zbGV3aXNAcHJvZmxleC5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5MjUpIDQwOS0zNDAwXCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjg3NCBHcm92ZSBTdHJlZXQsIEVkZ2V3YXRlciwgR2VvcmdpYSwgODExMlwiLFxuICAgICAgICBcImFib3V0XCI6IFwiRXggZXNzZSBkb2xvcmUgZXQgc2ludCBzaW50IHByb2lkZW50IG5vc3RydWQgdXQgb2ZmaWNpYS4gRG8gbnVsbGEgbW9sbGl0IGRvbG9yZSB1dCBhdXRlIGV4Y2VwdGV1ciBkZXNlcnVudCBsYWJvcmlzIHV0IHByb2lkZW50LiBVbGxhbWNvIGVzdCBkZXNlcnVudCBleCBjb21tb2RvIHZlbmlhbSBkdWlzIGVsaXQgZXhjZXB0ZXVyIHZlbGl0IHVsbGFtY28gZGVzZXJ1bnQgY3VscGEgZG8gZXN0LlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE1LTAyLTIyVDEwOjI1OjMyICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDU2LjI3ODg2MixcbiAgICAgICAgXCJsb25naXR1ZGVcIjogLTc5LjQ1OTEwMSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwibGFib3JlXCIsXG4gICAgICAgICAgICBcInByb2lkZW50XCIsXG4gICAgICAgICAgICBcImFsaXF1YVwiLFxuICAgICAgICAgICAgXCJhbWV0XCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwib2ZmaWNpYVwiLFxuICAgICAgICAgICAgXCJlbmltXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWFzb24gTm9ibGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ29mZmV5IE1lbmRlelwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJEaW9ubmUgQ29sZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgSm9obnMgTGV3aXMhIFlvdSBoYXZlIDUgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJiYW5hbmFcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjMDlkYzFiY2RjNTczMjQ5MVwiLFxuICAgICAgICBcImluZGV4XCI6IDEsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjMzMjU1OTk1LTA0MzEtNDI3MS05ODc2LTM3ZWFiYzExN2E3YlwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IGZhbHNlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMiwxNjcuNDBcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyMyxcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJsdWVcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGlhbXNvbiBHcmVnb3J5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiLFxuICAgICAgICBcImNvbXBhbnlcIjogXCJORVRBR1lcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcIndpbGxpYW1zb25ncmVnb3J5QG5ldGFneS5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg5MTApIDQ2Mi0zOTE4XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjE1OCBTZWRnd2ljayBTdHJlZXQsIEdsYXNnb3csIFV0YWgsIDU0OThcIixcbiAgICAgICAgXCJhYm91dFwiOiBcIkV4Y2VwdGV1ciBzaXQgbmlzaSBldCB2ZWxpdC4gTGFib3JpcyBtaW5pbSBpZCBkdWlzIGFkIHF1aSBjdXBpZGF0YXQuIEVzdCBMb3JlbSBxdWlzIGR1aXMgTG9yZW0gbGFib3JpcyB2ZWxpdCBsYWJvcmlzIG5vbiBleGNlcHRldXIgZXQgdmVsaXQgdm9sdXB0YXRlIHF1aS4gRG9sb3JlIHF1aSBhbmltIGV4ZXJjaXRhdGlvbiB2ZW5pYW0gaW5jaWRpZHVudCBsYWJvcmlzIGxhYm9yZS4gSWQgbWluaW0gbGFib3JlIGFtZXQgc3VudCBleGNlcHRldXIgdGVtcG9yIHByb2lkZW50LlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE2LTA0LTI1VDA0OjI1OjI0ICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDU0LjQ1NzgzMyxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogMTIyLjgwMzc2NSxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwidGVtcG9yXCIsXG4gICAgICAgICAgICBcImV4ZXJjaXRhdGlvblwiLFxuICAgICAgICAgICAgXCJldFwiLFxuICAgICAgICAgICAgXCJlbGl0XCIsXG4gICAgICAgICAgICBcImV4XCIsXG4gICAgICAgICAgICBcImNpbGx1bVwiLFxuICAgICAgICAgICAgXCJsYWJvcmlzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTmF2YXJybyBSZWV2ZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3RhbnRvbiBWaW5jZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFsZXhpcyBHdXptYW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIFdpbGxpYW1zb24gR3JlZ29yeSEgWW91IGhhdmUgMSB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImFwcGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0YzlkNzk5Nzg5YmM0OTRhM2NcIixcbiAgICAgICAgXCJpbmRleFwiOiAyLFxuICAgICAgICBcImd1aWRcIjogXCIxNThmZmE1ZC0xNWRhLTRhOWYtYTFkYS0wYTQ4Yjc2YjgyMjZcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IFwiJDEsMjg5LjM1XCIsXG4gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHA6Ly9wbGFjZWhvbGQuaXQvMzJ4MzJcIixcbiAgICAgICAgXCJhZ2VcIjogMzMsXG4gICAgICAgIFwiZXllQ29sb3JcIjogXCJncmVlblwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYWx0b24gSG91c2VcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCIsXG4gICAgICAgIFwiY29tcGFueVwiOiBcIkVZRVdBWFwiLFxuICAgICAgICBcImVtYWlsXCI6IFwiZGFsdG9uaG91c2VAZXlld2F4LmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDk1OSkgNTUwLTIyNjNcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiMTE2IEhvd2FyZCBBdmVudWUsIFJvc3Ntb3JlLCBOZXcgWW9yaywgNjMwMlwiLFxuICAgICAgICBcImFib3V0XCI6IFwiRWxpdCBldSBpcHN1bSBwYXJpYXR1ciBkdWlzIG1vbGxpdCBleCBxdWlzLiBBbWV0IG51bGxhIGV4ZXJjaXRhdGlvbiBsYWJvcmlzIG1pbmltIGZ1Z2lhdCB0ZW1wb3IgaW4gYWxpcXVhIG5pc2kgbm9zdHJ1ZCBhdXRlLiBEdWlzIG1pbmltIGVzc2UgaXJ1cmUgaXJ1cmUgZnVnaWF0IHNpdCBudWxsYSBldCB0ZW1wb3IgbmlzaSBjaWxsdW0gcHJvaWRlbnQgaWQgYWRpcGlzaWNpbmcuIEV1IGVsaXQgbWFnbmEgTG9yZW0gaXJ1cmUgbGFib3JlLiBBbGlxdWlwIGlkIHNpbnQgdmVuaWFtIGFkaXBpc2ljaW5nLiBBbWV0IGVpdXNtb2QgbW9sbGl0IHJlcHJlaGVuZGVyaXQgcmVwcmVoZW5kZXJpdCBkb2xvcmUuXFxyXFxuXCIsXG4gICAgICAgIFwicmVnaXN0ZXJlZFwiOiBcIjIwMTctMDItMjhUMDg6NTM6MDAgKzA0OjAwXCIsXG4gICAgICAgIFwibGF0aXR1ZGVcIjogLTI1LjY3OTc3NCxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogMjkuMzc0NzgxLFxuICAgICAgICBcInRhZ3NcIjogW1xuICAgICAgICAgICAgXCJxdWlcIixcbiAgICAgICAgICAgIFwiY2lsbHVtXCIsXG4gICAgICAgICAgICBcImFuaW1cIixcbiAgICAgICAgICAgIFwiaXJ1cmVcIixcbiAgICAgICAgICAgIFwibm9uXCIsXG4gICAgICAgICAgICBcImNvbW1vZG9cIixcbiAgICAgICAgICAgIFwiZGVzZXJ1bnRcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDYXJtZWxhIFdpbGNveFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFbGJhIEdhcnphXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdhcnJpc29uIENodXJjaFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgRGFsdG9uIEhvdXNlISBZb3UgaGF2ZSAxIHVucmVhZCBtZXNzYWdlcy5cIixcbiAgICAgICAgXCJmYXZvcml0ZUZydWl0XCI6IFwiYXBwbGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIl9pZFwiOiBcIjU5ZjEzMzRjZDE1MThjM2E0NGQ2OWZmZlwiLFxuICAgICAgICBcImluZGV4XCI6IDMsXG4gICAgICAgIFwiZ3VpZFwiOiBcIjUxMDliYzUwLTlhOGUtNDE4NC1hYmEwLTY3NDBkYzAwYjYwNlwiLFxuICAgICAgICBcImlzQWN0aXZlXCI6IHRydWUsXG4gICAgICAgIFwiYmFsYW5jZVwiOiBcIiQzLDg5MS44M1wiLFxuICAgICAgICBcInBpY3R1cmVcIjogXCJodHRwOi8vcGxhY2Vob2xkLml0LzMyeDMyXCIsXG4gICAgICAgIFwiYWdlXCI6IDIyLFxuICAgICAgICBcImV5ZUNvbG9yXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSYXkgV2lsa2luc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiRVhQT1NBXCIsXG4gICAgICAgIFwiZW1haWxcIjogXCJyYXl3aWxraW5zQGV4cG9zYS5jb21cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIisxICg4MTIpIDQxNC0zMjU4XCIsXG4gICAgICAgIFwiYWRkcmVzc1wiOiBcIjgzNyBCZWRmb3JkIEF2ZW51ZSwgSGFybGVpZ2gsIFNvdXRoIENhcm9saW5hLCAyMzIzXCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJFc3QgYW1ldCBxdWlzIGV1IHByb2lkZW50IGlwc3VtIHZlbmlhbSBzaXQuIElydXJlIGxhYm9yZSBhZCBjb25zZWN0ZXR1ciB1bGxhbWNvIHNpdCBpcHN1bSBwcm9pZGVudC4gQWQgcGFyaWF0dXIgaXJ1cmUgbmlzaSBpcnVyZSBjb21tb2RvIGFsaXF1aXAgbmlzaSBldSBhbmltIGlydXJlIGRvbG9yIGRvbG9yIHZlbmlhbSBxdWlzLlxcclxcblwiLFxuICAgICAgICBcInJlZ2lzdGVyZWRcIjogXCIyMDE1LTA5LTE3VDA0OjUyOjQyICswNDowMFwiLFxuICAgICAgICBcImxhdGl0dWRlXCI6IDM0LjM1NDgwMSxcbiAgICAgICAgXCJsb25naXR1ZGVcIjogLTE2OC4zMDM5NTIsXG4gICAgICAgIFwidGFnc1wiOiBbXG4gICAgICAgICAgICBcIm5pc2lcIixcbiAgICAgICAgICAgIFwibGFib3Jpc1wiLFxuICAgICAgICAgICAgXCJpbmNpZGlkdW50XCIsXG4gICAgICAgICAgICBcImFtZXRcIixcbiAgICAgICAgICAgIFwiYXV0ZVwiLFxuICAgICAgICAgICAgXCJxdWlzXCIsXG4gICAgICAgICAgICBcIm1vbGxpdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJpZW5kc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk9saXZpYSBSdXNzb1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSaXRhIFR5bGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkxvcmllIFdhbGtlclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3JlZXRpbmdcIjogXCJIZWxsbywgUmF5IFdpbGtpbnMhIFlvdSBoYXZlIDEgdW5yZWFkIG1lc3NhZ2VzLlwiLFxuICAgICAgICBcImZhdm9yaXRlRnJ1aXRcIjogXCJzdHJhd2JlcnJ5XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJfaWRcIjogXCI1OWYxMzM0YzY5MDFiZGEwMDNlNTJmYTZcIixcbiAgICAgICAgXCJpbmRleFwiOiA0LFxuICAgICAgICBcImd1aWRcIjogXCIwYWIzMzQ3Ny1iMTUyLTRiMTItYWYzNS1mNWI5MjU0ZDVjMmFcIixcbiAgICAgICAgXCJpc0FjdGl2ZVwiOiB0cnVlLFxuICAgICAgICBcImJhbGFuY2VcIjogXCIkMyw3MzAuNzFcIixcbiAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cDovL3BsYWNlaG9sZC5pdC8zMngzMlwiLFxuICAgICAgICBcImFnZVwiOiAyNyxcbiAgICAgICAgXCJleWVDb2xvclwiOiBcImJyb3duXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1hZGRlbiBIYXRmaWVsZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIixcbiAgICAgICAgXCJjb21wYW55XCI6IFwiWk9HQUtcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcIm1hZGRlbmhhdGZpZWxkQHpvZ2FrLmNvbVwiLFxuICAgICAgICBcInBob25lXCI6IFwiKzEgKDgzMikgNTUyLTIyOTRcIixcbiAgICAgICAgXCJhZGRyZXNzXCI6IFwiNTMwIENsZXJtb250IEF2ZW51ZSwgQmV0aHBhZ2UsIFZpcmdpbiBJc2xhbmRzLCA1NjA3XCIsXG4gICAgICAgIFwiYWJvdXRcIjogXCJDb21tb2RvIHRlbXBvciBhbmltIHRlbXBvciBkZXNlcnVudCBsYWJvcmlzIHF1aSBldSByZXByZWhlbmRlcml0IGNvbnNlcXVhdC4gTm9uIGxhYm9ydW0gdWxsYW1jbyBxdWkgcHJvaWRlbnQuIEVzdCBjdXBpZGF0YXQgZG8gZG9sb3IgZXhjZXB0ZXVyIGVzdCBub3N0cnVkIGxhYm9ydW0uIEV1IGV4Y2VwdGV1ciBleCBjb21tb2RvIGFsaXF1aXAgYWRpcGlzaWNpbmcgZXhjZXB0ZXVyLiBFdCByZXByZWhlbmRlcml0IGxhYm9yaXMgcmVwcmVoZW5kZXJpdCBhdXRlIHV0IGV4Y2VwdGV1ciBkZXNlcnVudCBub3N0cnVkIHZlbGl0LiBVbGxhbWNvIGVzdCBzaXQgZnVnaWF0IGlydXJlIGFsaXF1YSBhbGlxdWlwIHByb2lkZW50LiBWb2x1cHRhdGUgYWQgY3VscGEgZG9sb3IgaWQgZW5pbSB0ZW1wb3IgbGFib3J1bS5cXHJcXG5cIixcbiAgICAgICAgXCJyZWdpc3RlcmVkXCI6IFwiMjAxNi0wNC0xMFQwMzozNzoxNyArMDQ6MDBcIixcbiAgICAgICAgXCJsYXRpdHVkZVwiOiA4MC44ODg4NzYsXG4gICAgICAgIFwibG9uZ2l0dWRlXCI6IDExNy44NDMzNyxcbiAgICAgICAgXCJ0YWdzXCI6IFtcbiAgICAgICAgICAgIFwib2NjYWVjYXRcIixcbiAgICAgICAgICAgIFwibmlzaVwiLFxuICAgICAgICAgICAgXCJlc3RcIixcbiAgICAgICAgICAgIFwiYWRcIixcbiAgICAgICAgICAgIFwibm9zdHJ1ZFwiLFxuICAgICAgICAgICAgXCJldVwiLFxuICAgICAgICAgICAgXCJkb2xvcmVcIlxuICAgICAgICBdLFxuICAgICAgICBcImZyaWVuZHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJWaW5jZW50IEdheVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSb3NhcmlvIEZvcmJlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJCYXh0ZXIgR3JlZW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImdyZWV0aW5nXCI6IFwiSGVsbG8sIE1hZGRlbiBIYXRmaWVsZCEgWW91IGhhdmUgNCB1bnJlYWQgbWVzc2FnZXMuXCIsXG4gICAgICAgIFwiZmF2b3JpdGVGcnVpdFwiOiBcImJhbmFuYVwiXG4gICAgfVxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYWdlXzEgPSByZXF1aXJlKFwiLi4vUGFnZVwiKTtcbnZhciB0YWJsZV8xID0gcmVxdWlyZShcIi4vd21sL3RhYmxlXCIpO1xudmFyIGRhdGFfMSA9IHJlcXVpcmUoXCIuL2RhdGFcIik7XG52YXIgY29sdW1ucyA9IFtcbiAgICB7IG5hbWU6ICdpbmRleCcsIGhlYWRpbmc6ICcjJyB9LFxuICAgIHsgbmFtZTogJ25hbWUnLCBoZWFkaW5nOiAnTmFtZScgfSxcbiAgICB7IG5hbWU6ICdiYWxhbmNlJywgaGVhZGluZzogJ0JhbGFuY2UnIH1cbl07XG52YXIgVGFibGVQYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZVBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB0YWJsZV8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICB1c2VyczogZGF0YV8xLnVzZXJzLFxuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIG9uQ2VsbENsaWNrZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIllvdSBjbGlja2VkIFwiICsgZS5jb2x1bW4gKyBlLnJvd051bWJlciArIFwiIVwiKSk7XG4gICAgICAgICAgICAgICAgZS5jZWxsLnNldENvbnRlbnQoeyByZW5kZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYW47IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGFibGVQYWdlID0gVGFibGVQYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZ3JpZC9HcmlkXCIpO1xuO1xudmFyIFRhYmxlXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi90YWJsZS9UYWJsZVwiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChHcmlkXzEuR3JpZCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGFibGVfMS5UYWJsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGVjdGFibGUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IF9fX2NvbnRleHQudmFsdWVzLnVzZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1ucyc6IF9fX2NvbnRleHQudmFsdWVzLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNlbGxDbGlja2VkJzogX19fY29udGV4dC52YWx1ZXMub25DZWxsQ2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3RhYnNcIik7XG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4uL1BhZ2VcIik7XG52YXIgVGFic1BhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYnNQYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYnNQYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudGFiID0gJ0ZpcnN0JztcbiAgICAgICAgX3RoaXMuY29udGVudCA9ICdGaXJzdCBUYWInO1xuICAgICAgICBfdGhpcy5jbGlja2VkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICBfdGhpcy50YWIgPSBuYW1lO1xuICAgICAgICAgICAgX3RoaXMuY29udGVudCA9IG5hbWUgKyBcIiBUYWJcIjtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJzUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGFic1BhZ2UgPSBUYWJzUGFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JpZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2dyaWQvR3JpZFwiKTtcbjtcbnZhciBUYWJzXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3RhYnMvVGFic1wiKTtcbjtcbnZhciBUYWJfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvdGFicy9UYWJcIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoR3JpZF8xLkdyaWQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KFRhYnNfMS5UYWJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGFiXzEuVGFiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnRhYiA9PT0gXCJGaXJzdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJGaXJzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkZpcnN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQuY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KFRhYl8xLlRhYiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC50YWIgPT09IFwiU2Vjb25kXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlNlY29uZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIlNlY29uZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0LmNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChUYWJfMS5UYWIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQudGFiID09PSBcIlRoaXJkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRoaXJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVGhpcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5jbGlja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jb250ZW50KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90ZXh0LWZpZWxkXCIpO1xudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuLi9QYWdlXCIpO1xudmFyIFRleHRGaWVsZFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRGaWVsZFBhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dEZpZWxkUGFnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkID0gJ3RleHQnO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAodmFsdWUgPT09ICdpbnZhbGlkJykgP1xuICAgICAgICAgICAgICAgIF90aGlzLmdldChfdGhpcy5pZCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuc2V0RXJyb3IoJ1RoaXMgY29udHJvbCBpcyBub3cgaW52YWxpZCEnKTtcbiAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgKHZhbHVlID09PSAndmFsaWQnKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdldChfdGhpcy5pZCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnNldFN1Y2Nlc3MoJ1RoaXMgY29udHJvbCBpcyBub3cgdmFsaWQhJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnd2FybicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdldChfdGhpcy5pZCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5zZXRXYXJuaW5nKCdUaGlzIGNvbnRyb2wgbm93IGhhcyBhIHdhcm5pbmchJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdyZXNldCcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXQoX3RoaXMuaWQsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kQnlJZCgnY29udGVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUubGFzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDaGlsZChlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dEZpZWxkUGFnZTtcbn0oUGFnZV8xLlBhZ2UpKTtcbmV4cG9ydHMuVGV4dEZpZWxkUGFnZSA9IFRleHRGaWVsZFBhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEdyaWRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9ncmlkL0dyaWRcIik7XG47XG52YXIgVGV4dEZpZWxkXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3RleHQtZmllbGQvVGV4dEZpZWxkXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEdyaWRfMS5HcmlkLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLlJvdywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KEdyaWRfMS5Db2x1bW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC50ZXh0KFwiVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpczpcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoXCIoTm90aGluZylcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGV4dEZpZWxkXzEuVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnc3Ryb25nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlN1Y2Nlc3NcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChUZXh0RmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Y2Nlc3MnOiBcIlRoaXMgdGV4dGZpZWxkIGhhcyBhIHN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChHcmlkXzEuUm93LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoR3JpZF8xLkNvbHVtbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgncCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3N0cm9uZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJXYXJuaW5nXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGV4dEZpZWxkXzEuVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3YXJuaW5nJzogXCJUaGlzIHRleHRmaWVsZCBoYXMgYSB3YXJuaW5nLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnc3Ryb25nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIkVycm9yXCIpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGV4dEZpZWxkXzEuVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcic6IFwiVGhpcyB0ZXh0ZmllbGQgaGFzIGFuIGVycm9yLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2hhbmdlJzogX19fY29udGV4dC5vbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KEdyaWRfMS5Sb3csIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChHcmlkXzEuQ29sdW1uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlRoZSBvbmUgdXNlcyByb3dzIHRvIHJlbmRlciBhIHRleHQgYXJlYTpcIildLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQoVGV4dEZpZWxkXzEuVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyb3dzJzogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBEcmF3ZXJfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9kcmF3ZXIvRHJhd2VyXCIpO1xuO1xudmFyIEFjdGlvbkJhcl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvYXBwL2FjdGlvbi1iYXIvQWN0aW9uQmFyXCIpO1xuO1xuO1xudmFyIEljb25CdXR0b25fMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvaWNvbi1idXR0b24vSWNvbkJ1dHRvblwiKTtcbjtcbnZhciBkYXNoXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9hcHAvZGFzaFwiKTtcbjtcbnZhciBNYWluXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvbWFpbi9NYWluXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KERyYXdlcl8xLkRyYXdlciwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5sYXlvdXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICdkcmF3ZXInOiBfX19jb250ZXh0Lm5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChBY3Rpb25CYXJfMS5BY3Rpb25CYXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChJY29uQnV0dG9uXzEuSWNvbkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudG9nZ2xlRHJhd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KGRhc2hfMS5EYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChNYWluXzEuTWFpbiwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY29udGVudC5yZW5kZXIoKSldLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL25hdi9tZW51XCIpO1xudmFyIE5hdmlnYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hdmlnYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KG1lbnVfMS5NZW51LCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJob21lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImhvbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiSG9tZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJMYXlvdXRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5TdWJNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwicGFuZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9wYW5lbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJwYW5lbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiUGFuZWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImxpc3QtZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9saXN0LWdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImxpc3QtZ3JvdXBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkxpc3QgR3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuU3ViTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvdGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwidGFibGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJDb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuU3ViTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRleHQtZmllbGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy90ZXh0LWZpZWxkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInRleHQtZmllbGRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRleHQgRmllbGRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2RhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwiZGF0ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiRGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9zZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwic2VsZWN0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJTZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiYXV0b2NvbXBsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvYXV0b2NvbXBsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImF1dG9jb21wbGV0ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQXV0b2NvbXBsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImJ1dHRvbi1zZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9idXR0b24tc2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImJ1dHRvbi1zZWxlY3RcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkJ1dHRvbiBTZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9jaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJjaGVja2JveFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQ2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvc3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInN3aXRjaFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiU3dpdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcInRhYnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy90YWJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInRhYnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIlRhYnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9zdGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJzdGFja1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiU3RhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwic2VhcmNoLXN0YWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvc2VhcmNoLXN0YWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcInNlYXJjaC1zdGFja1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiU2VhcmNoIFN0YWNrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLkhlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJBcHBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5TdWJNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC53aWRnZXQobWVudV8xLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dyb3VwJzogXCJsaW5rc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiYnVzeS1pbmRpY2F0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiIy9idXN5LWluZGljYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJidXN5LWluZGljYXRvclwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiQnVzeSBJbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KSwgX19fd21sLndpZGdldChtZW51XzEuSGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIk5hdlwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLlN1Yk1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJicmVhZGNydW1ic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogXCIjL2JyZWFkY3J1bWJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uQ2xpY2snOiBfX19jb250ZXh0Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiAoX19fY29udGV4dC5wYWdlID09PSBcImJyZWFkY3J1bWJzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJCcmVhZENydW1ic1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KV0sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5IZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IFwiTWVudVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQobWVudV8xLlN1Yk1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChtZW51XzEuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ3JvdXAnOiBcImxpbmtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJtZW51XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvbWVudVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogKF9fX2NvbnRleHQucGFnZSA9PT0gXCJtZW51XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JzogXCJNZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KG1lbnVfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdncm91cCc6IFwibGlua3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcImJ1dHRvbi1tZW51XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBcIiMvYnV0dG9uLW1lbnVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IChfX19jb250ZXh0LnBhZ2UgPT09IFwiYnV0dG9uLW1lbnVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBcIkJ1dHRvbiBNZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmF2aWdhdGlvbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIEdyb3VwXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250ZW50L0dyb3VwXCIpO1xudmFyIGFjdGlvbl9iYXJfMSA9IHJlcXVpcmUoXCIuL3dtbC9hY3Rpb25fYmFyXCIpO1xuLyoqXG4gKiBBY3Rpb25CYXIgcHJvdmlkZXMgYSBiYXIgYWNyb3NzIHRoZSBzY3JlZW4gdGhhdCBjYW4gYmVcbiAqIHVzZWQgYXMgYSB0b29sYmFyLCBuYXZpZ2F0aW9uIG1lbnUgb3Igc29tZXRoaW5nIHNpbWlsbGFyLlxuICovXG52YXIgQWN0aW9uQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpb25CYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aW9uQmFyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBhY3Rpb25fYmFyXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2NvbnRlbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsLmNvbWJpbmUoW25hbWVzLkFDVElPTl9CQVIsIG5hbWVzLkZJWEVEX1BVU0hBQkxFXSksXG4gICAgICAgICAgICAgICAgY29udGVudDogbmFtZXMuQUNUSU9OX0JBUl9DT05URU5UXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjdGlvbkJhcjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5BY3Rpb25CYXIgPSBBY3Rpb25CYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb25CYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaWQuY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbl9iYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBidXN5X2luZGljYXRvcl8xID0gcmVxdWlyZShcIi4vd21sL2J1c3lfaW5kaWNhdG9yXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBCdXN5SW5kaWNhdG9yIHByb3ZpZGVzIGEgJ2hhbWJ1cmdlcicgbWVudSBidXR0b24uXG4gKi9cbnZhciBCdXN5SW5kaWNhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXN5SW5kaWNhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1c3lJbmRpY2F0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGJ1c3lfaW5kaWNhdG9yXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdsb2FkaW5nJywgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXN5SW5kaWNhdG9yO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkJ1c3lJbmRpY2F0b3IgPSBCdXN5SW5kaWNhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVzeUluZGljYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXN5X2luZGljYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgZGFzaF8xID0gcmVxdWlyZShcIi4vd21sL2Rhc2hcIik7XG4vKipcbiAqIERhc2ggYXJlIGxpdGVyYWwgaG9yaXpvbnRhbCBkYXNoZXMuXG4gKlxuICogVGhlc2UgY2FuIGJlIHVzZWQgd2l0aCBhcHAvbWVudS9CdXR0b24gdG8gY3JlYXRlICdoYW1idXJnZXInIG1lbnVzLlxuICovXG52YXIgRGFzaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGFzaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXNoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBkYXNoXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuREFTSFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEYXNoO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGFzaCA9IERhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhc2hfMSA9IHJlcXVpcmUoXCIuL0Rhc2hcIik7XG5leHBvcnRzLkRhc2ggPSBEYXNoXzEuRGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEhJRERFTiBpbmRpY2F0ZXMgYW4gZWxlbWVudCBzaG91bGQgYmUgaGlkZGVuIGZyb20gc2lnaHQuXG4gKi9cbmV4cG9ydHMuSElEREVOID0gJy1oaWRkZW4nO1xuLyoqXG4gKiBESVNBQkxFRCBpbmRpY2F0ZXMgYW4gZWxlbWVudCBzaG91bGQgYXBwZWFyIHRvIGJlIGluYWNjZXNpYmxlXG4gKi9cbmV4cG9ydHMuRElTQUJMRUQgPSAnLWRpc2FibGVkJztcbi8qKlxuICogT04gaW5kaWNhdGVzIGFuICdvbicgc3RhdGUuXG4gKi9cbmV4cG9ydHMuT04gPSAnLW9uJztcbi8qKlxuICogT0ZGIGluZGljYXRlcyBhbiAnb2ZmJyBzdGF0ZS5cbiAqL1xuZXhwb3J0cy5PRkYgPSAnLW9mZic7XG4vKipcbiAqIG9wZW4gaW5kaWNhdGVzIGFuIG9wZW4gc3RhdGUgaW4gY29sbGFwc2FibGUgd2lkZ2V0c1xuICovXG5leHBvcnRzLk9QRU4gPSAnLW9wZW4nO1xuLyoqXG4gKiBQVVNIQUJMRSBpcyB1c2VkIGJ5IG90aGVyIHN0eWxlcyB0byBtb3ZlIGFuIGVsZW1lbnQgYXJvdW5kLlxuICovXG5leHBvcnRzLlBVU0hBQkxFID0gJy1wdXNoYWJsZSc7XG4vKipcbiAqIEZJWEVEX1BVU0hBQkxFIGlzIGxpa2UgUFVTSEFCTEUgYnV0IHVzZWQgZm9yIGZpeGVkIGVsZW1lbnRzLlxuICovXG5leHBvcnRzLkZJWEVEX1BVU0hBQkxFID0gJy1maXhlZC1wdXNoYWJsZSc7XG4vKipcbiAqIE5PX0hPVkVSIGluZGljYXRlcyBob3ZlciBlZmZlY3RzIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAqL1xuZXhwb3J0cy5OT19IT1ZFUiA9ICctbm8taG92ZXInO1xuLyoqXG4gKiBERUZBVUxUIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLkRFRkFVTFQgPSAnLWRlZmF1bHQnO1xuLyoqXG4gKiBQUklNQVJZIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLlBSSU1BUlkgPSAnLXByaW1hcnknO1xuLyoqXG4gKiBTVUNDRVNTIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLlNVQ0NFU1MgPSAnLXN1Y2Nlc3MnO1xuLyoqXG4gKiBJTkZPIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLklORk8gPSAnLWluZm8nO1xuLyoqXG4gKiBXQVJOSU5HIHN0eWxlIG1vZGlmaWVyLlxuICovXG5leHBvcnRzLldBUk5JTkcgPSAnLXdhcm5pbmcnO1xuLyoqXG4gKiBEQU5HRVIgc3R5bGUgbW9kaWZpZXIuXG4gKi9cbmV4cG9ydHMuREFOR0VSID0gJy1kYW5nZXInO1xuZXhwb3J0cy5MQVJHRSA9ICctbGFyZ2UnO1xuZXhwb3J0cy5TTUFMTCA9ICctc21hbGwnO1xuZXhwb3J0cy5FWFRSQV9TTUFMTCA9ICctZXh0cmEtc21hbGwnO1xuZXhwb3J0cy5BQ1RJVkUgPSAnYWN0aXZlJzsgLy9AdG9kbzogcmVmYWN0b3IgdG8gZmxhZyBzeW50YXhcbmV4cG9ydHMuRFJBV0VSID0gJ3d3LWRyYXdlci1sYXlvdXQnO1xuZXhwb3J0cy5BU0lERSA9ICd3dy1kcmF3ZXInO1xuZXhwb3J0cy5BU0lERV9DT05URU5UID0gJ3d3LWRyYXdlcl9fY29udGVudCc7XG5leHBvcnRzLkFTSURFX1BVU0hBQkxFID0gJy1kcmF3ZXItcHVzaGFibGUnO1xuZXhwb3J0cy5BU0lERV9QVVNIQUJMRV9GSVhFRCA9ICctZHJhd2VyLXB1c2hhYmxlLWZpeGVkJztcbi8qKlxuICogQUNUSU9OX0JBUiBjbGFzcyBuYW1lLiBmb3IgdGhlIEFjdGlvbkJhciByb290LlxuICovXG5leHBvcnRzLkFDVElPTl9CQVIgPSAnd3ctYWN0aW9uLWJhcic7XG4vKipcbiAqIEFDVElPTl9CQVJfQ09OVEVOVCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkFDVElPTl9CQVJfQ09OVEVOVCA9ICd3dy1hY3Rpb24tYmFyX19jb250ZW50Jztcbi8qKlxuICogSUNPTl9CVVRUT04gY2xhc2VzcyBmb3IgSWNvbkJ1dHRvbnMuXG4gKi9cbmV4cG9ydHMuSUNPTl9CVVRUT04gPSAnd3ctaWNvbi1idXR0b24nO1xuLyoqXG4gKiBCVVRUT05fTUVOVSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkJVVFRPTl9NRU5VID0gJ3d3LWJ1dHRvbi1tZW51IGJ0bi1ncm91cCc7XG4vKipcbiAqIEJVVFRPTl9NRU5VX0JVVFRPTiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkJVVFRPTl9NRU5VX0JVVFRPTiA9IGV4cG9ydHMuQlVUVE9OX01FTlUgKyBcIl9fYnV0dG9uXCI7XG4vKipcbiAqIEJVVFRPTl9NRU5VX01FTlUgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5CVVRUT05fTUVOVV9NRU5VID0gZXhwb3J0cy5CVVRUT05fTUVOVV9CVVRUT04gKyBcIl9fbWVudVwiO1xuLyoqXG4gKiBCVVRUT05fU0VMRUNUXG4gKi9cbmV4cG9ydHMuQlVUVE9OX1NFTEVDVCA9ICdidG4tZ3JvdXAnO1xuZXhwb3J0cy5CVVRUT05fU0VMRUNUX09QVElPTiA9IGV4cG9ydHMuQlVUVE9OX1NFTEVDVCArIFwiX19vcHRpb24gYnRuXCI7XG5leHBvcnRzLk1BSU5fVklFVyA9ICd3dy1tYWluLXZpZXcnO1xuLyoqXG4gKiBNRU5VIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTUVOVSA9ICd3dy1tZW51Jztcbi8qKlxuICogTUVOVV9JVEVNIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTUVOVV9JVEVNID0gZXhwb3J0cy5NRU5VICsgXCJfX2l0ZW1cIjtcbi8qKlxuICogTUVOVV9IRUFERVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5NRU5VX0hFQURFUiA9IGV4cG9ydHMuTUVOVSArIFwiX19oZWFkZXJcIjtcbi8qKlxuICogTUVOVV9ESVZJREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTUVOVV9ESVZJREVSID0gZXhwb3J0cy5NRU5VICsgXCJfX2RpdmlkZXJcIjtcbi8qKlxuICogREFTSCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBU0ggPSAnd3ctZGFzaCc7XG4vKipcbiAqIE5BViBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk5BViA9ICd3dy1uYXYnO1xuLyoqXG4gKiBOQVZfTElOSyBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLk5BVl9MSU5LID0gJ3d3LW5hdi1saW5rJztcbi8qKlxuICogTkFWX01FTlUgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5OQVZfTUVOVSA9ICd3dy1uYXYtbWVudSc7XG4vKipcbiAqIE5BVl9NRU5VX0lURU0gY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5OQVZfTUVOVV9JVEVNID0gJ3d3LW5hdi1tZW51X19pdGVtJztcbi8qKlxuICogTkFWX01FTlVfSEVBREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTkFWX01FTlVfSEVBREVSID0gJ3d3LW5hdi1tZW51X19oZWFkZXInO1xuLyoqXG4gKiBOQVZfTUVOVV9MSU5LIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuTkFWX01FTlVfTElOSyA9ICd3dy1uYXYtbWVudV9fbGluayc7XG4vKipcbiAqIE5BVl9NRU5VX1NVQk1FTlUgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5OQVZfTUVOVV9TVUJNRU5VID0gJ3d3LW5hdi1tZW51X19zdWJtZW51JztcbmV4cG9ydHMuQlVUVE9OID0gJ3d3LWJ1dHRvbic7XG5leHBvcnRzLkJVVFRPTl9HUk9VUCA9ICd3dy1idXR0b24tZ3JvdXAnO1xuLy9AdG9kbzogcmVmYWN0b3IgdGhpcyB0byBiZSBpbmxpbmUgd2l0aCBvdGhlciBjbGFzcyBuYW1lc1xuZXhwb3J0cy5HUklEID0gJ2NvbnRhaW5lci1mbHVpZCc7XG5leHBvcnRzLkdSSURfQ09MVU1OID0gJ3d3LWdyaWQtY29sdW1uJztcbmV4cG9ydHMuR1JJRF9ST1cgPSAncm93Jztcbi8qKlxuICogUEFORUwgd3JhcHBlciBjbGFzcy5cbiAqL1xuZXhwb3J0cy5QQU5FTCA9ICd3dy1wYW5lbCc7XG4vKipcbiAqIFBBTkVMX0hFQURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0hFQURFUiA9ICd3dy1wYW5lbF9faGVhZGVyJztcbi8qKlxuICogUEFORUxfQk9EWSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlBBTkVMX0JPRFkgPSAnd3ctcGFuZWxfX2JvZHknO1xuLyoqXG4gKiBQQU5FTF9GT09URVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5QQU5FTF9GT09URVIgPSAnd3ctcGFuZWxfX2Zvb3Rlcic7XG4vKipcbiAqIEhFQURFUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkhFQURFUiA9ICd3dy1oZWFkZXInO1xuZXhwb3J0cy5NT0RBTCA9ICd3dy1tb2RhbCc7XG5leHBvcnRzLk1PREFMX0RJQUxPRyA9ICd3dy1tb2RhbF9fZGlhbG9nJztcbmV4cG9ydHMuTU9EQUxfQ09OVEVOVCA9ICd3dy1tb2RhbF9fY29udGVudCc7XG5leHBvcnRzLk1PREFMX0hFQURFUiA9ICd3dy1tb2RhbF9faGVhZGVyJztcbmV4cG9ydHMuTU9EQUxfQk9EWSA9ICd3dy1tb2RhbF9fYm9keSc7XG5leHBvcnRzLk1PREFMX0ZPT1RFUiA9ICd3dy1tb2FkbF9fZm9vdGVyJztcbmV4cG9ydHMuRk9STV9HUk9VUCA9ICdmb3JtLWdyb3VwJztcbmV4cG9ydHMuQ09OVFJPTF9MQUJFTCA9ICdjb250cm9sLWxhYmVsJztcbmV4cG9ydHMuSU5QVVQgPSAnZm9ybS1jb250cm9sJztcbmV4cG9ydHMuVEVYVEFSRUEgPSAnZm9ybS1jb250cm9sJztcbmV4cG9ydHMuU0VMRUNUID0gJ2Zvcm0tY29udHJvbCc7XG4vKipcbiAqIFRBQlMgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5UQUJTID0gJ3d3LXRhYnMnO1xuLyoqXG4gKiBUQUJTX1RBQiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlRBQlNfVEFCID0gJ3d3LXRhYnNfX3RhYic7XG4vKipcbiAqIFNXSVRDSCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlNXSVRDSCA9ICd3dy1zd2l0Y2gnO1xuLyoqXG4gKiBTV0lUQ0hfU0xJREVSIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuU1dJVENIX1NMSURFUiA9ICd3dy1zd2l0Y2hfX3NsaWRlcic7XG4vKipcbiAqIENIRUNLQk9YIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuQ0hFQ0tCT1ggPSAnY2hlY2tib3gnO1xuZXhwb3J0cy5UQUJMRSA9ICd0YWJsZSc7IC8vQHRvZG8gdW4tYm9vdHN0cmFwXG4vKipcbiAqIEJSRUFEX0NSVU1CUyBjbGFzZXNzXG4gKi9cbmV4cG9ydHMuQlJFQURfQ1JVTUJTID0gJ2JyZWFkY3J1bWInOyAvL0B0b2RvIHVuLWJvb3RzdHJhcFxuLyoqXG4gKiBCUkVBRF9DUlVNQlNfSVRFTSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkJSRUFEX0NSVU1CU19JVEVNID0gZXhwb3J0cy5CUkVBRF9DUlVNQlMgKyBcIl9faXRlbVwiO1xuZXhwb3J0cy5MSVNUID0gJ3d3LWxpc3QnO1xuZXhwb3J0cy5MSVNUX0lURU0gPSAnd3ctbGlzdF9faXRlbSc7XG4vKipcbiAqIFNFQVJDSCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlNFQVJDSCA9ICd3dy1zZWFyY2gnO1xuLyoqXG4gKiBTRUFSQ0hfSU5QVVQgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TRUFSQ0hfSU5QVVQgPSAnd3ctc2VhcmNoX19pbnB1dCc7XG4vKipcbiAqIERBVEUgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5EQVRFID0gJ3d3LWRhdGUnO1xuLyoqXG4gKiBEQVRFX0RBWSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBVEVfREFZID0gZXhwb3J0cy5EQVRFICsgXCJfX2RheVwiO1xuLyoqXG4gKiBEQVRFX01PTlRIIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuREFURV9NT05USCA9IGV4cG9ydHMuREFURSArIFwiX21vbnRoXCI7XG4vKipcbiAqIERBVEVfWUVBUiBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkRBVEVfWUVBUiA9IGV4cG9ydHMuREFURSArIFwiX195ZWFyXCI7XG4vKipcbiAqIFNUQUNLIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuU1RBQ0sgPSAnd3ctc3RhY2snO1xuLyoqXG4gKiBTVEFDS19DTE9TRSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLlNUQUNLX0NMT1NFID0gZXhwb3J0cy5TVEFDSyArIFwiX19jbG9zZVwiO1xuLyoqXG4gKiBTVEFDS19NRU1CRVIgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TVEFDS19NRU1CRVIgPSBleHBvcnRzLlNUQUNLICsgXCJfX21lbWJlclwiO1xuLyoqXG4gKiBTRUFSQ0hfU1RBQ0sgY2xhc3MgbmFtZS5cbiAqL1xuZXhwb3J0cy5TRUFSQ0hfU1RBQ0sgPSAnd3ctc2VhcmNoLXN0YWNrJztcbi8qKlxuICogTElTVF9HUk9VUCBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkxJU1RfR1JPVVAgPSAnbGlzdC1ncm91cCc7XG4vKipcbiAqIExJU1RfR1JPVVBfSVRFTSBjbGFzcyBuYW1lLlxuICovXG5leHBvcnRzLkxJU1RfR1JPVVBfSVRFTSA9ICdsaXN0LWdyb3VwLWl0ZW0nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGNvbWJpbmUgdGhlIG1lbWJlcnMgb2YgYW4gYXJyYXkgaW50byBvbmUgc3RyaW5nLlxuICovXG5leHBvcnRzLmNvbWJpbmUgPSBmdW5jdGlvbiAoc3RyLCBqb2luZXIpIHtcbiAgICBpZiAoam9pbmVyID09PSB2b2lkIDApIHsgam9pbmVyID0gJyAnOyB9XG4gICAgcmV0dXJuIHN0ci5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICgocyAhPSBudWxsKSB8fCBzICE9ICcnKTsgfSkuam9pbihqb2luZXIpO1xufTtcbi8qKlxuICogY29uY2F0IGpvaW5zIHZhcmlvdXMgc3RyaW5ncyB0b2dldGhlciB0byBmb3JtIGFuIGh0bWwgY2xhc3MgYXR0cmlidXRlIHZhbHVlLlxuICpcbiAqIFJlbW92ZXMgZW1wdHkgc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAqL1xuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0ciA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cltfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gKChzICE9IG51bGwpIHx8IHMgIT0gJycpOyB9KS5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBub29wXG4gKi9cbmV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogcmVwbGFjZUNvbnRlbnRcbiAqL1xuZXhwb3J0cy5yZXBsYWNlQ29udGVudCA9IGZ1bmN0aW9uIChyLCBub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKVxuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKHIucmVuZGVyKCkpO1xufTtcbi8qKlxuICogZGVib3VuY2UgYSBmdW5jdGlvbiBzbyB0aGF0IGl0IGlzIG9ubHkgY2FsbGVkIG9uY2UgYWZ0ZXJcbiAqIGEgcGVyaW9kIG9mIHRpbWUuXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbiAoZiwgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHJldHVybiBkZWxheSA9PT0gMCA/IGYgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoYSk7IH0sIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoYSk7IH0sIGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIEdyb3VwIGlzIGFuIGFic3RyYWN0IGNsYXNzIHByb3ZpZGluZyBhbiBhcGkgZm9yXG4gKiB3aWRnZXRzIHdob3NlIHByaW1hcnkgcHVycG9zZSBpcyBkaXNwbGF5aW5nIGNvbnRlbnQuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0Q29udGVudCBjaGFuZ2VzIHRoZSBjb250ZW50IHZhbHVlLlxuICAgICAqL1xuICAgIEdyb3VwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZW1vdmVDb250ZW50IHJlbW92ZXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgKi9cbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXA7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuLyoqXG4gKiBDb250cm9sXG4gKi9cbnZhciBDb250cm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbnRyb2w7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIERlZmF1bHREZWxlZ2F0ZSBmb3dhcmRzIGFsbCBldmVudHMgdG8gdGhlaXIgY29ycmVzcG9uZGluZ1xuICogZnVuY3Rpb24gaGFuZGxlcnMsIHNwZWNpZmVkIG9uIHRoZSBhdHRyaWJ1dGVzIG9mIGEgY29udHJvbC5cbiAqL1xudmFyIERlZmF1bHREZWxlZ2F0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0RGVsZWdhdGUoYXR0cnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF0dHJzLm9uSW5wdXQgPyBfdGhpcy5hdHRycy5vbklucHV0KGUpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXR0cnMub25DaGFuZ2UgPyBfdGhpcy5hdHRycy5vbkNoYW5nZShlKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBEZWZhdWx0RGVsZWdhdGU7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0RGVsZWdhdGUgPSBEZWZhdWx0RGVsZWdhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0RGVsZWdhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEV2ZW50IGlzIHRoZSBwYXJlbnQgY2xhc3Mgb2YgYWxsIGV2ZW50cyBnZW5lcmF0ZWQgYnkgY29udHJvbHMuXG4gKi9cbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBFdmVudDtcbn0oKSk7XG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnRyb2xfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xcIik7XG52YXIgRGVmYXVsdERlbGVnYXRlXzEgPSByZXF1aXJlKFwiLi9EZWZhdWx0RGVsZWdhdGVcIik7XG52YXIgSU5QVVRfU1VDQ0VTUyA9ICdoYXMtc3VjY2Vzcyc7XG52YXIgSU5QVVRfRVJST1IgPSAnaGFzLWVycm9yJztcbnZhciBJTlBVVF9XQVJOSU5HID0gJ2hhcy13YXJuaW5nJztcbnZhciBGb3JtQ29udHJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybUNvbnRyb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybUNvbnRyb2woKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IF90aGlzLmF0dHJzLnd3LmRlbGVnYXRlID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmRlbGVnYXRlIDogbmV3IERlZmF1bHREZWxlZ2F0ZV8xLkRlZmF1bHREZWxlZ2F0ZShfdGhpcy5hdHRycy53dyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNGaWxsZWRcbiAgICAgKi9cbiAgICAvLyAgIGFic3RyYWN0IGlzRmlsbGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogY2xlYXJcbiAgICAgKi9cbiAgICAvLyBhYnN0cmFjdCBjbGVhcigpOiBGb3JtQ29udHJvbDxWLCBBPjtcbiAgICAvKipcbiAgICAgKiBpc1JlcXVpcmVkIHRlbGxzIGlmIHRoZSBJbnB1dCB3YXMgcmVxdWlyZWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmF0dHJzLnd3LnJlcXVpcmVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhhc0NsYXNzIHF1ZXJpZXMgd2hldGhlciBhIGNsYXNzIGV4aXN0cyBvbiB0aGUgcm9vdCBlbGVtZW50IG9uIG5vdC5cbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSwgKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5jbGFzc05hbWUuc3BsaXQoJyAnKS5pbmRleE9mKGNscykgPT09IC0xO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NsYXNzKElOUFVUX0VSUk9SKTtcbiAgICB9O1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5oYXNXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhJTlBVVF9XQVJOSU5HKTtcbiAgICB9O1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5oYXNTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhJTlBVVF9TVUNDRVNTKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldEhlbHBUZXh0IHNldHMgdGhlIG1lc3NhZ2UgZm9yIHRoZSBtZXNzYWdlIHBvcnRpb24gb2ZcbiAgICAgKiB0aGlzIGlucHV0LlxuICAgICAqL1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zZXRIZWxwVGV4dCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaGVscC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobXNnKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcGxhY2VDaGlsZChub2RlLCBtZXNzYWdlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgfTtcbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMucm9vdC5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZChzdGF0ZSk7IH0pXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlU3RhdGUgcmVtb3ZlcyB0aGUgc3RhdGUgdmFsaWRhdGlvbiBzdGF0ZSBmcm9tIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVtb3ZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLnJvb3QuaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoSU5QVVRfU1VDQ0VTUyk7XG4gICAgICAgICAgICBoLmNsYXNzTGlzdC5yZW1vdmUoSU5QVVRfRVJST1IpO1xuICAgICAgICAgICAgaC5jbGFzc0xpc3QucmVtb3ZlKElOUFVUX1dBUk5JTkcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHN0YXRlXG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53dy5zdWNjZXNzID9cbiAgICAgICAgICAgICdoYXMtc3VjY2VzcycgOlxuICAgICAgICAgICAgdGhpcy5hdHRycy53dy5lcnJvciA/XG4gICAgICAgICAgICAgICAgJ2hhcy1lcnJvcicgOlxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnMud3cud2FybmluZyA/XG4gICAgICAgICAgICAgICAgICAgICdoYXMtd2FybmluZycgOlxuICAgICAgICAgICAgICAgICAgICAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldFN1Y2Nlc3NcbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0U3VjY2VzcyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAucmVtb3ZlU3RhdGUoKVxuICAgICAgICAgICAgLnNldEhlbHBUZXh0KG1lc3NhZ2UpXG4gICAgICAgICAgICAuc2V0U3RhdGUoSU5QVVRfU1VDQ0VTUyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRFcnJvclxuICAgICAqL1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zZXRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAucmVtb3ZlU3RhdGUoKVxuICAgICAgICAgICAgLnNldEhlbHBUZXh0KG1lc3NhZ2UpXG4gICAgICAgICAgICAuc2V0U3RhdGUoSU5QVVRfRVJST1IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0V2FybmluZ1xuICAgICAqL1xuICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zZXRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5yZW1vdmVTdGF0ZSgpXG4gICAgICAgICAgICAuc2V0SGVscFRleHQobWVzc2FnZSlcbiAgICAgICAgICAgIC5zZXRTdGF0ZShJTlBVVF9XQVJOSU5HKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlc2V0XG4gICAgICovXG4gICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5oZWxwLmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlU3RhdGUoKTtcbiAgICAgICAgICAgIHdoaWxlIChtLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgbS5yZW1vdmVDaGlsZChtLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgLy8gIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZW5kZXJlZCBjaGVja3MgaWYgdGhlIGlucHV0IHNob3VsZCBoYXZlIGEgdmFsaWRhdGlvbiBzdGF0ZSBzZXRcbiAgICAgKi9cbiAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuYXR0cnMud3csIHN1Y2Nlc3MgPSBfYS5zdWNjZXNzLCBlcnJvciA9IF9hLmVycm9yLCB3YXJuaW5nID0gX2Eud2FybmluZztcbiAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLnNldFN1Y2Nlc3MoKHR5cGVvZiBzdWNjZXNzID09PSAnc3RyaW5nJykgPyBzdWNjZXNzIDogJycpO1xuICAgICAgICBlbHNlIGlmIChlcnJvcilcbiAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpID8gZXJyb3IgOiAnJyk7XG4gICAgICAgIGVsc2UgaWYgKHdhcm5pbmcpXG4gICAgICAgICAgICB0aGlzLnNldFdhcm5pbmcoKHR5cGVvZiB3YXJuaW5nID09PSAnc3RyaW5nJykgPyB3YXJuaW5nIDogJycpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1Db250cm9sO1xufShDb250cm9sXzEuQ29udHJvbCkpO1xuZXhwb3J0cy5Gb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ybUNvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9hdXRvY29tcGxldGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgbHVyY2hfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvbHVyY2hcIik7XG5leHBvcnRzLkVTQ0FQRSA9IDI3O1xuZXhwb3J0cy5JTlBVVF9JRCA9ICdpbnB1dCc7XG4vKipcbiAqIEF1dG9jb21wbGF0ZSBwcm92aWRlcyBhbiBpbnB1dCB3aXRoIGEgZHJvcGRvd24gbWVudSB0aGF0IGFsbG93c1xuICogdGhlIHVzZXIgdG8gc2VhcmNoIGFuZCBzZWxlY3QgZm9ybSBhIGxpc3Qgb2Ygb3B0aW9ucy5cbiAqL1xudmFyIEF1dG9jb21wbGV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXV0b2NvbXBsZXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1dG9jb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0ge1xuICAgICAgICAgICAgcG9wdWxhdGVkOiAoX3RoaXMuYXR0cnMud3cucG9wdWxhdGVkKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucG9wdWxhdGVkIDogdmlld3MucG9wdWxhdGVkLFxuICAgICAgICAgICAgZW1wdHk6IChfdGhpcy5hdHRycy53dy5lbXB0eSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmVtcHR5IDogdmlld3MuZW1wdHlcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgbWVudTogJ21lbnUnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtZXNhZ2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJycsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuU0VBUkNILCBfdGhpcy5hdHRycy53dy5jbGFzcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWxwOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBfdGhpcy5hdHRycy53dy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfdGhpcy5hdHRycy53dy5lcnJvcixcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiBfdGhpcy5hdHRycy53dy53YXJuaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudToge1xuICAgICAgICAgICAgICAgIGlkOiAnbWVudSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LmxhYmVsIHx8ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdCgnZm9ybS1jb250cm9sJywgX3RoaXMuYXR0cnMud3cuaW5wdXRDbGFzcyksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cucGxhY2Vob2xkZXIgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogX3RoaXMub25LZXlEb3duLFxuICAgICAgICAgICAgICAgIG9uS2V5VXA6IF90aGlzLm9uS2V5VXAsXG4gICAgICAgICAgICAgICAgb25JbnB1dDogX3RoaXMub25JbnB1dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlYXJjaDoge1xuICAgICAgICAgICAgICAgIGRlbGF5OiBfdGhpcy5hdHRycy53dy5kZWJvdW5jZSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmRlYm91bmNlIDogX3RoaXMuREVGQVVMVF9ERUJPVU5DRV9USU1FLFxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBfdGhpcy50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnk6IF90aGlzLmF0dHJzLnd3LnN0cmluZ2lmaWVyID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuc3RyaW5naWZpZXIgOiBfdGhpcy5zdHJpbmdpZnksXG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmNsb3NlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uU2VsZWN0KG5ldyBsdXJjaF8xLkl0ZW1TZWxlY3RlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUsIF90aGlzLnZhbHVlcy5zZWFyY2gucmVzdWx0c1tOdW1iZXIoaW5kZXgpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5tZW51KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zaG93KCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQubWVudSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uaGlkZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsdWVzLnNlYXJjaC5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5tZW51KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRDb250ZW50KG5ldyB2aWV3cy5SZXN1bHRzKF90aGlzKSkuc2hvdygpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0b2NvbXBsZXRlO1xufShsdXJjaF8xLlNlYXJjaENvbnRyb2wpKTtcbmV4cG9ydHMuQXV0b2NvbXBsZXRlID0gQXV0b2NvbXBsZXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0b2NvbXBsZXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEF1dG9jb21wbGV0ZV8xID0gcmVxdWlyZShcIi4vQXV0b2NvbXBsZXRlXCIpO1xuZXhwb3J0cy5BdXRvY29tcGxldGUgPSBBdXRvY29tcGxldGVfMS5BdXRvY29tcGxldGU7XG52YXIgbHVyY2hfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvbHVyY2hcIik7XG5leHBvcnRzLkl0ZW1TZWxlY3RlZEV2ZW50ID0gbHVyY2hfMS5JdGVtU2VsZWN0ZWRFdmVudDtcbmV4cG9ydHMuVGVybUNoYW5nZWRFdmVudCA9IGx1cmNoXzEuVGVybUNoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWVudV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbWVudS9NZW51XCIpO1xuO1xudmFyIE1lbnVJdGVtXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9tZW51L01lbnVJdGVtXCIpO1xuO1xudmFyIEZyYWdtZW50XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9sYXlvdXQvZnJhZ21lbnQvRnJhZ21lbnRcIik7XG47XG47XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL3dtbFwiKTtcbmV4cG9ydHMucG9wdWxhdGVkID0gZnVuY3Rpb24gKG9wdGlvbiwgX2luZGV4LCBfb3B0aW9ucykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLml0ZW0uc3RyaW5naWZ5KG9wdGlvbikpOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLmRvbWlmeShcIk5vIHJlc3VsdHMgdG8gZGlzcGxheS5cIik7IH07IH07IH07XG47XG52YXIgUmVzdWx0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzdWx0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN1bHRzKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoRnJhZ21lbnRfMS5GcmFnbWVudCwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwubWFwKF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5yZXN1bHRzLCBmdW5jdGlvbiBfbWFwKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoTWVudUl0ZW1fMS5NZW51SXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IChcIlwiICsgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19fY29udGV4dC52YWx1ZXMuaXRlbS5jbGljayhpbmRleCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuaXRlbS50ZW1wbGF0ZS5wb3B1bGF0ZWQob3B0aW9uLCBpbmRleCwgX19fY29udGV4dC52YWx1ZXMuc2VhcmNoLnJlc3VsdHMpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuaXRlbS50ZW1wbGF0ZS5lbXB0eSgpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXN1bHRzO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5SZXN1bHRzID0gUmVzdWx0cztcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KHdtbF8xLmxhYmVsKF9fX2NvbnRleHQudmFsdWVzLmxhYmVsLmlkLCBfX19jb250ZXh0LnZhbHVlcy5sYWJlbC50ZXh0KShfX192aWV3KSksIF9fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29ua2V5ZG93bic6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmtleXVwJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25LZXlVcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmlucHV0JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQuaWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLndpZGdldChNZW51XzEuTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5tZW51LmlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlkZGVuJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwuZG9taWZ5KHdtbF8xLm1lc3NhZ2UoX19fY29udGV4dC52YWx1ZXMuaGVscC5pZCwgX19fY29udGV4dC52YWx1ZXMuaGVscCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b2NvbXBsZXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbi8qKlxuICogQnV0dG9uQ2hhbmdlZEV2ZW50XG4gKi9cbnZhciBCdXR0b25DaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbkNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25DaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvbkNoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLkJ1dHRvbkNoYW5nZWRFdmVudCA9IEJ1dHRvbkNoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbkNoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQnV0dG9uQ2hhbmdlZEV2ZW50XCIpO1xudmFyIEJ1dHRvblNlbGVjdEdyb3VwXzEgPSByZXF1aXJlKFwiLi9CdXR0b25TZWxlY3RHcm91cFwiKTtcbnZhciBNYXliZV8xID0gcmVxdWlyZShcImFmcGwvbGliL21vbmFkL01heWJlXCIpO1xuLyoqXG4gKiBCdXR0b25TZWxlY3RcbiAqL1xudmFyIEJ1dHRvblNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uU2VsZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblNlbGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUuZnJvbUFueSh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnNlbGVjdC52YWx1ZSA9IE1heWJlXzEuTWF5YmUuZnJvbUFueSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUub25DaGFuZ2UobmV3IEJ1dHRvbkNoYW5nZWRFdmVudF8xLkJ1dHRvbkNoYW5nZWRFdmVudCh0aGlzLmF0dHJzLnd3Lm5hbWUsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBCdXR0b25TZWxlY3QucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuc2VsZWN0LnZhbHVlLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHY7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdDtcbn0oQnV0dG9uU2VsZWN0R3JvdXBfMS5CdXR0b25TZWxlY3RHcm91cCkpO1xuZXhwb3J0cy5CdXR0b25TZWxlY3QgPSBCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXR0b25TZWxlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tc2VsZWN0XCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEJ1dHRvblNlbGVjdEdyb3VwXG4gKi9cbnZhciBCdXR0b25TZWxlY3RHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uU2VsZWN0R3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnV0dG9uU2VsZWN0R3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogbmFtZXMuQlVUVE9OX1NFTEVDVFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2hlbHAnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF90aGlzLmF0dHJzLnd3LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF90aGlzLmF0dHJzLnd3LmVycm9yLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IF90aGlzLmF0dHJzLnd3Lndhcm5pbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuaW5pdGlhbGl6ZShfdGhpcy5hdHRycy53dy52YWx1ZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX3RoaXMuYXR0cnMud3cub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuaXNTZWxlY3RlZCh2KTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xpY2sodik7IH07IH0sXG4gICAgICAgICAgICBjYWxjdWxhdGVDbGFzczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbmNhdChuYW1lcy5CVVRUT05fU0VMRUNUX09QVElPTiwgY2xhc3NOYW1lLCAoX3RoaXMuYXR0cnMud3cudmFyaWFudCkgPyBfdGhpcy5hdHRycy53dy52YXJpYW50IDogbmFtZXMuREVGQVVMVCwgX3RoaXMudmFsdWVzLnNlbGVjdC5pc1NlbGVjdGVkKHZhbHVlKSA/IG5hbWVzLkFDVElWRSA6ICcnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvblNlbGVjdEdyb3VwO1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuQnV0dG9uU2VsZWN0R3JvdXAgPSBCdXR0b25TZWxlY3RHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvblNlbGVjdEdyb3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnV0dG9uQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9CdXR0b25DaGFuZ2VkRXZlbnRcIik7XG52YXIgQnV0dG9uU2VsZWN0R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0J1dHRvblNlbGVjdEdyb3VwXCIpO1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiYWZwbC9saWIvbW9uYWQvTWF5YmVcIik7XG4vKipcbiAqIE11bHRpQnV0dG9uU2VsZWN0XG4gKi9cbnZhciBNdWx0aUJ1dHRvblNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlCdXR0b25TZWxlY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlCdXR0b25TZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTXVsdGlCdXR0b25TZWxlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQW55KHYpLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQXJyYXkoW10pOyB9LCBmdW5jdGlvbiAodikgeyByZXR1cm4gTWF5YmVfMS5NYXliZS5mcm9tQXJyYXkodik7IH0pO1xuICAgIH07XG4gICAgTXVsdGlCdXR0b25TZWxlY3QucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YWx1ZXMuc2VsZWN0LnZhbHVlID0gdGhpc1xuICAgICAgICAgICAgLnZhbHVlc1xuICAgICAgICAgICAgLnNlbGVjdFxuICAgICAgICAgICAgLnZhbHVlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHZhbHVlLmluZGV4T2Yodik7XG4gICAgICAgICAgICBpZiAocG9zID4gLTEpXG4gICAgICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2KTtcbiAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uQ2hhbmdlKG5ldyBCdXR0b25DaGFuZ2VkRXZlbnRfMS5CdXR0b25DaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgdmFsdWUuc2xpY2UoKSkpO1xuICAgICAgICAgICAgX3RoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt2XTsgfSk7XG4gICAgfTtcbiAgICBNdWx0aUJ1dHRvblNlbGVjdC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5zZWxlY3QudmFsdWUuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5pbmRleE9mKHYpID4gLTE7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpQnV0dG9uU2VsZWN0O1xufShCdXR0b25TZWxlY3RHcm91cF8xLkJ1dHRvblNlbGVjdEdyb3VwKSk7XG5leHBvcnRzLk11bHRpQnV0dG9uU2VsZWN0ID0gTXVsdGlCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aUJ1dHRvblNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCdXR0b25TZWxlY3RHcm91cF8xID0gcmVxdWlyZShcIi4vQnV0dG9uU2VsZWN0R3JvdXBcIik7XG5leHBvcnRzLkJ1dHRvblNlbGVjdEdyb3VwID0gQnV0dG9uU2VsZWN0R3JvdXBfMS5CdXR0b25TZWxlY3RHcm91cDtcbnZhciBCdXR0b25TZWxlY3RfMSA9IHJlcXVpcmUoXCIuL0J1dHRvblNlbGVjdFwiKTtcbmV4cG9ydHMuQnV0dG9uU2VsZWN0ID0gQnV0dG9uU2VsZWN0XzEuQnV0dG9uU2VsZWN0O1xudmFyIEJ1dHRvbkNoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQnV0dG9uQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5CdXR0b25DaGFuZ2VkRXZlbnQgPSBCdXR0b25DaGFuZ2VkRXZlbnRfMS5CdXR0b25DaGFuZ2VkRXZlbnQ7XG52YXIgTXVsdGlCdXR0b25TZWxlY3RfMSA9IHJlcXVpcmUoXCIuL011bHRpQnV0dG9uU2VsZWN0XCIpO1xuZXhwb3J0cy5NdWx0aUJ1dHRvblNlbGVjdCA9IE11bHRpQnV0dG9uU2VsZWN0XzEuTXVsdGlCdXR0b25TZWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEJ1dHRvbl8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9idXR0b24vQnV0dG9uXCIpO1xuO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9wdGlvbnMsIGZ1bmN0aW9uIF9tYXAob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEJ1dHRvbl8xLkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jYWxjdWxhdGVDbGFzcyhvcHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBfX19jb250ZXh0LnZhbHVlcy5zZWxlY3QuaXNTZWxlY3RlZChvcHQudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuY2xpY2sob3B0LnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IG9wdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgfSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tc2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRlbnQvR3JvdXBcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnV0dG9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBHcm91cCBtdWx0aXBsZSBidXR0b25zIGludG8gb25lIGVsZW1lbnQuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkdyb3VwKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdidG4tZ3JvdXAnLCAoX3RoaXMuYXR0cnMud3cpID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JvdXA7XG59KEcuR3JvdXApKTtcbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbjtcbi8qKlxuICogQnV0dG9uIGlzIGFuIGltcHJvdmVtZW50IG92ZXIgSFRNTEJ1dHRpb25FbGVtZW50XG4gKi9cbnZhciBCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLkJ1dHRvbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uOiAnYnV0dG9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dyA/XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jb25jYXQobmFtZXMuQlVUVE9OLCBfdGhpcy5hdHRycy53dy52YXJpYW50IHx8IG5hbWVzLkRFRkFVTFQsIF90aGlzLmF0dHJzLnd3LnN0eWxlLCBfdGhpcy5hdHRycy53dy5hY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuQUNUSVZFIDogJycsIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA6XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLkJVVFRPTixcbiAgICAgICAgICAgICAgICB0eXBlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudHlwZSkgPyBfdGhpcy5hdHRycy53dy50eXBlIDogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgbmFtZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID8gX3RoaXMuYXR0cnMud3cubmFtZSA6ICcnLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQpID8gX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKSA/IF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sgOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID8gX3RoaXMuYXR0cnMud3cudGV4dCA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSB0aGlzIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBlbmFibGUgdGhpcyBidXR0b24uXG4gICAgICovXG4gICAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfSk7XG4gICAgfTtcbiAgICBCdXR0b24ucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdHRycy53dylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzLnd3LmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5idXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b247XG59KEcuR3JvdXApKTtcbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcm91cDtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbjtcbnZhciBCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYnV0dG9uLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbmNsaWNrXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogXCJidXR0b25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZXh0KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b247XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgY2hlY2tib3hfMSA9IHJlcXVpcmUoXCIuL3dtbC9jaGVja2JveFwiKTtcbnZhciBDaGVja2JveENoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQ2hlY2tib3hDaGFuZ2VkRXZlbnRcIik7XG4vKipcbiAqIENoZWNrYm94IGNvbnRyb2wuXG4gKlxuICogVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgbmF0aXZlIGNoZWNrYm94IHRoYXQgY2FuIGJlIHN0eWxlZC5cbiAqL1xudmFyIENoZWNrYm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja2JveCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgY2hlY2tib3hfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5DSEVDS0JPWCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogX3RoaXMuYXR0cnMud3cuY2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQuY2hlY2tlZCA9ICFfdGhpcy52YWx1ZXMuaW5wdXQuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25DaGFuZ2UobmV3IENoZWNrYm94Q2hhbmdlZEV2ZW50XzEuQ2hlY2tib3hDaGFuZ2VkRXZlbnQoX3RoaXMudmFsdWVzLmlucHV0Lm5hbWUsIF90aGlzLnZhbHVlcy5pbnB1dC5jaGVja2VkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNoZWNrYm94ID0gQ2hlY2tib3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGVja2JveC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV2ZW50XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL0V2ZW50XCIpO1xuLyoqXG4gKiBDaGVja2JveENoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBjaGVja2JveCBzdGF0ZS5cbiAqL1xudmFyIENoZWNrYm94Q2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja2JveENoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveENoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hlY2tib3hDaGFuZ2VkRXZlbnQ7XG59KEV2ZW50XzEuRXZlbnQpKTtcbmV4cG9ydHMuQ2hlY2tib3hDaGFuZ2VkRXZlbnQgPSBDaGVja2JveENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoZWNrYm94Q2hhbmdlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2xhYmVsJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjaGVja2VkJzogKF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmNoZWNrZWQgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9kYXRlXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBEYXRlQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9EYXRlQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5mb3JtYXQgPSB7XG4gICAgWVlZWURETU06ICdZWVlZLU1NLUREJyxcbiAgICBERDogJ0REJyxcbiAgICBNTTogJ01NJyxcbiAgICBZWVlZOiAnWVlZWSdcbn07XG5leHBvcnRzLk1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbjtcbnZhciBfaW5wdXRWYWx1ZXMgPSBmdW5jdGlvbiAoaWQsIGtsYXNzLCB2YWx1ZSwgZGF0ZSwgY2IpIHsgcmV0dXJuICh7XG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzOiBrbGFzcyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGlzYWJsZWQ6IChkYXRlLmF0dHJzLnd3LmRpc2FibGVkID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgIHJlYWRPbmx5OiAoZGF0ZS5hdHRycy53dy5yZWFkT25seSA9PT0gdHJ1ZSkgPyB0cnVlIDogbnVsbCxcbiAgICBvbklucHV0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIGNiKHZhbHVlKTtcbiAgICAgICAgZGF0ZS5kYXRlLnZhbHVlID0gZGF0ZS5jYWxjdWxhdGUoKTtcbiAgICAgICAgZGF0ZS5maXJlQ2hhbmdlKCk7XG4gICAgfVxufSk7IH07XG52YXIgX3ByZWZpeCA9IGZ1bmN0aW9uIChzLCBpbmMpIHtcbiAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gZmFsc2U7IH1cbiAgICB2YXIgbiA9IE51bWJlcihzKTtcbiAgICBpZiAoaW5jKVxuICAgICAgICBuID0gbiArIDE7XG4gICAgaWYgKGlzTmFOKG4pKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIChuIDwgMTApID8gXCIwXCIgKyBuIDogXCJcIiArIG47XG59O1xuLyoqXG4gKiBEYXRlIGlucHV0LlxuICovXG52YXIgRGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy5kZWxlZ2F0ZSA6IG5ldyBjb250cm9sXzEuRGVmYXVsdERlbGVnYXRlKF90aGlzLmF0dHJzLnd3KTtcbiAgICAgICAgX3RoaXMuZGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSA/IG1vbWVudChfdGhpcy5hdHRycy53dy52YWx1ZSwgZXhwb3J0cy5mb3JtYXQuWVlZWURETU0pIDogbnVsbCxcbiAgICAgICAgICAgIHNlcDogJy0nLFxuICAgICAgICAgICAgZm9ybWF0OiBleHBvcnRzLmZvcm1hdC5ZWVlZRERNTVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdChuYW1lcy5EQVRFLCAnZm9ybS1ncm91cCcsIF90aGlzLmF0dHJzLnd3LmNsYXNzLCBfdGhpcy5zdGF0ZSgpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmxpbmU6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm0taW5saW5lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBtb250aHM6IGV4cG9ydHMuTU9OVEhTLm1hcChmdW5jdGlvbiAobGFiZWwsIHZhbHVlKSB7IHJldHVybiAoeyBsYWJlbDogbGFiZWwsIHZhbHVlOiBfcHJlZml4KHZhbHVlICsgMSkgfSk7IH0pLFxuICAgICAgICAgICAgICAgIHByZWZpeDogX3ByZWZpeFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGVnYXRlOiBfdGhpcy5kZWxlZ2F0ZSxcbiAgICAgICAgICAgIGRheTogX2lucHV0VmFsdWVzKCdkYXknLCBuYW1lcy5EQVRFX0RBWSwgKF90aGlzLmRhdGUudmFsdWUgJiYgX3RoaXMuZGF0ZS52YWx1ZS5pc1ZhbGlkKCkpID9cbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlLnZhbHVlLmZvcm1hdChleHBvcnRzLmZvcm1hdC5ERCkgOiAnJywgX3RoaXMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy52YWx1ZXMuZGF5LnZhbHVlID0gX3ByZWZpeCh2KTsgfSksXG4gICAgICAgICAgICBtb250aDogX2lucHV0VmFsdWVzKCdtb250aCcsIG5hbWVzLkRBVEVfTU9OVEgsIChfdGhpcy5kYXRlLnZhbHVlICYmIF90aGlzLmRhdGUudmFsdWUuaXNWYWxpZCgpKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0ZS52YWx1ZS5mb3JtYXQoZXhwb3J0cy5mb3JtYXQuTU0pIDogJycsIF90aGlzLCBmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMudmFsdWVzLm1vbnRoLnZhbHVlID0gdjsgfSksXG4gICAgICAgICAgICB5ZWFyOiBfaW5wdXRWYWx1ZXMoJ3llYXInLCBuYW1lcy5EQVRFX1lFQVIsIChfdGhpcy5kYXRlLnZhbHVlICYmIF90aGlzLmRhdGUudmFsdWUuaXNWYWxpZCgpKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0ZS52YWx1ZS5mb3JtYXQoZXhwb3J0cy5mb3JtYXQuWVlZWSkgOiAnJywgX3RoaXMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy52YWx1ZXMueWVhci52YWx1ZSA9IHY7IH0pLFxuICAgICAgICAgICAgbmFtZTogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2hlbHBzJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBfdGhpcy5hdHRycy53dy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfdGhpcy5hdHRycy53dy5lcnJvcixcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiBfdGhpcy5hdHRycy53dy53YXJuaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy5sYWJlbCB8fCAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXRzLlxuICAgICAqL1xuICAgIERhdGUucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBbXG4gICAgICAgICAgICB0aGlzLnZhbHVlcy55ZWFyLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZXMubW9udGgudmFsdWUsXG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXkudmFsdWVcbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQ7IH0pO1xuICAgICAgICByZXR1cm4gKGRhdGUubGVuZ3RoICE9IDMpID8gbnVsbCA6IG1vbWVudChkYXRlLmpvaW4odGhpcy5kYXRlLnNlcCksIG1vbWVudC5JU09fODYwMSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogZmlyZUNoYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGF0ZS5wcm90b3R5cGUuZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZS52YWx1ZSAmJiB0aGlzLmRhdGUudmFsdWUuaXNWYWxpZCgpKVxuICAgICAgICAgICAgdGhpcy52YWx1ZXMuZGVsZWdhdGUub25DaGFuZ2UobmV3IERhdGVDaGFuZ2VkRXZlbnRfMS5EYXRlQ2hhbmdlZEV2ZW50KHRoaXMudmFsdWVzLm5hbWUsIHRoaXMuZGF0ZS52YWx1ZS5mb3JtYXQodGhpcy5kYXRlLmZvcm1hdCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlO1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuRGF0ZSA9IERhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXZlbnRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvRXZlbnRcIik7XG4vKipcbiAqIERhdGVDaGFuZ2VkRXZlbnQgaXMgZ2VuZXJhdGVkIHdoZW4gdGhlIGRhdGUgaGFzXG4gKiBiZWVuIGNoYW5nZWQgdG8gYSB2YWxpZCBkYXRlLlxuICovXG52YXIgRGF0ZUNoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZUNoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlQ2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEYXRlQ2hhbmdlZEV2ZW50O1xufShFdmVudF8xLkV2ZW50KSk7XG5leHBvcnRzLkRhdGVDaGFuZ2VkRXZlbnQgPSBEYXRlQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZUNoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHNlbGVjdF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9zZWxlY3RcIik7XG47XG52YXIgdGV4dF9maWVsZF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC90ZXh0LWZpZWxkXCIpO1xuO1xuO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeSh3bWxfMS5sYWJlbChfX19jb250ZXh0LnZhbHVlcy5sYWJlbC5pZCwgX19fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCkoX19fdmlldykpLCBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5pbmxpbmUuY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHNlbGVjdF8xLlNlbGVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25DaGFuZ2UnOiBfX19jb250ZXh0LnZhbHVlcy5tb250aC5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLm1vbnRoLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWFkT25seSc6IF9fX2NvbnRleHQudmFsdWVzLm1vbnRoLnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLm1vbnRoLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJzogX19fY29udGV4dC52YWx1ZXMuZGF0ZS5tb250aHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdvcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZWQnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLnRleHQoXCJNb250aFwiKV0sIF9fX3ZpZXcpXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQodGV4dF9maWVsZF8xLlRleHRGaWVsZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5kYXkuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuZGF5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLmRheS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZWQnOiBfX19jb250ZXh0LnZhbHVlcy5kYXkuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRPbmx5JzogX19fY29udGV4dC52YWx1ZXMuZGF5LnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmRheS5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInOiBcIkREXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpLCBfX193bWwud2lkZ2V0KHRleHRfZmllbGRfMS5UZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMueWVhci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLnllYXIub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLnllYXIuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRPbmx5JzogX19fY29udGV4dC52YWx1ZXMueWVhci5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy55ZWFyLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcic6IFwiWVlZWVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLmRvbWlmeSh3bWxfMS5tZXNzYWdlKF9fX2NvbnRleHQudmFsdWVzLmhlbHAuaWQsIF9fX2NvbnRleHQudmFsdWVzLmhlbHApKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgaWNvbl9idXR0b25fMSA9IHJlcXVpcmUoXCIuL3dtbC9pY29uLWJ1dHRvblwiKTtcbi8qKlxuICogSWNvbkJ1dHRvbiBwcm92aWRlcyBhICdoYW1idXJnZXInIG1lbnUgYnV0dG9uLlxuICovXG52YXIgSWNvbkJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWNvbkJ1dHRvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJY29uQnV0dG9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyBpY29uX2J1dHRvbl8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLklDT05fQlVUVE9OXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHV0aWxfMS5jb25jYXQobmFtZXMuSUNPTl9CVVRUT04sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cub25DbGljaykgPyBfdGhpcy5hdHRycy53dy5vbkNsaWNrIDogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEljb25CdXR0b247XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5JY29uQnV0dG9uID0gSWNvbkJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUljb25CdXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy5idXR0b24ub25DbGlja1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pY29uLWJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5leHBvcnRzLkV2ZW50ID0gRXZlbnRfMS5FdmVudDtcbnZhciBEZWZhdWx0RGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHREZWxlZ2F0ZVwiKTtcbmV4cG9ydHMuRGVmYXVsdERlbGVnYXRlID0gRGVmYXVsdERlbGVnYXRlXzEuRGVmYXVsdERlbGVnYXRlO1xudmFyIENvbnRyb2xfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xcIik7XG5leHBvcnRzLkNvbnRyb2wgPSBDb250cm9sXzEuQ29udHJvbDtcbnZhciBGb3JtQ29udHJvbF8xID0gcmVxdWlyZShcIi4vRm9ybUNvbnRyb2xcIik7XG5leHBvcnRzLkZvcm1Db250cm9sID0gRm9ybUNvbnRyb2xfMS5Gb3JtQ29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbnZhciBJdGVtU2VsZWN0ZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlbVNlbGVjdGVkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbVNlbGVjdGVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEl0ZW1TZWxlY3RlZEV2ZW50O1xufShjb250cm9sXzEuRXZlbnQpKTtcbmV4cG9ydHMuSXRlbVNlbGVjdGVkRXZlbnQgPSBJdGVtU2VsZWN0ZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZW1TZWxlY3RlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgVGVybUNoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vVGVybUNoYW5nZWRFdmVudFwiKTtcbnZhciBTZWFyY2hEZWZhdWx0RGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaERlZmF1bHREZWxlZ2F0ZVwiKTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuZXhwb3J0cy5FU0NBUEUgPSAyNztcbmV4cG9ydHMuREVGQVVMVF9ERUJPVU5DRV9USU1FID0gNTAwO1xuZXhwb3J0cy5JTlBVVF9JRCA9ICdpbnB1dCc7XG4vKipcbiAqIFNlYXJjaENvbnRyb2xcbiAqL1xudmFyIFNlYXJjaENvbnRyb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlYXJjaENvbnRyb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VhcmNoQ29udHJvbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfREVCT1VOQ0VfVElNRSA9IGV4cG9ydHMuREVGQVVMVF9ERUJPVU5DRV9USU1FO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IF90aGlzLmF0dHJzLnd3LmRlbGVnYXRlID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmRlbGVnYXRlIDogbmV3IFNlYXJjaERlZmF1bHREZWxlZ2F0ZV8xLlNlYXJjaERlZmF1bHREZWxlZ2F0ZShfdGhpcy5hdHRycy53dyk7XG4gICAgICAgIF90aGlzLnJlc3VsdHMgPSBbXTtcbiAgICAgICAgX3RoaXMub25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLmtleUNvZGUgIT09IGV4cG9ydHMuRVNDQVBFKSA/IF90aGlzLmV4ZWN1dGUobnVsbCkgOiBudWxsOyB9O1xuICAgICAgICBfdGhpcy5vbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IGV4cG9ydHMuRVNDQVBFKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbklucHV0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vRm9yIGNvbXBhdGFiaWxpdHkgcmVhc29uc1xuICAgICAgICAgICAgZS50YXJnZXQub25rZXlkb3duID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm9uS2V5RG93bihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY3V0ZSA9IHV0aWxfMS5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pbnB1dC5pZClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vblNlYXJjaChuZXcgVGVybUNoYW5nZWRFdmVudF8xLlRlcm1DaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBfdGhpcy5hdHRycy53dy5kZWJvdW5jZSB8fCBfdGhpcy5ERUZBVUxUX0RFQk9VTkNFX1RJTUUpO1xuICAgICAgICBfdGhpcy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gU3RyaW5nKHYpOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlYXJjaENvbnRyb2wucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgIH07XG4gICAgU2VhcmNoQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QuY29udGFpbnMoZS50YXJnZXQpKVxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaENvbnRyb2w7XG59KGNvbnRyb2xfMS5Gb3JtQ29udHJvbCkpO1xuZXhwb3J0cy5TZWFyY2hDb250cm9sID0gU2VhcmNoQ29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlYXJjaENvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuLyoqXG4gKiBTZWFyY2hEZWZhdWx0RGVsZWdhdGUgZm93YXJkcyBhbGwgZXZlbnRzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIGZ1bmN0aW9uIGhhbmRsZXJzLCBzcGVjaWZlZCBvbiB0aGUgYXR0cmlidXRlcyBvZiBhIGNvbnRyb2wuXG4gKi9cbnZhciBTZWFyY2hEZWZhdWx0RGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlYXJjaERlZmF1bHREZWxlZ2F0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hEZWZhdWx0RGVsZWdhdGUoYXR0cnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYXR0cnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIF90aGlzLm9uU2VhcmNoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hdHRycy5vblNlYXJjaClcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy5vblNlYXJjaChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TZWxlY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmF0dHJzLm9uU2VsZWN0KVxuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLm9uU2VsZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZWFyY2hEZWZhdWx0RGVsZWdhdGU7XG59KGNvbnRyb2xfMS5EZWZhdWx0RGVsZWdhdGUpKTtcbmV4cG9ydHMuU2VhcmNoRGVmYXVsdERlbGVnYXRlID0gU2VhcmNoRGVmYXVsdERlbGVnYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoRGVmYXVsdERlbGVnYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbFwiKTtcbi8qKlxuICogVGVybUNoYW5nZWRFdmVudCBzaWduYWxzIHRoZSBzZWFyY2ggdGVybSBoYXMgY2hhbmdlZC5cbiAqL1xudmFyIFRlcm1DaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlcm1DaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVybUNoYW5nZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGVybUNoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLlRlcm1DaGFuZ2VkRXZlbnQgPSBUZXJtQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVybUNoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTZWFyY2hDb250cm9sXzEgPSByZXF1aXJlKFwiLi9TZWFyY2hDb250cm9sXCIpO1xuZXhwb3J0cy5TZWFyY2hDb250cm9sID0gU2VhcmNoQ29udHJvbF8xLlNlYXJjaENvbnRyb2w7XG52YXIgU2VhcmNoRGVmYXVsdERlbGVnYXRlXzEgPSByZXF1aXJlKFwiLi9TZWFyY2hEZWZhdWx0RGVsZWdhdGVcIik7XG5leHBvcnRzLlNlYXJjaERlZmF1bHREZWxlZ2F0ZSA9IFNlYXJjaERlZmF1bHREZWxlZ2F0ZV8xLlNlYXJjaERlZmF1bHREZWxlZ2F0ZTtcbnZhciBJdGVtU2VsZWN0ZWRFdmVudF8xID0gcmVxdWlyZShcIi4vSXRlbVNlbGVjdGVkRXZlbnRcIik7XG5leHBvcnRzLkl0ZW1TZWxlY3RlZEV2ZW50ID0gSXRlbVNlbGVjdGVkRXZlbnRfMS5JdGVtU2VsZWN0ZWRFdmVudDtcbnZhciBUZXJtQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9UZXJtQ2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5UZXJtQ2hhbmdlZEV2ZW50ID0gVGVybUNoYW5nZWRFdmVudF8xLlRlcm1DaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3NlYXJjaC1zdGFja1wiKTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuLyoqXG4gKiBTZWFyY2hTdGFja1xuICovXG52YXIgU2VhcmNoU3RhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlYXJjaFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaFN0YWNrKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogJ3NlYXJjaCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ21lc3NhZ2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGlkOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6IG5hbWVzLlNFQVJDSF9TVEFDS1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlbHA6IHtcbiAgICAgICAgICAgICAgICBpZDogJ2hlbHAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBmdW5jdGlvbiAoZXZ0KSB7IGlmIChfdGhpcy5hdHRycy53dy5vblNlYXJjaClcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cub25TZWFyY2goZXZ0KTsgfSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdzdGFjaycsXG4gICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cnMud3cudmFsdWUsXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBfdGhpcy5hdHRycy53dy5kZWNvcmF0b3IgPyBfdGhpcy5hdHRycy53dy5kZWNvcmF0b3IgOiBmdW5jdGlvbiAodikgeyByZXR1cm4gU3RyaW5nKHYpOyB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vbkNoYW5nZShldnQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBTZWFyY2hTdGFjay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5zZWFyY2guaWQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVwZGF0ZShsaXN0KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcHVzaCBhIHZhbHVlIG9udG8gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIFNlYXJjaFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5zdGFjay5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucHVzaCh2KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaFN0YWNrO1xufShjb250cm9sXzEuRm9ybUNvbnRyb2wpKTtcbmV4cG9ydHMuU2VhcmNoU3RhY2sgPSBTZWFyY2hTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlYXJjaFN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgYXV0b2NvbXBsZXRlXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sL2F1dG9jb21wbGV0ZVwiKTtcbjtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC9zdGFja1wiKTtcbjtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KHN0YWNrXzEuU3RhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2suaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuc3RhY2submFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlY29yYXRvcic6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbkNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIF9fX3dtbC53aWRnZXQoYXV0b2NvbXBsZXRlXzEuQXV0b2NvbXBsZXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5zZWFyY2gubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmdpZmllcic6IF9fX2NvbnRleHQudmFsdWVzLnN0YWNrLmRlY29yYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvblNlYXJjaCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlYXJjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvblNlbGVjdCc6IF9fX2NvbnRleHQudmFsdWVzLnNlYXJjaC5vblNlbGVjdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc2VsZWN0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG52YXIgU2VsZWN0Q2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9TZWxlY3RDaGFuZ2VkRXZlbnRcIik7XG4vKipcbiAqIFNlbGVjdCBwcm92aWRlcyBhIGRyb3Bkb3duIGxpc3QgZm9yIHNlbGVjdGluZyBpdGVtcy5cbiAqXG4gKiBOb3RlOiBDdXJyZW50bHkgdGhpcyByZWxpZXMgb24gdGhlIG5hdGl2ZSBzZWxlY3QgYnV0IHRoaXNcbiAqIGlzIGxpa2VseSB0byBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gVXNlIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAqIGRpcmVjdGx5IGlmIHlvdSBtdXN0IGhhdmUgdGhhdC5cbiAqL1xudmFyIFNlbGVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KCdmb3JtLWdyb3VwJywgX3RoaXMuYXR0cnMud3cuY2xhc3MsIF90aGlzLnN0YXRlKCkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy5sYWJlbCB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgIGlkOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybS1jb250cm9sJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cnMud3cudmFsdWUgfHwgJycsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IChfdGhpcy5hdHRycy53dy5kaXNhYmxlZCA9PT0gdHJ1ZSkgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWFkT25seTogKF90aGlzLmF0dHJzLnd3LnJlYWRPbmx5ID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IF90aGlzLmF0dHJzLnd3Lm9wdGlvbnMgfHwgW10sXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIHx8ICdTZWxlY3Qgb25lLicsXG4gICAgICAgICAgICAgICAgb3B0VmFsdWU6IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBvIDogby52YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBvcHRMYWJlbDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvLmxhYmVsOyB9LFxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBfdGhpcy52YWx1ZXMuc2VsZWN0LnZhbHVlID09PSBzOyB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsZWdhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShuZXcgU2VsZWN0Q2hhbmdlZEV2ZW50XzEuU2VsZWN0Q2hhbmdlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUsIHRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWxwOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBfdGhpcy5hdHRycy53dy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfdGhpcy5hdHRycy53dy5lcnJvcixcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiBfdGhpcy5hdHRycy53dy53YXJuaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdDtcbn0oY29udHJvbF8xLkZvcm1Db250cm9sKSk7XG5leHBvcnRzLlNlbGVjdCA9IFNlbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG52YXIgU2VsZWN0Q2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3RDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0Q2hhbmdlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3RDaGFuZ2VkRXZlbnQ7XG59KGNvbnRyb2xfMS5FdmVudCkpO1xuZXhwb3J0cy5TZWxlY3RDaGFuZ2VkRXZlbnQgPSBTZWxlY3RDaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3RDaGFuZ2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2VsZWN0XzEgPSByZXF1aXJlKFwiLi9TZWxlY3RcIik7XG5leHBvcnRzLlNlbGVjdCA9IFNlbGVjdF8xLlNlbGVjdDtcbnZhciBTZWxlY3RDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1NlbGVjdENoYW5nZWRFdmVudFwiKTtcbmV4cG9ydHMuU2VsZWN0Q2hhbmdlZEV2ZW50ID0gU2VsZWN0Q2hhbmdlZEV2ZW50XzEuU2VsZWN0Q2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2wvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMucm9vdC5jbGFzc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkod21sXzEubGFiZWwoX19fY29udGV4dC52YWx1ZXMubGFiZWwuaWQsIF9fX2NvbnRleHQudmFsdWVzLmxhYmVsLnRleHQpKF9fX3ZpZXcpKSwgX19fd21sLm5vZGUoJ3NlbGVjdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5zZWxlY3QubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmNoYW5nZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWFkb25seSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5pZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdvcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJlbGQnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5zZWxlY3QucGxhY2Vob2xkZXIpXSwgX19fdmlldyksIF9fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMuc2VsZWN0Lm9wdGlvbnMsIGZ1bmN0aW9uIF9tYXAob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ29wdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5vcHRWYWx1ZShvcHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWQnOiBfX19jb250ZXh0LnZhbHVlcy5zZWxlY3QuaXNTZWxlY3RlZChfX19jb250ZXh0LnZhbHVlcy5zZWxlY3Qub3B0VmFsdWUob3B0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnNlbGVjdC5vcHRMYWJlbChvcHQpKV0sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvdGhlcndpc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpLCBfX193bWwuZG9taWZ5KHdtbF8xLm1lc3NhZ2UoX19fY29udGV4dC52YWx1ZXMuaGVscC5pZCwgX19fY29udGV4dC52YWx1ZXMuaGVscCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvc3RhY2tcIik7XG52YXIgU3RhY2tDaGFuZ2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1N0YWNrQ2hhbmdlZEV2ZW50XCIpO1xuLyoqXG4gKiBTdGFjayBkaXNwbGF5cyBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBjYW4gYmUgbW9kaWZpZWRcbiAqIGJ5IHJlbGVhc2luZyBvbmUgb3IgbW9yZSBhdCBhIHRpbWUuXG4gKi9cbnZhciBTdGFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IF90aGlzLmF0dHJzLnd3LnRlbXBsYXRlID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRlbXBsYXRlIDogdmlld3MuY29udGVudDtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgYTogJ2xpbmsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5TVEFDSyxcbiAgICAgICAgICAgICAgICBjbG9zZTogbmFtZXMuU1RBQ0tfQ0xPU0UsXG4gICAgICAgICAgICAgICAgbWVtYmVyOiBuYW1lcy5TVEFDS19NRU1CRVJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IF90aGlzLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnZhbHVlLnNwbGljZShOdW1iZXIoaW5kZXgpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgICAgICAgICAgIH07IH0sXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBfdGhpcy5hdHRycy53dy5kZWNvcmF0b3IgPyBfdGhpcy5hdHRycy53dy5kZWNvcmF0b3IgOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gU3RyaW5nKG0pOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IF90aGlzLmF0dHJzLnd3LnZhbHVlID8gX3RoaXMuYXR0cnMud3cudmFsdWUgOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHB1c2ggYSBuZXcgbWVtYmVyIG9udG8gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdGhpcy52YWx1ZXMudmFsdWUucHVzaChtKTtcbiAgICAgICAgdGhpcy5maXJlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhY2sucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJzLnd3Lm9uQ2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgU3RhY2tDaGFuZ2VkRXZlbnRfMS5TdGFja0NoYW5nZWRFdmVudCh0aGlzLmF0dHJzLnd3Lm5hbWUsIHRoaXMudmFsdWVzLnZhbHVlLnNsaWNlKCkpKTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGFjaztcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5TdGFjayA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuLyoqXG4gKiBTdGFja0NoYW5nZWRFdmVudCBpcyBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciByZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgc3RhY2suXG4gKi9cbnZhciBTdGFja0NoYW5nZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhY2tDaGFuZ2VkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2tDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrQ2hhbmdlZEV2ZW50O1xufShjb250cm9sXzEuRXZlbnQpKTtcbmV4cG9ydHMuU3RhY2tDaGFuZ2VkRXZlbnQgPSBTdGFja0NoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YWNrQ2hhbmdlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0YWNrXzEgPSByZXF1aXJlKFwiLi9TdGFja1wiKTtcbmV4cG9ydHMuU3RhY2sgPSBTdGFja18xLlN0YWNrO1xudmFyIFN0YWNrQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9TdGFja0NoYW5nZWRFdmVudFwiKTtcbmV4cG9ydHMuU3RhY2tDaGFuZ2VkRXZlbnQgPSBTdGFja0NoYW5nZWRFdmVudF8xLlN0YWNrQ2hhbmdlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbmV4cG9ydHMuY29udGVudCA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3MubWVtYmVyXG4gICAgfSxcbiAgICB3bWw6IHt9XG59LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLmRlY29yYXRvcihtKSldLCBfX192aWV3KTsgfTsgfTsgfTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5tYXAoX19fY29udGV4dC52YWx1ZXMudmFsdWUsIGZ1bmN0aW9uIF9tYXAobSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5pdGVtLnRlbXBsYXRlKG0sIGluZGV4LCBfX19jb250ZXh0LnZhbHVlcy52YWx1ZSkoX19fY29udGV4dCkoX19fdmlldykpLCBfX193bWwubm9kZSgnYnV0dG9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3MuY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuaXRlbS5jbG9zZShpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtfX193bWwudGV4dChcIlxcdTAwRDdcIildLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB9KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBzd2l0Y2hfMSA9IHJlcXVpcmUoXCIuL3dtbC9zd2l0Y2hcIik7XG52YXIgU3dpdGNoQ2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9Td2l0Y2hDaGFuZ2VkRXZlbnRcIik7XG4vKipcbiAqIFN3aXRjaCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGJldHdlZW4gb25lIG9yIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBTd2l0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHN3aXRjaF8xLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lcy5TV0lUQ0gsXG4gICAgICAgICAgICAgICAgc2xpZGVyOiBuYW1lcy5TV0lUQ0hfU0xJREVSXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5hdHRycy53dy5uYW1lLFxuICAgICAgICAgICAgICAgIG9uOiBfdGhpcy5hdHRycy53dy5vbiB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3RoaXMuYXR0cnMud3cuZGlzYWJsZWQgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZXMuaW5wdXQub24gPSAhX3RoaXMudmFsdWVzLmlucHV0Lm9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cub25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNoYW5nZShuZXcgU3dpdGNoQ2hhbmdlZEV2ZW50XzEuU3dpdGNoQ2hhbmdlZEV2ZW50KF90aGlzLnZhbHVlcy5pbnB1dC5uYW1lLCBfdGhpcy52YWx1ZXMuaW5wdXQub24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN3aXRjaDtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlN3aXRjaCA9IFN3aXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN3aXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG4vKipcbiAqIFN3aXRjaENoYW5nZWRFdmVudCBzaWduYWxzIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBzd2l0Y2guXG4gKi9cbnZhciBTd2l0Y2hDaGFuZ2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaENoYW5nZWRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN3aXRjaENoYW5nZWRFdmVudDtcbn0oY29udHJvbF8xLkV2ZW50KSk7XG5leHBvcnRzLlN3aXRjaENoYW5nZWRFdmVudCA9IFN3aXRjaENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN3aXRjaENoYW5nZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGFiZWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5sYWJlbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2hlY2tlZCc6IChfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5vbiB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2hhbmdlJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KSwgX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Muc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3ID0gcmVxdWlyZShcIi4vd21sL3RhYnNcIik7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIFRhYkNsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vVGFiQ2xpY2tlZEV2ZW50XCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgX3Vua25vd24gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwiTWlzc2luZyBlbGVtZW50IHdpdGggaWQgXCIgKyBpZCArIFwiLlwiKTtcbn07XG4vKipcbiAqIFRhYiBwcm92aWRlcyBhIHNpbmdsZSB0YWIgaXRlbS5cbiAqXG4gKiBXaGVuIGEgdGFiIGlzIGNsaWNrZWQsIGl0IGF0dGVtcHRzIHRvIHJlbW92ZSB0aGUgYWN0aXZlIGNsYXNzIGZyb21cbiAqIGl0J3Mgc2libGluZ3MgYW5kIGFwcGx5IGl0IHRvIGl0c2VsZi4gVGhlcmVmb3JlIHRoZSBzaWJsaW5nIG9mIGFcbiAqIHRhYiBzaG91bGQgYWx3YXlzIGJlIGEgVGFiLlxuICovXG52YXIgVGFiID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFiKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3LlRhYihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGE6ICdsaW5rJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgbGk6IHV0aWxfMS5jb25jYXQobmFtZXMuVEFCU19UQUIsIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSA/IG5hbWVzLkFDVElWRSA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhYjoge1xuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzLmF0dHJzLnd3LnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpc1xuICAgICAgICAgICAgICAgIC52aWV3XG4gICAgICAgICAgICAgICAgLmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgICAgIC5jaGFpbihmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIHVzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHVzW2ldLmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgICAgICAgICAgLmZpbmRCeUlkKF90aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChuYW1lcy5BQ1RJVkUpOyB9KVxuICAgICAgICAgICAgICAgICAgICAub3JKdXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF91bmtub3duKF90aGlzLnZhbHVlcy5pZC5yb290KTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNoYWluKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFmcGwuTWF5YmUuZnJvbUFueShfdGhpcy5hdHRycy53dy5vbkNsaWNrKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihuZXcgVGFiQ2xpY2tlZEV2ZW50XzEuVGFiQ2xpY2tlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsaWNrIHRoaXMgVGFiXG4gICAgICovXG4gICAgVGFiLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnZpZXdcbiAgICAgICAgICAgIC5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5hKVxuICAgICAgICAgICAgLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3Vua25vd24oX3RoaXMudmFsdWVzLmlkLmEpOyB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGljaygpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUYWI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWIgPSBUYWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRhYkNsaWNrZWRFdmVudCBpcyBmaXJlZCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSB0YWIuXG4gKlxuICogSXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYiB0aGF0IHdhcyBjbGlja2VkLlxuICovXG52YXIgVGFiQ2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYkNsaWNrZWRFdmVudChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBUYWJDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5UYWJDbGlja2VkRXZlbnQgPSBUYWJDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3ID0gcmVxdWlyZShcIi4vd21sL3RhYnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbi8qKlxuICogVGFicyBhY3RzIGFzIGEgcGFyZW50IGNvbnRhaW5lciBmb3IgYSBncm91cCBvZiBUYWIuXG4gKlxuICogVXNlIGl0IHRvIGNyZWF0ZSBhIHRhYmJlZCBuYXZpZ2F0aW9uIG9yIHZpZXcgZm9yIG1haW4gbGF5b3V0LFxuICogc3ViIHZpZXdzIG9yIGZvcm1zIGV0Yy5cbiAqL1xudmFyIFRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFicygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlldy5UYWJzKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KG5hbWVzLlRBQlMsICduYXYgbmF2LXRhYnMnLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYnM7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UYWJzID0gVGFicztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbjtcbnZhciBUYWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWIoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3MubGlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5yb290XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW19fX3dtbC5ub2RlKCdhJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IFwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LmNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbKF9fX2NvbnRleHQudmFsdWVzLnRhYi50ZXh0KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGFiLnRleHQpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuVGFiID0gVGFiO1xuO1xudmFyIFRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFicyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJzO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5UYWJzID0gVGFicztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250cm9sXCIpO1xuLyoqXG4gKiBUZXh0Q2hhbmdlZEV2ZW50XG4gKi9cbnZhciBUZXh0Q2hhbmdlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0Q2hhbmdlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHRDaGFuZ2VkRXZlbnQ7XG59KGNvbnRyb2xfMS5FdmVudCkpO1xuZXhwb3J0cy5UZXh0Q2hhbmdlZEV2ZW50ID0gVGV4dENoYW5nZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRDaGFuZ2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC90ZXh0LWZpZWxkXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIGNvbnRyb2xfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbnRyb2xcIik7XG52YXIgVGV4dENoYW5nZWRFdmVudF8xID0gcmVxdWlyZShcIi4vVGV4dENoYW5nZWRFdmVudFwiKTtcbi8qKlxuICogVGV4dEZpZWxkXG4gKi9cbnZhciBUZXh0RmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRGaWVsZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmllbGQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdyb290JyxcbiAgICAgICAgICAgICAgICBjbGFzczogdXRpbF8xLmNvbmNhdCgnZm9ybS1ncm91cCcsIF90aGlzLmF0dHJzLnd3LmNsYXNzLCBfdGhpcy5zdGF0ZSgpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWxwOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBfdGhpcy5hdHRycy53dy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfdGhpcy5hdHRycy53dy5lcnJvcixcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiBfdGhpcy5hdHRycy53dy53YXJuaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMuYXR0cnMud3cubmFtZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy5sYWJlbCB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtLWNvbnRyb2wnLFxuICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmF0dHJzLnd3Lm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuYXR0cnMud3cudHlwZSB8fCAndGV4dCcsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF90aGlzLmF0dHJzLnd3LnBsYWNlaG9sZGVyIHx8ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRycy53dy52YWx1ZSB8fCAnJyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogKF90aGlzLmF0dHJzLnd3LmRpc2FibGVkID09PSB0cnVlKSA/IHRydWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiAoX3RoaXMuYXR0cnMud3cucmVhZE9ubHkgPT09IHRydWUpID8gdHJ1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgcm93czogX3RoaXMuYXR0cnMud3cucm93cyB8fCAxLFxuICAgICAgICAgICAgICAgIG9uSW5wdXQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vbkNoYW5nZShuZXcgVGV4dENoYW5nZWRFdmVudF8xLlRleHRDaGFuZ2VkRXZlbnQoX3RoaXMuYXR0cnMud3cubmFtZSwgZS50YXJnZXQudmFsdWUpKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZXh0RmllbGQ7XG59KGNvbnRyb2xfMS5Gb3JtQ29udHJvbCkpO1xuZXhwb3J0cy5UZXh0RmllbGQgPSBUZXh0RmllbGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0RmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4dEZpZWxkXzEgPSByZXF1aXJlKFwiLi9UZXh0RmllbGRcIik7XG5leHBvcnRzLlRleHRGaWVsZCA9IFRleHRGaWVsZF8xLlRleHRGaWVsZDtcbnZhciBUZXh0Q2hhbmdlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9UZXh0Q2hhbmdlZEV2ZW50XCIpO1xuZXhwb3J0cy5UZXh0Q2hhbmdlZEV2ZW50ID0gVGV4dENoYW5nZWRFdmVudF8xLlRleHRDaGFuZ2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udHJvbC93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeSh3bWxfMS5sYWJlbChfX19jb250ZXh0LnZhbHVlcy5sYWJlbC5pZCwgX19fY29udGV4dC52YWx1ZXMubGFiZWwudGV4dCkoX19fdmlldykpLCAoKF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnJvd3MgPT09IDEpKSA/IF9fX3dtbC5ub2RlKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25pbnB1dCc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm9uSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRvbmx5JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQucmVhZE9ubHksXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpIDogX19fd21sLm5vZGUoJ3RleHRhcmVhJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmlucHV0JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQub25JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWRvbmx5JzogX19fY29udGV4dC52YWx1ZXMuaW5wdXQucmVhZE9ubHksXG4gICAgICAgICAgICAgICAgICAgICAgICAncm93cyc6IF9fX2NvbnRleHQudmFsdWVzLmlucHV0LnJvd3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5pbnB1dC5jbGFzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IFwiaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuaW5wdXQudmFsdWUpXSwgX19fdmlldyksIF9fX3dtbC5kb21pZnkod21sXzEubWVzc2FnZShfX19jb250ZXh0LnZhbHVlcy5oZWxwLmlkLCBfX19jb250ZXh0LnZhbHVlcy5oZWxwKShfX192aWV3KSldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuZXhwb3J0cy5sYWJlbCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCdsYWJlbCcsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdmb3InOiBpZCxcbiAgICAgICAgJ2NsYXNzJzogXCJjb250cm9sLWxhYmVsXCJcbiAgICB9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwuZG9taWZ5KHRleHQpXSwgX19fdmlldyk7IH07IH07XG47XG5leHBvcnRzLm1lc3NhZ2UgPSBmdW5jdGlvbiAoaWQsIG0pIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiAobS5zdWNjZXNzKSA/IF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogXCJoZWxwLXRleHRcIlxuICAgIH0sXG4gICAgd21sOiB7XG4gICAgICAgICdpZCc6IGlkXG4gICAgfVxufSwgW19fX3dtbC5kb21pZnkobS5zdWNjZXNzKV0sIF9fX3ZpZXcpIDogKG0uZXJyb3IpID8gX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgaHRtbDoge1xuICAgICAgICAnY2xhc3MnOiBcImhlbHAtdGV4dFwiXG4gICAgfSxcbiAgICB3bWw6IHtcbiAgICAgICAgJ2lkJzogaWRcbiAgICB9XG59LCBbX19fd21sLmRvbWlmeShtLmVycm9yKV0sIF9fX3ZpZXcpIDogKG0ud2FybmluZykgPyBfX193bWwubm9kZSgnc3BhbicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IFwiaGVscC10ZXh0XCJcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBpZFxuICAgIH1cbn0sIFtfX193bWwuZG9taWZ5KG0ud2FybmluZyldLCBfX192aWV3KSA6IF9fX3dtbC5ub2RlKCdzcGFuJywge1xuICAgIGh0bWw6IHtcbiAgICAgICAgJ2NsYXNzJzogXCJoZWxwLXRleHRcIlxuICAgIH0sXG4gICAgd21sOiB7XG4gICAgICAgICdpZCc6IGlkXG4gICAgfVxufSwgW10sIF9fX3ZpZXcpOyB9OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciBHcm91cF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29udGVudC9Hcm91cFwiKTtcbnZhciBhc2lkZV8xID0gcmVxdWlyZShcIi4vd21sL2FzaWRlXCIpO1xuLyoqXG4gKiBBc2lkZSBwcm92aWRlcyBhIHdpZGdldCBmb3IgZGlzcGxheWluZyBuYXZpZ2F0aW9uIGFuZCBvdGhlciBzaWRlYmFyIGNvbnRlbnQuXG4gKlxuICogSXQncyBhcGkgYWxsb3dzIGZvciB0b2dnbGluZyBiZXR3ZWVuIGhpZGRlbiBhbmQgc2hvd24gc3RhdGVzIGFzIHdlbGwgYXMgcXVlcnlpbmcgdGhlXG4gKiBjdXJyZW50IHN0YXRlLlxuICpcbiAqIFRoaXMgd2lkZ2V0J3Mgc3R5bGUgaW50ZW50aW9uYWxseSBnaXZlcyBpdCBhIGhpZ2ggei1pbmRleCBzbyB0aGF0IGl0IGFwcGVhcnMgaW4tZnJvbnRcbiAqIG9mIG90aGVyIGNvbnRlbnQuIEFkanVzdCB0aGUgcmVzcGVjdGl2ZSBzdHlsZSB2YXJpYWJsZXMgdG8gY2hhbmdlLlxuICovXG52YXIgQXNpZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzaWRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzaWRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyBpcyBhIGhhc2ggb2YgdmFsdWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdhc2lkZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiBuYW1lcy5BU0lERSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lcy5BU0lERV9DT05URU5UXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnd3c6Y29udGVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY29udGVudCkgPyBfdGhpcy5hdHRycy53dy5jb250ZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IGFzaWRlXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXNpZGUucHJvdG90eXBlLl9nZXREcmF3ZXJET00gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB2aXNpYmxlIHF1ZXJpZXMgd2hldGhlciB0aGUgRHJhd2VyIGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqL1xuICAgIEFzaWRlLnByb3RvdHlwZS52aXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2dldERyYXdlckRPTShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZXMuSElEREVOKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoaWRlIHRoZSBkcmF3ZXIuXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUoKSlcbiAgICAgICAgICAgIHRoaXMuX2dldERyYXdlckRPTShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QuYWRkKG5hbWVzLkhJRERFTik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2hvd0RyYXdlciBzaG93cyB0aGUgZHJhd2VyXG4gICAgICovXG4gICAgQXNpZGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKCkpXG4gICAgICAgICAgICB0aGlzLl9nZXREcmF3ZXJET00oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lcy5ISURERU4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGlzIERyYXdlclxuICAgICAqL1xuICAgIEFzaWRlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dldERyYXdlckRPTShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc0xpc3QudG9nZ2xlKG5hbWVzLkhJRERFTik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzaWRlO1xufShHcm91cF8xLkdyb3VwKSk7XG5leHBvcnRzLkFzaWRlID0gQXNpZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc2lkZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLnJvb3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3MuY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy5jb250ZW50KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuY29udGVudC5yZW5kZXIoKSkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyldLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2lkZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEdyb3VwXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250ZW50L0dyb3VwXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIGRyYXdlcl8xID0gcmVxdWlyZShcIi4vd21sL2RyYXdlclwiKTtcbjtcbi8qKlxuICogRHJhd2VyIHByb3ZpZGVzIGEgMiBjb2x1bW4gYXBwbGljYXRpb24gbGF5b3V0IHdpdGggdGhlIGZpcnN0IHR5cGljYWxseSB1c2VkIGFzIG5hdmFpZ2F0aW9uXG4gKiBhbmQgdGhlIHNlY29uZCBtYWluIGFwcGxpY2F0aW9uIGNvbnRlbnQuXG4gKlxuICogYGBgd21sXG4gKlxuICogIDxEcmF3ZXJcbiAqICAgd21sOmlkPVwibGF5b3V0XCJcbiAqICAgY29udGVudD17e3RoaXMuZ2V0Q29udGVudCgpfX0gLz5cbiAqXG4gKiBgYGBcbiAqL1xudmFyIERyYXdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJhd2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYXdlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgZHJhd2VyXzEuTWFpbihfdGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgaXMgYSBoYXNoIG9mIHZhbHVlcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgIGRyYXdlcjogJ2RyYXdlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IG5hbWVzLkRSQVdFUixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIERSQVdFUjogJ3d3OmRyYXdlcicsXG4gICAgICAgICAgICAgICAgQ09OVEVOVDogJ3d3OmNvbnRlbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNpZGU6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuZHJhd2VyKSA/IF90aGlzLmF0dHJzLnd3LmRyYXdlciA6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY29udGVudCkgPyBfdGhpcy5hdHRycy53dy5jb250ZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdlci5wcm90b3R5cGUuX2dldEFzaWRlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5kcmF3ZXIpLmNhdGEoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgZik7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLl9jb21iaW5lID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZHJhd2VyVmlzaWJsZSBxdWVyaWVzIHdoZXRoZXIgdGhlIEFzaWRlIGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUuZHJhd2VyVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFzaWRlKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2libGUoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoaWRlRHJhd2VyIGhpZGVzIHRoZSBkcmF3ZXIuXG4gICAgICovXG4gICAgRHJhd2VyLnByb3RvdHlwZS5oaWRlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuaGlkZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNob3dEcmF3ZXIgc2hvd3MgdGhlIGRyYXdlclxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUuc2hvd0RyYXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFzaWRlKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnNob3coKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEFzaWRlLlxuICAgICAqL1xuICAgIERyYXdlci5wcm90b3R5cGUudG9nZ2xlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXNpZGUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudG9nZ2xlKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERyYXdlcjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5EcmF3ZXIgPSBEcmF3ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmF3ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBBc2lkZV8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvbGF5b3V0L2FzaWRlL0FzaWRlXCIpO1xuO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLnJvb3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLndpZGdldChBc2lkZV8xLkFzaWRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IF9fX2NvbnRleHQudmFsdWVzLmlkLmRyYXdlclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQnOiBfX19jb250ZXh0LnZhbHVlcy5hc2lkZS5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSwgX19fdmlldyksIChfX19jb250ZXh0LmNvbnRlbnQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNvbnRlbnQpIDogKF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5jb250ZW50LnJlbmRlcigpKSA6IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC92aWV3c1wiKTtcbnZhciB3bWxfMSA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIEZyYWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcmFnbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcmFnbWVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihudWxsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGcmFnbWVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmcmFnLmFwcGVuZENoaWxkKGMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfTtcbiAgICByZXR1cm4gRnJhZ21lbnQ7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhZ21lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2ZyYWdtZW50Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtdLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2dyaWRcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbjtcbi8qKlxuICogR3JpZFxuICovXG52YXIgR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JpZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmlkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5HcmlkKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLkdSSUQsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcmlkO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuR3JpZCA9IEdyaWQ7XG52YXIgUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Sb3coX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuR1JJRF9ST1csIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5jbGFzcykgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3c7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Sb3cgPSBSb3c7XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2x1bW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sdW1uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Db2x1bW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IF90aGlzLmF0dHJzLnd3ID8gdXRpbF8xLmNvbmNhdChfdGhpcy5hdHRycy53dy5zaXplID9cbiAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtXCIgKyBfdGhpcy5hdHRycy53dy5zaXplIDogJ2NvbC1tZC0xMicsIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA6ICdjb2wtbWQtMTInXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbjtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWQoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3NlY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcmlkO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5HcmlkID0gR3JpZDtcbjtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3coY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvdztcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuUm93ID0gUm93O1xuO1xudmFyIENvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sdW1uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbHVtbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29sdW1uO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbGlzdC1ncm91cFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbi8qKlxuICogTGlzdEdyb3VwIGlzIHVzZWQgdG8gY3JlYXRlIGEgdmVydGljYWwgbGlzdCBvZiBjb250ZW50LlxuICpcbiAqIENoaWxkcmVuIG11c3QgYmUgTGlzdEdyb3VwSXRlbXMuXG4gKi9cbnZhciBMaXN0R3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3RHcm91cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0R3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IG5hbWVzLkxJU1RfR1JPVVBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdEdyb3VwO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkxpc3RHcm91cCA9IExpc3RHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3RHcm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpc3QtZ3JvdXAtaXRlbVwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbi8qKlxuICogTGlzdEdyb3VwSXRlbVxuICovXG52YXIgTGlzdEdyb3VwSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdEdyb3VwSXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0R3JvdXBJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBuYW1lcy5MSVNUX0dST1VQX0lURU1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdEdyb3VwSXRlbTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5MaXN0R3JvdXBJdGVtID0gTGlzdEdyb3VwSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3RHcm91cEl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlzdEdyb3VwXzEgPSByZXF1aXJlKFwiLi9MaXN0R3JvdXBcIik7XG5leHBvcnRzLkxpc3RHcm91cCA9IExpc3RHcm91cF8xLkxpc3RHcm91cDtcbnZhciBMaXN0R3JvdXBJdGVtXzEgPSByZXF1aXJlKFwiLi9MaXN0R3JvdXBJdGVtXCIpO1xuZXhwb3J0cy5MaXN0R3JvdXBJdGVtID0gTGlzdEdyb3VwSXRlbV8xLkxpc3RHcm91cEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnbGknLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QtZ3JvdXAtaXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgndWwnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5yb290LmNsYXNzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QtZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9tYWluXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIEdyb3VwXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb250ZW50L0dyb3VwXCIpO1xuLyoqXG4gKiBNYWluIHByb3ZpZGVzIGEgY29udGFpbmVyIGZvciB0aGUgbWFpbiBjb250ZW50IG9mIGFuIGFwcGxpY2F0aW9uLlxuICovXG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLk1BSU5fVklFVywgbmFtZXMuUFVTSEFCTEUsIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oR3JvdXBfMS5Hcm91cCkpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1haW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3BhbmVsXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgUGFuZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhbmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhbmVsKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5QYW5lbChfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5QQU5FTCwgX3RoaXMuYXR0cnMud3cgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5zdHlsZSA6IG5hbWVzLkRFRkFVTFQsIF90aGlzLmF0dHJzLnd3ID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWw7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5QYW5lbCA9IFBhbmVsO1xudmFyIEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuSGVhZGVyKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLlBBTkVMX0hFQURFUiwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5IZWFkZXIgPSBIZWFkZXI7XG52YXIgQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb2R5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5Cb2R5KF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLlBBTkVMX0JPRFksIF90aGlzLmF0dHJzLnd3ID8gX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQm9keTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkJvZHkgPSBCb2R5O1xudmFyIEZvb3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9vdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvb3RlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuRm9vdGVyKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLlBBTkVMX0ZPT1RFUiwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGb290ZXI7XG59KHdtbF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Gb290ZXIgPSBGb290ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYW5lbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5lbChjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuZWw7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLlBhbmVsID0gUGFuZWw7XG47XG52YXIgSGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXI7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcjtcbjtcbnZhciBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvZHkoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJvZHk7XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLkJvZHkgPSBCb2R5O1xuO1xudmFyIEZvb3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9vdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvb3Rlcihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRm9vdGVyO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5Gb290ZXIgPSBGb290ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYW5lbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2RpdmlkZXJcIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG4vKipcbiAqIERpdmlkZXJcbiAqL1xudmFyIERpdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGl2aWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuTUVOVV9ESVZJREVSXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERpdmlkZXI7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGl2aWRlciA9IERpdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvaGVhZGVyXCIpO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xuLyoqXG4gKiBIZWFkZXJcbiAqL1xudmFyIEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5NRU5VX0hFQURFUiwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVyO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIG1lbnVfMSA9IHJlcXVpcmUoXCIuL3dtbC9tZW51XCIpO1xuLyoqXG4gKiBNZW51XG4gKi9cbnZhciBNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbnUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IG1lbnVfMS5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAnbWVudSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuTUVOVSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmNsYXNzKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycsIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5oaWRkZW4pID9cbiAgICAgICAgICAgICAgICAgICAgbmFtZXMuSElEREVOIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDogX3RoaXMuY2hpbGRyZW4sXG4gICAgICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgICAgIGhpZGVPbkNsaWNrOiAoX3RoaXMuYXR0cnMud3cgJiYgKF90aGlzLmF0dHJzLnd3LmhpZGVPbkNsaWNrICE9IG51bGwpKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LmhpZGVPbkNsaWNrIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoaWRlT25FeHRlcm5hbENsaWNrOiAoX3RoaXMuYXR0cnMud3cgJiYgKF90aGlzLmF0dHJzLnd3LmhpZGVPbkV4dGVybmFsQ2xpY2sgIT0gbnVsbCkpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaGlkZU9uRXh0ZXJuYWxDbGljayA6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpc0hpZGRlblxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAuY2F0YShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWVzLkhJRERFTik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5hZGQobmFtZXMuSElEREVOKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2hvdyB0aGlzIG1lbnUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkhJRERFTik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGlzIG1lbnUncyB2aXNpYmlsaXR5XG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC50b2dnbGUobmFtZXMuSElEREVOKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0Q29udGVudCBvZiB0aGlzIG1lbnUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNvbnRlbnQgPSBbdmlldy5yZW5kZXIoKV07XG4gICAgICAgIHRoaXMudmlldy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWVudS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcyk7XG4gICAgICAgICAgICBpZiAoKCFyb290LmNvbnRhaW5zKGUudGFyZ2V0KSkgJiYgX3RoaXMudmFsdWVzLmNsaWNrLmhpZGVPbkV4dGVybmFsQ2xpY2spXG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lbnUucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbnU7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTWVudSA9IE1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWVudS1pdGVtXCIpO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIE1lbnVJdGVtQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9NZW51SXRlbUNsaWNrZWRFdmVudFwiKTtcbi8qKlxuICogTWVudUl0ZW1cbiAqL1xudmFyIE1lbnVJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51SXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW51SXRlbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLk1FTlVfSVRFTSwgKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmRpc2FibGVkKSA/XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLkRJU0FCTEVEIDogbnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRleHQgOiBudWxsLFxuICAgICAgICAgICAgY2xpY2tlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2spID9cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5vbkNsaWNrKG5ldyBNZW51SXRlbUNsaWNrZWRFdmVudF8xLk1lbnVJdGVtQ2xpY2tlZEV2ZW50KF90aGlzLmF0dHJzLnd3Lm5hbWUpKSA6IGZ1bmN0aW9uICgpIHsgfTsgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZW51SXRlbTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5NZW51SXRlbSA9IE1lbnVJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVudUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1lbnVJdGVtQ2xpY2tlZEV2ZW50IGluZGljYXRlcyBhIG1lbnUgaXRlbSBoYXMgYmVlbiBjbGlja2VkLlxuICovXG52YXIgTWVudUl0ZW1DbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVudUl0ZW1DbGlja2VkRXZlbnQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTWVudUl0ZW1DbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5NZW51SXRlbUNsaWNrZWRFdmVudCA9IE1lbnVJdGVtQ2xpY2tlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVudUl0ZW1DbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9idXR0b24tbWVudVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogQnV0dG9uTWVudVxuICovXG52YXIgQnV0dG9uTWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnV0dG9uTWVudSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25NZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2J1dHRvblRlbXBsYXRlID0gX3RoaXMuYXR0cnMud3cuYnV0dG9uVGVtcGxhdGUgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYnV0dG9uVGVtcGxhdGUgOiB2aWV3cy5idXR0b247XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIHRhcmdldDogJ21lbnUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KG5hbWVzLkJVVFRPTl9NRU5VLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuY2xhc3MpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuY2xhc3MgOiAnJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBfdGhpcy5hdHRycy53dy50ZXh0ID8gX3RoaXMuYXR0cnMud3cudGV4dCA6ICcnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBfdGhpcy5fYnV0dG9uVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgY2xhc3M6IG5hbWVzLkJVVFRPTl9NRU5VX0JVVFRPTixcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IF90aGlzLnZpZXcuZmluZEJ5SWQoX3RoaXMudmFsdWVzLm1lbnUuaWQpLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50b2dnbGUoKTsgfSk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdtZW51JyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfdGhpcy5hdHRycy53dy5jb250ZW50ID8gX3RoaXMuYXR0cnMud3cuY29udGVudCA6IF90aGlzLmNoaWxkcmVuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBCdXR0b25NZW51LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMubWVudS5pZClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uaGlkZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzaG93IHRoZSBtZW51LlxuICAgICAqL1xuICAgIEJ1dHRvbk1lbnUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5tZW51LmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zaG93KCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBCdXR0b25NZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5tZW51LmlkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50b2dnbGUoKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2V0Q29udGVudCBvZiB0aGlzIG1lbnUuXG4gICAgICovXG4gICAgQnV0dG9uTWVudS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLm1lbnUuY29udGVudCA9IFt2aWV3LnJlbmRlcigpXTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQnV0dG9uTWVudTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5CdXR0b25NZW51ID0gQnV0dG9uTWVudTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbk1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnV0dG9uTWVudV8xID0gcmVxdWlyZShcIi4vQnV0dG9uTWVudVwiKTtcbmV4cG9ydHMuQnV0dG9uTWVudSA9IEJ1dHRvbk1lbnVfMS5CdXR0b25NZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNZW51XzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9tZW51L01lbnVcIik7XG47XG5leHBvcnRzLmJ1dHRvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ2J1dHRvbicsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5jbGFzcyxcbiAgICAgICAgJ3R5cGUnOiBcImJ1dHRvblwiLFxuICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi5vbkNsaWNrXG4gICAgfSxcbiAgICB3bWw6IHt9XG59LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5idXR0b24udGV4dCldLCBfX192aWV3KTsgfTsgfTsgfTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnJvb3QuY2xhc3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmJ1dHRvbi50ZW1wbGF0ZSgpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKSwgX19fd21sLndpZGdldChNZW51XzEuTWVudSwge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5tZW51LmlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlkZGVuJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMubWVudS5jb250ZW50KV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGl2aWRlcl8xID0gcmVxdWlyZShcIi4vRGl2aWRlclwiKTtcbmV4cG9ydHMuRGl2aWRlciA9IERpdmlkZXJfMS5EaXZpZGVyO1xudmFyIEhlYWRlcl8xID0gcmVxdWlyZShcIi4vSGVhZGVyXCIpO1xuZXhwb3J0cy5IZWFkZXIgPSBIZWFkZXJfMS5IZWFkZXI7XG52YXIgTWVudUl0ZW1fMSA9IHJlcXVpcmUoXCIuL01lbnVJdGVtXCIpO1xuZXhwb3J0cy5NZW51SXRlbSA9IE1lbnVJdGVtXzEuTWVudUl0ZW07XG52YXIgTWVudUl0ZW1DbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL01lbnVJdGVtQ2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5NZW51SXRlbUNsaWNrZWRFdmVudCA9IE1lbnVJdGVtQ2xpY2tlZEV2ZW50XzEuTWVudUl0ZW1DbGlja2VkRXZlbnQ7XG52YXIgTWVudV8xID0gcmVxdWlyZShcIi4vTWVudVwiKTtcbmV4cG9ydHMuTWVudSA9IE1lbnVfMS5NZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW10sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC52YWx1ZXMuY2xpY2tlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy50ZXh0KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMudGV4dCkgOiBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQuY2hpbGRyZW4pXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS1pdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCd1bCcsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFtfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLmNvbnRlbnQpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2JyZWFkY3J1bWJzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG4vKipcbiAqIEJyZWFkQ3J1bWJcbiAqL1xudmFyIEJyZWFkQ3J1bWJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmVhZENydW1icywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcmVhZENydW1icygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuQnJlYWRDcnVtYnMoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHV0aWxfMS5jb25jYXQobmFtZXMuQlJFQURfQ1JVTUJTLCBfdGhpcy5hdHRycy53dyA/IF90aGlzLmF0dHJzLnd3LmNsYXNzIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyZWFkQ3J1bWJzO1xufSh3bWxfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQnJlYWRDcnVtYnMgPSBCcmVhZENydW1icztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyZWFkQ3J1bWJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvYnJlYWRjcnVtYnNcIik7XG52YXIgd21sXzEgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbi8qKlxuICogSXRlbSBmb3IgYnJlYWRjcnVtYiBsaXN0cy5cbiAqL1xudmFyIEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuSXRlbShfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogbmFtZXMuQlJFQURfQ1JVTUJTX0lURU1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkl0ZW0gPSBJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xuO1xudmFyIEJyZWFkQ3J1bWJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmVhZENydW1icywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcmVhZENydW1icyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnb2wnLCB7XG4gICAgICAgICAgICAgICAgaHRtbDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCcmVhZENydW1icztcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuQnJlYWRDcnVtYnMgPSBCcmVhZENydW1icztcbjtcbnZhciBJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZW0oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ2xpJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSXRlbTtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuSXRlbSA9IEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVhZGNydW1icy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpbmtcIik7XG52YXIgTGlua0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vTGlua0NsaWNrZWRFdmVudFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vdXRpbFwiKTtcbi8qKlxuICogTGluayBnZW5lcmF0ZXMgYW4gPGE+IGVsZW1lbnQuXG4gKi9cbnZhciBMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZSBhc3NpZ25lZCB0byB0aGlzIExpbmsuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3Lm5hbWUpID9cbiAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm5hbWUgOiAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpdGxlIGFzc2lnbmVkIHRvIHRoaXMgTGluay5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRpdGxlID0gKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRpdGxlKSA/XG4gICAgICAgICAgICBfdGhpcy5hdHRycy53dy50aXRsZSA6ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogaHJlZiBhc3NpZ25lZCB0byB0aGlzIGxpbmtcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmhyZWYgPSAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaHJlZikgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcnO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHJvb3Q6ICdyb290J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogdXRpbF8xLmNvbmNhdChuYW1lcy5OQVZfTElOSywgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnLCAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuYWN0aXZlKSA/XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLkFDVElWRSA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRpdGxlKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRpdGxlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuYW1lOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5uYW1lIDogbnVsbCxcbiAgICAgICAgICAgICAgICBocmVmOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cuaHJlZikgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5ocmVmIDogJyMnLFxuICAgICAgICAgICAgICAgIGFjdGl2ZTogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmFjdGl2ZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5hY3RpdmUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy50ZXh0IDogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYXR0cnMud3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5hdHRycy53dywgbmFtZV8xID0gX2EubmFtZSwgaHJlZiA9IF9hLmhyZWYsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgICAgICAgICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkNsaWNrKVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKG5ldyBMaW5rQ2xpY2tlZEV2ZW50XzEuTGlua0NsaWNrZWRFdmVudChuYW1lXzEsIGhyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBJdGVtLlxuICAgICAgKi9cbiAgICBMaW5rLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB3LmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LmFkZChuYW1lcy5BQ1RJVkUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGluYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBpdGVtLlxuICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLmluYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5maW5kQnlJZCh0aGlzLnZhbHVlcy5pZC5yb290KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzLkFDVElWRSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KHdtbC5Db21wb25lbnQpKTtcbmV4cG9ydHMuTGluayA9IExpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMaW5rQ2xpY2tlZEV2ZW50IGluZGljYXRlcyBhIGxpbmsgaGFzIGJlZW4gY2xpY2tlZC5cbiAqL1xudmFyIExpbmtDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua0NsaWNrZWRFdmVudChuYW1lLCBocmVmKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBMaW5rQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuTGlua0NsaWNrZWRFdmVudCA9IExpbmtDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtfMSA9IHJlcXVpcmUoXCIuL0xpbmtcIik7XG5leHBvcnRzLkxpbmsgPSBMaW5rXzEuTGluaztcbnZhciBMaW5rQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9MaW5rQ2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5MaW5rQ2xpY2tlZEV2ZW50ID0gTGlua0NsaWNrZWRFdmVudF8xLkxpbmtDbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fX3dtbCA9IHJlcXVpcmUoXCJAcXVlbmsvd21sXCIpO1xudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1haW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFpbihjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwubm9kZSgnYScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICdocmVmJzogX19fY29udGV4dC52YWx1ZXMuYS5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiBfX19jb250ZXh0LnZhbHVlcy5hLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQuY2xpY2tlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgWyhfX19jb250ZXh0LnZhbHVlcy5hLnRleHQpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5hLnRleHQpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3cyA9IHJlcXVpcmUoXCIuL3dtbC9oZWFkZXJcIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEhlYWRlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5vbi1jbGlja2FibGUgaGVhZGluZyB0ZXh0IGluIGEgbmF2IGxpc3QuXG4gKi9cbnZhciBIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52aWV3ID0gbmV3IHZpZXdzLk1haW4oX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB7XG4gICAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KG5hbWVzLk5BVl9NRU5VX0hFQURFUiwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy50ZXh0KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVyO1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2l0ZW1cIik7XG52YXIgd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIEl0ZW0gd3JhcHMgY29udGVudCBpbiBhIG5hdmlnYXRpb24gbGlzdC5cbiAqXG4gKiBJdGVtcyBzaG91bGQgbm90IGhhdmUgYW55IHNpYmxpbmdzIHRoYXQgYXJlIG5vdCBvdGhlciBJdGVtcy5cbiAqL1xudmFyIEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgcm9vdDogJ3Jvb3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLk5BVl9NRU5VX0lURU0sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gbmFtZXMuQUNUSVZFIDogbnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGV4dCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3LnRleHQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWN0aXZhdGUgdGhpcyBuYXYgbGlzdCBJdGVtLlxuICAgICAqL1xuICAgIEl0ZW0ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZmluZEJ5SWQodGhpcy52YWx1ZXMuaWQucm9vdClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHcuY2xhc3NMaXN0LnJlbW92ZShuYW1lcy5BQ1RJVkUpO1xuICAgICAgICAgICAgdy5jbGFzc0xpc3QuYWRkKG5hbWVzLkFDVElWRSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogaW5hY3RpdmF0ZSB0aGlzIG5hdiBsaXN0IGl0ZW0uXG4gICAgICovXG4gICAgSXRlbS5wcm90b3R5cGUuaW5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKHRoaXMudmFsdWVzLmlkLnJvb3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LmNsYXNzTGlzdC5yZW1vdmUobmFtZXMuQUNUSVZFKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXRlbTtcbn0od21sLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5JdGVtID0gSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEl0ZW1DbGlja2VkRXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gaXRlbSBpblxuICogYSBuYXYgbGlzdC5cbiAqL1xudmFyIEl0ZW1DbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXRlbUNsaWNrZWRFdmVudChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBJdGVtQ2xpY2tlZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuSXRlbUNsaWNrZWRFdmVudCA9IEl0ZW1DbGlja2VkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGVtQ2xpY2tlZEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGluayA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL25hdi9saW5rXCIpO1xudmFyIG5hbWVzID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL25hbWVzXCIpO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL2xpbmtcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG4vKipcbiAqIExpbmsgcHJvdmlkZXMgYSBsaW5rIGVudHJ5IGludG8gYSBuYXYgbWVudS5cbiAqL1xudmFyIExpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlld3MuTWFpbihfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHtcbiAgICAgICAgICAgIGlkOiB7IHJvb3Q6ICcnIH0sXG4gICAgICAgICAgICBjbGFzczogeyByb290OiAnJyB9LFxuICAgICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KG5hbWVzLk5BVl9NRU5VX0lURU0sIChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID8gbmFtZXMuQUNUSVZFIDogJycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB1dGlsXzEuY29uY2F0KChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgbmFtZXMuQUNUSVZFIDogJycpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cudGl0bGUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGl0bGUgOiAnJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAoX3RoaXMuYXR0cnMud3cgJiYgX3RoaXMuYXR0cnMud3cubmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRycy53dy5uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgaHJlZjogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LmhyZWYpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuaHJlZiA6ICcjJyxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5hY3RpdmUpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuYWN0aXZlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGV4dDogKF90aGlzLmF0dHJzLnd3ICYmIF90aGlzLmF0dHJzLnd3LnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cudGV4dCA6ICcnLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IChfdGhpcy5hdHRycy53dyAmJiBfdGhpcy5hdHRycy53dy5vbkNsaWNrKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJzLnd3Lm9uQ2xpY2sgOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpbms7XG59KGxpbmsuTGluaykpO1xuZXhwb3J0cy5MaW5rID0gTGluaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG52YXIgdmlld3MgPSByZXF1aXJlKFwiLi93bWwvbWVudVwiKTtcbnZhciB3bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbi8qKlxuICogTWVudSBvZiBuYXZpZ2F0aW9uIGxpbmtzLlxuICovXG52YXIgTWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVudSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsLmNvbmNhdChuYW1lcy5OQVZfTUVOVSwgX3RoaXMuYXR0cnMud3cgPyBfdGhpcy5hdHRycy53dy5jbGFzcyA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZW51O1xufSh3bWwuQ29tcG9uZW50KSk7XG5leHBvcnRzLk1lbnUgPSBNZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZpZXdzID0gcmVxdWlyZShcIi4vd21sL3N1Yi1tZW51XCIpO1xudmFyIE1lbnVfMSA9IHJlcXVpcmUoXCIuL01lbnVcIik7XG4vKipcbiAqIFN1Yk1lbnUgaXMgdXNlZCBmb3IgbmVzdGVkIG1lbnVzLlxuICovXG52YXIgU3ViTWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViTWVudSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmlldyA9IG5ldyB2aWV3cy5NYWluKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3ViTWVudTtcbn0oTWVudV8xLk1lbnUpKTtcbmV4cG9ydHMuU3ViTWVudSA9IFN1Yk1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJNZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEl0ZW1fMSA9IHJlcXVpcmUoXCIuL0l0ZW1cIik7XG5leHBvcnRzLkl0ZW0gPSBJdGVtXzEuSXRlbTtcbnZhciBJdGVtQ2xpY2tlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9JdGVtQ2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5JdGVtQ2xpY2tlZEV2ZW50ID0gSXRlbUNsaWNrZWRFdmVudF8xLkl0ZW1DbGlja2VkRXZlbnQ7XG52YXIgTWVudV8xID0gcmVxdWlyZShcIi4vTWVudVwiKTtcbmV4cG9ydHMuTWVudSA9IE1lbnVfMS5NZW51O1xudmFyIFN1Yk1lbnVfMSA9IHJlcXVpcmUoXCIuL1N1Yk1lbnVcIik7XG5leHBvcnRzLlN1Yk1lbnUgPSBTdWJNZW51XzEuU3ViTWVudTtcbnZhciBIZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0hlYWRlclwiKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyXzEuSGVhZGVyO1xudmFyIExpbmtfMSA9IHJlcXVpcmUoXCIuL0xpbmtcIik7XG5leHBvcnRzLkxpbmsgPSBMaW5rXzEuTGluaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgSXRlbV8xID0gcmVxdWlyZShcIi4uL0l0ZW1cIik7XG47XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgIHd3OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLml0ZW0uY2xhc3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnNwYW4uY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgICAgIH0sIFsoX19fY29udGV4dC52YWx1ZXMudGV4dCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC5ub2RlKCdsaScsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgIH0sIFsoX19fY29udGV4dC52YWx1ZXMudGV4dCkgPyBfX193bWwuZG9taWZ5KF9fX2NvbnRleHQudmFsdWVzLnRleHQpIDogX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBsaW5rXzEgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9uYXYvbGlua1wiKTtcbjtcbjtcbnZhciBJdGVtXzEgPSByZXF1aXJlKFwiLi4vSXRlbVwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLndpZGdldChJdGVtXzEuSXRlbSwge1xuICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgIHdtbDoge30sXG4gICAgICAgICAgICAgICAgd3c6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuaXRlbS5jbGFzc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtfX193bWwud2lkZ2V0KGxpbmtfMS5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3bWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3dzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuYS5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogX19fY29udGV4dC52YWx1ZXMuYS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogX19fY29udGV4dC52YWx1ZXMuYS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogX19fY29udGV4dC52YWx1ZXMuYS5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnOiBfX19jb250ZXh0LnZhbHVlcy5hLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogX19fY29udGV4dC52YWx1ZXMuYS5hY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25DbGljayc6IF9fX2NvbnRleHQudmFsdWVzLmEub25DbGlja1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KV0sIF9fX3ZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNYWluO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5NYWluID0gTWFpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX193bWwgPSByZXF1aXJlKFwiQHF1ZW5rL3dtbFwiKTtcbnZhciBNYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYWluLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1haW4oY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChfX19jb250ZXh0LCBfX192aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gX19fd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogX19fY29udGV4dC52YWx1ZXMuY2xhc3Mucm9vdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd21sOiB7fVxuICAgICAgICAgICAgfSwgW19fX3dtbC5kb21pZnkoX19fY29udGV4dC5jaGlsZHJlbildLCBfX192aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWFpbjtcbn0oX19fd21sLkFwcFZpZXcpKTtcbmV4cG9ydHMuTWFpbiA9IE1haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG47XG52YXIgSXRlbV8xID0gcmVxdWlyZShcIi4uL0l0ZW1cIik7XG52YXIgTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYWluKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGVtcGxhdGUgPSBmdW5jdGlvbiAoX19fY29udGV4dCwgX19fdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIF9fX3dtbC53aWRnZXQoSXRlbV8xLkl0ZW0sIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbX19fd21sLm5vZGUoJ3VsJywge1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy5jbGFzcy5yb290XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdtbDoge31cbiAgICAgICAgICAgICAgICB9LCBbX19fd21sLmRvbWlmeShfX19jb250ZXh0LmNoaWxkcmVuKV0sIF9fX3ZpZXcpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1haW47XG59KF9fX3dtbC5BcHBWaWV3KSk7XG5leHBvcnRzLk1haW4gPSBNYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViLW1lbnUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFsbFNlbGVjdGVkRXZlbnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhbGwgdGhlIGZpZWxkcyBvbiB0aGUgdGFibGUuXG4gKi9cbnZhciBBbGxTZWxlY3RlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsbFNlbGVjdGVkRXZlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gQWxsU2VsZWN0ZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkFsbFNlbGVjdGVkRXZlbnQgPSBBbGxTZWxlY3RlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxsU2VsZWN0ZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2VsbCB3cmFwcyBhcm91bmQgYSA8dGQ+IHRvIHByb3ZpZGUgYW4gZWFzaWVyIHRvIHVzZSBhcGkuXG4gKi9cbnZhciBDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlbGwoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXRDb250ZW50IGNoYW5hZ2VzIHRoZSBjb250ZW50IG9mIHRoZSBDZWxsJ3MgPHRkPiBlbGVtZW50LlxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB3aGlsZSAodGhpcy5lbGVtZW50Lmxhc3RDaGlsZClcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHIucmVuZGVyKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBDZWxsO1xufSgpKTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDZWxsQ2xpY2tlZEV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB3aGl0ZXNwYWNlIG9mIGEgY2VsbCBpcyBjbGlja2VkLlxuICovXG52YXIgQ2VsbENsaWNrZWRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWxsQ2xpY2tlZEV2ZW50KHZhbHVlLCBjb2x1bW4sIHJvd0RhdGEsIHJvd051bWJlciwgY2VsbCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLnJvd0RhdGEgPSByb3dEYXRhO1xuICAgICAgICB0aGlzLnJvd051bWJlciA9IHJvd051bWJlcjtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB9XG4gICAgcmV0dXJuIENlbGxDbGlja2VkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5DZWxsQ2xpY2tlZEV2ZW50ID0gQ2VsbENsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNlbGxDbGlja2VkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIERlZmF1bHREZWxlZ2F0ZSB3aWxsIGhhbmRsZSB0YWJsZSBldmVudHMgaWYgbm8gRGVsZWdhdGUgaXNcbiAqIHNwZWNpZmllZC5cbiAqXG4gKiBJdCBwYXNzZXMgaXQncyBldmVudHMgb250byByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqL1xudmFyIERlZmF1bHREZWxlZ2F0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0RGVsZWdhdGUodGFibGUpIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgIH1cbiAgICBEZWZhdWx0RGVsZWdhdGUucHJvdG90eXBlLm9uQWxsU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50YWJsZS5hdHRycy53dy5vbkFsbFNlbGVjdGVkKVxuICAgICAgICAgICAgdGhpcy50YWJsZS5hdHRycy53dy5vbkFsbFNlbGVjdGVkKGUpO1xuICAgIH07XG4gICAgRGVmYXVsdERlbGVnYXRlLnByb3RvdHlwZS5vbkNlbGxDbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFibGUuYXR0cnMud3cub25DZWxsQ2xpY2tlZClcbiAgICAgICAgICAgIHRoaXMudGFibGUuYXR0cnMud3cub25DZWxsQ2xpY2tlZChlKTtcbiAgICB9O1xuICAgIERlZmF1bHREZWxlZ2F0ZS5wcm90b3R5cGUub25IZWFkaW5nQ2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uSGVhZGluZ0NsaWNrZWQpXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uSGVhZGluZ0NsaWNrZWQoZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0RGVsZWdhdGUucHJvdG90eXBlLm9uUm93Q2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhYmxlLmF0dHJzLnd3Lm9uUm93Q2xpY2tlZClcbiAgICAgICAgICAgIHRoaXMudGFibGUuYXR0cnMud3cub25Sb3dDbGlja2VkKGUpO1xuICAgIH07XG4gICAgRGVmYXVsdERlbGVnYXRlLnByb3RvdHlwZS5vblJvd1NlbGVjdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFibGUuYXR0cnMud3cub25Sb3dTZWxlY3RlZClcbiAgICAgICAgICAgIHRoaXMudGFibGUuYXR0cnMud3cub25Sb3dTZWxlY3RlZChlKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0RGVsZWdhdGU7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0RGVsZWdhdGUgPSBEZWZhdWx0RGVsZWdhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0RGVsZWdhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEhlYWRpbmdDbGlja2VkIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvblxuICogb25lIG9mIHRoZSBjb2x1bW4gaGVhZGluZ3MuXG4gKi9cbnZhciBIZWFkaW5nQ2xpY2tlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdDbGlja2VkRXZlbnQoZmllbGQpIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZ0NsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLkhlYWRpbmdDbGlja2VkRXZlbnQgPSBIZWFkaW5nQ2xpY2tlZEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhZGluZ0NsaWNrZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUm93Q2xpY2tlZEV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB3aGl0ZXNwYWNlIGluXG4gKiB0aGUgcm93IG9mIGEgdGFibGUuXG4gKi9cbnZhciBSb3dDbGlja2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm93Q2xpY2tlZEV2ZW50KHZhbHVlLCByb3csIGRhdGEpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIFJvd0NsaWNrZWRFdmVudDtcbn0oKSk7XG5leHBvcnRzLlJvd0NsaWNrZWRFdmVudCA9IFJvd0NsaWNrZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvd0NsaWNrZWRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJvd0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vUm93Q2xpY2tlZEV2ZW50XCIpO1xuLyoqXG4gKiBSb3dTZWxlY3RlZEV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjaGVja2JveCAoaWYgZGlzcGxheWVkKSBpcyBjbGlja2VkXG4gKiBvbiBmb3IgYSByb3cuXG4gKi9cbnZhciBSb3dTZWxlY3RlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3dTZWxlY3RlZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvd1NlbGVjdGVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvd1NlbGVjdGVkRXZlbnQ7XG59KFJvd0NsaWNrZWRFdmVudF8xLlJvd0NsaWNrZWRFdmVudCkpO1xuZXhwb3J0cy5Sb3dTZWxlY3RlZEV2ZW50ID0gUm93U2VsZWN0ZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvd1NlbGVjdGVkRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWZhdWx0RGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHREZWxlZ2F0ZVwiKTtcbnZhciBTb3J0RGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvcnREZWxlZ2F0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb3J0RGVsZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU29ydERlbGVnYXRlLnByb3RvdHlwZS5vbkhlYWRpbmdDbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy50YWJsZS5zb3J0KGUuZmllbGQpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uSGVhZGluZ0NsaWNrZWQuY2FsbCh0aGlzLCBlKTtcbiAgICB9O1xuICAgIHJldHVybiBTb3J0RGVsZWdhdGU7XG59KERlZmF1bHREZWxlZ2F0ZV8xLkRlZmF1bHREZWxlZ2F0ZSkpO1xuZXhwb3J0cy5Tb3J0RGVsZWdhdGUgPSBTb3J0RGVsZWdhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tb3J0RGVsZWdhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuYW1lcyA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi9uYW1lc1wiKTtcbnZhciB2aWV3ID0gcmVxdWlyZShcIi4vd21sL3RhYmxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2NvbW1vbi91dGlsXCIpO1xudmFyIHdtbF8xID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgcHJvcGVydHlfc2Vla18xID0gcmVxdWlyZShcInByb3BlcnR5LXNlZWtcIik7XG52YXIgQ2VsbENsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQ2VsbENsaWNrZWRFdmVudFwiKTtcbnZhciBSb3dDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1Jvd0NsaWNrZWRFdmVudFwiKTtcbnZhciBSb3dTZWxlY3RlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9Sb3dTZWxlY3RlZEV2ZW50XCIpO1xudmFyIEhlYWRpbmdDbGlja2VkRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0hlYWRpbmdDbGlja2VkRXZlbnRcIik7XG52YXIgQWxsU2VsZWN0ZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQWxsU2VsZWN0ZWRFdmVudFwiKTtcbnZhciBTb3J0RGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL1NvcnREZWxlZ2F0ZVwiKTtcbnZhciBDZWxsXzEgPSByZXF1aXJlKFwiLi9DZWxsXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi5cIik7XG4vKipcbiAqIFRhYmxlIHByb3ZpZGVzIGEgc21hcnRlciBodG1sIHRhYmxlLlxuICpcbiAqIEB0b2RvIHNwbGl0IHNvcnQgYW5kIHNlbGVjdCBhcGkgaW50byBvd24gdGFibGUgd2lkZ2V0cy5cbiAqL1xudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9yaWdpbmFsRGF0YSA9IF90aGlzLmF0dHJzLnd3LmRhdGE7XG4gICAgICAgIF90aGlzLnZpZXcgPSBuZXcgdmlldy5UYWJsZShfdGhpcyk7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgP1xuICAgICAgICAgICAgX3RoaXMuYXR0cnMud3cuZGVsZWdhdGUgOiBuZXcgU29ydERlbGVnYXRlXzEuU29ydERlbGVnYXRlKF90aGlzKTtcbiAgICAgICAgX3RoaXMudmFsdWVzID0ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICByb290OiAncm9vdCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICByb290OiB1dGlsXzEuY29uY2F0KG5hbWVzLlRBQkxFLCBfdGhpcy5hdHRycy53dy5jbGFzcyksXG4gICAgICAgICAgICAgICAgcm93OiBfdGhpcy5hdHRycy53dy5yb3dDbGFzcyB8fCAnJyxcbiAgICAgICAgICAgICAgICBjZWxsOiBfdGhpcy5hdHRycy53dy5jZWxsQ2xhc3MgfHwgJycsXG4gICAgICAgICAgICAgICAgaGVhZGluZzogX3RoaXMuYXR0cnMud3cuaGVhZGluZ0NsYXNzIHx8ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgICAgICBlbXB0eTogX3RoaXMuYXR0cnMud3cuZW1wdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogX3RoaXMuYXR0cnMud3cuc2VsZWN0YWJsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgdGhlYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vbkhlYWRpbmdDbGlja2VkKG5ldyBIZWFkaW5nQ2xpY2tlZEV2ZW50XzEuSGVhZGluZ0NsaWNrZWRFdmVudChmaWVsZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlbGVnYXRlLm9uQWxsU2VsZWN0ZWQobmV3IEFsbFNlbGVjdGVkRXZlbnRfMS5BbGxTZWxlY3RlZEV2ZW50KF90aGlzLm9yaWdpbmFsRGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0Ym9keToge1xuICAgICAgICAgICAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF90aGlzLmF0dHJzLnd3LnJvd0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKHJvdywgaW5kZXgsIGRhdGEpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVsZWdhdGUub25Sb3dDbGlja2VkKG5ldyBSb3dDbGlja2VkRXZlbnRfMS5Sb3dDbGlja2VkRXZlbnQocm93LCBpbmRleCwgZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAocm93LCBpbmRleCwgZGF0YSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWxlZ2F0ZS5vblJvd1NlbGVjdGVkKG5ldyBSb3dTZWxlY3RlZEV2ZW50XzEuUm93U2VsZWN0ZWRFdmVudChyb3csIGluZGV4LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9OyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZnVuY3Rpb24gKGNvbHVtbiwgcm93TnVtYmVyKSB7IHJldHVybiBjb2x1bW4gKyBcIixcIiArIHJvd051bWJlcjsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfdGhpcy5hdHRycy53dy5jZWxsQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAodmFsdWUsIGNvbHVtbiwgcm93RGF0YSwgcm93TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGVnYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DZWxsQ2xpY2tlZChuZXcgQ2VsbENsaWNrZWRFdmVudF8xLkNlbGxDbGlja2VkRXZlbnQodmFsdWUsIGNvbHVtbiwgcm93RGF0YSwgcm93TnVtYmVyLCBuZXcgQ2VsbF8xLkNlbGwoZS50YXJnZXQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0ZWRPbjogJycsXG4gICAgICAgICAgICBkYXRhOiBfdGhpcy5vcmlnaW5hbERhdGEuc2xpY2UoKSxcbiAgICAgICAgICAgIGNvbHVtbnM6IF90aGlzLmF0dHJzLnd3LmNvbHVtbnMsXG4gICAgICAgICAgICBhcnJvdzogJydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtb2RpZnlCb2R5IGFsbG93cyBhIGZ1bmN0aW9uIHRvIG1vZGlmeSB0aGUgY29udGVudHNcbiAgICAgKiBvZiB0aGUgPHRib2R5PlxuICAgICAqL1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb2RpZnlCb2R5ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy52aWV3LmZpbmRCeUlkKCdib2R5JykubWFwKGYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmF0dHJzLnd3ID8gdGhpcy5hdHRycy53dy5jb2x1bW5zID8gdGhpcy5hdHRycy53dy5jb2x1bW5zIDogW10gOiBbXTtcbiAgICAgICAgdmFyIGZpZWxkID0gY29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHsgcmV0dXJuIHAgPyBwIDogKGMubmFtZSA9PT0gbmFtZSA/IGMgOiBudWxsKTsgfSk7XG4gICAgICAgIHZhciBzb3J0T247XG4gICAgICAgIHZhciBzdHJhdGVneTtcbiAgICAgICAgaWYgKCFmaWVsZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhYmxlI3NvcnQ6IHVua25vd24gZmllbGQgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgc29ydE9uID0gZmllbGQuc29ydEFzIHx8IG5hbWU7XG4gICAgICAgIHN0cmF0ZWd5ID0gZmllbGQuc3RyYXRlZ3kgfHwgXzEuc3RyaW5nU29ydDtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLnNvcnRlZE9uID09PSBuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpcy52YWx1ZXMuZGF0YS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9ICh0aGlzLnZhbHVlcy5hcnJvdyA9PT0gXzEuQVNDX0FSUk9XKSA/IF8xLkRFU0NfQVJST1cgOiBfMS5BU0NfQVJST1c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5hcnJvdyA9IF8xLkRFU0NfQVJST1c7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gdGhpc1xuICAgICAgICAgICAgICAgIC5vcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzdHJhdGVneShwcm9wZXJ0eV9zZWVrXzEuZ2V0KHNvcnRPbiwgYSksIHByb3BlcnR5X3NlZWtfMS5nZXQoc29ydE9uLCBiKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnNvcnRlZE9uID0gbmFtZTtcbiAgICAgICAgdGhpcy52aWV3LmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGRhdGEgdGhlIHRhYmxlIGRpc3BsYXlzXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gZGF0YS5zbGljZSgpO1xuICAgICAgICB0aGlzLnZhbHVlcy5kYXRhID0gZGF0YS5zbGljZSgpO1xuICAgICAgICAodGhpcy52YWx1ZXMuc29ydGVkT24gPT09ICcnKSA/IHRoaXMudmlldy5pbnZhbGlkYXRlKCkgOiB0aGlzLnNvcnQodGhpcy52YWx1ZXMuc29ydGVkT24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNlbGxBdCBwcm9kdWNlcyBhIENlbGwgaW5zdGFuY2UgZm9yIHRoZSBjb29yZGluYXRlcyBwYXNzZWQgKGlmIGZvdW5kKS5cbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUuY2VsbEF0ID0gZnVuY3Rpb24gKGNvbHVtbiwgcm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAudmlld1xuICAgICAgICAgICAgLmZpbmRCeUlkKFwiXCIgKyBjb2x1bW4gKyByb3cpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBuZXcgQ2VsbF8xLkNlbGwoZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcHJlcGVuZCBhZGRzIG9uZSBvciBtb3JlIG5ldyBkYXRhIHJvd3MgdG8gdGhlIGJlZ2luaW5nIG9mIHRoZSB0YWJsZS5cbiAgICAgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gICAgICAgIHRoaXMubW9kaWZ5Qm9keShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRvbSA9IHZpZXcucm93cyhkLCBfdGhpcy52YWx1ZXMuY29sdW1ucykoX3RoaXMpKF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgaWYgKGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlLnJlcGxhY2VDaGlsZChkb20sIGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhZGRzIG9uZSBvciBtb3JlIG5ldyBkYXRhIHJvd3MgdG8gdGhlIGVuZCBvZiB0aGUgdGFibGUuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gICAgICAgIHRoaXMubW9kaWZ5Qm9keShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQodmlldy5yb3dzKGQsIF90aGlzLnZhbHVlcy5jb2x1bW5zKShfdGhpcykoX3RoaXMudmlldykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBwcmVwZW5kUm93IHByZXBlbmRzIGN1c3RvbWlzYWJsZSBET00gY29udGVudCB0byB0aGVcbiAgICAgKiBiZWdpbmluZyBvZiB0aGUgdGFibGUgYm9keS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgRE9NIGNvbnRlbnQgb2YgbXVzdCBiZSBiZXR3ZWVuIDx0cj4gZWxlbWVudHMuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnByZXBlbmRSb3cgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlCb2R5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5maXJzdENoaWxkID09IG51bGwpXG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChyZW5kZXJlci5yZW5kZXIoKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZS5yZXBsYWNlQ2hpbGQocmVuZGVyZXIucmVuZGVyKCksIGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwcGVuZFJvdyBhcHBlbmRzIGN1c3RvbWlzYWJsZSBET00gY29udGVudCB0byB0aGVcbiAgICAgKiBiZWdpbmluZyBvZiB0aGUgdGFibGUgYm9keS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgRE9NIGNvbnRlbnQgb2YgbXVzdCBiZSBiZXR3ZWVuIDx0cj4gZWxlbWVudHMuXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLmFwcGVuZFJvdyA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICB0aGlzLm1vZGlmeUJvZHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQocmVuZGVyZXIucmVuZGVyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZW1vdmVSb3cgd2lsbCByZW1vdmUgYW4gZW50aXJlIHJvdyBmcm9tIHRoZSB0YWJsZSBnaXZlbiBpdHMgaW5kZXguXG4gICAgICovXG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLm1vZGlmeUJvZHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGUucm93cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGUucm93c1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUucm93c1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZTtcbn0od21sXzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBbGxTZWxlY3RlZEV2ZW50XzEgPSByZXF1aXJlKFwiLi9BbGxTZWxlY3RlZEV2ZW50XCIpO1xuZXhwb3J0cy5BbGxTZWxlY3RlZEV2ZW50ID0gQWxsU2VsZWN0ZWRFdmVudF8xLkFsbFNlbGVjdGVkRXZlbnQ7XG52YXIgQ2VsbENsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vQ2VsbENsaWNrZWRFdmVudFwiKTtcbmV4cG9ydHMuQ2VsbENsaWNrZWRFdmVudCA9IENlbGxDbGlja2VkRXZlbnRfMS5DZWxsQ2xpY2tlZEV2ZW50O1xudmFyIFJvd0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vUm93Q2xpY2tlZEV2ZW50XCIpO1xuZXhwb3J0cy5Sb3dDbGlja2VkRXZlbnQgPSBSb3dDbGlja2VkRXZlbnRfMS5Sb3dDbGlja2VkRXZlbnQ7XG52YXIgSGVhZGluZ0NsaWNrZWRFdmVudF8xID0gcmVxdWlyZShcIi4vSGVhZGluZ0NsaWNrZWRFdmVudFwiKTtcbmV4cG9ydHMuSGVhZGluZ0NsaWNrZWRFdmVudCA9IEhlYWRpbmdDbGlja2VkRXZlbnRfMS5IZWFkaW5nQ2xpY2tlZEV2ZW50O1xudmFyIFRhYmxlXzEgPSByZXF1aXJlKFwiLi9UYWJsZVwiKTtcbmV4cG9ydHMuVGFibGUgPSBUYWJsZV8xLlRhYmxlO1xudmFyIENlbGxfMSA9IHJlcXVpcmUoXCIuL0NlbGxcIik7XG5leHBvcnRzLkNlbGwgPSBDZWxsXzEuQ2VsbDtcbmV4cG9ydHMuQVNDX0FSUk9XID0gJ1xcdTIxZTcnO1xuZXhwb3J0cy5ERVNDX0FSUk9XID0gJ1xcdTIxZTknO1xuZXhwb3J0cy5kYXRlU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG5hID0gbmV3IERhdGUoYSkuZ2V0VGltZSgpO1xuICAgIHZhciBuYiA9IG5ldyBEYXRlKGIpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmEgPiBuYiA/IC0xIDogbmEgPCBuYiA/IDEgOiAwO1xufTtcbmV4cG9ydHMuc3RyaW5nU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGxhID0gU3RyaW5nKGEpLnJlcGxhY2UoL1xccysvLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbGIgPSBTdHJpbmcoYikucmVwbGFjZSgvXFxzKy8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobGEgPiBsYikgPyAtMSA6IChsYSA8IGxiKSA/IDEgOiAwO1xufTtcbmV4cG9ydHMubmF0dXJhbFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHsgYSA9ICcnOyB9XG4gICAgaWYgKGIgPT09IHZvaWQgMCkgeyBiID0gJyc7IH1cbiAgICAvL1NvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzQwMjI3L3NvcnQtbWl4ZWQtYWxwaGEtbnVtZXJpYy1hcnJheVxuICAgIHZhciByZUEgPSAvW15hLXpBLVpdL2c7XG4gICAgdmFyIHJlTiA9IC9bXjAtOV0vZztcbiAgICB2YXIgQUludCA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICB2YXIgQkludCA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICBpZiAoaXNOYU4oQUludCkgJiYgaXNOYU4oQkludCkpIHtcbiAgICAgICAgdmFyIGFBID0gYS5yZXBsYWNlKHJlQSwgJycpO1xuICAgICAgICB2YXIgYkEgPSBiLnJlcGxhY2UocmVBLCAnJyk7XG4gICAgICAgIGlmIChhQSA9PT0gYkEpIHtcbiAgICAgICAgICAgIHZhciBhTiA9IHBhcnNlSW50KGEucmVwbGFjZShyZU4sICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIGJOID0gcGFyc2VJbnQoYi5yZXBsYWNlKHJlTiwgJycpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gYU4gPT09IGJOID8gMCA6IGFOID4gYk4gPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYUEgPiBiQSA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihBSW50KSkge1xuICAgICAgICByZXR1cm4gLTE7IC8vdG8gbWFrZSBhbHBoYW51bWVyaWMgc29ydCBmaXJzdCByZXR1cm4gLTEgaGVyZVxuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTihCSW50KSkge1xuICAgICAgICByZXR1cm4gMTsgLy90byBtYWtlIGFscGhhbnVtZXJpYyBzb3J0IGZpcnN0IHJldHVybiAxIGhlcmVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBBSW50ID4gQkludCA/IC0xIDogMTtcbiAgICB9XG59O1xuZXhwb3J0cy5udW1iZXJTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgbmEgPSBwYXJzZUZsb2F0KGEpO1xuICAgIHZhciBuYiA9IHBhcnNlRmxvYXQoYik7XG4gICAgbmEgPSAoaXNOYU4oYSkpID8gLUluZmluaXR5IDogYTtcbiAgICBuYiA9IChpc05hTihiKSkgPyAtSW5maW5pdHkgOiBiO1xuICAgIHJldHVybiAobmEgPiBuYikgPyAtMSA6IChuYSA8IG5iKSA/IDEgOiAwO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19fd21sID0gcmVxdWlyZShcIkBxdWVuay93bWxcIik7XG52YXIgbmFtZXMgPSByZXF1aXJlKFwiQHBhY2thZ2Uvc2VsZi9jb21tb24vbmFtZXNcIik7XG47XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBwYWNrYWdlL3NlbGYvY29tbW9uL3V0aWxcIik7XG47XG52YXIgcHJvcGVydHlfc2Vla18xID0gcmVxdWlyZShcInByb3BlcnR5LXNlZWtcIik7XG47XG52YXIgRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCJAcGFja2FnZS9zZWxmL2xheW91dC9mcmFnbWVudC9GcmFnbWVudFwiKTtcbjtcbmV4cG9ydHMuYWxsU2VsZWN0ZWRDaGVja2JveCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RoJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICd0eXBlJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC50aC5vblNlbGVjdFxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldyk7IH07IH07IH07XG47XG5leHBvcnRzLmhlYWRpbmdzID0gZnVuY3Rpb24gKGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm1hcChjb2x1bW5zLCBmdW5jdGlvbiBfbWFwKGZpZWxkKSB7XG4gICAgcmV0dXJuIChmaWVsZC5zb3J0QXMpID8gX19fd21sLm5vZGUoJ3RoJywge1xuICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAnY2xhc3MnOiB1dGlsXzEuY29uY2F0KF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLmhlYWRpbmcsICgoX19fY29udGV4dC52YWx1ZXMuc29ydGVkT24gPT09IGZpZWxkLm5hbWUpKSA/IG5hbWVzLkFDVElWRSA6IFwiXCIpLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50aGVhZC50aC5vbmNsaWNrKGZpZWxkLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHdtbDoge31cbiAgICB9LCBbX19fd21sLmRvbWlmeShmaWVsZC5oZWFkaW5nKSwgKChfX19jb250ZXh0LnZhbHVlcy5zb3J0ZWRPbiA9PT0gZmllbGQubmFtZSkpID8gX19fd21sLmRvbWlmeShfX19jb250ZXh0LnZhbHVlcy5hcnJvdykgOiBfX193bWwuZG9taWZ5KFwiXCIpXSwgX19fdmlldykgOiBfX193bWwubm9kZSgndGgnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IHV0aWxfMS5jb25jYXQoX19fY29udGV4dC52YWx1ZXMuY2xhc3MuaGVhZGluZywgKChfX19jb250ZXh0LnZhbHVlcy5zb3J0ZWRPbiA9PT0gZmllbGQubmFtZSkpID8gbmFtZXMuQUNUSVZFIDogXCJcIiksXG4gICAgICAgICAgICAnb25jbGljayc6IF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRoZWFkLnRoLm9uY2xpY2soZmllbGQubmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGZpZWxkLmhlYWRpbmcpLCBfX193bWwuZG9taWZ5KCgoX19fY29udGV4dC52YWx1ZXMuc29ydGVkT24gPT09IGZpZWxkLm5hbWUpKSA/IF9fX2NvbnRleHQudmFsdWVzLmFycm93IDogXCJcIildLCBfX192aWV3KTtcbn0sIGZ1bmN0aW9uIG90aGVyd2lzZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufSk7IH07IH07IH07XG47XG5leHBvcnRzLnRoZWFkID0gZnVuY3Rpb24gKGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLm5vZGUoJ3RyJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFsoX19fY29udGV4dC52YWx1ZXMub3B0aW9ucy5zZWxlY3RhYmxlKSA/IF9fX3dtbC5ib3goX19fd21sLmRvbWlmeShleHBvcnRzLmFsbFNlbGVjdGVkQ2hlY2tib3goKShfX19jb250ZXh0KShfX192aWV3KSksIF9fX3dtbC5kb21pZnkoZXhwb3J0cy5oZWFkaW5ncyhjb2x1bW5zKShfX19jb250ZXh0KShfX192aWV3KSkpIDogX19fd21sLmRvbWlmeShleHBvcnRzLmhlYWRpbmdzKGNvbHVtbnMpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5yb3dTZWxlY3RDaGVja2JveCA9IGZ1bmN0aW9uIChyb3csIGluZGV4KSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIChfX19jb250ZXh0LnZhbHVlcy5vcHRpb25zLnNlbGVjdGFibGUpID8gX19fd21sLm5vZGUoJ3RkJywge1xuICAgIGh0bWw6IHt9LFxuICAgIHdtbDoge31cbn0sIFtfX193bWwubm9kZSgnaW5wdXQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICd0eXBlJzogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ci5vblNlbGVjdChyb3csIGluZGV4LCBfX19jb250ZXh0LnZhbHVlcy5kYXRhKVxuICAgICAgICB9LFxuICAgICAgICB3bWw6IHt9XG4gICAgfSwgW10sIF9fX3ZpZXcpXSwgX19fdmlldykgOiBfX193bWwuZG9taWZ5KFwiXCIpOyB9OyB9OyB9O1xuO1xuZXhwb3J0cy5jZWxscyA9IGZ1bmN0aW9uIChyb3dEYXRhLCByb3dOdW1iZXIsIGNvbHVtbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX19jb250ZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoX19fdmlldykgeyByZXR1cm4gX19fd21sLmJveCgoX19fY29udGV4dC52YWx1ZXMub3B0aW9ucy5zZWxlY3RhYmxlKSA/IF9fX3dtbC5kb21pZnkoZXhwb3J0cy5yb3dTZWxlY3RDaGVja2JveChyb3dEYXRhLCByb3dOdW1iZXIpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKSA6IF9fX3dtbC5kb21pZnkoXCJcIiksIF9fX3dtbC5tYXAoY29sdW1ucywgZnVuY3Rpb24gX21hcChmaWVsZCkge1xuICAgIHJldHVybiBfX193bWwubm9kZSgndGQnLCB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLnRhYmxlLnRib2R5LnRkLmNsYXNzLFxuICAgICAgICAgICAgJ29uY2xpY2snOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ZC5vbmNsaWNrKHByb3BlcnR5X3NlZWtfMS5nZXQoZmllbGQubmFtZSwgcm93RGF0YSksIGZpZWxkLm5hbWUsIHJvd0RhdGEsIHJvd051bWJlcilcbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7XG4gICAgICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ZC5pZChmaWVsZC5uYW1lLCByb3dOdW1iZXIpXG4gICAgICAgIH1cbiAgICB9LCBbKGZpZWxkLmZyYWdtZW50KSA/IF9fX3dtbC5kb21pZnkoZmllbGQuZnJhZ21lbnQocHJvcGVydHlfc2Vla18xLmdldChmaWVsZC5uYW1lLCByb3dEYXRhKSwgZmllbGQubmFtZSwgcm93RGF0YSkoX19fdmlldykpIDogX19fd21sLmRvbWlmeShwcm9wZXJ0eV9zZWVrXzEuZ2V0KGZpZWxkLm5hbWUsIHJvd0RhdGEpKV0sIF9fX3ZpZXcpO1xufSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG59KSk7IH07IH07IH07XG47XG5leHBvcnRzLnJvd3MgPSBmdW5jdGlvbiAoZGF0YSwgY29sdW1ucykgeyByZXR1cm4gZnVuY3Rpb24gKF9fX2NvbnRleHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfX192aWV3KSB7IHJldHVybiBfX193bWwubWFwKGRhdGEsIGZ1bmN0aW9uIF9tYXAocm93RGF0YSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX19fd21sLm5vZGUoJ3RyJywge1xuICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAnY2xhc3MnOiBfX19jb250ZXh0LnZhbHVlcy50YWJsZS50Ym9keS50ci5jbGFzcyxcbiAgICAgICAgICAgICdvbmNsaWNrJzogX19fY29udGV4dC52YWx1ZXMudGFibGUudGJvZHkudHIub25jbGljayhyb3dEYXRhLCBpbmRleCwgZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgd21sOiB7fVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGV4cG9ydHMuY2VsbHMocm93RGF0YSwgaW5kZXgsIGNvbHVtbnMpKF9fX2NvbnRleHQpKF9fX3ZpZXcpKV0sIF9fX3ZpZXcpO1xufSwgZnVuY3Rpb24gb3RoZXJ3aXNlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG59KTsgfTsgfTsgfTtcbjtcbmV4cG9ydHMudGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoX19fY29udGV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKF9fX3ZpZXcpIHsgcmV0dXJuIF9fX3dtbC5ub2RlKCd0YWJsZScsIHtcbiAgICBodG1sOiB7XG4gICAgICAgICdjbGFzcyc6IF9fX2NvbnRleHQudmFsdWVzLmNsYXNzLnJvb3RcbiAgICB9LFxuICAgIHdtbDoge1xuICAgICAgICAnaWQnOiBfX19jb250ZXh0LnZhbHVlcy5pZC5yb290XG4gICAgfVxufSwgW19fX3dtbC5ub2RlKCd0aGVhZCcsIHtcbiAgICAgICAgaHRtbDoge30sXG4gICAgICAgIHdtbDoge1xuICAgICAgICAgICAgJ2lkJzogXCJoZWFkXCJcbiAgICAgICAgfVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGV4cG9ydHMudGhlYWQoX19fY29udGV4dC52YWx1ZXMuY29sdW1ucykoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyksIF9fX3dtbC5ub2RlKCd0Ym9keScsIHtcbiAgICAgICAgaHRtbDoge30sXG4gICAgICAgIHdtbDoge1xuICAgICAgICAgICAgJ2lkJzogXCJib2R5XCJcbiAgICAgICAgfVxuICAgIH0sIFtfX193bWwuZG9taWZ5KGV4cG9ydHMucm93cyhfX19jb250ZXh0LnZhbHVlcy5kYXRhLCBfX19jb250ZXh0LnZhbHVlcy5jb2x1bW5zKShfX19jb250ZXh0KShfX192aWV3KSldLCBfX192aWV3KV0sIF9fX3ZpZXcpOyB9OyB9OyB9O1xuO1xudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZShjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gZnVuY3Rpb24gKF9fX2NvbnRleHQsIF9fX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX193bWwud2lkZ2V0KEZyYWdtZW50XzEuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBodG1sOiB7fSxcbiAgICAgICAgICAgICAgICB3bWw6IHt9XG4gICAgICAgICAgICB9LCBbKChfX19jb250ZXh0LnZhbHVlcy5kYXRhLmxlbmd0aCA9PT0gMCkpID8gKF9fX2NvbnRleHQudmFsdWVzLmZyYWdtZW50LmVtcHR5KSA/IF9fX3dtbC5kb21pZnkoX19fY29udGV4dC52YWx1ZXMuZnJhZ21lbnQuZW1wdHkucmVuZGVyKCkpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnRhYmxlKCkoX19fY29udGV4dCkoX19fdmlldykpIDogX19fd21sLmRvbWlmeShleHBvcnRzLnRhYmxlKCkoX19fY29udGV4dCkoX19fdmlldykpXSwgX19fdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlO1xufShfX193bWwuQXBwVmlldykpO1xuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFdNTCBBU1QuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbjtcbi8qKlxuICogTW9kdWxlIGlzIHdoYXQgYSB3bWwgZmlsZSBjb21waWxlcyB0by5cbiAqXG4gKiBBIG1vZHVsZSBjb250YWlucyBhIGxpc3Qgb2YgaW1wb3J0cyBhbmQgZXhwb3J0ZWQgc3ltYm9scy5cbiAqIEFsbCBkZWNsYXJhdGlvbnMgaW4gd21sIGFyZSBleHBvcnRlZC4gVGhlcmUgaXMgbm8gc3VjaCB0aGluZ1xuICogYXMgcHJpdmF0ZSBoZXJlLlxuICovXG52YXIgTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZHVsZShpbXBvcnRzLCBleHBvcnRzLCBtYWluLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmltcG9ydHMgPSBpbXBvcnRzO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBleHBvcnRzO1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdtb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gTW9kdWxlO1xufSgpKTtcbmV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xuLyoqXG4gKiBJbXBvcnRTdGF0ZW1lbnRcbiAqL1xudmFyIEltcG9ydFN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRTdGF0ZW1lbnQobWVtYmVyLCBtb2R1bGUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1wb3J0LXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJbXBvcnRTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5JbXBvcnRTdGF0ZW1lbnQgPSBJbXBvcnRTdGF0ZW1lbnQ7XG4vKipcbiAqIEFsaWFzZWRNZW1iZXJcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gYWxpYXMgLSBUaGUgaWRlbnRpZmllciBpbnRyb2R1Y2VkIHRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBtZW1iZXIgLSBUaGUgaWRlbnRpZmllciB0aGF0IGlzIGFsaWFzZWQuXG4gKi9cbnZhciBBbGlhc2VkTWVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFsaWFzZWRNZW1iZXIobWVtYmVyLCBhbGlhcywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYWxpYXNlZC1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQWxpYXNlZE1lbWJlcjtcbn0oKSk7XG5leHBvcnRzLkFsaWFzZWRNZW1iZXIgPSBBbGlhc2VkTWVtYmVyO1xuLyoqXG4gKiBBZ2dyZWdhdGVNZW1iZXJcbiAqL1xudmFyIEFnZ3JlZ2F0ZU1lbWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZ2dyZWdhdGVNZW1iZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVhbGlmaWVkLW1lbWJlcic7XG4gICAgfVxuICAgIHJldHVybiBBZ2dyZWdhdGVNZW1iZXI7XG59KCkpO1xuZXhwb3J0cy5BZ2dyZWdhdGVNZW1iZXIgPSBBZ2dyZWdhdGVNZW1iZXI7XG4vKipcbiAqIENvbXBvc2l0ZU1lbWJlclxuICogQHByb3BlcnR5IHsuLi5JZGVudGlmaWVyfEFsaWFzZWRfTWVtYmVyfSBtZW1iZXJzXG4gKi9cbnZhciBDb21wb3NpdGVNZW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9zaXRlTWVtYmVyKG1lbWJlcnMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbXBvc2l0ZS1tZW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9zaXRlTWVtYmVyO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9zaXRlTWVtYmVyID0gQ29tcG9zaXRlTWVtYmVyO1xudmFyIFR5cGVkTWFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlZE1haW4oaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtbWFpbic7XG4gICAgfVxuICAgIHJldHVybiBUeXBlZE1haW47XG59KCkpO1xuZXhwb3J0cy5UeXBlZE1haW4gPSBUeXBlZE1haW47XG52YXIgVW50eXBlZE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW50eXBlZE1haW4odGFnLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1tYWluJztcbiAgICB9XG4gICAgcmV0dXJuIFVudHlwZWRNYWluO1xufSgpKTtcbmV4cG9ydHMuVW50eXBlZE1haW4gPSBVbnR5cGVkTWFpbjtcbnZhciBFeHBvcnRTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0U3RhdGVtZW50KG1lbWJlcnMsIG1vZHVsZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4cG9ydC1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRXhwb3J0U3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRXhwb3J0U3RhdGVtZW50ID0gRXhwb3J0U3RhdGVtZW50O1xuLyoqXG4gKiBWaWV3U3RhdGVtZW50XG4gKi9cbnZhciBWaWV3U3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdTdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCB0YWcsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlQ2xhc3NlcyA9IHR5cGVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndmlldy1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gVmlld1N0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLlZpZXdTdGF0ZW1lbnQgPSBWaWV3U3RhdGVtZW50O1xudmFyIEZ1blN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5TdGF0ZW1lbnQoaWQsIHR5cGVDbGFzc2VzLCBjb250ZXh0LCBwYXJhbWV0ZXJzLCBib2R5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBGdW5TdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5GdW5TdGF0ZW1lbnQgPSBGdW5TdGF0ZW1lbnQ7XG4vKipcbiAqIFR5cGVDbGFzc1xuICovXG52YXIgVHlwZUNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVDbGFzcyhpZCwgY29uc3RyYWludCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd0eXBlLWNsYXNzJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVDbGFzcztcbn0oKSk7XG5leHBvcnRzLlR5cGVDbGFzcyA9IFR5cGVDbGFzcztcbnZhciBUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGUoaWQsIHR5cGVDbGFzc2VzLCBsaXN0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZUNsYXNzZXMgPSB0eXBlQ2xhc3NlcztcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZSc7XG4gICAgfVxuICAgIHJldHVybiBUeXBlO1xufSgpKTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG52YXIgVHlwZWRQYXJhbWV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZWRQYXJhbWV0ZXIoaWQsIGhpbnQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5oaW50ID0gaGludDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHlwZWQtcGFyYW1ldGVyJztcbiAgICB9XG4gICAgcmV0dXJuIFR5cGVkUGFyYW1ldGVyO1xufSgpKTtcbmV4cG9ydHMuVHlwZWRQYXJhbWV0ZXIgPSBUeXBlZFBhcmFtZXRlcjtcbnZhciBVbnR5cGVkUGFyYW1ldGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVudHlwZWRQYXJhbWV0ZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW50eXBlZC1wYXJhbWV0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gVW50eXBlZFBhcmFtZXRlcjtcbn0oKSk7XG5leHBvcnRzLlVudHlwZWRQYXJhbWV0ZXIgPSBVbnR5cGVkUGFyYW1ldGVyO1xudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShvcGVuLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICB9XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KG9wZW4sIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBjbG9zZSkge1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3dpZGdldCc7XG4gICAgfVxuICAgIHJldHVybiBXaWRnZXQ7XG59KCkpO1xuZXhwb3J0cy5XaWRnZXQgPSBXaWRnZXQ7XG52YXIgQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lc3BhY2UsIG5hbWUsIHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdhdHRyaWJ1dGUnO1xuICAgIH1cbiAgICByZXR1cm4gQXR0cmlidXRlO1xufSgpKTtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xudmFyIEludGVycG9sYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihleHByZXNzaW9uLCBmaWx0ZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbnRlcnBvbGF0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KCkpO1xuZXhwb3J0cy5JbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGlvbjtcbnZhciBGb3JTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KHZhcmlhYmxlLCBpbmRleCwgYWxsLCBsaXN0LCBib2R5LCBvdGhlcndpc2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmFsbCA9IGFsbDtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Zvci1zdGF0ZW1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xufSgpKTtcbmV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xudmFyIElmU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXN0YXRlbWVudCc7XG4gICAgfVxuICAgIHJldHVybiBJZlN0YXRlbWVudDtcbn0oKSk7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG52YXIgRWxzZUNsYXVzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbHNlQ2xhdXNlKGNoaWxkcmVuLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VDbGF1c2U7XG59KCkpO1xuZXhwb3J0cy5FbHNlQ2xhdXNlID0gRWxzZUNsYXVzZTtcbnZhciBFbHNlSWZDbGF1c2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxzZUlmQ2xhdXNlKGNvbmRpdGlvbiwgdGhlbiwgZWxzZUNsYXVzZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Vsc2UtaWYtY2xhdXNlJztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VJZkNsYXVzZTtcbn0oKSk7XG5leHBvcnRzLkVsc2VJZkNsYXVzZSA9IEVsc2VJZkNsYXVzZTtcbnZhciBDaGFyYWN0ZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJhY3RlcnModmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2hhcmFjdGVycyc7XG4gICAgfVxuICAgIHJldHVybiBDaGFyYWN0ZXJzO1xufSgpKTtcbmV4cG9ydHMuQ2hhcmFjdGVycyA9IENoYXJhY3RlcnM7XG52YXIgSWZUaGVuRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZlRoZW5FeHByZXNzaW9uKGNvbmRpdGlvbiwgaWZ0cnVlLCBpZmZhbHNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5pZnRydWUgPSBpZnRydWU7XG4gICAgICAgIHRoaXMuaWZmYWxzZSA9IGlmZmFsc2U7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lmLXRoZW4tZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBJZlRoZW5FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuSWZUaGVuRXhwcmVzc2lvbiA9IElmVGhlbkV4cHJlc3Npb247XG52YXIgQmluYXJ5RXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeS1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbnZhciBVbmFyeUV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VuYXJ5LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xudmFyIFZpZXdDb25zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0NvbnN0cnVjdGlvbihjb25zLCBjb250ZXh0LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmNvbnMgPSBjb25zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICd2aWV3LWNvbnN0cnVjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29uc3RydWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuVmlld0NvbnN0cnVjdGlvbiA9IFZpZXdDb25zdHJ1Y3Rpb247XG52YXIgRnVuQXBwbGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuQXBwbGljYXRpb24odGFyZ2V0LCB0eXBlQXJncywgY29udGV4dCwgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudHlwZUFyZ3MgPSB0eXBlQXJncztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnVuLWFwcGxpY2F0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIEZ1bkFwcGxpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuQXBwbGljYXRpb24gPSBGdW5BcHBsaWNhdGlvbjtcbnZhciBDb25zdHJ1Y3RFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0cnVjdEV4cHJlc3Npb24oY29ucywgYXJncywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25zID0gY29ucztcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29uc3RydWN0LWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gQ29uc3RydWN0RXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNvbnN0cnVjdEV4cHJlc3Npb24gPSBDb25zdHJ1Y3RFeHByZXNzaW9uO1xudmFyIENhbGxFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKHRhcmdldCwgdHlwZUFyZ3MsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnR5cGVBcmdzID0gdHlwZUFyZ3M7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NhbGwtZXhwcmVzc2lvbic7XG4gICAgfVxuICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG4vKipcbiAqIE1lbWJlckV4cHJlc3Npb25cbiAqL1xudmFyIE1lbWJlckV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtYmVyRXhwcmVzc2lvbih0YXJnZXQsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIHJldHVybiBNZW1iZXJFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuTWVtYmVyRXhwcmVzc2lvbiA9IE1lbWJlckV4cHJlc3Npb247XG52YXIgUmVhZEV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVhZEV4cHJlc3Npb24odGFyZ2V0LCBwYXRoLCBoaW50LCBkZWZhdWx0cywgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVhZC1leHByZXNzaW9uJztcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRFeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuUmVhZEV4cHJlc3Npb24gPSBSZWFkRXhwcmVzc2lvbjtcbnZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtZXRlcnMsIGJvZHksIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uLWV4cHJlc3Npb24nO1xuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xudmFyIExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdChtZW1iZXJzLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdsaXN0JztcbiAgICB9XG4gICAgcmV0dXJuIExpc3Q7XG59KCkpO1xuZXhwb3J0cy5MaXN0ID0gTGlzdDtcbnZhciBSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb3JkKHByb3BlcnRpZXMsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlY29yZCc7XG4gICAgfVxuICAgIHJldHVybiBSZWNvcmQ7XG59KCkpO1xuZXhwb3J0cy5SZWNvcmQgPSBSZWNvcmQ7XG52YXIgUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvcGVydHkoa2V5LCB2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAncHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gUHJvcGVydHk7XG59KCkpO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xudmFyIFN0cmluZ0xpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHJpbmcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nTGl0ZXJhbDtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBTdHJpbmdMaXRlcmFsO1xudmFyIE51bWJlckxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbCh2YWx1ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdudW1iZXItbGl0ZXJhbCc7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJMaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IE51bWJlckxpdGVyYWw7XG52YXIgQm9vbGVhbkxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwodmFsdWUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm9vbGVhbi1saXRlcmFsJztcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW5MaXRlcmFsO1xufSgpKTtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbnZhciBDb250ZXh0UHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dFByb3BlcnR5KG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5tZW1iZXIgPSBtZW1iZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbnRleHQtcHJvcGVydHknO1xuICAgIH1cbiAgICByZXR1cm4gQ29udGV4dFByb3BlcnR5O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dFByb3BlcnR5ID0gQ29udGV4dFByb3BlcnR5O1xudmFyIENvbnRleHRWYXJpYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0VmFyaWFibGUobG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29udGV4dC12YXJpYWJsZSc7XG4gICAgfVxuICAgIHJldHVybiBDb250ZXh0VmFyaWFibGU7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0VmFyaWFibGUgPSBDb250ZXh0VmFyaWFibGU7XG52YXIgVW5xdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZENvbnN0cnVjdG9yKGlkLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VucXVhbGlmaWVkLWNvbnN0cnVjdG9yJztcbiAgICB9XG4gICAgcmV0dXJuIFVucXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZENvbnN0cnVjdG9yID0gVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcjtcbnZhciBRdWFsaWZpZWRDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWFsaWZpZWRDb25zdHJ1Y3RvcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtY29uc3RydWN0b3InO1xuICAgIH1cbiAgICByZXR1cm4gUXVhbGlmaWVkQ29uc3RydWN0b3I7XG59KCkpO1xuZXhwb3J0cy5RdWFsaWZpZWRDb25zdHJ1Y3RvciA9IFF1YWxpZmllZENvbnN0cnVjdG9yO1xudmFyIFVucXVhbGlmaWVkSWRlbnRpZmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnF1YWxpZmllZElkZW50aWZpZXIoaWQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAndW5xdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBVbnF1YWxpZmllZElkZW50aWZpZXI7XG59KCkpO1xuZXhwb3J0cy5VbnF1YWxpZmllZElkZW50aWZpZXIgPSBVbnF1YWxpZmllZElkZW50aWZpZXI7XG4vKipcbiAqIFF1YWxpZmllZElkZW50aWZpZXJcbiAqL1xudmFyIFF1YWxpZmllZElkZW50aWZpZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVhbGlmaWVkSWRlbnRpZmllcihxdWFsaWZpZXIsIG1lbWJlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbWVtYmVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWFsaWZpZWQtaWRlbnRpZmllcic7XG4gICAgfVxuICAgIHJldHVybiBRdWFsaWZpZWRJZGVudGlmaWVyO1xufSgpKTtcbmV4cG9ydHMuUXVhbGlmaWVkSWRlbnRpZmllciA9IFF1YWxpZmllZElkZW50aWZpZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BU1QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPSdQYXJzZXIuZC50cycgLz5cbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XG52YXIgbm9kZXMgPSByZXF1aXJlKFwiLi9BU1RcIik7XG52YXIgYWZwbCA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGpzZm10ID0gcmVxdWlyZShcImpzLWJlYXV0aWZ5XCIpO1xudmFyIFR5cGVTY3JpcHQgPSByZXF1aXJlKFwiLi9UeXBlU2NyaXB0XCIpO1xudmFyIGFmcGxfMSA9IHJlcXVpcmUoXCJhZnBsXCIpO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBtYWluOiAnTWFpbicsXG4gICAgbW9kdWxlOiAnQHF1ZW5rL3dtbCcsXG59O1xuLyoqXG4gKiBwYXJzZSBhIHN0cmluZyBhcyBXTUwgcmV0dXJuaW5nIGVpdGhlciBhbiBlcnJvciBvciBhbiBBU1QuXG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBhc3QpIHtcbiAgICBpZiAoYXN0ID09PSB2b2lkIDApIHsgYXN0ID0gbm9kZXM7IH1cbiAgICBQYXJzZXIucGFyc2VyLnl5ID0geyBhc3Q6IGFzdCB9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLnJpZ2h0KFBhcnNlci5wYXJzZXIucGFyc2Uoc3RyKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBhZnBsXzEuRWl0aGVyLmxlZnQoZSk7XG4gICAgfVxufTtcbi8qKlxuICogcHJldHR5IHVwIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24gKGRvaXQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIGRvaXQgPyBqc2ZtdChzLCB7fSkgOiBzO1xufTsgfTtcbi8qKlxuICogY29tcGlsZSBhIHN0cmluZyBvZiBXTUwgdHVybmluZyBpdCBpbnRvIHR5cGVzY3JpcHQgY29kZS5cbiAqL1xuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9wdHMgPSBhZnBsLnV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBleHBvcnRzLnBhcnNlKHNyYylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gVHlwZVNjcmlwdC5jb2RlKG0sIG9wdHMpOyB9KVxuICAgICAgICAubWFwKGV4cG9ydHMucHJldHR5KG9wdGlvbnMucHJldHR5KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcGlsZXIuanMubWFwIiwiXG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNi4xLTIwMyAqL1xuXG4vKlxuICogUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIFBhcnNlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRlcml2YXRpdmUvY29weSBvZiB0aGlzIG9uZSxcbiAqICAgICAgICAgICAgICAgbm90IGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqICB9XG4gKlxuICogIFBhcnNlci5wcm90b3R5cGU6IHtcbiAqICAgIHl5OiB7fSxcbiAqICAgIEVPRjogMSxcbiAqICAgIFRFUlJPUjogMixcbiAqXG4gKiAgICB0cmFjZTogZnVuY3Rpb24oZXJyb3JNZXNzYWdlLCAuLi4pLFxuICpcbiAqICAgIEppc29uUGFyc2VyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKlxuICogICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlXG4gKiAgICAgICAgICAgICAgIHF1b3RlcyBhcm91bmQgbGl0ZXJhbCBJRHMgaW4gYSBkZXNjcmlwdGlvbiBzdHJpbmcuXG4gKlxuICogICAgb3JpZ2luYWxRdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgcXVvdGVOYW1lIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcXVvdGVOYW1lKClgIHRvIHJlZmVyZW5jZSB0aGlzIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYC5cbiAqXG4gKiAgICBkZXNjcmliZVN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSxcbiAqICAgICAgICAgICAgICAgUmV0dXJuIGEgbW9yZS1vci1sZXNzIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBzeW1ib2wsIHdoZW5cbiAqICAgICAgICAgICAgICAgYXZhaWxhYmxlLCBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2tcbiAqICAgICAgICAgICAgICAgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbiAqXG4gKiAgICAgICAgICAgICAgIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG4gKlxuICogICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICogICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gKiAgICBub250ZXJtaW5hbHM6IHthc3NvY2lhdGl2ZSBsaXN0OiBydWxlLW5hbWUgPT0+IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IHJ1bGUtYWx0fX0sXG4gKiAgICB0ZXJtaW5hbF9kZXNjcmlwdGlvbnNfOiAoaWYgdGhlcmUgYXJlIGFueSkge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gZGVzY3JpcHRpb259LFxuICogICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX3BlcmZvcm1BY3Rpb24oeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eWxvYywgeXlzdGF0ZSwgeXlzcCwgeXl2c3RhY2ssIHl5bHN0YWNrLCB5eXN0YWNrLCB5eXNzdGFjayksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYHl5dmFsYCBpbnRlcm5hbCBvYmplY3QsIHdoaWNoIGhhcyBtZW1iZXJzIChgJGAgYW5kIGBfJGApXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RvcmUvcmVmZXJlbmNlIHRoZSBydWxlIHZhbHVlIGAkJGAgYW5kIGxvY2F0aW9uIGluZm8gYEAkYC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgT25lIGltcG9ydGFudCB0aGluZyB0byBub3RlIGFib3V0IGB0aGlzYCBhLmsuYS4gYHl5dmFsYDogZXZlcnkgKnJlZHVjZSogYWN0aW9uIGdldHNcbiAqICAgICAgICAgICAgICAgICB0byBzZWUgdGhlIHNhbWUgb2JqZWN0IHZpYSB0aGUgYHRoaXNgIHJlZmVyZW5jZSwgaS5lLiBpZiB5b3Ugd2lzaCB0byBjYXJyeSBjdXN0b21cbiAqICAgICAgICAgICAgICAgICBkYXRhIGZyb20gb25lIHJlZHVjZSBhY3Rpb24gdGhyb3VnaCB0byB0aGUgbmV4dCB3aXRoaW4gYSBzaW5nbGUgcGFyc2UgcnVuLCB0aGVuIHlvdVxuICogICAgICAgICAgICAgICAgIG1heSBnZXQgbmFzdHkgYW5kIHVzZSBgeXl2YWxgIGEuay5hLiBgdGhpc2AgZm9yIHN0b3JpbmcgeW91IG93biBzZW1pLXBlcm1hbmVudCBkYXRhLlxuICpcbiAqICAgICAgICAgICAgICAgICBgdGhpcy55eWAgaXMgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIHNoYXJlZCBzdGF0ZSBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICAgIGAlcGFyc2UtcGFyYW1gLXNwZWNpZmllZCBhZGRpdGlvbmFsIGBwYXJzZSgpYCBhcmd1bWVudHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgYHl5YFxuICogICAgICAgICAgICAgICAgIG9iamVjdCBhdCBgcGFyc2UoKWAgc3RhcnQgYW5kIGFyZSB0aGVyZWZvcmUgYXZhaWxhYmxlIHRvIHRoZSBhY3Rpb24gY29kZSB2aWEgdGhlXG4gKiAgICAgICAgICAgICAgICAgc2FtZSBuYW1lZCBgeXkueHh4eGAgYXR0cmlidXRlcyAod2hlcmUgYHh4eHhgIHJlcHJlc2VudHMgYSBpZGVudGlmaWVyIG5hbWUgZnJvbVxuICogICAgICAgICAgICAgICAgIHRoZSAlcGFyc2UtcGFyYW1gIGxpc3QuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXRleHRgICA6IHJlZmVyZW5jZSB0byB0aGUgbGV4ZXIgdmFsdWUgd2hpY2ggYmVsb25ncyB0byB0aGUgbGFzdCBsZXhlciB0b2tlbiB1c2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gbWF0Y2ggdGhpcyBydWxlLiBUaGlzIGlzICpub3QqIHRoZSBsb29rLWFoZWFkIHRva2VuLCBidXQgdGhlIGxhc3QgdG9rZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0J3MgYWN0dWFsbHkgcGFydCBvZiB0aGlzIHJ1bGUuXG4gKlxuICogICAgICAgICAgICAgICAgIEZvcm11bGF0ZWQgYW5vdGhlciB3YXksIGB5eXRleHRgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW1tZWRpYXRlbHkgcHJlY2VlZGluZ1xuICogICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGxvb2stYWhlYWQgdG9rZW4uXG4gKiAgICAgICAgICAgICAgICAgQ2F2ZWF0cyBhcHBseSBmb3IgcnVsZXMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBsb29rLWFoZWFkLCBzdWNoIGFzIGVwc2lsb24gcnVsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxlbmdgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGVuZyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGluZW5vYDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsaW5lbm8gdmFsdWUuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxvY2AgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGxvYyBsZXhlciB0b2tlbiBsb2NhdGlvbiBpbmZvLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdBUk5JTkc6IHNpbmNlIGppc29uIDAuNC4xOC0xODYgdGhpcyBlbnRyeSBtYXkgYmUgTlVMTC9VTkRFRklORUQgaW5zdGVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYW4gZW1wdHkgb2JqZWN0IHdoZW4gbm8gc3VpdGFibGUgbG9jYXRpb24gaW5mbyBjYW4gYmUgcHJvdmlkZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YXRlYCA6IHRoZSBjdXJyZW50IHBhcnNlciBzdGF0ZSBudW1iZXIsIHVzZWQgaW50ZXJuYWxseSBmb3IgZGlzcGF0Y2hpbmcgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpbmcgdGhlIGFjdGlvbiBjb2RlIGNodW5rIG1hdGNoaW5nIHRoZSBydWxlIGN1cnJlbnRseSBiZWluZyByZWR1Y2VkLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzcGAgICAgOiB0aGUgY3VycmVudCBzdGF0ZSBzdGFjayBwb3NpdGlvbiAoYS5rLmEuICdzdGFjayBwb2ludGVyJylcbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAgIEFsc28gbm90ZSB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoaXMgYW5kIG90aGVyIHN0YWNrIGluZGV4IHZhbHVlcyB1c2luZyB0aGUgbmV3IGRvdWJsZS1oYXNoXG4gKiAgICAgICAgICAgICAgICAgc3ludGF4LCBpLmUuIGAjIyQgPT09ICMjMCA9PT0geXlzcGAsIHdoaWxlIGAjIzFgIGlzIHRoZSBzdGFjayBpbmRleCBmb3IgYWxsIHRoaW5nc1xuICogICAgICAgICAgICAgICAgIHJlbGF0ZWQgdG8gdGhlIGZpcnN0IHJ1bGUgdGVybSwganVzdCBsaWtlIHlvdSBoYXZlIGAkMWAsIGBAMWAgYW5kIGAjMWAuXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBpcyBtYWRlIGF2YWlsYWJsZSB0byB3cml0ZSB2ZXJ5IGFkdmFuY2VkIGdyYW1tYXIgYWN0aW9uIHJ1bGVzLCBlLmcuIHdoZW4geW91IHdhbnRcbiAqICAgICAgICAgICAgICAgICB0byBpbnZlc3RpZ2F0ZSB0aGUgcGFyc2Ugc3RhdGUgc3RhY2sgaW4geW91ciBhY3Rpb24gY29kZSwgd2hpY2ggd291bGQsIGZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgIGJlIHJlbGV2YW50IHdoZW4geW91IHdpc2ggdG8gaW1wbGVtZW50IGVycm9yIGRpYWdub3N0aWNzIGFuZCByZXBvcnRpbmcgc2NoZW1lcyBzaW1pbGFyXG4gKiAgICAgICAgICAgICAgICAgdG8gdGhlIHdvcmsgZGVzY3JpYmVkIGhlcmU6XG4gKlxuICogICAgICAgICAgICAgICAgICsgUG90dGllciwgRi4sIDIwMTYuIFJlYWNoYWJpbGl0eSBhbmQgZXJyb3IgZGlhZ25vc2lzIGluIExSKDEpIGF1dG9tYXRhLlxuICogICAgICAgICAgICAgICAgICAgSW4gSm91cm7DqWVzIEZyYW5jb3Bob25lcyBkZXMgTGFuZ3VhZ2VzIEFwcGxpY2F0aWZzLlxuICpcbiAqICAgICAgICAgICAgICAgICArIEplZmZlcnksIEMuTC4sIDIwMDMuIEdlbmVyYXRpbmcgTFIgc3ludGF4IGVycm9yIG1lc3NhZ2VzIGZyb20gZXhhbXBsZXMuXG4gKiAgICAgICAgICAgICAgICAgICBBQ00gVHJhbnNhY3Rpb25zIG9uIFByb2dyYW1taW5nIExhbmd1YWdlcyBhbmQgU3lzdGVtcyAoVE9QTEFTKSwgMjUoNSksIHBwLjYzMeKAkzY0MC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZWxlbmd0aGA6IHRoZSBjdXJyZW50IHJ1bGUncyB0ZXJtIGNvdW50LCBpLmUuIHRoZSBudW1iZXIgb2YgZW50cmllcyBvY2N1cGllZCBvbiB0aGUgc3RhY2suXG4gKlxuICogICAgICAgICAgICAgICAgIFRoaXMgb25lIGNvbWVzIGluIGhhbmR5IHdoZW4geW91IGFyZSBnb2luZyB0byBkbyBhZHZhbmNlZCB0aGluZ3MgdG8gdGhlIHBhcnNlclxuICogICAgICAgICAgICAgICAgIHN0YWNrcywgYWxsIG9mIHdoaWNoIGFyZSBhY2Nlc3NpYmxlIGZyb20geW91ciBhY3Rpb24gY29kZSAoc2VlIHRoZSBuZXh0IGVudHJpZXMgYmVsb3cpLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXl2c3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciB2YWx1ZSBzdGFjay4gQWxzbyBhY2Nlc3NlZCB2aWEgdGhlIGAkMWAgZXRjLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdHMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGxvY2F0aW9uIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgQDFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGFycmF5IE1BWSBjb250YWluIHNsb3RzIHdoaWNoIGFyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVOREVGSU5FRCByYXRoZXIgdGhhbiBhbiBlbXB0eSAobG9jYXRpb24pIG9iamVjdCwgd2hlbiB0aGUgbGV4ZXIvcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uIGNvZGUgZGlkIG5vdCBwcm92aWRlIGEgc3VpdGFibGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hlbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90IHdhcyBmaWxsZWQhXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YWNrYCA6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGlkIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIzFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZTogdGhpcyBpcyBhIGJpdCBvZiBhICoqd2hpdGUgbGllKiogYXMgd2UgY2FuIHN0YXRpY2FsbHkgZGVjb2RlIGFueSBgI25gIHJlZmVyZW5jZSB0b1xuICogICAgICAgICAgICAgICAgIGl0cyBudW1lcmljIHRva2VuIGlkIHZhbHVlLCBoZW5jZSB0aGF0IGNvZGUgd291bGRuJ3QgbmVlZCB0aGUgYHl5c3RhY2tgIGJ1dCAqeW91KiBtaWdodFxuICogICAgICAgICAgICAgICAgIHdhbnQgYWNjZXNzIHRoaXMgYXJyYXkgZm9yIHlvdXIgb3duIHB1cnBvc2VzLCBzdWNoIGFzIGVycm9yIGFuYWx5c2lzIGFzIG1lbnRpb25lZCBhYm92ZSFcbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoaXMgc3RhY2sgc3RvcmVzIHRoZSBjdXJyZW50IHN0YWNrIG9mICp0b2tlbnMqLCB0aGF0IGlzIHRoZSBzZXF1ZW5jZSBvZlxuICogICAgICAgICAgICAgICAgIGFscmVhZHkgcGFyc2VkPXJlZHVjZWQgKm5vbnRlcm1pbmFscyogKHRva2VucyByZXByZXNlbnRpbmcgcnVsZXMpIGFuZCAqdGVybWluYWxzKlxuICogICAgICAgICAgICAgICAgIChsZXhlciB0b2tlbnMgKnNoaWZ0ZWQqIG9udG8gdGhlIHN0YWNrIHVudGlsIHRoZSBydWxlIHRoZXkgYmVsb25nIHRvIGlzIGZvdW5kIGFuZFxuICogICAgICAgICAgICAgICAgICpyZWR1Y2VkKi5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3N0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgc3RhdGUgc3RhY2suIFRoaXMgb25lIGNhcnJpZXMgdGhlIGludGVybmFsIHBhcnNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICpzdGF0ZXMqIHN1Y2ggYXMgdGhlIG9uZSBpbiBgeXlzdGF0ZWAsIHdoaWNoIGFyZSB1c2VkIHRvIHJlcHJlc2VudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpbiB0aGUgKnBhcnNlIHRhYmxlKi4gKlZlcnkqICppbnRlcm5hbCogc3R1ZmYsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hhdCBjYW4gSSBzYXk/IElmIHlvdSBhY2Nlc3MgdGhpcyBvbmUsIHlvdSdyZSBjbGVhcmx5IGRvaW5nIHdpY2tlZCB0aGluZ3NcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYC4uLmAgICAgIDogdGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXIgZGVmaW5pdGlvbiBmaWxlLlxuICpcbiAqICAgIHRhYmxlOiBbLi4uXSxcbiAqICAgICAgICAgICAgICAgU3RhdGUgdHJhbnNpdGlvbiB0YWJsZVxuICogICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogICAgICAgICAgICAgICBpbmRleCBsZXZlbHMgYXJlOlxuICogICAgICAgICAgICAgICAtIGBzdGF0ZWAgIC0tPiBoYXNoIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0gYHN5bWJvbGAgLS0+IGFjdGlvbiAobnVtYmVyIG9yIGFycmF5KVxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYW4gYXJyYXksIHRoZXNlIGFyZSB0aGUgZWxlbWVudHMnIG1lYW5pbmc6XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMF06IDEgPSBzaGlmdCwgMiA9IHJlZHVjZSwgMyA9IGFjY2VwdFxuICogICAgICAgICAgICAgICAgIC0gaW5kZXggWzFdOiBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICAgICAgICAgICAgICAgSWYgdGhlIGBhY3Rpb25gIGlzIGEgbnVtYmVyLCBpdCBpcyB0aGUgR09UTyBgc3RhdGVgXG4gKlxuICogICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgeXlFcnJvcjogZnVuY3Rpb24oc3RyLCAuLi4pLFxuICogICAgeXlSZWNvdmVyaW5nOiBmdW5jdGlvbigpLFxuICogICAgeXlFcnJPazogZnVuY3Rpb24oKSxcbiAqICAgIHl5Q2xlYXJJbjogZnVuY3Rpb24oKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgZXhjZXB0aW9uX29iamVjdCwgZXhwZWN0ZWRfdG9rZW5fc2V0LCBpc19yZWNvdmVyYWJsZSksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIHBhcnNlciBrZXJuZWwgaW4gbWFueSBwbGFjZXM7IGV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgdmFyIGluZm9PYmogPSBwYXJzZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgbnVsbCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSksIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHBhcnNlci5wYXJzZUVycm9yKGluZm9PYmouZXJyU3RyLCBpbmZvT2JqLCBwYXJzZXIuSmlzb25QYXJzZXJFcnJvcik7XG4gKlxuICogICAgb3JpZ2luYWxQYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICAgICAgICAgVGhlIGJhc2ljIGBwYXJzZUVycm9yYCBoYW5kbGVyIHByb3ZpZGVkIGJ5IEpJU09OLlxuICogICAgICAgICAgICAgICBgY2xlYW51cEFmdGVyUGFyc2UoKWAgd2lsbCBjbGVhbiB1cCBhbmQgcmVzZXQgYHBhcnNlRXJyb3IoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIG9wdGlvbnM6IHsgLi4uIHBhcnNlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXRbLCBhcmdzLi4uXSksXG4gKiAgICAgICAgICAgICAgIFBhcnNlIHRoZSBnaXZlbiBgaW5wdXRgIGFuZCByZXR1cm4gdGhlIHBhcnNlZCB2YWx1ZSAob3IgYHRydWVgIHdoZW4gbm9uZSB3YXMgcHJvdmlkZWQgYnlcbiAqICAgICAgICAgICAgICAgdGhlIHJvb3QgYWN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwYXJzZXIgaXMgYWN0aW5nIGFzIGEgKm1hdGNoZXIqKS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhpcyBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIFBhcnNlcidzIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgKHZpYSBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSBqaXNvbiBydW4tdGltZTtcbiAqICAgICAgICAgICAgICAgd2hlbiBzdWNoIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gdG8gcHJldmVudCB0aGUgZ2VuZXJhdGVkIHJ1bi10aW1lXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uIVxuICpcbiAqICAgICAgICAgICAgICAgVGhlIGxleGVyIE1BWSBhZGQgaXRzIG93biBzZXQgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzICh2aWEgdGhlIGAlcGFyc2UtcGFyYW1gIGxpbmUgaW5cbiAqICAgICAgICAgICAgICAgdGhlIGxleGVyIHNlY3Rpb24gb2YgdGhlIGdyYW1tYXIgc3BlYyk6IHRoZXNlIHdpbGwgYmUgaW5zZXJ0ZWQgaW4gdGhlIGB5eWAgc2hhcmVkIHN0YXRlXG4gKiAgICAgICAgICAgICAgIG9iamVjdCBhbmQgYW55IGNvbGxpc2lvbiB3aXRoIHRob3NlIHdpbGwgYmUgcmVwb3J0ZWQgYnkgdGhlIGxleGVyIHZpYSBhIHRocm93biBleGNlcHRpb24uXG4gKlxuICogICAgY2xlYW51cEFmdGVyUGFyc2U6IGZ1bmN0aW9uKHJlc3VsdFZhbHVlLCBpbnZva2VfcG9zdF9tZXRob2RzLCBkb19ub3RfbnVrZV9lcnJvcmluZm9zKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYCBjYWxsLCB1bmxlc3MgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd25cbiAqICAgICAgICAgICAgICAgYW5kIGAlb3B0aW9ucyBuby10cnktY2F0Y2hgIGhhcyBiZWVuIGRlZmluZWQgZm9yIHRoaXMgZ3JhbW1hcjogaW4gdGhhdCBjYXNlIHRoaXMgaGVscGVyIE1BWVxuICogICAgICAgICAgICAgICBiZSBpbnZva2VkIGJ5IGNhbGxpbmcgdXNlciBjb2RlIHRvIGVuc3VyZSB0aGUgYHBvc3RfcGFyc2VgIGNhbGxiYWNrcyBhcmUgaW52b2tlZCBhbmRcbiAqICAgICAgICAgICAgICAgdGhlIGludGVybmFsIHBhcnNlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkIHVuZGVyIHRoZXNlIHBhcnRpY3VsYXIgY2lyY3Vtc3RhbmNlcy5cbiAqXG4gKiAgICB5eU1lcmdlTG9jYXRpb25JbmZvOiBmdW5jdGlvbihmaXJzdF9pbmRleCwgbGFzdF9pbmRleCwgZmlyc3RfeXlsbG9jLCBsYXN0X3l5bGxvYywgZG9udF9sb29rX2JhY2spLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGNhbiBiZSBpbnZva2VkIHRvIGNhbGN1bGF0ZSBhIHNwYW5uaW5nIGB5eWxsb2NgIGxvY2F0aW9uIGluZm8gb2JqZWN0LlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZTogJWVwc2lsb24gcnVsZXMgTUFZIHNwZWNpZnkgbm8gYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AsIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gb2J0YWluIGEgc3VpdGFibGUgbG9jYXRpb24gbWFya2VyIGJ5IGluc3BlY3RpbmcgdGhlIGxvY2F0aW9uIHN0YWNrXG4gKiAgICAgICAgICAgICAgIGJhY2t3YXJkcy5cbiAqXG4gKiAgICAgICAgICAgICAgIEZvciBtb3JlIGluZm8gc2VlIHRoZSBkb2N1bWVudGF0aW9uIGNvbW1lbnQgZnVydGhlciBiZWxvdywgaW1tZWRpYXRlbHkgYWJvdmUgdGhpcyBmdW5jdGlvbidzXG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqICAgIGxleGVyOiB7XG4gKiAgICAgICAgeXk6IHsuLi59LCAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHNvLWNhbGxlZCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgb25jZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkIHZpYSBhIGNhbGwgdG8gdGhlIGAuc2V0SW5wdXQoaW5wdXQsIHl5KWAgbGV4ZXIgQVBJLlxuICogICAgICAgIEVPRjogMSxcbiAqICAgICAgICBFUlJPUjogMixcbiAqICAgICAgICBKaXNvbkxleGVyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAqICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICogICAgICAgIHJlamVjdDogZnVuY3Rpb24oKSxcbiAqICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCwgLi4uKSxcbiAqICAgICAgICBuZXh0OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGxleDogZnVuY3Rpb24oLi4uKSxcbiAqICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqICAgICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKClcbiAqXG4gKiAgICAgICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJULCAuLi4pLFxuICogICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAqICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICAgIH1cbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gKiAgICBmaXJzdF9saW5lOiBuLFxuICogICAgbGFzdF9saW5lOiBuLFxuICogICAgZmlyc3RfY29sdW1uOiBuLFxuICogICAgbGFzdF9jb2x1bW46IG4sXG4gKiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl1cbiAqICAgICAgICAgICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgemVyby1iYXNlZClcbiAqICB9XG4gKlxuICogLS0tXG4gKlxuICogVGhlIGBwYXJzZUVycm9yYCBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmRcbiAqIHBhcnNlciBlcnJvcnM6XG4gKlxuICogIHtcbiAqICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICogICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAqICAgIHRva2VuX2lkOiAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuIG51bWVyaWMgSUQsIGlmIGFueSlcbiAqICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gKiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAqICB9XG4gKlxuICogcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgYWRkaXRpb25hbCBtZW1iZXJzOlxuICpcbiAqICB7XG4gKiAgICBleHBlY3RlZDogICAgKGFycmF5IGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnM7XG4gKiAgICAgICAgICAgICAgICAgIG1heSBiZSBVTkRFRklORUQgd2hlbiB3ZSBjYW5ub3QgZWFzaWx5IHByb2R1Y2Ugc3VjaCBhIHNldClcbiAqICAgIHN0YXRlOiAgICAgICAoaW50ZWdlciAob3IgYXJyYXkgd2hlbiB0aGUgdGFibGUgaW5jbHVkZXMgZ3JhbW1hciBjb2xsaXNpb25zKTtcbiAqICAgICAgICAgICAgICAgICAgcmVwcmVzZW50cyB0aGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgcGFyc2VyIGtlcm5lbC5cbiAqICAgICAgICAgICAgICAgICAgY2FuLCBmb3IgZXhhbXBsZSwgYmUgdXNlZCB0byBwYXNzIHRvIHRoZSBgY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoKWBcbiAqICAgICAgICAgICAgICAgICAgQVBJIHRvIG9idGFpbiB0aGUgZXhwZWN0ZWQgdG9rZW4gc2V0KVxuICogICAgYWN0aW9uOiAgICAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIGFjdGlvbiB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkKVxuICogICAgbmV3X3N0YXRlOiAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBuZXh0L3BsYW5uZWQgaW50ZXJuYWwgc3RhdGUsIG9uY2UgdGhlIGN1cnJlbnRcbiAqICAgICAgICAgICAgICAgICAgYWN0aW9uIGhhcyBleGVjdXRlZClcbiAqICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgTUFZIGhhdmUgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZVxuICogICAgICAgICAgICAgICAgICBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAqICAgIHN0YXRlX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIHN0YXRlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgdmFsdWVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgYCQkYCB2YWx1ZSBzdGFjazsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxvY2F0aW9uX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIGxvY2F0aW9uIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICAgIHBhcnNlcjogICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZSlcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBsZXhlciwgYHRoaXNgIHdpbGwgc3RpbGwgcmVmZXJlbmNlIHRoZSByZWxhdGVkICpwYXJzZXIqXG4gKiBpbnN0YW5jZSwgd2hpbGUgdGhlc2UgYWRkaXRpb25hbCBgaGFzaGAgZmllbGRzIHdpbGwgYWxzbyBiZSBwcm92aWRlZDpcbiAqXG4gKiAge1xuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2Ugd2hpY2ggcmVwb3J0ZWQgdGhlIGVycm9yKVxuICogIH1cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgZHVlIHRvIGEgKipKYXZhU2NyaXB0IGV4Y2VwdGlvbioqIGJlaW5nIGZpcmVkXG4gKiBmcm9tIGVpdGhlciB0aGUgcGFyc2VyIG9yIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBleGNlcHRpb246ICAgKHJlZmVyZW5jZSB0byB0aGUgZXhjZXB0aW9uIHRocm93bilcbiAqICB9XG4gKlxuICogUGxlYXNlIGRvIG5vdGUgdGhhdCBpbiB0aGUgbGF0dGVyIHNpdHVhdGlvbiwgdGhlIGBleHBlY3RlZGAgZmllbGQgd2lsbCBiZSBvbWl0dGVkIGFzXG4gKiB0aGlzIHR5cGUgb2YgZmFpbHVyZSBpcyBhc3N1bWVkIG5vdCB0byBiZSBkdWUgdG8gKnBhcnNlIGVycm9ycyogYnV0IHJhdGhlciBkdWUgdG8gdXNlclxuICogYWN0aW9uIGNvZGUgaW4gZWl0aGVyIHBhcnNlciBvciBsZXhlciBmYWlsaW5nIHVuZXhwZWN0ZWRseS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgcGFyc2VyIG9wdGlvbnMgYnkgc2V0dGluZyAvIG1vZGlmeWluZyB0aGUgYC55eWAgb2JqZWN0IG9mIHlvdXIgUGFyc2VyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICMjIyBvcHRpb25zIHdoaWNoIGFyZSBnbG9iYWwgZm9yIGFsbCBwYXJzZXIgaW5zdGFuY2VzXG4gKlxuICogIFBhcnNlci5wcmVfcGFyc2U6IGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwcmVfcGFyc2UoKSBmdW5jdGlvbiBpbiB0aGUgY2h1bmsgZm9sbG93aW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdyYW1tYXIsIGkuZS4gYWZ0ZXIgdGhlIGxhc3QgYCUlYC5cbiAqICBQYXJzZXIucG9zdF9wYXJzZTogZnVuY3Rpb24oeXksIHJldHZhbCwgcGFyc2VJbmZvKSB7IHJldHVybiByZXR2YWw7IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogeW91IGNhbiBzcGVjaWZ5IGEgcG9zdF9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLiBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgYHJldHZhbGAuXG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHNldCB1cCBwZXIgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogIHl5OiB7XG4gKiAgICAgIHByZV9wYXJzZTogIGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIGJlZm9yZSB0aGUgcGFyc2UgY3ljbGUgc3RhcnRzIChhbmQgYmVmb3JlIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2YgYGxleCgpYCkgYnV0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgYHBhcnNlci5wcmVfcGFyc2UoKWApLlxuICogICAgICBwb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIHBhcnNlIHRlcm1pbmF0ZXMgZHVlIHRvIHN1Y2Nlc3MgKCdhY2NlcHQnKVxuICogICAgICAgICAgICAgICAgIG9yIGZhaWx1cmUgKGV2ZW4gd2hlbiBleGNlcHRpb25zIGFyZSB0aHJvd24pLlxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgIGNvbnRhaW5zIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgcHJvZHVjZWQgYnkgYFBhcnNlci5wYXJzZSgpYDtcbiAqICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIGNhbiBvdmVycmlkZSB0aGUgcmV0dXJuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSwgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWxcbiAqICAgICAgICAgICAgICAgICBgcmV0dmFsYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGBwYXJzZXIucG9zdF9wYXJzZSgpYC5cbiAqXG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgICAgIHF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIHBhcnNlci5sZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiAgICAgIHJhbmdlczogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyLlxuICogICAgICBmbGV4OiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWRcbiAqICAgICAgICAgICAgICAgICBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaC5cbiAqICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgaW52b2tlZDtcbiAqICAgICAgICAgICAgICAgICB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlLlxuICogICAgICB4cmVnZXhwOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcnVsZSByZWdleGVzIGFyZSBcImV4dGVuZGVkIHJlZ2V4IGZvcm1hdFwiIHJlcXVpcmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICBgWFJlZ0V4cGAgbGlicmFyeS4gV2hlbiB0aGlzIGAlb3B0aW9uYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG4gICAgICAgIFxuICAgIFxuICAgICAgICAgICAgdmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG5cbi8vIFNlZSBhbHNvOlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHQvIzM1ODgxNTA4XG4vLyBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuLy8gd2l0aCB1c2VybGFuZCBjb2RlIHdoaWNoIG1pZ2h0IGFjY2VzcyB0aGUgZGVyaXZlZCBjbGFzcyBpbiBhICdjbGFzc2ljJyB3YXkuXG5mdW5jdGlvbiBKaXNvblBhcnNlckVycm9yKG1zZywgaGFzaCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6ICdKaXNvblBhcnNlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKSBtc2cgPSAnPz8/JztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbXNnXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc2ggPSBoYXNoO1xuXG4gICAgdmFyIHN0YWNrdHJhY2U7XG4gICAgaWYgKGhhc2ggJiYgaGFzaC5leGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgZXgyID0gaGFzaC5leGNlcHRpb247XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgICAgc3RhY2t0cmFjZSA9IGV4Mi5zdGFjaztcbiAgICB9XG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgeyAgICAgICAgLy8gVjgvQ2hyb21lIGVuZ2luZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFja3RyYWNlID0gKG5ldyBFcnJvcihtc2cpKS5zdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2t0cmFjZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogc3RhY2t0cmFjZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xufSBlbHNlIHtcbiAgICBKaXNvblBhcnNlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbn1cbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25QYXJzZXJFcnJvcjtcbkppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25QYXJzZXJFcnJvcic7XG5cblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlIHByb2R1Y3Rpb25zW10gdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYnAocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICB2YXIgcCA9IHMucG9wO1xuICAgICAgICAgICAgdmFyIHIgPSBzLnJ1bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcnYucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgZGVmYXVsdEFjdGlvbnNbXSB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBiZGEocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgICAgICB2YXIgZCA9IHMuaWR4O1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBkW2ldO1xuICAgICAgICAgICAgICAgIHJ2W2pdID0gZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgJ2dvdG8nIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJ0KHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgdmFyIGQgPSBzLmxlbjtcbiAgICAgICAgICAgIHZhciB5ID0gcy5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgdCA9IHMudHlwZTtcbiAgICAgICAgICAgIHZhciBhID0gcy5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBtID0gcy5tb2RlO1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBxID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSA9PT0gMTogYWNjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnYucHVzaChxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiBydW5sZW5ndGggZW5jb2Rpbmcgd2l0aCBpbmNyZW1lbnQgc3RlcDogY29kZSwgbGVuZ3RoOiBzdGVwIChkZWZhdWx0IHN0ZXAgPSAwKVxuICAgICAgICAvLyBgdGhpc2AgcmVmZXJlbmNlcyBhbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBzKGMsIGwsIGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBjICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXI6IGR1cGxpY2F0ZSBzZXF1ZW5jZSBmcm9tICpyZWxhdGl2ZSogb2Zmc2V0IGFuZCBsZW5ndGguXG4gICAgICAgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGFuIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIGMoaSwgbCkge1xuICAgICAgICAgICAgaSA9IHRoaXMubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVscGVyOiB1bnBhY2sgYW4gYXJyYXkgdXNpbmcgaGVscGVycyBhbmQgZGF0YSwgYWxsIHBhc3NlZCBpbiBhbiBhcnJheSBhcmd1bWVudCAnYScuXG4gICAgICAgIGZ1bmN0aW9uIHUoYSkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhW2ldO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgZW50cnkgYSBoZWxwZXIgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBseShydiwgYVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnYucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxudmFyIHBhcnNlciA9IHtcbiAgICAvLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIE9wdGlvbnM6XG4gICAgLy9cbiAgICAvLyAgIGRlZmF1bHQgYWN0aW9uIG1vZGU6IC4uLi4uLi4uLi4uLi4gY2xhc3NpYyxtZXJnZVxuICAgIC8vICAgbm8gdHJ5Li5jYXRjaDogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbm8gZGVmYXVsdCByZXNvbHZlIG9uIGNvbmZsaWN0OiAgICBmYWxzZVxuICAgIC8vICAgb24tZGVtYW5kIGxvb2stYWhlYWQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXJyb3IgcmVjb3ZlcnkgdG9rZW4gc2tpcCBtYXhpbXVtOiAzXG4gICAgLy8gICB5eWVycm9yIGluIHBhcnNlIGFjdGlvbnMgaXM6IC4uLi4uIE5PVCByZWNvdmVyYWJsZSxcbiAgICAvLyAgIHl5ZXJyb3IgaW4gbGV4ZXIgYWN0aW9ucyBhbmQgb3RoZXIgbm9uLWZhdGFsIGxleGVyIGFyZTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgZGVidWcgZ3JhbW1hci9vdXRwdXQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIHBhcnRpYWwgTFIgY29uZmxpY3QgdXBncmFkZTogICB0cnVlXG4gICAgLy8gICBydWRpbWVudGFyeSB0b2tlbi1zdGFjayBzdXBwb3J0OiAgIGZhbHNlXG4gICAgLy8gICBwYXJzZXIgdGFibGUgY29tcHJlc3Npb24gbW9kZTogLi4uIDJcbiAgICAvLyAgIGV4cG9ydCBkZWJ1ZyB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGV4cG9ydCAqYWxsKiB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIG1vZHVsZSB0eXBlOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gY29tbW9uanNcbiAgICAvLyAgIHBhcnNlciBlbmdpbmUgdHlwZTogLi4uLi4uLi4uLi4uLi4gbGFsclxuICAgIC8vICAgb3V0cHV0IG1haW4oKSBpbiB0aGUgbW9kdWxlOiAuLi4uLiB0cnVlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgbWFpbigpOiAuLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgcmVxdWlyZSgpL2ltcG9ydCBtb2R1bGVzIGZvciBtYWluKCk6IFxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbnVtYmVyIG9mIGV4cGVjdGVkIGNvbmZsaWN0czogLi4uLiAwXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFBhcnNlciBBbmFseXNpcyBmbGFnczpcbiAgICAvL1xuICAgIC8vICAgbm8gc2lnbmlmaWNhbnQgYWN0aW9ucyAocGFyc2VyIGlzIGEgbGFuZ3VhZ2UgbWF0Y2hlciBvbmx5KTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgUGFyc2VFcnJvciBBUEk6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPUjogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlSRUNPVkVSSU5HOiAuLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlFUlJPSzogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgWVlDTEVBUklOOiAuLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHRyYWNrcyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgYXNzaWducyBydWxlIHZhbHVlczogLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIGxvY2F0aW9uIHRyYWNraW5nOiAuLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIGFzc2lnbnMgbG9jYXRpb246IC4uLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgdXNlcyB5eXN0YWNrOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNzdGFjazogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNwOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIHl5cnVsZWxlbmd0aDogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5TWVyZ2VMb2NhdGlvbkluZm8gQVBJOiAuLi4uIHRydWVcbiAgICAvLyAgIGhhcyBlcnJvciByZWNvdmVyeTogLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGhhcyBlcnJvciByZXBvcnRpbmc6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLSBFTkQgT0YgUkVQT1JUIC0tLS0tLS0tLS0tXG5cbnRyYWNlOiBmdW5jdGlvbiBub19vcF90cmFjZSgpIHt9LFxuSmlzb25QYXJzZXJFcnJvcjogSmlzb25QYXJzZXJFcnJvcixcbnl5OiB7fSxcbm9wdGlvbnM6IHtcbiAgdHlwZTogXCJsYWxyXCIsXG4gIGhhc1BhcnRpYWxMclVwZ3JhZGVPbkNvbmZsaWN0OiB0cnVlLFxuICBlcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQ6IDMsXG4gIGVibmY6IHRydWVcbn0sXG5zeW1ib2xzXzoge1xuICBcIiFcIjogMTYsXG4gIFwiIT1cIjogNjAsXG4gIFwiJGFjY2VwdFwiOiAwLFxuICBcIiRlbmRcIjogMSxcbiAgXCIlfVwiOiAzMCxcbiAgXCImJlwiOiA2MSxcbiAgXCIoXCI6IDcsXG4gIFwiKVwiOiA4LFxuICBcIipcIjogMyxcbiAgXCIrXCI6IDIxLFxuICBcIixcIjogNixcbiAgXCItXCI6IDIzLFxuICBcIi5cIjogMTcsXG4gIFwiL1wiOiAyMixcbiAgXCIvPlwiOiAzOCxcbiAgXCI6XCI6IDEyLFxuICBcIjtcIjogMjAsXG4gIFwiPFwiOiAxMyxcbiAgXCI8L1wiOiAzNyxcbiAgXCI8PVwiOiA1OCxcbiAgXCI9XCI6IDksXG4gIFwiPT1cIjogNTksXG4gIFwiPT5cIjogNTAsXG4gIFwiPlwiOiAxNCxcbiAgXCI+PVwiOiA1NyxcbiAgXCI/XCI6IDE4LFxuICBcIkBcIjogMTksXG4gIFwiQVNcIjogMjcsXG4gIFwiQ0hBUkFDVEVSU1wiOiA0NyxcbiAgXCJDT05TVFJVQ1RPUlwiOiA1NixcbiAgXCJFTFNFXCI6IDQ0LFxuICBcIkVOREZPUlwiOiA0MyxcbiAgXCJFTkRGVU5cIjogMzYsXG4gIFwiRU5ESUZcIjogNDYsXG4gIFwiRU5ETUFJTlwiOiAzMSxcbiAgXCJFTkRWSUVXXCI6IDM0LFxuICBcIkVPRlwiOiAxLFxuICBcIkVYUE9SVFwiOiAzMixcbiAgXCJGQUxTRVwiOiA1NCxcbiAgXCJGT1JcIjogNDEsXG4gIFwiRlJPTVwiOiAyNixcbiAgXCJGVU5cIjogMzUsXG4gIFwiSURFTlRJRklFUlwiOiA1NSxcbiAgXCJJRlwiOiA0NSxcbiAgXCJJTVBPUlRcIjogMjUsXG4gIFwiSU5cIjogNDIsXG4gIFwiSU5TVEFOQ0VPRlwiOiA2MyxcbiAgXCJNQUlOXCI6IDI5LFxuICBcIk5VTUJFUl9MSVRFUkFMXCI6IDUyLFxuICBcIlNUUklOR19MSVRFUkFMXCI6IDUxLFxuICBcIlRIRU5cIjogNDgsXG4gIFwiVFJVRVwiOiA1MyxcbiAgXCJWSUVXXCI6IDMzLFxuICBcIltcIjogMTAsXG4gIFwiXFxcXFxcXFxcIjogNDksXG4gIFwiXVwiOiAxMSxcbiAgXCJeXCI6IDI0LFxuICBcImFnZ3JlZ2F0ZV9tZW1iZXJcIjogNjksXG4gIFwiYWxpYXNlZF9tZW1iZXJcIjogNjgsXG4gIFwiYXJndW1lbnRfbGlzdFwiOiAxMDUsXG4gIFwiYXJndW1lbnRzXCI6IDEwNCxcbiAgXCJhdHRyaWJ1dGVcIjogOTQsXG4gIFwiYXR0cmlidXRlX3ZhbHVlXCI6IDk1LFxuICBcImF0dHJpYnV0ZV92YWx1ZV9ncm91cFwiOiAxNTUsXG4gIFwiYXR0cmlidXRlc1wiOiA5MyxcbiAgXCJiaW5hcnlfZXhwcmVzc2lvblwiOiAxMDgsXG4gIFwiYmluYXJ5X29wZXJhdG9yXCI6IDEzOCxcbiAgXCJiaW5hcnlfb3BlcmF0b3JfZ3JvdXBcIjogMTYxLFxuICBcImJvb2xlYW5fbGl0ZXJhbFwiOiAxMjksXG4gIFwiY2FsbF9leHByZXNzaW9uXCI6IDExNyxcbiAgXCJjaGFyYWN0ZXJzXCI6IDEwMyxcbiAgXCJjaGlsZFwiOiA4OSxcbiAgXCJjaGlsZF9ncm91cFwiOiAxNTAsXG4gIFwiY2hpbGRyZW5cIjogODgsXG4gIFwiY29tcG9zaXRlX21lbWJlclwiOiA3MCxcbiAgXCJjb25zXCI6IDEzMixcbiAgXCJjb25zdHJ1Y3RfZXhwcmVzc2lvblwiOiAxMTYsXG4gIFwiY29udGV4dF9wcm9wZXJ0eVwiOiAxMzAsXG4gIFwiY29udGV4dF90eXBlXCI6IDgwLFxuICBcImNvbnRleHRfdmFyaWFibGVcIjogMTMxLFxuICBcImNvbnRyb2xcIjogOTksXG4gIFwiY29udHJvbF9ncm91cFwiOiAxNTYsXG4gIFwiZWxzZV9jbGF1c2VcIjogMTAyLFxuICBcImVuZF9tYWluXCI6IDc0LFxuICBcImVycm9yXCI6IDIsXG4gIFwiZXhwb3J0XCI6IDc2LFxuICBcImV4cG9ydF9zdGF0ZW1lbnRcIjogNzcsXG4gIFwiZXhwb3J0c1wiOiA3NSxcbiAgXCJleHByZXNzaW9uXCI6IDEwNixcbiAgXCJmaWx0ZXJcIjogOTgsXG4gIFwiZmlsdGVyc1wiOiA5NyxcbiAgXCJmb3Jfc3RhdGVtZW50XCI6IDEwMCxcbiAgXCJmdW5fYXBwbGljYXRpb25cIjogMTEyLFxuICBcImZ1bl9zdGF0ZW1lbnRcIjogNzksXG4gIFwiZnVuX3RhcmdldFwiOiAxMTMsXG4gIFwiZnVuY3Rpb25fZXhwcmVzc2lvblwiOiAxMjEsXG4gIFwiaWRlbnRpZmllclwiOiAxMzUsXG4gIFwiaWZfZXhwcmVzc2lvblwiOiAxMDcsXG4gIFwiaWZfc3RhdGVtZW50XCI6IDEwMSxcbiAgXCJpbXBvcnRfbWVtYmVyXCI6IDY3LFxuICBcImltcG9ydF9zdGF0ZW1lbnRcIjogNjYsXG4gIFwiaW1wb3J0X3N0YXRlbWVudF9vcHRpb25cIjogMTM5LFxuICBcImltcG9ydHNcIjogNjUsXG4gIFwiaW50ZXJwb2xhdGlvblwiOiA5NixcbiAgXCJsaXN0XCI6IDEyNixcbiAgXCJsaXRlcmFsXCI6IDEyMixcbiAgXCJsaXRlcmFsX2dyb3VwXCI6IDE1OSxcbiAgXCJtYWluXCI6IDczLFxuICBcIm1haW5fb3B0aW9uXCI6IDE0MyxcbiAgXCJtYWluX29wdGlvbjJcIjogMTQ0LFxuICBcIm1haW5fb3B0aW9uM1wiOiAxNDUsXG4gIFwibWFpbl9vcHRpb240XCI6IDE0NixcbiAgXCJtZW1iZXJcIjogNzIsXG4gIFwibWVtYmVyX2V4cHJlc3Npb25cIjogMTE4LFxuICBcIm1lbWJlcl9ncm91cFwiOiAxNDIsXG4gIFwibWVtYmVyX2xpc3RcIjogNzEsXG4gIFwibWVtYmVyX2xpc3RfZ3JvdXBcIjogMTQwLFxuICBcIm1lbWJlcl9saXN0X2dyb3VwMlwiOiAxNDEsXG4gIFwibW9kdWxlXCI6IDY0LFxuICBcIm5vZGVcIjogOTEsXG4gIFwibm9kZV9vcHRpb25cIjogMTUxLFxuICBcIm5vZGVfb3B0aW9uMlwiOiAxNTIsXG4gIFwibnVtYmVyX2xpdGVyYWxcIjogMTI4LFxuICBcInBhcmFtZXRlclwiOiA4NyxcbiAgXCJwYXJhbWV0ZXJfbGlzdFwiOiA4NixcbiAgXCJwYXJhbWV0ZXJzXCI6IDg1LFxuICBcInByb3BlcnRpZXNcIjogMTI0LFxuICBcInByb3BlcnR5XCI6IDEyNSxcbiAgXCJwcm9wZXJ0eV9ncm91cFwiOiAxNjAsXG4gIFwicXVhbGlmaWVkX2NvbnN0cnVjdG9yXCI6IDEzMyxcbiAgXCJxdWFsaWZpZWRfaWRlbnRpZmllclwiOiAxMzYsXG4gIFwicmVhZF9leHByZXNzaW9uXCI6IDExOSxcbiAgXCJyZWFkYWJsZV9leHByZXNzaW9uXCI6IDEyMCxcbiAgXCJyZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwXCI6IDE1OCxcbiAgXCJyZWNvcmRcIjogMTIzLFxuICBcInNpbXBsZV9leHByZXNzaW9uXCI6IDExMCxcbiAgXCJzaW1wbGVfZXhwcmVzc2lvbl9ncm91cFwiOiAxNTcsXG4gIFwic3RyaW5nX2xpdGVyYWxcIjogMTI3LFxuICBcInRhZ1wiOiA5MCxcbiAgXCJ0eXBlXCI6IDg0LFxuICBcInR5cGVfYXJnX2xpc3RcIjogMTE1LFxuICBcInR5cGVfYXJndW1lbnRzXCI6IDExNCxcbiAgXCJ0eXBlX2NsYXNzXCI6IDgzLFxuICBcInR5cGVfY2xhc3NfbGlzdFwiOiA4MixcbiAgXCJ0eXBlX2NsYXNzZXNcIjogODEsXG4gIFwidHlwZV9vcHRpb25cIjogMTQ5LFxuICBcInVuYXJ5X2V4cHJlc3Npb25cIjogMTA5LFxuICBcInVucXVhbGlmaWVkX2NvbnN0cnVjdG9yXCI6IDEzNCxcbiAgXCJ1bnF1YWxpZmllZF9pZGVudGlmaWVyXCI6IDEzNyxcbiAgXCJ2aWV3X2NvbnN0cnVjdGlvblwiOiAxMTEsXG4gIFwidmlld19zdGF0ZW1lbnRcIjogNzgsXG4gIFwidmlld19zdGF0ZW1lbnRfb3B0aW9uXCI6IDE0NyxcbiAgXCJ2aWV3X3N0YXRlbWVudF9vcHRpb24yXCI6IDE0OCxcbiAgXCJ3aWRnZXRcIjogOTIsXG4gIFwid2lkZ2V0X29wdGlvblwiOiAxNTMsXG4gIFwid2lkZ2V0X29wdGlvbjJcIjogMTU0LFxuICBcIntcIjogNCxcbiAgXCJ7JVwiOiAyOCxcbiAgXCJ7e1wiOiAzOSxcbiAgXCJ8XCI6IDE1LFxuICBcInx8XCI6IDYyLFxuICBcIn1cIjogNSxcbiAgXCJ9fVwiOiA0MFxufSxcbnRlcm1pbmFsc186IHtcbiAgMTogXCJFT0ZcIixcbiAgMjogXCJlcnJvclwiLFxuICAzOiBcIipcIixcbiAgNDogXCJ7XCIsXG4gIDU6IFwifVwiLFxuICA2OiBcIixcIixcbiAgNzogXCIoXCIsXG4gIDg6IFwiKVwiLFxuICA5OiBcIj1cIixcbiAgMTA6IFwiW1wiLFxuICAxMTogXCJdXCIsXG4gIDEyOiBcIjpcIixcbiAgMTM6IFwiPFwiLFxuICAxNDogXCI+XCIsXG4gIDE1OiBcInxcIixcbiAgMTY6IFwiIVwiLFxuICAxNzogXCIuXCIsXG4gIDE4OiBcIj9cIixcbiAgMTk6IFwiQFwiLFxuICAyMDogXCI7XCIsXG4gIDIxOiBcIitcIixcbiAgMjI6IFwiL1wiLFxuICAyMzogXCItXCIsXG4gIDI0OiBcIl5cIixcbiAgMjU6IFwiSU1QT1JUXCIsXG4gIDI2OiBcIkZST01cIixcbiAgMjc6IFwiQVNcIixcbiAgMjg6IFwieyVcIixcbiAgMjk6IFwiTUFJTlwiLFxuICAzMDogXCIlfVwiLFxuICAzMTogXCJFTkRNQUlOXCIsXG4gIDMyOiBcIkVYUE9SVFwiLFxuICAzMzogXCJWSUVXXCIsXG4gIDM0OiBcIkVORFZJRVdcIixcbiAgMzU6IFwiRlVOXCIsXG4gIDM2OiBcIkVOREZVTlwiLFxuICAzNzogXCI8L1wiLFxuICAzODogXCIvPlwiLFxuICAzOTogXCJ7e1wiLFxuICA0MDogXCJ9fVwiLFxuICA0MTogXCJGT1JcIixcbiAgNDI6IFwiSU5cIixcbiAgNDM6IFwiRU5ERk9SXCIsXG4gIDQ0OiBcIkVMU0VcIixcbiAgNDU6IFwiSUZcIixcbiAgNDY6IFwiRU5ESUZcIixcbiAgNDc6IFwiQ0hBUkFDVEVSU1wiLFxuICA0ODogXCJUSEVOXCIsXG4gIDQ5OiBcIlxcXFxcXFxcXCIsXG4gIDUwOiBcIj0+XCIsXG4gIDUxOiBcIlNUUklOR19MSVRFUkFMXCIsXG4gIDUyOiBcIk5VTUJFUl9MSVRFUkFMXCIsXG4gIDUzOiBcIlRSVUVcIixcbiAgNTQ6IFwiRkFMU0VcIixcbiAgNTU6IFwiSURFTlRJRklFUlwiLFxuICA1NjogXCJDT05TVFJVQ1RPUlwiLFxuICA1NzogXCI+PVwiLFxuICA1ODogXCI8PVwiLFxuICA1OTogXCI9PVwiLFxuICA2MDogXCIhPVwiLFxuICA2MTogXCImJlwiLFxuICA2MjogXCJ8fFwiLFxuICA2MzogXCJJTlNUQU5DRU9GXCJcbn0sXG5URVJST1I6IDIsXG5FT0Y6IDEsXG5cbi8vIGludGVybmFsczogZGVmaW5lZCBoZXJlIHNvIHRoZSBvYmplY3QgKnN0cnVjdHVyZSogZG9lc24ndCBnZXQgbW9kaWZpZWQgYnkgcGFyc2UoKSBldCBhbCxcbi8vIHRodXMgaGVscGluZyBKSVQgY29tcGlsZXJzIGxpa2UgQ2hyb21lIFY4Llxub3JpZ2luYWxRdW90ZU5hbWU6IG51bGwsXG5vcmlnaW5hbFBhcnNlRXJyb3I6IG51bGwsXG5jbGVhbnVwQWZ0ZXJQYXJzZTogbnVsbCxcbmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvOiBudWxsLFxueXlNZXJnZUxvY2F0aW9uSW5mbzogbnVsbCxcblxuX19yZWVudHJhbnRfY2FsbF9kZXB0aDogMCwgLy8gSU5URVJOQUwgVVNFIE9OTFlcbl9fZXJyb3JfaW5mb3M6IFtdLCAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuX19lcnJvcl9yZWNvdmVyeV9pbmZvczogW10sIC8vIElOVEVSTkFMIFVTRSBPTkxZOiB0aGUgc2V0IG9mIHBhcnNlRXJyb3JJbmZvIG9iamVjdHMgY3JlYXRlZCBzaW5jZSB0aGUgbGFzdCBjbGVhbnVwXG5cbi8vIEFQSXMgd2hpY2ggd2lsbCBiZSBzZXQgdXAgZGVwZW5kaW5nIG9uIHVzZXIgYWN0aW9uIGNvZGUgYW5hbHlzaXM6XG4vL3l5UmVjb3ZlcmluZzogMCxcbi8veXlFcnJPazogMCxcbi8veXlDbGVhckluOiAwLFxuXG4vLyBIZWxwZXIgQVBJc1xuLy8gLS0tLS0tLS0tLS1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlIHF1b3RlcyBhcm91bmRcbi8vIGxpdGVyYWwgSURzIGluIGEgZGVzY3JpcHRpb24gc3RyaW5nLlxucXVvdGVOYW1lOiBmdW5jdGlvbiBwYXJzZXJfcXVvdGVOYW1lKGlkX3N0cikge1xuICAgIHJldHVybiAnXCInICsgaWRfc3RyICsgJ1wiJztcbn0sXG5cbi8vIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gc3ltYm9sICh0ZXJtaW5hbCBvciBub24tdGVybWluYWwpIGFzIGEgc3RyaW5nLCB3aGVuIGF2YWlsYWJsZS5cbi8vXG4vLyBSZXR1cm4gTlVMTCB3aGVuIHRoZSBzeW1ib2wgaXMgdW5rbm93biB0byB0aGUgcGFyc2VyLlxuZ2V0U3ltYm9sTmFtZTogZnVuY3Rpb24gcGFyc2VyX2dldFN5bWJvbE5hbWUoc3ltYm9sKSB7XG4gICAgaWYgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UuLi4gdGhpcyBtaWdodCByZWZlciB0byBhIFJVTEUgdG9rZW4gaS5lLiBhIG5vbi10ZXJtaW5hbDogc2VlIGlmIHdlIGNhbiBkaWcgdGhhdCBvbmUgdXAuXG4gICAgLy9cbiAgICAvLyBBbiBleGFtcGxlIG9mIHRoaXMgbWF5IGJlIHdoZXJlIGEgcnVsZSdzIGFjdGlvbiBjb2RlIGNvbnRhaW5zIGEgY2FsbCBsaWtlIHRoaXM6XG4gICAgLy9cbiAgICAvLyAgICAgIHBhcnNlci5nZXRTeW1ib2xOYW1lKCMkKVxuICAgIC8vXG4gICAgLy8gdG8gb2J0YWluIGEgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY3VycmVudCBncmFtbWFyIHJ1bGUuXG4gICAgdmFyIHMgPSB0aGlzLnN5bWJvbHNfO1xuICAgIGZvciAodmFyIGtleSBpbiBzKSB7XG4gICAgICAgIGlmIChzW2tleV0gPT09IHN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0sXG5cbi8vIFJldHVybiBhIG1vcmUtb3ItbGVzcyBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZ2l2ZW4gc3ltYm9sLCB3aGVuIGF2YWlsYWJsZSxcbi8vIG9yIHRoZSBzeW1ib2wgaXRzZWxmLCBzZXJ2aW5nIGFzIGl0cyBvd24gJ2Rlc2NyaXB0aW9uJyBmb3IgbGFjayBvZiBzb21ldGhpbmcgYmV0dGVyIHRvIHNlcnZlIHVwLlxuLy9cbi8vIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG5kZXNjcmliZVN5bWJvbDogZnVuY3Rpb24gcGFyc2VyX2Rlc2NyaWJlU3ltYm9sKHN5bWJvbCkge1xuICAgIGlmIChzeW1ib2wgIT09IHRoaXMuRU9GICYmIHRoaXMudGVybWluYWxfZGVzY3JpcHRpb25zXyAmJiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc19bc3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF07XG4gICAgfSBlbHNlIGlmIChzeW1ib2wgPT09IHRoaXMuRU9GKSB7XG4gICAgICAgIHJldHVybiAnZW5kIG9mIGlucHV0JztcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5nZXRTeW1ib2xOYW1lKHN5bWJvbCk7XG4gICAgaWYgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3RlTmFtZShpZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufSxcblxuLy8gUHJvZHVjZSBhIChtb3JlIG9yIGxlc3MpIGh1bWFuLXJlYWRhYmxlIGxpc3Qgb2YgZXhwZWN0ZWQgdG9rZW5zIGF0IHRoZSBwb2ludCBvZiBmYWlsdXJlLlxuLy9cbi8vIFRoZSBwcm9kdWNlZCBsaXN0IG1heSBjb250YWluIHRva2VuIG9yIHRva2VuIHNldCBkZXNjcmlwdGlvbnMgaW5zdGVhZCBvZiB0aGUgdG9rZW5zXG4vLyB0aGVtc2VsdmVzIHRvIGhlbHAgdHVybmluZyB0aGlzIG91dHB1dCBpbnRvIHNvbWV0aGluZyB0aGF0IGVhc2llciB0byByZWFkIGJ5IGh1bWFuc1xuLy8gdW5sZXNzIGBkb19ub3RfZGVzY3JpYmVgIHBhcmFtZXRlciBpcyBzZXQsIGluIHdoaWNoIGNhc2UgYSBsaXN0IG9mIHRoZSByYXcsICpudW1lcmljKixcbi8vIGV4cGVjdGVkIHRlcm1pbmFscyBhbmQgbm9udGVybWluYWxzIGlzIHByb2R1Y2VkLlxuLy9cbi8vIFRoZSByZXR1cm5lZCBsaXN0IChhcnJheSkgd2lsbCBub3QgY29udGFpbiBhbnkgZHVwbGljYXRlIGVudHJpZXMuXG5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldDogZnVuY3Rpb24gcGFyc2VyX2NvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlLCBkb19ub3RfZGVzY3JpYmUpIHtcbiAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgdmFyIHRva2Vuc2V0ID0gW107XG4gICAgdmFyIGNoZWNrID0ge307XG4gICAgLy8gSGFzIHRoaXMgKGVycm9yPykgc3RhdGUgYmVlbiBvdXRmaXR0ZWQgd2l0aCBhIGN1c3RvbSBleHBlY3RhdGlvbnMgZGVzY3JpcHRpb24gdGV4dCBmb3IgaHVtYW4gY29uc3VtcHRpb24/XG4gICAgLy8gSWYgc28sIHVzZSB0aGF0IG9uZSBpbnN0ZWFkIG9mIHRoZSBsZXNzIHBhbGF0YWJsZSB0b2tlbiBzZXQuXG4gICAgaWYgKCFkb19ub3RfZGVzY3JpYmUgJiYgdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfICYmIHRoaXMuc3RhdGVfZGVzY3JpcHRpb25zX1tzdGF0ZV0pIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc19bc3RhdGVdXTtcbiAgICB9XG4gICAgZm9yICh2YXIgcCBpbiB0aGlzLnRhYmxlW3N0YXRlXSkge1xuICAgICAgICBwID0gK3A7XG4gICAgICAgIGlmIChwICE9PSBURVJST1IpIHtcbiAgICAgICAgICAgIHZhciBkID0gZG9fbm90X2Rlc2NyaWJlID8gcCA6IHRoaXMuZGVzY3JpYmVTeW1ib2wocCk7XG4gICAgICAgICAgICBpZiAoZCAmJiAhY2hlY2tbZF0pIHtcbiAgICAgICAgICAgICAgICB0b2tlbnNldC5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIGNoZWNrW2RdID0gdHJ1ZTsgLy8gTWFyayB0aGlzIHRva2VuIGRlc2NyaXB0aW9uIGFzIGFscmVhZHkgbWVudGlvbmVkIHRvIHByZXZlbnQgb3V0cHV0dGluZyBkdXBsaWNhdGUgZW50cmllcy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zZXQ7XG59LFxucHJvZHVjdGlvbnNfOiBicCh7XG4gIHBvcDogdShbXG4gIHMsXG4gIFs2NCwgN10sXG4gIDY1LFxuICA2NSxcbiAgNjYsXG4gIHMsXG4gIFs2NywgM10sXG4gIHMsXG4gIFs2OCwgNCwgMV0sXG4gIDcxLFxuICA3MixcbiAgNzMsXG4gIDczLFxuICA3NCxcbiAgNzUsXG4gIDc1LFxuICBzLFxuICBbNzYsIDNdLFxuICA3NyxcbiAgNzgsXG4gIHMsXG4gIFs3OSwgMTZdLFxuICA4MCxcbiAgODEsXG4gIDgyLFxuICA4MixcbiAgcyxcbiAgWzgzLCA0XSxcbiAgcyxcbiAgWzg0LCAzXSxcbiAgODUsXG4gIDg1LFxuICA4NixcbiAgODYsXG4gIDg3LFxuICA4NyxcbiAgODgsXG4gIDg4LFxuICA4OSxcbiAgOTAsXG4gIDkwLFxuICBzLFxuICBbOTEsIDRdLFxuICBzLFxuICBbOTIsIDRdLFxuICA5MyxcbiAgOTMsXG4gIHMsXG4gIFs5NCwgNF0sXG4gIDk1LFxuICA5NixcbiAgOTYsXG4gIDk3LFxuICBzLFxuICBbOTcsIDQsIDFdLFxuICBzLFxuICBbMTAwLCA1XSxcbiAgMTAxLFxuICAxMDIsXG4gIDEwMixcbiAgMTAzLFxuICAxMDQsXG4gIDEwNCxcbiAgMTA1LFxuICAxMDUsXG4gIHMsXG4gIFsxMDYsIDddLFxuICAxMDcsXG4gIHMsXG4gIFsxMDgsIDRdLFxuICAxMDksXG4gIHMsXG4gIFsxMDksIDQsIDFdLFxuICBzLFxuICBbMTEyLCAzXSxcbiAgcyxcbiAgWzExMywgM10sXG4gIDExNCxcbiAgMTE1LFxuICAxMTUsXG4gIDExNixcbiAgcyxcbiAgWzExNywgOF0sXG4gIHMsXG4gIFsxMTgsIDEwXSxcbiAgcyxcbiAgWzExOSwgMTBdLFxuICAxMjAsXG4gIDEyMCxcbiAgMTIxLFxuICAxMjEsXG4gIDEyMixcbiAgMTIzLFxuICAxMjMsXG4gIDEyNCxcbiAgMTI0LFxuICAxMjUsXG4gIDEyNixcbiAgcyxcbiAgWzEyNiwgNCwgMV0sXG4gIHMsXG4gIFsxMjksIDQsIDFdLFxuICAxMzIsXG4gIDEzMyxcbiAgMTMzLFxuICAxMzQsXG4gIDEzNSxcbiAgMTM1LFxuICAxMzYsXG4gIHMsXG4gIFsxMzYsIDQsIDFdLFxuICAxMzksXG4gIDE0MCxcbiAgMTQwLFxuICAxNDEsXG4gIDE0MSxcbiAgMTQyLFxuICAxNDIsXG4gIDE0MyxcbiAgMTQzLFxuICAxNDQsXG4gIDE0NCxcbiAgMTQ1LFxuICAxNDUsXG4gIDE0NixcbiAgMTQ2LFxuICAxNDcsXG4gIDE0NyxcbiAgMTQ4LFxuICAxNDgsXG4gIDE0OSxcbiAgMTQ5LFxuICBzLFxuICBbMTUwLCA1XSxcbiAgMTUxLFxuICAxNTEsXG4gIDE1MixcbiAgMTUyLFxuICAxNTMsXG4gIDE1MyxcbiAgMTU0LFxuICAxNTQsXG4gIDE1NSxcbiAgMTU1LFxuICAxNTYsXG4gIDE1NixcbiAgcyxcbiAgWzE1NywgMTBdLFxuICBzLFxuICBbMTU4LCA0XSxcbiAgcyxcbiAgWzE1OSwgNV0sXG4gIDE2MCxcbiAgMTYwLFxuICBzLFxuICBbMTYxLCAxNF1cbl0pLFxuICBydWxlOiB1KFtcbiAgNCxcbiAgMyxcbiAgMyxcbiAgMixcbiAgMyxcbiAgMixcbiAgMixcbiAgMSxcbiAgMixcbiAgNSxcbiAgcyxcbiAgWzEsIDNdLFxuICBzLFxuICBbMywgM10sXG4gIDEsXG4gIDMsXG4gIDEsXG4gIDExLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIHMsXG4gIFsxLCAzXSxcbiAgNixcbiAgMTMsXG4gIDExLFxuICAxMCxcbiAgMTAsXG4gIDksXG4gIDEwLFxuICA5LFxuICA5LFxuICA4LFxuICA5LFxuICA4LFxuICA4LFxuICA3LFxuICA4LFxuICA3LFxuICA3LFxuICA2LFxuICBjLFxuICBbMzEsIDVdLFxuICBjLFxuICBbNCwgM10sXG4gIDIsXG4gIDQsXG4gIGMsXG4gIFs1MywgM10sXG4gIGMsXG4gIFs0NiwgM10sXG4gIDEsXG4gIGMsXG4gIFs0MCwgNV0sXG4gIDgsXG4gIDcsXG4gIDQsXG4gIDMsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzY4LCAzXSxcbiAgYyxcbiAgWzE5LCA0XSxcbiAgMyxcbiAgNCxcbiAgMSxcbiAgYyxcbiAgWzgwLCAzXSxcbiAgMTAsXG4gIDEyLFxuICAxNCxcbiAgMTQsXG4gIDE2LFxuICAxOCxcbiAgNixcbiAgNyxcbiAgNyxcbiAgMSxcbiAgYyxcbiAgWzQyLCA0XSxcbiAgcyxcbiAgWzEsIDZdLFxuICAzLFxuICA2LFxuICAzLFxuICA1LFxuICA1LFxuICA3LFxuICAyLFxuICA0LFxuICAxLFxuICA0LFxuICA2LFxuICA1LFxuICA1LFxuICA0LFxuICBjLFxuICBbMTExLCA0XSxcbiAgYyxcbiAgWzc1LCAzXSxcbiAgYyxcbiAgWzEyNywgNF0sXG4gIDMsXG4gIDIsXG4gIDUsXG4gIGMsXG4gIFsxMzYsIDNdLFxuICBzLFxuICBbMywgNl0sXG4gIDUsXG4gIDMsXG4gIDYsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIGMsXG4gIFs0LCA0XSxcbiAgMTAsXG4gIDgsXG4gIGMsXG4gIFs3NiwgM10sXG4gIGMsXG4gIFsxNTQsIDNdLFxuICBjLFxuICBbMTA2LCA0XSxcbiAgYyxcbiAgWzUsIDNdLFxuICBzLFxuICBbMSwgM10sXG4gIGMsXG4gIFsxMTAsIDRdLFxuICBjLFxuICBbOTksIDRdLFxuICBjLFxuICBbNSwgNV0sXG4gIDAsXG4gIHMsXG4gIFsxLCA3XSxcbiAgMCxcbiAgYyxcbiAgWzEwLCAzXSxcbiAgYyxcbiAgWzQsIDEwXSxcbiAgYyxcbiAgWzE5LCAxM10sXG4gIHMsXG4gIFsxLCAzOV1cbl0pXG59KSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBhcnNlcl9fUGVyZm9ybUFjdGlvbih5eWxvYywgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sIHl5c3AsIHl5dnN0YWNrLCB5eWxzdGFjaykge1xuXG4gICAgICAgICAgLyogdGhpcyA9PSB5eXZhbCAqL1xuXG4gICAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBpdHNlbGYgY2FuIGdvIGFuZCByZW1vdmUgdGhlc2Ugc3RhdGVtZW50cyB3aGVuIGB5eWAgdHVybnMgb3V0IHRvIGJlIHVudXNlZCBpbiBhbnkgYWN0aW9uIGNvZGUhXG4gICAgICAgICAgdmFyIHl5ID0gdGhpcy55eTtcbiAgICAgICAgICB2YXIgeXlwYXJzZXIgPSB5eS5wYXJzZXI7XG4gICAgICAgICAgdmFyIHl5bGV4ZXIgPSB5eS5sZXhlcjtcblxuICAgICAgICAgIFxuXG4gICAgICAgICAgc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICAkYWNjZXB0IDogbW9kdWxlICRlbmQgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXTtcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcCAtIDFdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBpbXBvcnRzIGV4cG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZSh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSAyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBleHBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBudWxsLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSAzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbW9kdWxlIDogaW1wb3J0cyBtYWluIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGltcG9ydHMgRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9XG4gICAgbmV3IHl5LmFzdC5Nb2R1bGUoeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgbnVsbCwgdGhpcy5fJCk7IFxuICAgIHJldHVybiB0aGlzLiQ7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1vZHVsZSA6IGV4cG9ydHMgbWFpbiBFT0YgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0Lk1vZHVsZShbXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBleHBvcnRzIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIG51bGwsIHRoaXMuXyQpOyBcbiAgICByZXR1cm4gdGhpcy4kO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtb2R1bGUgOiBtYWluIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPVxuICAgIG5ldyB5eS5hc3QuTW9kdWxlKFtdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTsgXG4gICAgcmV0dXJuIHRoaXMuJDtcbiAgICBicmVhaztcblxuY2FzZSA4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0cyA6IGltcG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgODU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXJzIDogZmlsdGVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSAgW3l5dnN0YWNrW3l5c3BdXTtcbiAgICBicmVhaztcblxuY2FzZSA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0cyA6IGltcG9ydHMgaW1wb3J0X3N0YXRlbWVudCAqL1xuY2FzZSAyNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydHMgOiBleHBvcnRzIGV4cG9ydCAqL1xuY2FzZSA2NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkcmVuIDogY2hpbGRyZW4gY2hpbGQgKi9cbmNhc2UgNzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVzIDogYXR0cmlidXRlcyBhdHRyaWJ1dGUgKi9cbmNhc2UgODY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXJzIDogZmlsdGVycyBmaWx0ZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXS5jb25jYXQoeXl2c3RhY2tbeXlzcF0pO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X3N0YXRlbWVudCA6IElNUE9SVCBpbXBvcnRfbWVtYmVyIEZST00gc3RyaW5nX2xpdGVyYWwgaW1wb3J0X3N0YXRlbWVudF9vcHRpb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JbXBvcnRTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW1wb3J0X21lbWJlciA6IGFnZ3JlZ2F0ZV9tZW1iZXIgKi9cbmNhc2UgMTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfbWVtYmVyIDogYWxpYXNlZF9tZW1iZXIgKi9cbmNhc2UgMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpbXBvcnRfbWVtYmVyIDogY29tcG9zaXRlX21lbWJlciAqL1xuY2FzZSAxOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlciA6IG1lbWJlcl9ncm91cCAqL1xuY2FzZSAyNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydCA6IGV4cG9ydF9zdGF0ZW1lbnQgKi9cbmNhc2UgMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiB2aWV3X3N0YXRlbWVudCAqL1xuY2FzZSAxNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsIDogbGl0ZXJhbF9ncm91cCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsLSwtLExULExBLC0sLSk6XG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcF07XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSwtLC0sTFQsTEEsLSwtKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYWxpYXNlZF9tZW1iZXIgOiBtZW1iZXIgQVMgbWVtYmVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQWxpYXNlZE1lbWJlcih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFnZ3JlZ2F0ZV9tZW1iZXIgOiBcIipcIiBBUyBtZW1iZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5BZ2dyZWdhdGVNZW1iZXIoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29tcG9zaXRlX21lbWJlciA6IFwie1wiIG1lbWJlcl9saXN0IFwifVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29tcG9zaXRlTWVtYmVyKHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdCA6IG1lbWJlcl9saXN0X2dyb3VwICovXG5jYXNlIDIzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwb3J0cyA6IGV4cG9ydCAqL1xuY2FzZSA0ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3NfbGlzdCA6IHR5cGVfY2xhc3MgKi9cbmNhc2UgNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJfbGlzdCA6IHBhcmFtZXRlciAqL1xuY2FzZSA2MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkcmVuIDogY2hpbGQgKi9cbmNhc2UgNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVzIDogYXR0cmlidXRlICovXG5jYXNlIDEwMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFyZ3VtZW50X2xpc3QgOiBleHByZXNzaW9uICovXG5jYXNlIDEyNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJnX2xpc3QgOiB0eXBlICovXG5jYXNlIDE2NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnRpZXMgOiBwcm9wZXJ0eSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gW3l5dnN0YWNrW3l5c3BdXTtcbiAgICBicmVhaztcblxuY2FzZSAxODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9saXN0IDogbWVtYmVyX2xpc3QgXCIsXCIgbWVtYmVyX2xpc3RfZ3JvdXAyICovXG5jYXNlIDQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzc19saXN0IDogdHlwZV9jbGFzc19saXN0IFwiLFwiIHR5cGVfY2xhc3MgKi9cbmNhc2UgNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXJfbGlzdCA6IHBhcmFtZXRlcl9saXN0IFwiLFwiIHBhcmFtZXRlciAqL1xuY2FzZSAxMDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhcmd1bWVudF9saXN0IDogYXJndW1lbnRfbGlzdCBcIixcIiBleHByZXNzaW9uICovXG5jYXNlIDEyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfYXJnX2xpc3QgOiB0eXBlX2FyZ19saXN0IFwiLFwiIHR5cGUgKi9cbmNhc2UgMTY2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydGllcyA6IHByb3BlcnRpZXMgXCIsXCIgcHJvcGVydHkgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXS5jb25jYXQoeXl2c3RhY2tbeXlzcF0pO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbiA6IFwieyVcIiBNQUlOIG1haW5fb3B0aW9uIG1haW5fb3B0aW9uMiBcIihcIiB0eXBlIFwiKVwiIG1haW5fb3B0aW9uMyBcIiV9XCIgdGFnIG1haW5fb3B0aW9uNCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTAsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlZE1haW4oeXl2c3RhY2tbeXlzcCAtIDhdLCB5eXZzdGFja1t5eXNwIC0gN118fFtdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluIDogdGFnICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW50eXBlZE1haW4oeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZW5kX21haW4gOiBcInslXCIgRU5ETUFJTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAyXTtcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLC0sLSxMVCxMQSwtLC0pXG4gICAgYnJlYWs7XG5cbmNhc2UgMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHBvcnQgOiBmdW5fc3RhdGVtZW50ICovXG5jYXNlIDY1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGQgOiBjaGlsZF9ncm91cCAqL1xuY2FzZSA2NjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHRhZyA6IG5vZGUgKi9cbmNhc2UgNjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0YWcgOiB3aWRnZXQgKi9cbmNhc2UgODI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWUgOiBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgKi9cbmNhc2UgODg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250cm9sIDogY29udHJvbF9ncm91cCAqL1xuY2FzZSAxMDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogaWZfZXhwcmVzc2lvbiAqL1xuY2FzZSAxMDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogYmluYXJ5X2V4cHJlc3Npb24gKi9cbmNhc2UgMTA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IHNpbXBsZV9leHByZXNzaW9uICovXG5jYXNlIDEwNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiByZWFkX2V4cHJlc3Npb24gKi9cbmNhc2UgMTA4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IGZ1bmN0aW9uX2V4cHJlc3Npb24gKi9cbmNhc2UgMTE3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb24gOiBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxMjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogaWRlbnRpZmllciAqL1xuY2FzZSAxMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fdGFyZ2V0IDogY29udGV4dF9wcm9wZXJ0eSAqL1xuY2FzZSAxNTg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uIDogcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCAqL1xuY2FzZSAxNzY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb25zIDogcXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE3NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnMgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAxODE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZGVudGlmaWVyIDogcXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTgyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaWRlbnRpZmllciA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTg2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yIDogYmluYXJ5X29wZXJhdG9yX2dyb3VwICovXG5jYXNlIDE4ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uIDogXCI7XCIgKi9cbmNhc2UgMTg5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBtZW1iZXIgKi9cbmNhc2UgMTkwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAgOiBhbGlhc2VkX21lbWJlciAqL1xuY2FzZSAxOTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfbGlzdF9ncm91cDIgOiBtZW1iZXIgKi9cbmNhc2UgMTkyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2xpc3RfZ3JvdXAyIDogYWxpYXNlZF9tZW1iZXIgKi9cbmNhc2UgMTkzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2dyb3VwIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxOTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZ3JvdXAgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuY2FzZSAxOTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbiA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yICovXG5jYXNlIDE5ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uMiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjMgOiBwYXJhbWV0ZXJzICovXG5jYXNlIDIwMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1haW5fb3B0aW9uNCA6IGVuZF9tYWluICovXG5jYXNlIDIwNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfc3RhdGVtZW50X29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24yIDogcGFyYW1ldGVycyAqL1xuY2FzZSAyMDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX29wdGlvbiA6IHR5cGVfY2xhc3NlcyAqL1xuY2FzZSAyMDk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IHRhZyAqL1xuY2FzZSAyMTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGludGVycG9sYXRpb24gKi9cbmNhc2UgMjExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hpbGRfZ3JvdXAgOiBjb250cm9sICovXG5jYXNlIDIxMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNoaWxkX2dyb3VwIDogY2hhcmFjdGVycyAqL1xuY2FzZSAyMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjaGlsZF9ncm91cCA6IGlkZW50aWZpZXIgKi9cbmNhc2UgMjE1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbm9kZV9vcHRpb24gOiBjaGlsZHJlbiAqL1xuY2FzZSAyMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbjIgOiBjaGlsZHJlbiAqL1xuY2FzZSAyMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uIDogY2hpbGRyZW4gKi9cbmNhc2UgMjIxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0X29wdGlvbjIgOiBjaGlsZHJlbiAqL1xuY2FzZSAyMjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBhdHRyaWJ1dGVfdmFsdWVfZ3JvdXAgOiBpbnRlcnBvbGF0aW9uICovXG5jYXNlIDIyMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGF0dHJpYnV0ZV92YWx1ZV9ncm91cCA6IGxpdGVyYWwgKi9cbmNhc2UgMjI0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29udHJvbF9ncm91cCA6IGZvcl9zdGF0ZW1lbnQgKi9cbmNhc2UgMjI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY29udHJvbF9ncm91cCA6IGlmX3N0YXRlbWVudCAqL1xuY2FzZSAyMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IHZpZXdfY29uc3RydWN0aW9uICovXG5jYXNlIDIyNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogZnVuX2FwcGxpY2F0aW9uICovXG5jYXNlIDIyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29uc3RydWN0X2V4cHJlc3Npb24gKi9cbmNhc2UgMjI5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjYWxsX2V4cHJlc3Npb24gKi9cbmNhc2UgMjMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBtZW1iZXJfZXhwcmVzc2lvbiAqL1xuY2FzZSAyMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGxpdGVyYWwgKi9cbmNhc2UgMjMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb250ZXh0X3Byb3BlcnR5ICovXG5jYXNlIDIzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHNpbXBsZV9leHByZXNzaW9uX2dyb3VwIDogY29ucyAqL1xuY2FzZSAyMzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBzaW1wbGVfZXhwcmVzc2lvbl9ncm91cCA6IGlkZW50aWZpZXIgKi9cbmNhc2UgMjM1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgc2ltcGxlX2V4cHJlc3Npb25fZ3JvdXAgOiBjb250ZXh0X3ZhcmlhYmxlICovXG5jYXNlIDIzNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb25fZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyMzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkYWJsZV9leHByZXNzaW9uX2dyb3VwIDogbWVtYmVyX2V4cHJlc3Npb24gKi9cbmNhc2UgMjM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IGNvbnRleHRfcHJvcGVydHkgKi9cbmNhc2UgMjM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZGFibGVfZXhwcmVzc2lvbl9ncm91cCA6IGNhbGxfZXhwcmVzc2lvbiAqL1xuY2FzZSAyNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogcmVjb3JkICovXG5jYXNlIDI0MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBsaXN0ICovXG5jYXNlIDI0MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpdGVyYWxfZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBsaXRlcmFsX2dyb3VwIDogbnVtYmVyX2xpdGVyYWwgKi9cbmNhc2UgMjQ0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbGl0ZXJhbF9ncm91cCA6IGJvb2xlYW5fbGl0ZXJhbCAqL1xuY2FzZSAyNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwcm9wZXJ0eV9ncm91cCA6IHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMjQ2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcHJvcGVydHlfZ3JvdXAgOiBzdHJpbmdfbGl0ZXJhbCAqL1xuY2FzZSAyNDc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj5cIiAqL1xuY2FzZSAyNDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIj49XCIgKi9cbmNhc2UgMjQ5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI8XCIgKi9cbmNhc2UgMjUwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI8PVwiICovXG5jYXNlIDI1MTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwiPT1cIiAqL1xuY2FzZSAyNTI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIiE9XCIgKi9cbmNhc2UgMjUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCIrXCIgKi9cbmNhc2UgMjU0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCIvXCIgKi9cbmNhc2UgMjU1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCItXCIgKi9cbmNhc2UgMjU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCI9XCIgKi9cbmNhc2UgMjU3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X29wZXJhdG9yX2dyb3VwIDogXCImJlwiICovXG5jYXNlIDI1ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9vcGVyYXRvcl9ncm91cCA6IFwifHxcIiAqL1xuY2FzZSAyNTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBcIl5cIiAqL1xuY2FzZSAyNjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBiaW5hcnlfb3BlcmF0b3JfZ3JvdXAgOiBJTlNUQU5DRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwXTtcbiAgICBicmVhaztcblxuY2FzZSAyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cG9ydF9zdGF0ZW1lbnQgOiBcInslXCIgRVhQT1JUIGNvbXBvc2l0ZV9tZW1iZXIgRlJPTSBzdHJpbmdfbGl0ZXJhbCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5FeHBvcnRTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDI5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmlld19zdGF0ZW1lbnQgOiBcInslXCIgVklFVyB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciB2aWV3X3N0YXRlbWVudF9vcHRpb24gXCIoXCIgdHlwZSBcIilcIiB2aWV3X3N0YXRlbWVudF9vcHRpb24yIFwiJX1cIiB0YWcgXCJ7JVwiIEVORFZJRVcgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlZpZXdTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDEwXSwgeXl2c3RhY2tbeXlzcCAtIDldfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV18fFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxMCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gOF0sIHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBjb250ZXh0X3R5cGUgXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGVU4gXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDMyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgcGFyYW1ldGVycyBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDksIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNl0sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgbnVsbCwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIGNvbnRleHRfdHlwZSBwYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gN10sIFtdLCB5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gNV0sIFtdLCB5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBwYXJhbWV0ZXJzIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERlVOIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gOCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNl0sW10sbnVsbCx5eXZzdGFja1t5eXNwIC0gNV0seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZVTiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLFtdLG51bGwsW10seXl2c3RhY2tbeXlzcCAtIDNdLHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDM4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA4LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA2XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAzOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgdHlwZV9jbGFzc2VzIGNvbnRleHRfdHlwZSBcIj1cIiBjaGlsZCBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5TdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHR5cGVfY2xhc3NlcyBwYXJhbWV0ZXJzIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSA0XSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciB0eXBlX2NsYXNzZXMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCBudWxsLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA0MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9zdGF0ZW1lbnQgOiBcInslXCIgRlVOIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgY29udGV4dF90eXBlIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDQzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3N0YXRlbWVudCA6IFwieyVcIiBGVU4gdW5xdWFsaWZpZWRfaWRlbnRpZmllciBjb250ZXh0X3R5cGUgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIHBhcmFtZXRlcnMgXCI9XCIgY2hpbGQgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA0XSxbXSxudWxsLHl5dnN0YWNrW3l5c3AgLSAzXSx5eXZzdGFja1t5eXNwIC0gMV0sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fc3RhdGVtZW50IDogXCJ7JVwiIEZVTiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiPVwiIGNoaWxkIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1blN0YXRlbWVudCh5eXZzdGFja1t5eXNwIC0gM10sW10sbnVsbCxbXSx5eXZzdGFja1t5eXNwIC0gMV0sdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNDY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjb250ZXh0X3R5cGUgOiBcIihcIiB0eXBlIFwiKVwiICovXG5jYXNlIDQ3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzc2VzIDogXCJbXCIgdHlwZV9jbGFzc19saXN0IFwiXVwiICovXG5jYXNlIDU4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVycyA6IFwiKFwiIHBhcmFtZXRlcl9saXN0IFwiKVwiICovXG5jYXNlIDEwMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGFyZ3VtZW50cyA6IFwiKFwiIGFyZ3VtZW50X2xpc3QgXCIpXCIgKi9cbmNhc2UgMTA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cbmNhc2UgMTI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZnVuX3RhcmdldCA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cbmNhc2UgMTI2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9hcmd1bWVudHMgOiBcIltcIiB0eXBlX2FyZ19saXN0IFwiXVwiICovXG5jYXNlIDE1OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRhYmxlX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgYnJlYWs7XG5cbmNhc2UgNTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSA1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGVfY2xhc3MgOiB1bnF1YWxpZmllZF9jb25zdHJ1Y3RvciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGVDbGFzcyh5eXZzdGFja1t5eXNwXSwgbnVsbCwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlX2NsYXNzIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB0eXBlICovXG5jYXNlIDUzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9jbGFzcyA6IHVucXVhbGlmaWVkX2NvbnN0cnVjdG9yIFwiOlwiIHR5cGUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlQ2xhc3MoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB0eXBlIDogY29ucyB0eXBlX29wdGlvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGUoeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXXx8W10sIGZhbHNlLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA1NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHR5cGUgOiBjb25zIHR5cGVfY2xhc3NlcyBcIltcIiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlR5cGUoeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZSA6IGNvbnMgXCJbXCIgXCJdXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5UeXBlKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDU3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVycyA6IFwiKFwiIFwiKVwiICovXG5jYXNlIDk5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXJndW1lbnRzIDogXCIoXCIgXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IFtdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDYxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcGFyYW1ldGVyIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB0eXBlICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVHlwZWRQYXJhbWV0ZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBwYXJhbWV0ZXIgOiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuVW50eXBlZFBhcmFtZXRlcih5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNjg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBhdHRyaWJ1dGVzIFwiPlwiIG5vZGVfb3B0aW9uIFwiPC9cIiBpZGVudGlmaWVyIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gNl0sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA2OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIFwiPlwiIG5vZGVfb3B0aW9uMiBcIjwvXCIgaWRlbnRpZmllciBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk5vZGUoeXl2c3RhY2tbeXlzcCAtIDVdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDNdfHxbXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGUgOiBcIjxcIiBpZGVudGlmaWVyIGF0dHJpYnV0ZXMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTm9kZSh5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlIDogXCI8XCIgaWRlbnRpZmllciBcIi8+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Ob2RlKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgd2lkZ2V0IDogXCI8XCIgY29ucyBhdHRyaWJ1dGVzIFwiPlwiIHdpZGdldF9vcHRpb24gXCI8L1wiIGNvbnMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDcsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5XaWRnZXQoeXl2c3RhY2tbeXlzcCAtIDZdLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIFwiPlwiIHdpZGdldF9vcHRpb24yIFwiPC9cIiBjb25zIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSA1XSwgW10sIHl5dnN0YWNrW3l5c3AgLSAzXXx8W10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgNzQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXQgOiBcIjxcIiBjb25zIGF0dHJpYnV0ZXMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldCA6IFwiPFwiIGNvbnMgXCIvPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuV2lkZ2V0KHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyIFwiPVwiIGF0dHJpYnV0ZV92YWx1ZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkF0dHJpYnV0ZSh5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDc5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIj1cIiBhdHRyaWJ1dGVfdmFsdWUgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID1cbiAgICBuZXcgeXkuYXN0LkF0dHJpYnV0ZShuZXcgeXkuYXN0LlVucXVhbGlmaWVkSWRlbnRpZmllcignaHRtbCcsIHRoaXMuXyQpLFxuICAgIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDgwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciBcIjpcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQXR0cmlidXRlKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIG5ldyB5eS5hc3QuQm9vbGVhbkxpdGVyYWwodHJ1ZSwgdGhpcy5fJCksIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDgxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYXR0cmlidXRlIDogdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkF0dHJpYnV0ZShcbiAgICBuZXcgeXkuYXN0LlVucXVhbGlmaWVkSWRlbnRpZmllcignaHRtbCcsIHRoaXMuXyQpLFxuICAgIHl5dnN0YWNrW3l5c3BdLCBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKHRydWUsIHRoaXMuXyQpLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGludGVycG9sYXRpb24gOiBcInt7XCIgZXhwcmVzc2lvbiBcIn19XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDIsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5JbnRlcnBvbGF0aW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDg0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgaW50ZXJwb2xhdGlvbiA6IFwie3tcIiBleHByZXNzaW9uIGZpbHRlcnMgXCJ9fVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSW50ZXJwb2xhdGlvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgODc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmaWx0ZXIgOiBcInxcIiBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwXVxuICAgIGJyZWFrO1xuXG5jYXNlIDg5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTkRGT1IgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA3XSwgbnVsbCwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIFtdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZvcl9zdGF0ZW1lbnQgOiBcInslXCIgRk9SIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDExLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCBudWxsLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDkxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBcIixcIiBwYXJhbWV0ZXIgSU4gZXhwcmVzc2lvbiBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEzLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAxMV0sIHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDkyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZm9yX3N0YXRlbWVudCA6IFwieyVcIiBGT1IgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDExXSwgbnVsbCwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIElOIGV4cHJlc3Npb24gXCIlfVwiIGNoaWxkcmVuIFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ERk9SIFwiJX1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMTUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Gb3JTdGF0ZW1lbnQoeXl2c3RhY2tbeXlzcCAtIDEzXSwgeXl2c3RhY2tbeXlzcCAtIDExXSwgbnVsbCwgeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSAzXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmb3Jfc3RhdGVtZW50IDogXCJ7JVwiIEZPUiBwYXJhbWV0ZXIgXCIsXCIgcGFyYW1ldGVyIFwiLFwiIHBhcmFtZXRlciBJTiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRUxTRSBcIiV9XCIgY2hpbGRyZW4gXCJ7JVwiIEVOREZPUiBcIiV9XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDE3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRm9yU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAxNV0sIHl5dnN0YWNrW3l5c3AgLSAxM10sIG51bGwsIHl5dnN0YWNrW3l5c3AgLSAxMV0sIHl5dnN0YWNrW3l5c3AgLSA5XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSA5NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGlmX3N0YXRlbWVudCA6IFwieyVcIiBJRiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBlbHNlX2NsYXVzZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LklmU3RhdGVtZW50KHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgOTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBlbHNlX2NsYXVzZSA6IFwieyVcIiBFTFNFIFwiJX1cIiBjaGlsZHJlbiBcInslXCIgRU5ESUYgXCIlfVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRWxzZUNsYXVzZSh5eXZzdGFja1t5eXNwIC0gM10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgZWxzZV9jbGF1c2UgOiBcInslXCIgRUxTRSBJRiBleHByZXNzaW9uIFwiJX1cIiBjaGlsZHJlbiBlbHNlX2NsYXVzZSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkVsc2VJZkNsYXVzZSh5eXZzdGFja1t5eXNwIC0gM10sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDk4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2hhcmFjdGVycyA6IENIQVJBQ1RFUlMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5DaGFyYWN0ZXJzKHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogdW5hcnlfZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSwtLC0pXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID15eXZzdGFja1t5eXNwXTtcbiAgICBicmVhaztcblxuY2FzZSAxMTA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBpZl9leHByZXNzaW9uIDogSUYgZXhwcmVzc2lvbiBUSEVOIGV4cHJlc3Npb24gRUxTRSBleHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA1LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuSWZUaGVuRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogc2ltcGxlX2V4cHJlc3Npb24gYmluYXJ5X29wZXJhdG9yIHNpbXBsZV9leHByZXNzaW9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogc2ltcGxlX2V4cHJlc3Npb24gYmluYXJ5X29wZXJhdG9yIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA0XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJpbmFyeV9leHByZXNzaW9uIDogXCIoXCIgZXhwcmVzc2lvbiBcIilcIiBiaW5hcnlfb3BlcmF0b3Igc2ltcGxlX2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5CaW5hcnlFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYmluYXJ5X2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIGJpbmFyeV9vcGVyYXRvciBcIihcIiBleHByZXNzaW9uIFwiKVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA2LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQmluYXJ5RXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB1bmFyeV9leHByZXNzaW9uIDogXCIhXCIgc2ltcGxlX2V4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5hcnlfZXhwcmVzc2lvbiA6IFwiIVwiIFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbmFyeUV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDExODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZpZXdfY29uc3RydWN0aW9uIDogXCI8XCIgY29ucyBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDMsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5WaWV3Q29uc3RydWN0aW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyBhcmd1bWVudHMgXCI+XCIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDUsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5BcHBsaWNhdGlvbih5eXZzdGFja1t5eXNwIC0gNF0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9hcHBsaWNhdGlvbiA6IFwiPFwiIGZ1bl90YXJnZXQgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzIFwiPlwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuRnVuQXBwbGljYXRpb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMl0sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bl9hcHBsaWNhdGlvbiA6IFwiPFwiIGZ1bl90YXJnZXQgYXJndW1lbnRzIGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNCwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgW10sIHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMjI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5fYXBwbGljYXRpb24gOiBcIjxcIiBmdW5fdGFyZ2V0IGFyZ3VtZW50cyBcIj5cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bkFwcGxpY2F0aW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIFtdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnN0cnVjdF9leHByZXNzaW9uIDogY29ucyBhcmd1bWVudHMgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5Db25zdHJ1Y3RFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAxXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5jYXNlIDEzMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5jYXNlIDEzNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIHR5cGVfYXJndW1lbnRzIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTMxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogaWRlbnRpZmllciBhcmd1bWVudHMgKi9cbmNhc2UgMTMzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogY29udGV4dF9wcm9wZXJ0eSBhcmd1bWVudHMgKi9cbmNhc2UgMTM1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY2FsbF9leHByZXNzaW9uIDogbWVtYmVyX2V4cHJlc3Npb24gYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ2FsbEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDFdLCBbXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNhbGxfZXhwcmVzc2lvbiA6IFwiKFwiIGV4cHJlc3Npb24gXCIpXCIgdHlwZV9hcmd1bWVudHMgYXJndW1lbnRzICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA0LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ2FsbEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjYWxsX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIGFyZ3VtZW50cyAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNhbGxFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAyXSwgW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxMzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHF1YWxpZmllZF9pZGVudGlmaWVyIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cbmNhc2UgMTM5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBxdWFsaWZpZWRfY29uc3RydWN0b3IgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDI6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGxpc3QgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IHJlY29yZCBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE0NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogc3RyaW5nX2xpdGVyYWwgXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuY2FzZSAxNDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtZW1iZXJfZXhwcmVzc2lvbiA6IGNhbGxfZXhwcmVzc2lvbiBcIi5cIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5jYXNlIDE0NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1lbWJlcl9leHByZXNzaW9uIDogbWVtYmVyX2V4cHJlc3Npb24gXCIuXCIgdW5xdWFsaWZpZWRfaWRlbnRpZmllciAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lk1lbWJlckV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTQ2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWVtYmVyX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiLlwiIHVucXVhbGlmaWVkX2lkZW50aWZpZXIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDQsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5NZW1iZXJFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE0ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfdmFyaWFibGUgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1MjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGNvbnRleHRfcHJvcGVydHkgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiXVwiICovXG5jYXNlIDE1NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB5eXZzdGFja1t5eXNwIC0gMV0sIG51bGwsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE0OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IGlkZW50aWZpZXIgXCJbXCIgcmVhZGFibGVfZXhwcmVzc2lvbiBBUyB0eXBlIFwiP1wiIGV4cHJlc3Npb24gXCJdXCIgKi9cbmNhc2UgMTUxOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVhZF9leHByZXNzaW9uIDogY29udGV4dF92YXJpYWJsZSBcIltcIiByZWFkYWJsZV9leHByZXNzaW9uIEFTIHR5cGUgXCI/XCIgZXhwcmVzc2lvbiBcIl1cIiAqL1xuY2FzZSAxNTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBjb250ZXh0X3Byb3BlcnR5IFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5jYXNlIDE1NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHJlYWRfZXhwcmVzc2lvbiA6IG1lbWJlcl9leHByZXNzaW9uIFwiW1wiIHJlYWRhYmxlX2V4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA3LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUmVhZEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDddLCB5eXZzdGFja1t5eXNwIC0gNV0sIHl5dnN0YWNrW3l5c3AgLSAzXSwgeXl2c3RhY2tbeXlzcCAtIDFdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiW1wiIGV4cHJlc3Npb24gQVMgdHlwZSBcIj9cIiBleHByZXNzaW9uIFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSA5LCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUmVhZEV4cHJlc3Npb24oeXl2c3RhY2tbeXlzcCAtIDldLCB5eXZzdGFja1t5eXNwIC0gN10sIHl5dnN0YWNrW3l5c3AgLSA1XSwgeXl2c3RhY2tbeXlzcCAtIDNdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWFkX2V4cHJlc3Npb24gOiBcIihcIiBleHByZXNzaW9uIFwiKVwiIFwiW1wiIGV4cHJlc3Npb24gQVMgdHlwZSBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gNywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlYWRFeHByZXNzaW9uKHl5dnN0YWNrW3l5c3AgLSA3XSwgeXl2c3RhY2tbeXlzcCAtIDVdLCB5eXZzdGFja1t5eXNwIC0gM10sIG51bGwsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGZ1bmN0aW9uX2V4cHJlc3Npb24gOiBcIlxcXFxcIiBwYXJhbWV0ZXJfbGlzdCBcIj0+XCIgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMywgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkZ1bmN0aW9uRXhwcmVzc2lvbih5eXZzdGFja1t5eXNwIC0gMl0sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBmdW5jdGlvbl9leHByZXNzaW9uIDogXCI9PlwiIGV4cHJlc3Npb24gKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8oeXlzcCAtIDEsIHl5c3ApO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5GdW5jdGlvbkV4cHJlc3Npb24oW10sIHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICByZWNvcmQgOiBcIntcIiBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlY29yZChbXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTY0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgcmVjb3JkIDogXCJ7XCIgcHJvcGVydGllcyBcIn1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlJlY29yZCh5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHByb3BlcnR5IDogcHJvcGVydHlfZ3JvdXAgXCI6XCIgZXhwcmVzc2lvbiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlByb3BlcnR5KHl5dnN0YWNrW3l5c3AgLSAyXSwgeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2ODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpc3QgOiBcIltcIiBcIl1cIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMSwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0Lkxpc3QoW10sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGxpc3QgOiBcIltcIiBhcmd1bWVudF9saXN0IFwiXVwiICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTGlzdCh5eXZzdGFja1t5eXNwIC0gMV0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHN0cmluZ19saXRlcmFsIDogU1RSSU5HX0xJVEVSQUwgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5TdHJpbmdMaXRlcmFsKHl5dnN0YWNrW3l5c3BdLnNsaWNlKDEsIHl5dnN0YWNrW3l5c3BdLmxlbmd0aCAtIDEsIHRoaXMuXyQpKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBudW1iZXJfbGl0ZXJhbCA6IE5VTUJFUl9MSVRFUkFMICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuTnVtYmVyTGl0ZXJhbCh5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTcyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgYm9vbGVhbl9saXRlcmFsIDogVFJVRSAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkJvb2xlYW5MaXRlcmFsKHRydWUsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGJvb2xlYW5fbGl0ZXJhbCA6IEZBTFNFICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eWxzdGFja1t5eXNwXTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQm9vbGVhbkxpdGVyYWwoZmFsc2UsIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE3NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfcHJvcGVydHkgOiBcIkBcIiB1bnF1YWxpZmllZF9pZGVudGlmaWVyICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAxLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuQ29udGV4dFByb3BlcnR5KHl5dnN0YWNrW3l5c3BdLCB0aGlzLl8kKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE3NTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNvbnRleHRfdmFyaWFibGUgOiBcIkBcIiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LkNvbnRleHRWYXJpYWJsZSh0aGlzLl8kKTtcbiAgICBicmVhaztcblxuY2FzZSAxNzg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBxdWFsaWZpZWRfY29uc3RydWN0b3IgOiBJREVOVElGSUVSIFwiLlwiIENPTlNUUlVDVE9SICovXG5jYXNlIDE3OTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9jb25zdHJ1Y3RvciA6IENPTlNUUlVDVE9SIFwiLlwiIENPTlNUUlVDVE9SICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpOlxuICAgIHRoaXMuXyQgPSB5eXBhcnNlci55eU1lcmdlTG9jYXRpb25JbmZvKHl5c3AgLSAyLCB5eXNwKTtcbiAgICAvLyBFTkQgb2YgZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IG5ldyB5eS5hc3QuUXVhbGlmaWVkQ29uc3RydWN0b3IoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTgwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5xdWFsaWZpZWRfY29uc3RydWN0b3IgOiBDT05TVFJVQ1RPUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlsc3RhY2tbeXlzcF07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlVucXVhbGlmaWVkQ29uc3RydWN0b3IoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4MzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9pZGVudGlmaWVyIDogSURFTlRJRklFUiBcIi5cIiBJREVOVElGSUVSICovXG5jYXNlIDE4NDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHF1YWxpZmllZF9pZGVudGlmaWVyIDogQ09OU1RSVUNUT1IgXCIuXCIgSURFTlRJRklFUiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogVlQsVkEsVlUsLSxMVCxMQSxMVSxMVWJBKTpcbiAgICB0aGlzLl8kID0geXlwYXJzZXIueXlNZXJnZUxvY2F0aW9uSW5mbyh5eXNwIC0gMiwgeXlzcCk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSlcbiAgICBcbiAgICBcbiAgICB0aGlzLiQgPSBuZXcgeXkuYXN0LlF1YWxpZmllZElkZW50aWZpZXIoeXl2c3RhY2tbeXlzcCAtIDJdLCB5eXZzdGFja1t5eXNwXSwgdGhpcy5fJCk7XG4gICAgYnJlYWs7XG5cbmNhc2UgMTg1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdW5xdWFsaWZpZWRfaWRlbnRpZmllciA6IElERU5USUZJRVIgKi9cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsTFUsTFViQSk6XG4gICAgdGhpcy5fJCA9IHl5bHN0YWNrW3l5c3BdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLExVLExVYkEpXG4gICAgXG4gICAgXG4gICAgdGhpcy4kID0gbmV3IHl5LmFzdC5VbnF1YWxpZmllZElkZW50aWZpZXIoeXl2c3RhY2tbeXlzcF0sIHRoaXMuXyQpO1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4NzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGltcG9ydF9zdGF0ZW1lbnRfb3B0aW9uIDogJWVwc2lsb24gKi9cbmNhc2UgMTk1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWFpbl9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAxOTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjIgOiAlZXBzaWxvbiAqL1xuY2FzZSAxOTk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjMgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYWluX29wdGlvbjQgOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMDU6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2aWV3X3N0YXRlbWVudF9vcHRpb24yIDogJWVwc2lsb24gKi9cbmNhc2UgMjA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdHlwZV9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBub2RlX29wdGlvbiA6ICVlcHNpbG9uICovXG5jYXNlIDIxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG5vZGVfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5jYXNlIDIxODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHdpZGdldF9vcHRpb24gOiAlZXBzaWxvbiAqL1xuY2FzZSAyMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB3aWRnZXRfb3B0aW9uMiA6ICVlcHNpbG9uICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiBWVCxWQSxWVSwtLExULExBLC0sLSk6XG4gICAgdGhpcy5fJCA9IHl5cGFyc2VyLnl5TWVyZ2VMb2NhdGlvbkluZm8obnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IFZULFZBLFZVLC0sTFQsTEEsLSwtKVxuICAgIFxuICAgIFxuICAgIHRoaXMuJCA9IHVuZGVmaW5lZDtcbiAgICBicmVhaztcblxufVxufSxcbnRhYmxlOiBidCh7XG4gIGxlbjogdShbXG4gIDE1LFxuICAxLFxuICAxNCxcbiAgMTEsXG4gIDEsXG4gIDAsXG4gIDAsXG4gIDQsXG4gIDAsXG4gIDEyLFxuICBzLFxuICBbMCwgNV0sXG4gIDgsXG4gIGMsXG4gIFsxMywgNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgMCxcbiAgNSxcbiAgcyxcbiAgWzIsIDNdLFxuICBjLFxuICBbOCwgNF0sXG4gIDEsXG4gIDEsXG4gIDksXG4gIHMsXG4gIFswLCA1XSxcbiAgNixcbiAgNixcbiAgcyxcbiAgWzAsIDRdLFxuICAyOSxcbiAgMjksXG4gIGMsXG4gIFsyMCwgNF0sXG4gIDQsXG4gIDAsXG4gIDEsXG4gIDQsXG4gIDcsXG4gIDIsXG4gIDYsXG4gIDYsXG4gIDIsXG4gIDAsXG4gIDMsXG4gIDAsXG4gIDUsXG4gIDIzLFxuICBjLFxuICBbNDQsIDNdLFxuICBjLFxuICBbNSwgM10sXG4gIDIsXG4gIDIsXG4gIGMsXG4gIFs1NSwgM10sXG4gIDYsXG4gIGMsXG4gIFs1MSwgM10sXG4gIDUsXG4gIDQsXG4gIDIsXG4gIDIxLFxuICAyMCxcbiAgMTAsXG4gIGMsXG4gIFs0NiwgNV0sXG4gIDgsXG4gIGMsXG4gIFsyOCwgM10sXG4gIDEsXG4gIDIxLFxuICBzLFxuICBbMCwgN10sXG4gIDQzLFxuICBzLFxuICBbMCwgNF0sXG4gIDEwLFxuICAxLFxuICAyLFxuICAyLFxuICAxNyxcbiAgMjMsXG4gIGMsXG4gIFsyMSwgN10sXG4gIGMsXG4gIFs2NCwgNF0sXG4gIDMsXG4gIDEsXG4gIDYsXG4gIGMsXG4gIFs0OCwgNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgNSxcbiAgMjEsXG4gIDIwLFxuICAyMCxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgMixcbiAgOSxcbiAgYyxcbiAgWzY2LCAzXSxcbiAgYyxcbiAgWzExNSwgNF0sXG4gIDMsXG4gIGMsXG4gIFszOCwgM10sXG4gIDUsXG4gIGMsXG4gIFsxMDcsIDNdLFxuICAwLFxuICAwLFxuICAyNixcbiAgYyxcbiAgWzYxLCAzXSxcbiAgNDMsXG4gIDMzLFxuICAwLFxuICAyOCxcbiAgMjYsXG4gIDI5LFxuICAyOSxcbiAgNCxcbiAgYyxcbiAgWzcwLCA0XSxcbiAgMjUsXG4gIDAsXG4gIDI2LFxuICAyNyxcbiAgMjgsXG4gIDI3LFxuICBzLFxuICBbMjUsIDNdLFxuICAxMixcbiAgMCxcbiAgNDUsXG4gIDgsXG4gIHMsXG4gIFswLCA1XSxcbiAgMSxcbiAgMSxcbiAgMyxcbiAgNDMsXG4gIGMsXG4gIFs0MiwgNF0sXG4gIGMsXG4gIFsxMiwgNV0sXG4gIDIxLFxuICA1LFxuICBjLFxuICBbNzEsIDNdLFxuICA1LFxuICBjLFxuICBbMTc2LCAzXSxcbiAgMSxcbiAgYyxcbiAgWzg2LCAzXSxcbiAgYyxcbiAgWzg1LCA0XSxcbiAgYyxcbiAgWzQsIDRdLFxuICAyMCxcbiAgMSxcbiAgMyxcbiAgYyxcbiAgWzg0LCA1XSxcbiAgNyxcbiAgNyxcbiAgNixcbiAgMSxcbiAgMSxcbiAgNSxcbiAgMSxcbiAgYyxcbiAgWzEwLCAzXSxcbiAgYyxcbiAgWzgyLCAzXSxcbiAgcyxcbiAgWzAsIDE0XSxcbiAgYyxcbiAgWzU0LCAzXSxcbiAgNDMsXG4gIDE1LFxuICAxNSxcbiAgMTQsXG4gIDExLFxuICAyNCxcbiAgMixcbiAgMCxcbiAgNDUsXG4gIDIwLFxuICAyLFxuICAyNCxcbiAgYyxcbiAgWzIwOSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgMixcbiAgMCxcbiAgYyxcbiAgWzQsIDVdLFxuICBzLFxuICBbMiwgNF0sXG4gIGMsXG4gIFs5OCwgM10sXG4gIDQzLFxuICBjLFxuICBbMTMsIDRdLFxuICBjLFxuICBbMywgM10sXG4gIGMsXG4gIFsyNjIsIDNdLFxuICAyLFxuICAxLFxuICAxNyxcbiAgNSxcbiAgMSxcbiAgYyxcbiAgWzExNywgNF0sXG4gIDQsXG4gIGMsXG4gIFs5NiwgOF0sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzE4MiwgM10sXG4gIGMsXG4gIFsyOSwgNF0sXG4gIGMsXG4gIFsyOTQsIDRdLFxuICBjLFxuICBbNDYsIDNdLFxuICAzMSxcbiAgNDMsXG4gIDEsXG4gIDcsXG4gIDEsXG4gIDIsXG4gIGMsXG4gIFsyNTEsIDNdLFxuICBjLFxuICBbMzAxLCA0XSxcbiAgcyxcbiAgWzEsIDNdLFxuICBjLFxuICBbNDcsIDNdLFxuICBjLFxuICBbNywgNF0sXG4gIGMsXG4gIFszNCwgN10sXG4gIGMsXG4gIFsyNzQsIDVdLFxuICBjLFxuICBbMTAsIDNdLFxuICAyLFxuICAzLFxuICBjLFxuICBbMTIyLCAzXSxcbiAgMCxcbiAgNixcbiAgNDMsXG4gIDQzLFxuICAzLFxuICAyMSxcbiAgYyxcbiAgWzYyLCA1XSxcbiAgMSxcbiAgYyxcbiAgWzc0LCA4XSxcbiAgYyxcbiAgWzMsIDNdLFxuICBjLFxuICBbMzg3LCA1XSxcbiAgMzMsXG4gIDQ1LFxuICBjLFxuICBbMzUwLCA0XSxcbiAgMTUsXG4gIDYsXG4gIDAsXG4gIDYsXG4gIGMsXG4gIFszNTUsIDNdLFxuICBjLFxuICBbMzkzLCA0XSxcbiAgYyxcbiAgWzQ5LCAzXSxcbiAgYyxcbiAgWzU4LCA2XSxcbiAgMjEsXG4gIDAsXG4gIDQsXG4gIDQsXG4gIGMsXG4gIFszOCwgNV0sXG4gIGMsXG4gIFsxNywgM10sXG4gIDE1LFxuICAwLFxuICA0MyxcbiAgMSxcbiAgMjIsXG4gIGMsXG4gIFsxNjMsIDVdLFxuICA2LFxuICBjLFxuICBbNDQ0LCA2XSxcbiAgMjEsXG4gIDQzLFxuICBjLFxuICBbNzAsIDNdLFxuICA0LFxuICBjLFxuICBbNjcsIDZdLFxuICBjLFxuICBbNTMsIDNdLFxuICA0MyxcbiAgYyxcbiAgWzEwMSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzM1OCwgM10sXG4gIGMsXG4gIFsxOTYsIDNdLFxuICBjLFxuICBbMjMsIDNdLFxuICAxNSxcbiAgYyxcbiAgWzE0MCwgNF0sXG4gIDEsXG4gIDQsXG4gIDIxLFxuICA0MyxcbiAgMjEsXG4gIDQzLFxuICAxLFxuICAxLFxuICBjLFxuICBbMTQxLCA2XSxcbiAgMSxcbiAgYyxcbiAgWzIwMSwgM10sXG4gIDIwLFxuICBjLFxuICBbMTU4LCA1XSxcbiAgMjEsXG4gIDQsXG4gIDIxLFxuICBjLFxuICBbMTQzLCAzXSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgYyxcbiAgWzMyMCwgM10sXG4gIDMsXG4gIGMsXG4gIFsxNCwgM10sXG4gIGMsXG4gIFsyMCwgM10sXG4gIGMsXG4gIFs0MTUsIDRdLFxuICBjLFxuICBbMTEsIDNdLFxuICAxLFxuICAyMCxcbiAgYyxcbiAgWzEyOCwgNF1cbl0pLFxuICBzeW1ib2w6IHUoW1xuICAxMyxcbiAgMjUsXG4gIDI4LFxuICA2NCxcbiAgNjUsXG4gIDY2LFxuICA3MyxcbiAgcyxcbiAgWzc1LCA1LCAxXSxcbiAgOTAsXG4gIDkxLFxuICA5MixcbiAgMSxcbiAgMSxcbiAgYyxcbiAgWzE3LCAzXSxcbiAgYyxcbiAgWzE1LCAxMV0sXG4gIDEzLFxuICAyOCxcbiAgNzMsXG4gIGMsXG4gIFsxMSwgOF0sXG4gIDI5LFxuICAzMixcbiAgMzMsXG4gIDM1LFxuICAzLFxuICA0LFxuICA1NSxcbiAgNTYsXG4gIHMsXG4gIFs2NywgNCwgMV0sXG4gIDcyLFxuICAxMzQsXG4gIDEzNyxcbiAgMTQyLFxuICA1NSxcbiAgNTYsXG4gIHMsXG4gIFsxMzIsIDYsIDFdLFxuICBjLFxuICBbMzYsIDEyXSxcbiAgMSxcbiAgNyxcbiAgMTAsXG4gIDU2LFxuICAxMzQsXG4gIDE0MyxcbiAgNCxcbiAgNzAsXG4gIDU2LFxuICAxMzQsXG4gIDU1LFxuICAxMzcsXG4gIDI2LFxuICAyNyxcbiAgMjcsXG4gIDU1LFxuICA1NixcbiAgNjgsXG4gIDcxLFxuICBjLFxuICBbNDMsIDNdLFxuICAxNDAsXG4gIDE0MixcbiAgMTQsXG4gIDM4LFxuICA1NSxcbiAgOTMsXG4gIDk0LFxuICAxMzcsXG4gIGMsXG4gIFs2LCA2XSxcbiAgcyxcbiAgWzUsIDcsIDFdLFxuICAxMyxcbiAgMTQsXG4gIDE1LFxuICAxNyxcbiAgcyxcbiAgWzIxLCA0LCAxXSxcbiAgMjcsXG4gIDMwLFxuICAzOCxcbiAgNDAsXG4gIDQ0LFxuICA0OCxcbiAgNTUsXG4gIHMsXG4gIFs1NywgNywgMV0sXG4gIGMsXG4gIFsyOSwgMjldLFxuICBjLFxuICBbOTQsIDNdLFxuICA4MSxcbiAgMTQ0LFxuICAyNixcbiAgYyxcbiAgWzUsIDNdLFxuICAxNDcsXG4gIDcsXG4gIDksXG4gIDEwLFxuICAzMCxcbiAgODAsXG4gIDgxLFxuICA4NSxcbiAgNTEsXG4gIDEyNyxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTM5LCA2XSxcbiAgYyxcbiAgWzYsIDRdLFxuICA1LFxuICA2LFxuICA1LFxuICA2LFxuICAyNyxcbiAgYyxcbiAgWzEwMCwgM10sXG4gIDk0LFxuICAxMzcsXG4gIDEzLFxuICAyOCxcbiAgMzcsXG4gIDM5LFxuICA0NyxcbiAgNTUsXG4gIDU2LFxuICBzLFxuICBbODgsIDUsIDFdLFxuICA5NixcbiAgOTksXG4gIDEwMCxcbiAgMTAxLFxuICAxMDMsXG4gIGMsXG4gIFsxNjcsIDNdLFxuICAxNTAsXG4gIDE1MixcbiAgMTU2LFxuICA5LFxuICAxMixcbiAgYyxcbiAgWzMwLCAzXSxcbiAgYyxcbiAgWzMzLCAyNl0sXG4gIDE1NCxcbiAgMTU2LFxuICA1NSxcbiAgNTYsXG4gIDU1LFxuICA1NixcbiAgNyxcbiAgNTUsXG4gIDU2LFxuICA4MixcbiAgODMsXG4gIDEzNCxcbiAgMTM3LFxuICA1MSxcbiAgMTI3LFxuICA3LFxuICA3LFxuICA5LFxuICAzMCxcbiAgODAsXG4gIDg1LFxuICBjLFxuICBbNSwgM10sXG4gIDg1LFxuICA5LFxuICAzMCxcbiAgMTMsXG4gIDI4LFxuICBjLFxuICBbNDcsIDE4XSxcbiAgMTU2LFxuICBjLFxuICBbMjEsIDZdLFxuICBjLFxuICBbMjAsIDE0XSxcbiAgOCxcbiAgNTUsXG4gIDU2LFxuICA4NCxcbiAgODYsXG4gIDg3LFxuICBjLFxuICBbMjgxLCAzXSxcbiAgYyxcbiAgWzI3OSwgM10sXG4gIDIwLFxuICAyNSxcbiAgMjgsXG4gIDEzOSxcbiAgYyxcbiAgWzI1OCwgM10sXG4gIGMsXG4gIFsxNTUsIDNdLFxuICAxNDEsXG4gIDE0MixcbiAgYyxcbiAgWzExMywgMjFdLFxuICAxNTEsXG4gIDE1NixcbiAgMzcsXG4gIGMsXG4gIFsyNCwgN10sXG4gIGMsXG4gIFs2OSwgMTRdLFxuICBzLFxuICBbNCwgNiwgM10sXG4gIDQ1LFxuICBzLFxuICBbNDksIDgsIDFdLFxuICBzLFxuICBbMTA2LCA3LCAxXSxcbiAgcyxcbiAgWzExNiwgNCwgMV0sXG4gIDEyMSxcbiAgMTIyLFxuICAxMjMsXG4gIHMsXG4gIFsxMjYsIDEyLCAxXSxcbiAgMTU3LFxuICAxNTksXG4gIDEzLFxuICAxNCxcbiAgMTcsXG4gIDI4LFxuICAzMCxcbiAgYyxcbiAgWzY3LCA1XSxcbiAgMTcsXG4gIDQxLFxuICA0NSxcbiAgNTUsXG4gIDEzNyxcbiAgNCxcbiAgMTAsXG4gIDM5LFxuICBjLFxuICBbNTIsIDRdLFxuICA5NSxcbiAgOTYsXG4gIGMsXG4gIFs0MCwgNl0sXG4gIDE1NSxcbiAgMTU5LFxuICBjLFxuICBbMTIwLCAyMV0sXG4gIDE1MyxcbiAgYyxcbiAgWzEyMCwgMjNdLFxuICBjLFxuICBbMTg4LCAzXSxcbiAgYyxcbiAgWzg4LCAzXSxcbiAgNixcbiAgMTEsXG4gIDYsXG4gIDExLFxuICAxMixcbiAgYyxcbiAgWzMsIDNdLFxuICAzMCxcbiAgYyxcbiAgWzE1LCA2XSxcbiAgYyxcbiAgWzI1NywgNDddLFxuICBjLFxuICBbMzAwLCA0NV0sXG4gIDg2LFxuICA4NyxcbiAgYyxcbiAgWzM5NCwgM10sXG4gIGMsXG4gIFs0NiwgMzldLFxuICBjLFxuICBbMjAsIDIwXSxcbiAgMzAsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDYsXG4gIDgsXG4gIDEwLFxuICAxMSxcbiAgMTgsXG4gIDQyLFxuICA1MCxcbiAgODEsXG4gIDE0OSxcbiAgNixcbiAgOCxcbiAgMTIsXG4gIDQyLFxuICA1MCxcbiAgYyxcbiAgWzUsIDNdLFxuICAxNyxcbiAgYyxcbiAgWzE4LCA0XSxcbiAgMTQsXG4gIDE3LFxuICBjLFxuICBbMjAsIDNdLFxuICBjLFxuICBbNTI3LCAzXSxcbiAgYyxcbiAgWzIzMywgMjRdLFxuICBjLFxuICBbNywgM10sXG4gIDE1LFxuICA0MCxcbiAgOTcsXG4gIDk4LFxuICA1LFxuICA2LFxuICA4LFxuICA5LFxuICBjLFxuICBbNjIxLCA0XSxcbiAgYyxcbiAgWzYyMCwgNl0sXG4gIGMsXG4gIFs2MTksIDNdLFxuICBjLFxuICBbNjE4LCA3XSxcbiAgMTM4LFxuICAxNjEsXG4gIGMsXG4gIFszODgsIDQzXSxcbiAgYyxcbiAgWzQzLCA0N10sXG4gIDE5LFxuICBjLFxuICBbMzksIDZdLFxuICBjLFxuICBbMzUsIDZdLFxuICBjLFxuICBbMzMsIDE2XSxcbiAgYyxcbiAgWzc2OCwgMTBdLFxuICBjLFxuICBbMTQ3LCAxNl0sXG4gIDEwNCxcbiAgMTE0LFxuICBjLFxuICBbMTczLCA0XSxcbiAgYyxcbiAgWzc5NSwgMTJdLFxuICBjLFxuICBbMjgsIDEwXSxcbiAgYyxcbiAgWzgyMiwgMTddLFxuICBjLFxuICBbNTUsIDE0XSxcbiAgYyxcbiAgWzI5LCAyN10sXG4gIGMsXG4gIFszODcsIDRdLFxuICBjLFxuICBbMTkyLCA0M10sXG4gIGMsXG4gIFszMDQsIDhdLFxuICBjLFxuICBbMTMwLCAyMl0sXG4gIGMsXG4gIFsxODMsIDIxXSxcbiAgYyxcbiAgWzEyNywgMjddLFxuICBjLFxuICBbMjA5LCAxOV0sXG4gIGMsXG4gIFsxMDAzLCA4XSxcbiAgYyxcbiAgWzEwNjIsIDE4XSxcbiAgYyxcbiAgWzU1LCAxNF0sXG4gIGMsXG4gIFsyNSwgNzFdLFxuICA3LFxuICAxOSxcbiAgNTUsXG4gIDU2LFxuICAxMTMsXG4gIDEzMCxcbiAgYyxcbiAgWzIyMiwgNl0sXG4gIGMsXG4gIFsyNjMsIDNdLFxuICAxMSxcbiAgYyxcbiAgWzI2NCwgMTJdLFxuICBzLFxuICBbMTA1LCA4LCAxXSxcbiAgYyxcbiAgWzI2NSwgMjJdLFxuICA1MSxcbiAgNTUsXG4gIDEyNCxcbiAgMTI1LFxuICAxMjcsXG4gIDEzNyxcbiAgMTYwLFxuICBzLFxuICBbNTUsIDNdLFxuICBjLFxuICBbMzIxLCA0NV0sXG4gIDksXG4gIGMsXG4gIFsxMTUxLCAzXSxcbiAgYyxcbiAgWzY2MCwgMjRdLFxuICBjLFxuICBbMzYsIDNdLFxuICA4LFxuICAxNyxcbiAgNTUsXG4gIDU2LFxuICBjLFxuICBbMTE0OSwgM10sXG4gIGMsXG4gIFs4OTAsIDZdLFxuICBjLFxuICBbNiwgNl0sXG4gIDgsXG4gIGMsXG4gIFs4NTAsIDQzXSxcbiAgYyxcbiAgWzg0NSwgNjJdLFxuICBjLFxuICBbNjIsIDY4XSxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDM2LFxuICBjLFxuICBbMTE3MywgM10sXG4gIDg3LFxuICAxMzcsXG4gIGMsXG4gIFs5MzEsIDddLFxuICAxMSxcbiAgYyxcbiAgWzEzNzAsIDZdLFxuICBjLFxuICBbMjE1LCA2XSxcbiAgNTYsXG4gIGMsXG4gIFsxMzg3LCAzXSxcbiAgYyxcbiAgWzM2LCAzXSxcbiAgMTQsXG4gIDE1LFxuICA0MCxcbiAgOTgsXG4gIGMsXG4gIFs4MzIsIDc2XSxcbiAgOCxcbiAgNDgsXG4gIGMsXG4gIFs3MTgsIDQ1XSxcbiAgNyxcbiAgYyxcbiAgWzE1NCwgM10sXG4gIDE1LFxuICAxNyxcbiAgYyxcbiAgWzUzMCwgNV0sXG4gIGMsXG4gIFs4MDksIDZdLFxuICBjLFxuICBbMTUsIDE4XSxcbiAgYyxcbiAgWzE0LCA5XSxcbiAgOCxcbiAgYyxcbiAgWzI3LCA4XSxcbiAgYyxcbiAgWzk4LCAzXSxcbiAgMTksXG4gIDUxLFxuICBjLFxuICBbMTk4LCAzXSxcbiAgMTE1LFxuICAxMTcsXG4gIDExOCxcbiAgMTIwLFxuICBjLFxuICBbODIsIDNdLFxuICBjLFxuICBbODAsIDhdLFxuICAxNTgsXG4gIDcsXG4gIDEwNCxcbiAgNCxcbiAgYyxcbiAgWzUwLCAzXSxcbiAgYyxcbiAgWzU3OSwgNDFdLFxuICBjLFxuICBbNzEsIDddLFxuICBjLFxuICBbNjksIDhdLFxuICAxMzMsXG4gIGMsXG4gIFs2NywgNF0sXG4gIGMsXG4gIFsxNDc0LCAzXSxcbiAgYyxcbiAgWzkzLCAyM10sXG4gIDU1LFxuICAxMzcsXG4gIGMsXG4gIFs5NSwgNF0sXG4gIGMsXG4gIFsyOCwgMjZdLFxuICA2LFxuICA1MCxcbiAgNTUsXG4gIDEzNyxcbiAgNTUsXG4gIDEzNyxcbiAgYyxcbiAgWzQsIDhdLFxuICA3LFxuICAxMDQsXG4gIDcsXG4gIDEwLFxuICAxMDQsXG4gIDExNCxcbiAgYyxcbiAgWzI2NywgNDNdLFxuICA1NSxcbiAgMTM3LFxuICA2LFxuICAxMSxcbiAgNSxcbiAgNixcbiAgMTIsXG4gIDYsXG4gIDQyLFxuICAzMCxcbiAgYyxcbiAgWzE2MDMsIDE3XSxcbiAgYyxcbiAgWzY2NSwgNV0sXG4gIDE0LFxuICA3LFxuICAzMCxcbiAgODUsXG4gIDE0NSxcbiAgYyxcbiAgWzQsIDNdLFxuICAxNDgsXG4gIGMsXG4gIFs1NDksIDg2XSxcbiAgYyxcbiAgWzI0LCAyNF0sXG4gIGMsXG4gIFszLCAzXSxcbiAgMzAsXG4gIDExLFxuICAxNCxcbiAgYyxcbiAgWzQ2NywgNDddLFxuICBjLFxuICBbMTI2MSwgMjVdLFxuICBjLFxuICBbMTQ5NCwgNDVdLFxuICBjLFxuICBbMTk5NCwgNF0sXG4gIDExNSxcbiAgYyxcbiAgWzEzLCAzXSxcbiAgMjcsXG4gIDYsXG4gIDExLFxuICBjLFxuICBbNTQsIDQzXSxcbiAgMTcsXG4gIDI3LFxuICA3LFxuICAxMCxcbiAgMTcsXG4gIDI3LFxuICAxMDQsXG4gIDExNCxcbiAgYyxcbiAgWzYsIDZdLFxuICAxNyxcbiAgMjcsXG4gIHMsXG4gIFsxNywgM10sXG4gIGMsXG4gIFszOTQsIDRdLFxuICA2LFxuICA4LFxuICBjLFxuICBbMTAsIDNdLFxuICAyNyxcbiAgMjcsXG4gIGMsXG4gIFs3MywgNDNdLFxuICAxNCxcbiAgYyxcbiAgWzQ1MSwgM10sXG4gIDE0LFxuICAxMDQsXG4gIDgsXG4gIGMsXG4gIFs1MCwgNDNdLFxuICA1MSxcbiAgNTUsXG4gIGMsXG4gIFsxMTY5LCA0XSxcbiAgYyxcbiAgWzE3MjAsIDg2XSxcbiAgYyxcbiAgWzk2NSwgM10sXG4gIGMsXG4gIFs1MDUsIDIxXSxcbiAgMTQsXG4gIDMwLFxuICBjLFxuICBbNDY3LCAyNV0sXG4gIGMsXG4gIFs0NDMsIDRdLFxuICBjLFxuICBbNCwgNF0sXG4gIDMwLFxuICBjLFxuICBbMTk2LCA1XSxcbiAgYyxcbiAgWzk0OSwgMjldLFxuICBjLFxuICBbMTM3LCAxNV0sXG4gIDg0LFxuICBjLFxuICBbMTM4LCA3XSxcbiAgcyxcbiAgWzExNSwgNSwgMV0sXG4gIGMsXG4gIFs2ODIsIDE5XSxcbiAgNyxcbiAgMTA0LFxuICA0NCxcbiAgYyxcbiAgWzkzOSwgMTVdLFxuICBjLFxuICBbMTMyOCwgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzIyNDMsIDddLFxuICAxNCxcbiAgMTA0LFxuICAxNCxcbiAgMzAsXG4gIDYsXG4gIDQyLFxuICBjLFxuICBbMTcwLCAxNF0sXG4gIDEwMixcbiAgYyxcbiAgWzY3OSwgN10sXG4gIGMsXG4gIFsxNSwgM10sXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzE3MSwgNV0sXG4gIDMwLFxuICBjLFxuICBbODgsIDE1XSxcbiAgYyxcbiAgWzI5MCwgNDNdLFxuICAyNyxcbiAgNixcbiAgYyxcbiAgWzI3MDgsIDNdLFxuICBjLFxuICBbNjMyLCAzXSxcbiAgYyxcbiAgWzYzMCwgNV0sXG4gIGMsXG4gIFs2MjYsIDddLFxuICA4MSxcbiAgMTA0LFxuICAxNDksXG4gIGMsXG4gIFs2NiwgNDNdLFxuICAxMSxcbiAgMTgsXG4gIGMsXG4gIFs1NjUsIDZdLFxuICAxMSxcbiAgMTgsXG4gIDExLFxuICAxOCxcbiAgMTEsXG4gIDE4LFxuICAxNCxcbiAgYyxcbiAgWzM2OCwgMjFdLFxuICBjLFxuICBbNDM1LCA0Nl0sXG4gIDQxLFxuICA0NCxcbiAgNDUsXG4gIDEsXG4gIDI4LFxuICA3NCxcbiAgMTQ2LFxuICAyOCxcbiAgMzAsXG4gIGMsXG4gIFsyNzYsIDddLFxuICBjLFxuICBbMjI2MCwgOTBdLFxuICBjLFxuICBbNDMsIDgyXSxcbiAgYyxcbiAgWzU5OSwgMjFdLFxuICA0MixcbiAgMzAsXG4gIDQ1LFxuICAzMSxcbiAgMzQsXG4gIGMsXG4gIFs0MjAsIDE1XSxcbiAgYyxcbiAgWzMwMSwgM10sXG4gIHMsXG4gIFsxMSwgM10sXG4gIDQxLFxuICA0MyxcbiAgNDQsXG4gIGMsXG4gIFsxMDkzLCA3XSxcbiAgYyxcbiAgWzMwNiwgNThdLFxuICBjLFxuICBbNjQsIDY0XSxcbiAgMzAsXG4gIDMwLFxuICBjLFxuICBbNDUsIDQ1XSxcbiAgYyxcbiAgWzEzMTMsIDQyXSxcbiAgMTEsXG4gIGMsXG4gIFsxNTQsIDIxXSxcbiAgYyxcbiAgWzI0MywgMjVdLFxuICA0MSxcbiAgNDUsXG4gIDQ2LFxuICBjLFxuICBbMTQ0NiwgNDFdLFxuICBjLFxuICBbMTM1LCAzN10sXG4gIGMsXG4gIFs4MTEsIDddLFxuICA0MSxcbiAgNDMsXG4gIGMsXG4gIFsxMTIsIDIzXSxcbiAgYyxcbiAgWzEzNywgM10sXG4gIGMsXG4gIFs3MSwgMjJdLFxuICAzMCxcbiAgYyxcbiAgWzUxLCAyNF0sXG4gIGMsXG4gIFs0NywgMjFdLFxuICBjLFxuICBbNDUsIDNdLFxuICAzMFxuXSksXG4gIHR5cGU6IHUoW1xuICBzLFxuICBbMiwgM10sXG4gIHMsXG4gIFswLCAxMl0sXG4gIDEsXG4gIHMsXG4gIFsyLCA0XSxcbiAgcyxcbiAgWzAsIDEwXSxcbiAgYyxcbiAgWzEzLCAxMV0sXG4gIHMsXG4gIFsyLCA5XSxcbiAgYyxcbiAgWzE3LCAxMF0sXG4gIGMsXG4gIFszNiwgMjJdLFxuICBjLFxuICBbNywgM10sXG4gIDAsXG4gIDIsXG4gIGMsXG4gIFs0LCA0XSxcbiAgYyxcbiAgWzQ1LCAxMV0sXG4gIGMsXG4gIFsxMCwgNl0sXG4gIGMsXG4gIFs2LCA5XSxcbiAgcyxcbiAgWzIsIDU4XSxcbiAgYyxcbiAgWzY5LCA3XSxcbiAgYyxcbiAgWzkxLCA3XSxcbiAgYyxcbiAgWzEwMSwgNF0sXG4gIGMsXG4gIFsxMzksIDEwXSxcbiAgYyxcbiAgWzM2LCAxM10sXG4gIGMsXG4gIFsyMDAsIDE0XSxcbiAgYyxcbiAgWzE5NSwgMTRdLFxuICBjLFxuICBbMzMsIDMyXSxcbiAgYyxcbiAgWzExLCA1XSxcbiAgYyxcbiAgWzEwMCwgN10sXG4gIGMsXG4gIFs1LCA0XSxcbiAgYyxcbiAgWzI1MCwgMTZdLFxuICBjLFxuICBbNDYsIDEzXSxcbiAgYyxcbiAgWzIwLCAxN10sXG4gIGMsXG4gIFsyNjgsIDEzXSxcbiAgYyxcbiAgWzI5MywgMTFdLFxuICBjLFxuICBbMTQ2LCAzMF0sXG4gIGMsXG4gIFsyMiwgMjBdLFxuICBjLFxuICBbNTMsIDIzXSxcbiAgYyxcbiAgWzQzLCAyNl0sXG4gIGMsXG4gIFsxMDMsIDE4XSxcbiAgYyxcbiAgWzEyMCwgNDddLFxuICBjLFxuICBbODMsIDE1XSxcbiAgYyxcbiAgWzIxMCwgOF0sXG4gIGMsXG4gIFsyNTcsIDQ2XSxcbiAgYyxcbiAgWzQzLCA0Ml0sXG4gIGMsXG4gIFsyNSwgMjNdLFxuICBjLFxuICBbODksIDI3XSxcbiAgYyxcbiAgWzI1NCwgMjVdLFxuICBjLFxuICBbNjAwLCAzMV0sXG4gIGMsXG4gIFsxMjIsIDIxXSxcbiAgYyxcbiAgWzUyLCAyNl0sXG4gIGMsXG4gIFszODgsIDU5XSxcbiAgYyxcbiAgWzQzLCA0MF0sXG4gIGMsXG4gIFs3NiwgMzddLFxuICBjLFxuICBbMjI1LCA0Ml0sXG4gIGMsXG4gIFs1NSwgNTNdLFxuICBjLFxuICBbNzQzLCA0XSxcbiAgYyxcbiAgWzIzNSwgNjBdLFxuICBjLFxuICBbMTI4LCAzNl0sXG4gIGMsXG4gIFsxMDAwLCA1NV0sXG4gIHMsXG4gIFsyLCAxMDZdLFxuICBjLFxuICBbMjIwLCAyNF0sXG4gIHMsXG4gIFswLCAyOV0sXG4gIGMsXG4gIFszMiwgOF0sXG4gIGMsXG4gIFs1NTYsIDYwXSxcbiAgYyxcbiAgWzc4MiwgMjNdLFxuICBjLFxuICBbOTA1LCAxMV0sXG4gIGMsXG4gIFsxNDAwLCAyMV0sXG4gIGMsXG4gIFs4MDQsIDQ3XSxcbiAgYyxcbiAgWzg0NSwgNDhdLFxuICBjLFxuICBbNjIsIDc2XSxcbiAgYyxcbiAgWzY0MiwgMTddLFxuICBjLFxuICBbMjE1LCAxNF0sXG4gIGMsXG4gIFsxMTE4LCAxNV0sXG4gIGMsXG4gIFs4MzIsIDg1XSxcbiAgYyxcbiAgWzcxOCwgNDFdLFxuICBjLFxuICBbMTUsIDI5XSxcbiAgYyxcbiAgWzc2MiwgMjBdLFxuICBjLFxuICBbNzksIDE4XSxcbiAgYyxcbiAgWzU3OSwgNDldLFxuICBjLFxuICBbMzYsIDE3XSxcbiAgYyxcbiAgWzE0NzQsIDE5XSxcbiAgYyxcbiAgWzI2LCAxMF0sXG4gIGMsXG4gIFsyOCwgMzJdLFxuICBjLFxuICBbMTkxMiwgOF0sXG4gIGMsXG4gIFsxNiwgN10sXG4gIGMsXG4gIFs2NjQsIDQ2XSxcbiAgYyxcbiAgWzQ1LCAyNl0sXG4gIGMsXG4gIFsxOTc5LCAxMF0sXG4gIGMsXG4gIFs4NCwgMTBdLFxuICBjLFxuICBbNTQ5LCA4MV0sXG4gIGMsXG4gIFsxNzk4LCAzNF0sXG4gIGMsXG4gIFsxMTg1LCA2NV0sXG4gIGMsXG4gIFsxNDUxLCA1MF0sXG4gIGMsXG4gIFs4MiwgMjNdLFxuICBjLFxuICBbMTI4LCAzNF0sXG4gIGMsXG4gIFs3MzUsIDhdLFxuICBjLFxuICBbMTQxMiwgMzFdLFxuICBjLFxuICBbNzMsIDMwXSxcbiAgYyxcbiAgWzMsIDZdLFxuICBjLFxuICBbNTAsIDQ1XSxcbiAgYyxcbiAgWzE0ODUsIDYxXSxcbiAgYyxcbiAgWzU0MywgMzBdLFxuICBjLFxuICBbNTA1LCAyOF0sXG4gIGMsXG4gIFs0NDMsIDY0XSxcbiAgYyxcbiAgWzgyMiwgNDRdLFxuICBjLFxuICBbNzc3LCAxMl0sXG4gIGMsXG4gIFszNTEsIDExXSxcbiAgYyxcbiAgWzI1NywgMTNdLFxuICBjLFxuICBbMTMsIDEyXSxcbiAgYyxcbiAgWzMzMiwgOV0sXG4gIGMsXG4gIFsxMzUxLCAyNF0sXG4gIGMsXG4gIFs0LCA4XSxcbiAgYyxcbiAgWzIwNTMsIDc4XSxcbiAgYyxcbiAgWzQ4LCA4XSxcbiAgYyxcbiAgWzU3MSwgNTVdLFxuICBjLFxuICBbMTUyNSwgMzBdLFxuICBjLFxuICBbNDM1LCA0NV0sXG4gIGMsXG4gIFs3LCA5XSxcbiAgYyxcbiAgWzIyNjAsIDk5XSxcbiAgYyxcbiAgWzQzLCA4MV0sXG4gIGMsXG4gIFszNTYsIDMzXSxcbiAgYyxcbiAgWzE5NzUsIDMzXSxcbiAgYyxcbiAgWzExNSwgNjNdLFxuICBjLFxuICBbNTE1LCA2MV0sXG4gIGMsXG4gIFs0NSwgMzZdLFxuICBjLFxuICBbMTMxMywgNDNdLFxuICBjLFxuICBbMTExLCAyNV0sXG4gIGMsXG4gIFs5MTcsIDM4XSxcbiAgYyxcbiAgWzI5OTEsIDQzXSxcbiAgYyxcbiAgWzg4LCA1Ml0sXG4gIGMsXG4gIFsyOTc1LCAzMl0sXG4gIGMsXG4gIFsyMzIsIDM4XVxuXSksXG4gIHN0YXRlOiB1KFtcbiAgMSxcbiAgMixcbiAgNSxcbiAgNCxcbiAgMyxcbiAgNixcbiAgMTAsXG4gIDExLFxuICAxMixcbiAgOCxcbiAgMTMsXG4gIDE0LFxuICAxOSxcbiAgMTcsXG4gIDE2LFxuICBjLFxuICBbMTAsIDddLFxuICAyMCxcbiAgMjIsXG4gIGMsXG4gIFs4LCA2XSxcbiAgMjgsXG4gIDMwLFxuICAyOSxcbiAgMzEsXG4gIDMzLFxuICAzNyxcbiAgMzYsXG4gIDM1LFxuICA0MSxcbiAgNDQsXG4gIDQ1LFxuICA0MCxcbiAgNDIsXG4gIDQzLFxuICA0OCxcbiAgYyxcbiAgWzIyLCA3XSxcbiAgNTMsXG4gIDUyLFxuICA1NCxcbiAgNTUsXG4gIDU2LFxuICA2MyxcbiAgNjAsXG4gIDYyLFxuICAzNyxcbiAgMzYsXG4gIDYxLFxuICAzNSxcbiAgNjQsXG4gIDY3LFxuICA2OCxcbiAgNjksXG4gIDY3LFxuICA2OCxcbiAgNzYsXG4gIDc1LFxuICA4MCxcbiAgNzksXG4gIDgyLFxuICA4MSxcbiAgODMsXG4gIDg3LFxuICA4OSxcbiAgYyxcbiAgWzQ0LCAzXSxcbiAgOTAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgOTUsXG4gIDY4LFxuICA5NyxcbiAgOTgsXG4gIDEwMCxcbiAgMTMsXG4gIDE0LFxuICAxMDEsXG4gIDEwMixcbiAgMTA4LFxuICAxMDksXG4gIDEwMyxcbiAgMTA0LFxuICA0MixcbiAgNDMsXG4gIDk5LFxuICA5NixcbiAgMTA2LFxuICA5NSxcbiAgNjgsXG4gIDExOCxcbiAgYyxcbiAgWzE4LCAxM10sXG4gIDExNyxcbiAgMTA2LFxuICAxMjQsXG4gIDEyNSxcbiAgMTI3LFxuICAxMjYsXG4gIDEyOCxcbiAgMTMwLFxuICAxMzEsXG4gIDEzNCxcbiAgMTQwLFxuICBjLFxuICBbMjQsIDEzXSxcbiAgMTA2LFxuICAxNDEsXG4gIGMsXG4gIFsxNCwgMTNdLFxuICAxNDIsXG4gIDE0NCxcbiAgMTQ2LFxuICAxNDUsXG4gIDQ0LFxuICA0NSxcbiAgMTQ3LFxuICAxNTAsXG4gIDE1NCxcbiAgMTUzLFxuICAzNyxcbiAgMzYsXG4gIDE1MixcbiAgMzUsXG4gIDE1NixcbiAgYyxcbiAgWzQzLCAxM10sXG4gIDE1NSxcbiAgMTA2LFxuICAxNTgsXG4gIGMsXG4gIFs0NCwgMTNdLFxuICBzLFxuICBbMTU5LCA1LCAxXSxcbiAgcyxcbiAgWzE3NiwgNCwgMV0sXG4gIDE3MyxcbiAgMTY0LFxuICAxNjUsXG4gIDE4MCxcbiAgMTg2LFxuICAxODUsXG4gIDE4NyxcbiAgMTkyLFxuICAxOTMsXG4gIDE3MixcbiAgMTcxLFxuICAxODEsXG4gIDE4NCxcbiAgNDUsXG4gIDE3MCxcbiAgMTgyLFxuICA0MyxcbiAgMTY5LFxuICAxODksXG4gIDIwMSxcbiAgMjAyLFxuICBzLFxuICBbMjA0LCA1LCAxXSxcbiAgMTkyLFxuICAxOTMsXG4gIDIwMyxcbiAgMTg5LFxuICAyMTAsXG4gIGMsXG4gIFs2OSwgMTNdLFxuICAyMDksXG4gIGMsXG4gIFs2OSwgMTVdLFxuICAyMTIsXG4gIGMsXG4gIFsxMTEsIDNdLFxuICAyMTksXG4gIGMsXG4gIFs0LCAzXSxcbiAgMjIwLFxuICAyMjUsXG4gIGMsXG4gIFsxNTEsIDE0XSxcbiAgMjI2LFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMjI5LFxuICBjLFxuICBbMjksIDE0XSxcbiAgMjMwLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgMTQ0LFxuICAxNDYsXG4gIDE0NyxcbiAgMjMxLFxuICBjLFxuICBbMzIsIDE0XSxcbiAgMjMyLFxuICBjLFxuICBbMTQsIDEzXSxcbiAgYyxcbiAgWzExMywgMTRdLFxuICAyMzksXG4gIDIzOCxcbiAgYyxcbiAgWzE2LCAxNF0sXG4gIDI0NSxcbiAgNDIsXG4gIDQzLFxuICAyNDcsXG4gIDI0OCxcbiAgMjUwLFxuICAyNTEsXG4gIDI2NixcbiAgYyxcbiAgWzIwNSwgMjddLFxuICAyNjcsXG4gIGMsXG4gIFsyOCwgMjddLFxuICAyNjgsXG4gIGMsXG4gIFsyNCwgNF0sXG4gIDI3MCxcbiAgYyxcbiAgWzIyLCA2XSxcbiAgMjcxLFxuICAyNzMsXG4gIGMsXG4gIFsyMiwgM10sXG4gIDI3MixcbiAgYyxcbiAgWzIyLCA0XSxcbiAgMjc2LFxuICAyNzUsXG4gIDI4MyxcbiAgMjgyLFxuICAyODcsXG4gIDI4NixcbiAgMjg4LFxuICAxNDYsXG4gIDE0NyxcbiAgMjg5LFxuICBjLFxuICBbNTksIDI3XSxcbiAgMjkxLFxuICAyOTMsXG4gIDI5OSxcbiAgMzAxLFxuICAyOTgsXG4gIDQ0LFxuICA0NSxcbiAgMzAwLFxuICA0MixcbiAgNDMsXG4gIDMwNSxcbiAgMzA2LFxuICBjLFxuICBbMzksIDI3XSxcbiAgMzA4LFxuICAzMDksXG4gIDMxMixcbiAgMzExLFxuICAzMTAsXG4gIDMxMyxcbiAgMTQ3LFxuICAzMTQsXG4gIGMsXG4gIFszNSwgMjddLFxuICBjLFxuICBbMjEwLCAxNF0sXG4gIDMxNyxcbiAgNDQsXG4gIDQ1LFxuICAzMTksXG4gIDEyNyxcbiAgMTI2LFxuICAzMjAsXG4gIGMsXG4gIFszNDEsIDNdLFxuICAzMjEsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMzI1LFxuICBjLFxuICBbMjgzLCAxNF0sXG4gIDMyNixcbiAgYyxcbiAgWzE0LCAxM10sXG4gIDMyNyxcbiAgYyxcbiAgWzI5LCAxNF0sXG4gIDMyOCxcbiAgYyxcbiAgWzMxMiwgMjddLFxuICAzMzEsXG4gIGMsXG4gIFs0MywgMTRdLFxuICAzMzIsXG4gIGMsXG4gIFs0MywgMjddLFxuICBjLFxuICBbMTQsIDE0XSxcbiAgMzM4LFxuICAxNDcsXG4gIGMsXG4gIFs2MzQsIDRdLFxuICAzNDEsXG4gIGMsXG4gIFsxMzksIDNdLFxuICAzNDIsXG4gIDQyLFxuICA0MyxcbiAgMzQ1LFxuICAzNDYsXG4gIGMsXG4gIFsxOTksIDI3XSxcbiAgMzQ3LFxuICBjLFxuICBbMzMyLCAyMV0sXG4gIDM1MSxcbiAgYyxcbiAgWzUwLCAyN10sXG4gIDI4NyxcbiAgMjg2LFxuICAyODMsXG4gIDI4MixcbiAgMjc2LFxuICAyNzUsXG4gIDM1NyxcbiAgMzU0LFxuICAzNjEsXG4gIDM1OSxcbiAgMzUzLFxuICAzNjQsXG4gIDM2MyxcbiAgMzU4LFxuICAzNjAsXG4gIDM2MixcbiAgMTQ1LFxuICAxODQsXG4gIDQ1LFxuICAzNjUsXG4gIDE4MixcbiAgNDMsXG4gIDM1NSxcbiAgMzY2LFxuICAzNjgsXG4gIGMsXG4gIFszMzcsIDI4XSxcbiAgMzYxLFxuICAzNTksXG4gIDM2OSxcbiAgYyxcbiAgWzQ1LCA1XSxcbiAgMzcwLFxuICBjLFxuICBbNDMsIDRdLFxuICAzNzIsXG4gIGMsXG4gIFs2MSwgNF0sXG4gIDM3MyxcbiAgYyxcbiAgWzYxLCAxMl0sXG4gIDM3NCxcbiAgMzc1LFxuICBjLFxuICBbMTksIDRdLFxuICAzNzYsXG4gIGMsXG4gIFsxOSwgMTJdLFxuICAzNzcsXG4gIDM3OCxcbiAgcyxcbiAgWzM4MCwgNywgMV0sXG4gIDM4OCxcbiAgMzg3LFxuICAzODksXG4gIGMsXG4gIFs4OSwgMjddLFxuICAyOTMsXG4gIDM5OCxcbiAgYyxcbiAgWzc1NywgOV0sXG4gIDM5OSxcbiAgNDQsXG4gIDQ1LFxuICA0MDIsXG4gIDQwMSxcbiAgNDA0LFxuICA0MDMsXG4gIDQwNSxcbiAgYyxcbiAgWzMwOSwgMTRdLFxuICA0MDYsXG4gIGMsXG4gIFszMDksIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDQxOSxcbiAgYyxcbiAgWzExNywgMjddLFxuICA0MjQsXG4gIDQyMyxcbiAgNDIwLFxuICAyNTEsXG4gIDQyNSxcbiAgYyxcbiAgWzMyLCAyN10sXG4gIDM1NyxcbiAgMzU0LFxuICBjLFxuICBbMzc4LCAzXSxcbiAgNDMwLFxuICBjLFxuICBbMzI0LCAzM10sXG4gIDQzNSxcbiAgYyxcbiAgWzM0LCAyN10sXG4gIDQzNyxcbiAgNDM4LFxuICA0NDEsXG4gIGMsXG4gIFszMCwgMjddLFxuICA0NDIsXG4gIGMsXG4gIFs2NzEsIDNdLFxuICA0NDMsXG4gIGMsXG4gIFszMiwgMjddLFxuICA0NDQsXG4gIGMsXG4gIFsyOCwgMjddLFxuICA0NDUsXG4gIDE0NyxcbiAgNDQ2LFxuICBjLFxuICBbMjkwLCAxNF0sXG4gIGMsXG4gIFsyNDgsIDE0XSxcbiAgNDU5LFxuICBjLFxuICBbNTI5LCAyMV0sXG4gIDM1NyxcbiAgNDYxLFxuICBjLFxuICBbODIsIDZdLFxuICAzNTQsXG4gIGMsXG4gIFs4MywgMTNdLFxuICA0NjIsXG4gIGMsXG4gIFs4MywgN10sXG4gIDQ2MyxcbiAgNDY0LFxuICA0MjQsXG4gIDQyMyxcbiAgNDY2LFxuICBjLFxuICBbMjQzLCAzXSxcbiAgNDY3LFxuICBjLFxuICBbNCwgM10sXG4gIDQ2OSxcbiAgYyxcbiAgWzQsIDNdLFxuICA0NzAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgNDcxLFxuICBjLFxuICBbNCwgM10sXG4gIDQ3MixcbiAgYyxcbiAgWzkxLCA4XSxcbiAgNDc4LFxuICBjLFxuICBbOTIsIDZdLFxuICA0ODAsXG4gIDEzLFxuICAxNCxcbiAgNDgxLFxuICAxMyxcbiAgMTQsXG4gIDQyNCxcbiAgNDIzLFxuICA0ODYsXG4gIGMsXG4gIFsxNTksIDI3XSxcbiAgMjM5LFxuICAyOTEsXG4gIDIzOCxcbiAgNDg4LFxuICBjLFxuICBbMzc5LCAyOV0sXG4gIDQ5OCxcbiAgYyxcbiAgWzE5MCwgMTRdLFxuICA0OTksXG4gIGMsXG4gIFs0NSwgMjddLFxuICA1MDAsXG4gIDE0NyxcbiAgNTAzLFxuICA1MDIsXG4gIDUwOCxcbiAgYyxcbiAgWzEzNiwgM10sXG4gIDUwOSxcbiAgYyxcbiAgWzM2LCAyN10sXG4gIDUxMCxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUxMSxcbiAgYyxcbiAgWzI4LCAyN10sXG4gIDUxMixcbiAgYyxcbiAgWzEwNTIsIDQxXSxcbiAgNDI0LFxuICA0MjMsXG4gIDUyOCxcbiAgYyxcbiAgWzE3OSwgMTRdLFxuICA1MjksXG4gIGMsXG4gIFs1OSwgMjddLFxuICA1MzAsXG4gIGMsXG4gIFs0MywgMTRdLFxuICA1MzEsXG4gIGMsXG4gIFs0MywgMjddLFxuICA1MzQsXG4gIGMsXG4gIFsxMzAsIDQxXSxcbiAgYyxcbiAgWzE0LCAxNF0sXG4gIDU0MixcbiAgYyxcbiAgWzk5LCAxNF0sXG4gIDU0NSxcbiAgYyxcbiAgWzE1LCAxNF0sXG4gIDU0NyxcbiAgYyxcbiAgWzU0MSwgMjhdLFxuICBjLFxuICBbMTQsIDIyXSxcbiAgNTUzLFxuICBjLFxuICBbMTUsIDZdLFxuICA1NTUsXG4gIGMsXG4gIFs1OCwgMjhdLFxuICA1NjMsXG4gIGMsXG4gIFsyOSwgMjhdXG5dKSxcbiAgbW9kZTogdShbXG4gIHMsXG4gIFsxLCAyNl0sXG4gIDIsXG4gIDIsXG4gIGMsXG4gIFsxNywgMTddLFxuICBzLFxuICBbMiwgOF0sXG4gIGMsXG4gIFsxMSwgMTFdLFxuICBzLFxuICBbMiwgMThdLFxuICBjLFxuICBbMjksIDE5XSxcbiAgMSxcbiAgYyxcbiAgWzc1LCAzXSxcbiAgYyxcbiAgWzc4LCAxM10sXG4gIGMsXG4gIFs5MiwgOF0sXG4gIGMsXG4gIFs3LCA4XSxcbiAgYyxcbiAgWzE2LCA3XSxcbiAgYyxcbiAgWzExNCwgMTZdLFxuICBjLFxuICBbMTUyLCAyNF0sXG4gIGMsXG4gIFs0NywgNl0sXG4gIGMsXG4gIFs0NiwgOF0sXG4gIGMsXG4gIFs1NCwgMjBdLFxuICBjLFxuICBbMTM1LCAxMF0sXG4gIGMsXG4gIFsyMywgMTRdLFxuICBjLFxuICBbNTEsIDE2XSxcbiAgYyxcbiAgWzc3LCA5XSxcbiAgcyxcbiAgWzEsIDU1XSxcbiAgYyxcbiAgWzEwNCwgOV0sXG4gIGMsXG4gIFs3LCA2XSxcbiAgYyxcbiAgWzYsIDEzXSxcbiAgYyxcbiAgWzEwNCwgMTRdLFxuICBjLFxuICBbMjYxLCAxMF0sXG4gIGMsXG4gIFsxNTEsIDE4XSxcbiAgYyxcbiAgWzI0NiwgNDFdLFxuICBjLFxuICBbMzcyLCAyOV0sXG4gIGMsXG4gIFszNzcsIDIxXSxcbiAgYyxcbiAgWzI3LCA1MF0sXG4gIGMsXG4gIFsxMjIsIDE4XSxcbiAgYyxcbiAgWzQ3MiwgMjddLFxuICBzLFxuICBbMiwgMzFdLFxuICBjLFxuICBbMzMsIDMzXSxcbiAgYyxcbiAgWzM2LCAyMV0sXG4gIGMsXG4gIFsyMzEsIDMwXSxcbiAgYyxcbiAgWzI1LCA2Ml0sXG4gIGMsXG4gIFszNzAsIDQ0XSxcbiAgYyxcbiAgWzQ1LCA0XSxcbiAgYyxcbiAgWzU0MSwgNjBdLFxuICBjLFxuICBbNTYwLCAyNl0sXG4gIGMsXG4gIFs2MiwgNTldLFxuICBjLFxuICBbNzMxLCAxMl0sXG4gIGMsXG4gIFsxMywgMTddLFxuICBjLFxuICBbMjQ5LCAxNl0sXG4gIHMsXG4gIFsxLCA5Nl0sXG4gIGMsXG4gIFs3MjUsIDVdLFxuICBjLFxuICBbMjcwLCA2Ml0sXG4gIGMsXG4gIFszNTUsIDVdLFxuICBjLFxuICBbMTAyMywgN10sXG4gIGMsXG4gIFsxNzksIDQ4XSxcbiAgYyxcbiAgWzQxNywgOF0sXG4gIGMsXG4gIFsxMzUsIDYzXSxcbiAgYyxcbiAgWzQ4MywgODJdLFxuICBjLFxuICBbNDA4LCA5XSxcbiAgYyxcbiAgWzQ0LCA2MF0sXG4gIGMsXG4gIFs0NjcsIDE2XSxcbiAgYyxcbiAgWzc5LCAyM10sXG4gIGMsXG4gIFsyNTEsIDMzXSxcbiAgYyxcbiAgWzcwNywgODNdLFxuICBjLFxuICBbMjI0LCA0MF0sXG4gIHMsXG4gIFsxLCAxNDNdXG5dKSxcbiAgZ290bzogdShbXG4gIDE1LFxuICA5LFxuICA3LFxuICAxOCxcbiAgYyxcbiAgWzQsIDNdLFxuICAyMSxcbiAgMTUsXG4gIDcsXG4gIHMsXG4gIFsyMywgNSwgMV0sXG4gIDMyLFxuICAzNCxcbiAgMzgsXG4gIDM5LFxuICA0NixcbiAgNDcsXG4gIDQ5LFxuICAxNSxcbiAgNyxcbiAgNTAsXG4gIDUxLFxuICAxOTUsXG4gIDE5NSxcbiAgMzksXG4gIDM0LFxuICAzOSxcbiAgMzgsXG4gIDU3LFxuICA1OCxcbiAgNTksXG4gIDM4LFxuICAzOSxcbiAgNjUsXG4gIDY2LFxuICAzOCxcbiAgNzAsXG4gIDcxLFxuICAzOCxcbiAgcyxcbiAgWzE4NSwgMTBdLFxuICA3MixcbiAgcyxcbiAgWzE4NSwgMThdLFxuICBzLFxuICBbMTgwLCAxMF0sXG4gIDczLFxuICBzLFxuICBbMTgwLCAxOF0sXG4gIDc0LFxuICAxOTcsXG4gIDc3LFxuICA3OCxcbiAgMjAzLFxuICA3NyxcbiAgODYsXG4gIDg1LFxuICA3NyxcbiAgODQsXG4gIDg4LFxuICAzOCxcbiAgMzksXG4gIDM4LFxuICAzOSxcbiAgOTEsXG4gIDkyLFxuICAxODksXG4gIDE4OSxcbiAgNTksXG4gIDkzLFxuICA5NCxcbiAgMzgsXG4gIDE1LFxuICAxMTIsXG4gIDIxNixcbiAgMTA1LFxuICAxMDcsXG4gIDExMCxcbiAgMTExLFxuICAxMTQsXG4gIDExMyxcbiAgcyxcbiAgWzgxLCAzXSxcbiAgMTE1LFxuICAxMTYsXG4gIGMsXG4gIFsxNSwgM10sXG4gIDIyMCxcbiAgYyxcbiAgWzE1LCA0XSxcbiAgcyxcbiAgWzExOSwgNSwgMV0sXG4gIDM4LFxuICAzOSxcbiAgODgsXG4gIDEyOSxcbiAgODYsXG4gIDEzMyxcbiAgMTMyLFxuICAxMzcsXG4gIDEzNixcbiAgMTM1LFxuICAxMzksXG4gIDEzOCxcbiAgMTUsXG4gIDExMixcbiAgYyxcbiAgWzIzLCA0XSxcbiAgYyxcbiAgWzYsIDZdLFxuICAxNDMsXG4gIDE0OCxcbiAgMTQ5LFxuICAxODcsXG4gIDE4NyxcbiAgMTUxLFxuICAxODcsXG4gIDE4NyxcbiAgMzgsXG4gIDM5LFxuICAxNSxcbiAgMTEyLFxuICAyMTQsXG4gIGMsXG4gIFsxNywgNF0sXG4gIDE1NyxcbiAgMTUsXG4gIDExMixcbiAgMjE3LFxuICBjLFxuICBbOCwgNF0sXG4gIDE5MSxcbiAgMTY2LFxuICAxOTAsXG4gIDE4OCxcbiAgMTY4LFxuICAxODMsXG4gIDE2NyxcbiAgMTc0LFxuICAxNzUsXG4gIDg4LFxuICAxOTQsXG4gIDE5NSxcbiAgMTk2LFxuICA0NixcbiAgNDcsXG4gIDE4NSxcbiAgMTg1LFxuICAxOTcsXG4gIHMsXG4gIFsxODUsIDddLFxuICAxOTgsXG4gIDE5OSxcbiAgMjAwLFxuICAzOCxcbiAgMTkxLFxuICAxOTAsXG4gIDEwNSxcbiAgYyxcbiAgWzIzLCA0XSxcbiAgMTUsXG4gIDExMixcbiAgMjE4LFxuICBjLFxuICBbNDMsIDRdLFxuICAyMTEsXG4gIDE1LFxuICAxMTIsXG4gIDIyMSxcbiAgYyxcbiAgWzgsIDRdLFxuICAyMTMsXG4gIDE0OSxcbiAgMjE1LFxuICAyMTQsXG4gIDUwLFxuICA1MCxcbiAgMjE2LFxuICA1MixcbiAgNTIsXG4gIDIxNyxcbiAgMjE4LFxuICAyMTMsXG4gIDE0OSxcbiAgMTM3LFxuICAyMjIsXG4gIDIyMSxcbiAgMjI0LFxuICAyMjMsXG4gIGMsXG4gIFsxMDYsIDEyXSxcbiAgMjI4LFxuICAyMjcsXG4gIGMsXG4gIFsxMjAsIDEzXSxcbiAgYyxcbiAgWzE1OCwgM10sXG4gIGMsXG4gIFsxNCwgMTBdLFxuICAxNSxcbiAgMjMzLFxuICBjLFxuICBbNiwgNF0sXG4gIDIzNCxcbiAgMjM1LFxuICAyMzcsXG4gIDIzNixcbiAgMjA3LFxuICAyMDcsXG4gIDI0MCxcbiAgcyxcbiAgWzIwNywgNF0sXG4gIDYyLFxuICA2MixcbiAgMjQxLFxuICA2MixcbiAgNjIsXG4gIHMsXG4gIFsxODUsIDNdLFxuICAyNDIsXG4gIHMsXG4gIFsxODAsIDVdLFxuICAyNDMsXG4gIHMsXG4gIFsxODAsIDNdLFxuICAxOTEsXG4gIDE5MSxcbiAgNTksXG4gIDI0NCxcbiAgMTUsXG4gIDExMixcbiAgMjE1LFxuICBjLFxuICBbNDAsIDRdLFxuICAxMTAsXG4gIDExMSxcbiAgMjQ5LFxuICAyNDYsXG4gIHMsXG4gIFsxMDYsIDNdLFxuICAyNjEsXG4gIDEwNixcbiAgMjU0LFxuICAyNTIsXG4gIDEwNixcbiAgMjU4LFxuICAyNTksXG4gIDI2MCxcbiAgMjY0LFxuICBzLFxuICBbMTA2LCA1XSxcbiAgMjUzLFxuICAyNTUsXG4gIDI1NixcbiAgMjU3LFxuICAyNjIsXG4gIDI2MyxcbiAgMjY1LFxuICBjLFxuICBbMTgzLCAxNV0sXG4gIGMsXG4gIFsxNSwgMTZdLFxuICAyNjksXG4gIDE5MCxcbiAgMTg4LFxuICAxODMsXG4gIGMsXG4gIFsxMSwgNl0sXG4gIDIzNCxcbiAgMjM0LFxuICAyNzcsXG4gIDIzNCxcbiAgMjM0LFxuICAyNzQsXG4gIHMsXG4gIFsyMzQsIDIwXSxcbiAgcyxcbiAgWzIzNSwgNF0sXG4gIDI3OCxcbiAgcyxcbiAgWzIzNSwgNF0sXG4gIDI3OSxcbiAgcyxcbiAgWzIzNSwgMTZdLFxuICAyMzIsXG4gIDIzMixcbiAgMjc3LFxuICAyMzIsXG4gIDIzMixcbiAgMjgwLFxuICBzLFxuICBbMjMyLCA0XSxcbiAgMjgxLFxuICBzLFxuICBbMjMyLCAxNl0sXG4gIDIzMCxcbiAgMjMwLFxuICAyNzcsXG4gIDIzMCxcbiAgMjMwLFxuICAyODQsXG4gIHMsXG4gIFsyMzAsIDRdLFxuICAyODUsXG4gIHMsXG4gIFsyMzAsIDE2XSxcbiAgMzgsXG4gIGMsXG4gIFsxMzMsIDE1XSxcbiAgcyxcbiAgWzIyOSwgOF0sXG4gIDI5MCxcbiAgcyxcbiAgWzIyOSwgMTZdLFxuICAyMzMsXG4gIDIzMyxcbiAgMjc3LFxuICBzLFxuICBbMjMzLCAyMl0sXG4gIHMsXG4gIFsxODEsIDEwXSxcbiAgMjkyLFxuICBzLFxuICBbMTgxLCAxNl0sXG4gIHMsXG4gIFsxNzUsIDE5XSxcbiAgMzgsXG4gIHMsXG4gIFsxNzUsIDddLFxuICBzLFxuICBbMTc2LCAxMF0sXG4gIDI5NCxcbiAgcyxcbiAgWzE3NiwgMTZdLFxuICBzLFxuICBbMjQxLCA4XSxcbiAgMjk1LFxuICBzLFxuICBbMjQxLCAxNl0sXG4gIHMsXG4gIFsyNDAsIDhdLFxuICAyOTYsXG4gIHMsXG4gIFsyNDAsIDE2XSxcbiAgcyxcbiAgWzI0MiwgOF0sXG4gIDI5NyxcbiAgcyxcbiAgWzI0MiwgMTZdLFxuICAzMDIsXG4gIDMwMyxcbiAgYyxcbiAgWzM1OCwgNV0sXG4gIDMwNCxcbiAgYyxcbiAgWzIyNiwgMTJdLFxuICAzMDcsXG4gIDg4LFxuICAzOCxcbiAgMTE5LFxuICAxMjEsXG4gIGMsXG4gIFsyNDcsIDE2XSxcbiAgMzE1LFxuICBzLFxuICBbODAsIDNdLFxuICAzMTYsXG4gIDE1LFxuICAxMTIsXG4gIDIxOSxcbiAgYyxcbiAgWzU1NCwgNl0sXG4gIDMxOCxcbiAgMjQyLFxuICAzOCxcbiAgMzksXG4gIDIxMyxcbiAgMTQ5LFxuICAyMTMsXG4gIDE0OSxcbiAgMzIyLFxuICAzMjQsXG4gIDMyMyxcbiAgYyxcbiAgWzUyMSwgMTNdLFxuICBjLFxuICBbNiwgMTJdLFxuICAzMjksXG4gIGMsXG4gIFs2LCA0XSxcbiAgMzMwLFxuICBjLFxuICBbMTksIDEzXSxcbiAgMzMzLFxuICBjLFxuICBbNiwgNF0sXG4gIDMzNCxcbiAgMTUsXG4gIDMzNSxcbiAgYyxcbiAgWzcsIDRdLFxuICAzMzYsXG4gIDMzNyxcbiAgYyxcbiAgWzY1MCwgM10sXG4gIDIwOCxcbiAgMjA4LFxuICAzMzksXG4gIHMsXG4gIFsyMDgsIDRdLFxuICAzNDAsXG4gIGMsXG4gIFs3OCwgNF0sXG4gIDEyMCxcbiAgMTIyLFxuICAxMTAsXG4gIDExMSxcbiAgMzQzLFxuICAyNDksXG4gIDM0NCxcbiAgYyxcbiAgWzUwMCwgMTZdLFxuICAzNDgsXG4gIGMsXG4gIFs1MDAsIDldLFxuICAzNDksXG4gIDM1MCxcbiAgYyxcbiAgWzI4LCAxNV0sXG4gIGMsXG4gIFs0MzgsIDRdLFxuICAzNTIsXG4gIGMsXG4gIFs0MzUsIDhdLFxuICBjLFxuICBbNDc4LCA0XSxcbiAgMzUyLFxuICBjLFxuICBbNDc1LCA4XSxcbiAgYyxcbiAgWzU0MywgNF0sXG4gIDM1MixcbiAgYyxcbiAgWzUyOSwgMTFdLFxuICBjLFxuICBbNTI1LCA3XSxcbiAgMTkxLFxuICAzNTYsXG4gIDE5MCxcbiAgMTgzLFxuICA4OCxcbiAgNDYsXG4gIDQ3LFxuICAyNzcsXG4gIDE5MSxcbiAgMTY2LFxuICAzNjcsXG4gIGMsXG4gIFsxMDEsIDE0XSxcbiAgYyxcbiAgWzI0LCA1XSxcbiAgMzcxLFxuICAzOCxcbiAgYyxcbiAgWzMyLCA3XSxcbiAgMzgsXG4gIDI3NyxcbiAgYyxcbiAgWzksIDldLFxuICAyMzcsXG4gIDM3OSxcbiAgcyxcbiAgWzM4LCA2XSxcbiAgMjc3LFxuICAyNzcsXG4gIDM1MixcbiAgYyxcbiAgWzEyNSwgMTVdLFxuICAzOCxcbiAgMzkxLFxuICAzOTAsXG4gIDM5MixcbiAgMzkzLFxuICAzOTQsXG4gIDM5NixcbiAgMzk1LFxuICAzOTcsXG4gIGMsXG4gIFs4NDYsIDddLFxuICAyMTMsXG4gIDE0OSxcbiAgNDAwLFxuICAxMzcsXG4gIDE5OSxcbiAgMTM3LFxuICAyMDUsXG4gIGMsXG4gIFsyNDAsIDEzXSxcbiAgNDA3LFxuICBjLFxuICBbNiwgNF0sXG4gIDQwOCxcbiAgMTUsXG4gIDQwOSxcbiAgYyxcbiAgWzcsIDRdLFxuICA0MTAsXG4gIDQxMSxcbiAgMTk5LFxuICAyMDAsXG4gIDE1LFxuICA0MTIsXG4gIGMsXG4gIFsxMCwgNF0sXG4gIDQxMyxcbiAgNDE0LFxuICAxOTksXG4gIDIwMCxcbiAgNDE1LFxuICAxOTksXG4gIDIwMCxcbiAgNDE2LFxuICA0MTcsXG4gIDQxOCxcbiAgYyxcbiAgWzgzLCAxNV0sXG4gIDEwOSxcbiAgMTA5LFxuICAyNzcsXG4gIDEwOSxcbiAgMjYxLFxuICA0MjEsXG4gIDEwOSxcbiAgMjU0LFxuICAyNTIsXG4gIDEwOSxcbiAgNDIyLFxuICBjLFxuICBbNzkzLCA0XSxcbiAgcyxcbiAgWzEwOSwgNV0sXG4gIGMsXG4gIFs3OTMsIDIyXSxcbiAgNDI2LFxuICAyMTMsXG4gIDE0OSxcbiAgNDI3LFxuICA0MjksXG4gIDQyOCxcbiAgYyxcbiAgWzIxLCAxNV0sXG4gIDI5NyxcbiAgMjM2LFxuICAyNzcsXG4gIDM1MixcbiAgMjg1LFxuICAyMzcsXG4gIDI3NyxcbiAgMzUyLFxuICAyODEsXG4gIDIzOCxcbiAgMjkwLFxuICAyMzksXG4gIDI3OSxcbiAgMjk1LFxuICAyOTYsXG4gIDI3NyxcbiAgMzUyLFxuICAzOTEsXG4gIDQzMSxcbiAgNDMyLFxuICAyOTQsXG4gIDczLFxuICA0MzMsXG4gIDQzNCxcbiAgYyxcbiAgWzM5LCAxNV0sXG4gIDQzNixcbiAgMjc3LFxuICAyNzcsXG4gIDQzOSxcbiAgNDQwLFxuICBjLFxuICBbMjAsIDE1XSxcbiAgODgsXG4gIGMsXG4gIFs0OTUsIDE2XSxcbiAgYyxcbiAgWzIzNywgMTZdLFxuICBjLFxuICBbMjA5LCA2XSxcbiAgNDQ3LFxuICA0NDgsXG4gIDQ0OSxcbiAgMTUsXG4gIDQ1MCxcbiAgYyxcbiAgWzksIDRdLFxuICA0NTEsXG4gIDQ1MixcbiAgMTk5LFxuICAyMDAsXG4gIDQ1MyxcbiAgMTk5LFxuICAyMDAsXG4gIDQ1NCxcbiAgNDU1LFxuICAxOTksXG4gIDIwMCxcbiAgNDU2LFxuICA0NTcsXG4gIDQ1OCxcbiAgMTkxLFxuICA0NjAsXG4gIGMsXG4gIFs0MjAsIDldLFxuICBjLFxuICBbNTYsIDE2XSxcbiAgMjc3LFxuICA0NjUsXG4gIDExNixcbiAgMTE2LFxuICAyNzcsXG4gIDExNixcbiAgMzUyLFxuICAxMTYsXG4gIDExNixcbiAgNDIyLFxuICBzLFxuICBbMTE2LCA1XSxcbiAgYyxcbiAgWzU2NCwgNF0sXG4gIDQ2OCxcbiAgYyxcbiAgWzUsIDRdLFxuICAyMTMsXG4gIDE0OSxcbiAgMjc3LFxuICA0NzMsXG4gIDQ3NCxcbiAgNDc1LFxuICA0NzcsXG4gIDQ3NixcbiAgMTUsXG4gIDQ3OSxcbiAgYyxcbiAgWzI5NywgNV0sXG4gIDE1LFxuICA0ODIsXG4gIDE5OSxcbiAgMjAwLFxuICA0ODMsXG4gIDQ4NCxcbiAgNDg1LFxuICAxMTIsXG4gIDExMixcbiAgMjc3LFxuICAxMTIsXG4gIDM1MixcbiAgMTEyLFxuICAxMTIsXG4gIDQyMixcbiAgcyxcbiAgWzExMiwgNV0sXG4gIGMsXG4gIFs3NSwgMTVdLFxuICA0ODcsXG4gIDIwNyxcbiAgMjc3LFxuICAyMzMsXG4gIDI0MCxcbiAgMjA3LFxuICBzLFxuICBbMjMzLCAxNF0sXG4gIGMsXG4gIFszNSwgMTVdLFxuICA0ODksXG4gIDQ5MCxcbiAgMjc3LFxuICAzNTIsXG4gIDQyMixcbiAgMTU5LFxuICBzLFxuICBbNDkxLCA3LCAxXSxcbiAgYyxcbiAgWzE3OCwgNl0sXG4gIGMsXG4gIFsxNDQsIDE2XSxcbiAgMTk5LFxuICA1MDEsXG4gIDIwMCxcbiAgMjAxLFxuICBzLFxuICBbNTA0LCA0LCAxXSxcbiAgMjEzLFxuICAxNDksXG4gIGMsXG4gIFsxMTMxLCAzMV0sXG4gIGMsXG4gIFsxNSwgMjldLFxuICAxNSxcbiAgNTEzLFxuICBjLFxuICBbOTIsIDRdLFxuICBzLFxuICBbNTE0LCA2LCAxXSxcbiAgMTE0LFxuICAxMTQsXG4gIDI3NyxcbiAgMTE0LFxuICAzNTIsXG4gIDExNCxcbiAgMTE0LFxuICA0MjIsXG4gIHMsXG4gIFsxMTQsIDVdLFxuICA1MjEsXG4gIDUyMCxcbiAgcyxcbiAgWzUyMiwgNCwgMV0sXG4gIDE5OSxcbiAgNTI2LFxuICA1MjcsXG4gIDIwMCxcbiAgYyxcbiAgWzEyNywgMjFdLFxuICBjLFxuICBbMjEsIDIxXSxcbiAgNTMyLFxuICA1MzMsXG4gIGMsXG4gIFsxNywgMTVdLFxuICA1MzUsXG4gIDUzNixcbiAgMTUsXG4gIDUzNyxcbiAgYyxcbiAgWzQwLCA0XSxcbiAgNTM4LFxuICAxNSxcbiAgNTM5LFxuICBjLFxuICBbNywgNF0sXG4gIDU0MCxcbiAgNTQxLFxuICBjLFxuICBbNTUsIDZdLFxuICAxOTksXG4gIDU0MyxcbiAgNTQ0LFxuICBjLFxuICBbODYsIDddLFxuICAxOTksXG4gIDIwMCxcbiAgNTQ2LFxuICBjLFxuICBbNjA5LCA3XSxcbiAgNTQ4LFxuICBjLFxuICBbNiwgNF0sXG4gIDU0OSxcbiAgNTUwLFxuICAxNSxcbiAgNTUxLFxuICBjLFxuICBbOCwgNF0sXG4gIDU1MixcbiAgYyxcbiAgWzMzMywgNl0sXG4gIDE5OSxcbiAgNTU0LFxuICBjLFxuICBbMzksIDhdLFxuICA1NTYsXG4gIDU1NyxcbiAgMjAwLFxuICA1NTgsXG4gIDE1LFxuICA1NTksXG4gIGMsXG4gIFsxMSwgNF0sXG4gIDU2MCxcbiAgNTYxLFxuICAxOTksXG4gIDU2MixcbiAgYyxcbiAgWzIyLCA3XSxcbiAgNTY0LFxuICAxNSxcbiAgNTY1LFxuICBjLFxuICBbMjksIDVdLFxuICA1NjYsXG4gIDIwMCxcbiAgNTY3XG5dKVxufSksXG5kZWZhdWx0QWN0aW9uczogYmRhKHtcbiAgaWR4OiB1KFtcbiAgNSxcbiAgNixcbiAgOCxcbiAgcyxcbiAgWzEwLCA1LCAxXSxcbiAgMTgsXG4gIDE5LFxuICAyMSxcbiAgMjIsXG4gIDIzLFxuICAyOSxcbiAgMzAsXG4gIDMxLFxuICBzLFxuICBbMzUsIDUsIDFdLFxuICBzLFxuICBbNDIsIDQsIDFdLFxuICA0OSxcbiAgNTAsXG4gIDUxLFxuICA1MyxcbiAgNjEsXG4gIDYzLFxuICA2NixcbiAgNjcsXG4gIDcxLFxuICA3NCxcbiAgNzYsXG4gIDgwLFxuICBzLFxuICBbODgsIDQsIDFdLFxuICA5NCxcbiAgOTUsXG4gIHMsXG4gIFs5OCwgNywgMV0sXG4gIHMsXG4gIFsxMDYsIDQsIDFdLFxuICAxMTYsXG4gIHMsXG4gIFsxMTksIDQsIDFdLFxuICAxMjUsXG4gIDE0MyxcbiAgMTQ2LFxuICAxNTAsXG4gIDE1MSxcbiAgMTUyLFxuICAxNTQsXG4gIDE1OCxcbiAgMTYwLFxuICAxNjEsXG4gIDE2MixcbiAgMTY0LFxuICAxNjUsXG4gIDE2OSxcbiAgMTc2LFxuICAxNzcsXG4gIDE3OCxcbiAgMTgwLFxuICAxODksXG4gIHMsXG4gIFsxOTIsIDUsIDFdLFxuICBzLFxuICBbMjAyLCA3LCAxXSxcbiAgMjE0LFxuICAyMTgsXG4gIDIzNCxcbiAgMjM1LFxuICAyMzYsXG4gIDIzOCxcbiAgMjQ2LFxuICAyNDgsXG4gIHMsXG4gIFsyNTEsIDE1LCAxXSxcbiAgMjY4LFxuICAyNzYsXG4gIDI4MyxcbiAgcyxcbiAgWzI4NywgNCwgMl0sXG4gIDMwMCxcbiAgMzAxLFxuICAzMDQsXG4gIDMwNixcbiAgMzA3LFxuICAzMDksXG4gIDMxMSxcbiAgMzEyLFxuICAzMTksXG4gIDMyMCxcbiAgMzIxLFxuICAzMzAsXG4gIHMsXG4gIFszMzQsIDQsIDJdLFxuICAzNDEsXG4gIHMsXG4gIFszNDMsIDUsIDFdLFxuICAzNTUsXG4gIDM1NyxcbiAgMzY2LFxuICAzNjcsXG4gIDM3MixcbiAgMzc0LFxuICAzNzUsXG4gIDM3NyxcbiAgMzc4LFxuICBzLFxuICBbMzgwLCA2LCAxXSxcbiAgMzkwLFxuICAzOTIsXG4gIHMsXG4gIFszOTgsIDQsIDJdLFxuICA0MDgsXG4gIDQxMCxcbiAgNDEzLFxuICA0MTYsXG4gIDQxNyxcbiAgNDE4LFxuICA0MjQsXG4gIDQyOCxcbiAgNDMxLFxuICA0MzUsXG4gIDQzNixcbiAgcyxcbiAgWzQzOSwgNSwgMV0sXG4gIDQ0NyxcbiAgNDUxLFxuICA0NTQsXG4gIDQ1NixcbiAgNDU3LFxuICA0NTksXG4gIDQ2MyxcbiAgNDY0LFxuICA0NjcsXG4gIDQ3MyxcbiAgNDc0LFxuICA0NzgsXG4gIDQ4MyxcbiAgNDg0LFxuICA0ODUsXG4gIDQ4OCxcbiAgcyxcbiAgWzQ4OSwgNSwgMl0sXG4gIDUwMixcbiAgNTAzLFxuICA1MDYsXG4gIHMsXG4gIFs1MjEsIDUsIDFdLFxuICA1MzIsXG4gIDUzMyxcbiAgNTM1LFxuICA1NDEsXG4gIDU0OSxcbiAgNTUyLFxuICA1NTMsXG4gIDU1OCxcbiAgNTYwLFxuICA1NjQsXG4gIDU2N1xuXSksXG4gIGdvdG86IHUoW1xuICA4LFxuICAyMyxcbiAgMjEsXG4gIDI1LFxuICAyNixcbiAgMjcsXG4gIDY2LFxuICA2NyxcbiAgNCxcbiAgOSxcbiAgNixcbiAgMjQsXG4gIDcsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE5LFxuICAxOTMsXG4gIDE5NCxcbiAgMTg1LFxuICAxODAsXG4gIDE4MSxcbiAgMTgyLFxuICAxNzYsXG4gIDE3NyxcbiAgMixcbiAgMyxcbiAgNSxcbiAgMTk2LFxuICAxNyxcbiAgMTkwLFxuICA3MSxcbiAgNzYsXG4gIDc1LFxuICAxLFxuICAxOTgsXG4gIDIwNCxcbiAgMTcwLFxuICAxNSxcbiAgMTQsXG4gIDE2LFxuICA3MCxcbiAgNzcsXG4gIDYzLFxuICA2NSxcbiAgcyxcbiAgWzIwOSwgNSwgMV0sXG4gIDg4LFxuICA5OCxcbiAgMjI0LFxuICAyMjUsXG4gIDc0LFxuICAxODMsXG4gIDE3OCxcbiAgMTg0LFxuICAxNzksXG4gIDQ4LFxuICA1NyxcbiAgNTksXG4gIDEwLFxuICAxODgsXG4gIDE4LFxuICAxOTIsXG4gIDY0LFxuICAxMDMsXG4gIDEwNCxcbiAgMTA1LFxuICAxMDcsXG4gIDEwOCxcbiAgMTE3LFxuICAyMjYsXG4gIDIyNyxcbiAgMjI4LFxuICAyMzEsXG4gIDE2MixcbiAgMjQzLFxuICAyNDQsXG4gIDE3MSxcbiAgMTcyLFxuICAxNzMsXG4gIDc5LFxuICA4MixcbiAgMjIyLFxuICAyMjMsXG4gIDI0MCxcbiAgMjQxLFxuICAyNDIsXG4gIDQ3LFxuICAyOCxcbiAgNDUsXG4gIDQ2LFxuICA1OCxcbiAgNTQsXG4gIDgzLFxuICA4NSxcbiAgMTg2LFxuICBzLFxuICBbMjQ3LCAxNCwgMV0sXG4gIDExNSxcbiAgMTMxLFxuICAxMzMsXG4gIDEzNSxcbiAgMTYxLFxuICAxMjksXG4gIDE3NCxcbiAgMTIzLFxuICAxMjQsXG4gIDE2OCxcbiAgMTAxLFxuICAxNjMsXG4gIDE2NSxcbiAgMjQ1LFxuICAyNDYsXG4gIDQ5LFxuICA1MSxcbiAgNTMsXG4gIDQxLFxuICA0MyxcbiAgNDQsXG4gIDYwLFxuICA1NixcbiAgNjEsXG4gIDY5LFxuICA4NCxcbiAgODYsXG4gIDg3LFxuICAxMTEsXG4gIDE1OCxcbiAgMTI3LFxuICAxMzAsXG4gIDk5LFxuICAxNDAsXG4gIDE0MSxcbiAgMTMyLFxuICAxNDcsXG4gIDEzNCxcbiAgMTQ1LFxuICAxMzgsXG4gIDEzOSxcbiAgMTQyLFxuICAxNDMsXG4gIDE0NCxcbiAgMTY5LFxuICAxNjQsXG4gIDc4LFxuICA3MyxcbiAgMjAwLFxuICAyMDYsXG4gIDM5LFxuICA0MCxcbiAgNDIsXG4gIDM3LFxuICA1NSxcbiAgNjgsXG4gIDEzNyxcbiAgMTI2LFxuICAxMDAsXG4gIDE2MCxcbiAgMTE4LFxuICAxMjIsXG4gIDEyNSxcbiAgMTAyLFxuICAxNjYsXG4gIDE2NyxcbiAgNzIsXG4gIDM4LFxuICAzMyxcbiAgMzUsXG4gIDM2LFxuICAxMTMsXG4gIDE0NixcbiAgMTM2LFxuICAxMjgsXG4gIDEyMCxcbiAgMTIxLFxuICA5NSxcbiAgMzEsXG4gIDMyLFxuICAzNCxcbiAgMTEwLFxuICBzLFxuICBbMTQ4LCA0LCAyXSxcbiAgMTE5LFxuICAyMCxcbiAgMjAyLFxuICAzMCxcbiAgMTU3LFxuICBzLFxuICBbMTQ5LCA0LCAyXSxcbiAgMjIsXG4gIDI5LFxuICA4OSxcbiAgMTU2LFxuICA5MCxcbiAgOTYsXG4gIDk3LFxuICA5MixcbiAgOTEsXG4gIDkzLFxuICA5NFxuXSlcbn0pLFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUgJiYgdHlwZW9mIHRoaXMudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgICAgICBoYXNoLmRlc3Ryb3koKTsgLy8gZGVzdHJveS4uLiB3ZWxsLCAqYWxtb3N0KiFcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25QYXJzZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgIC8vIHRva2VuIHN0YWNrOiBzdG9yZXMgdG9rZW4gd2hpY2ggbGVhZHMgdG8gc3RhdGUgYXQgdGhlIHNhbWUgaW5kZXggKGNvbHVtbiBzdG9yYWdlKVxuICAgIHZhciBzc3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHN0YXRlIHN0YWNrOiBzdG9yZXMgc3RhdGVzIChjb2x1bW4gc3RvcmFnZSlcblxuICAgIHZhciB2c3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgdmFyIGxzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gbG9jYXRpb24gc3RhY2tcbiAgICB2YXIgdGFibGUgPSB0aGlzLnRhYmxlO1xuICAgIHZhciBzcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzdGFjayBwb2ludGVyJzogaW5kZXggaW50byB0aGUgc3RhY2tzXG4gICAgdmFyIHl5bG9jO1xuXG4gICAgdmFyIHl5bGluZW5vO1xuXG5cbiAgICB2YXIgc3ltYm9sID0gMDtcblxuXG5cbiAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgdmFyIEVPRiA9IHRoaXMuRU9GO1xuICAgIHZhciBFUlJPUl9SRUNPVkVSWV9UT0tFTl9ESVNDQVJEX0NPVU5UID0gKHRoaXMub3B0aW9ucy5lcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQgfCAwKSB8fCAzO1xuICAgIHZhciBOT19BQ1RJT04gPSBbMCwgNTY4IC8qID09PSB0YWJsZS5sZW5ndGggOjogZW5zdXJlcyB0aGF0IGFueW9uZSB1c2luZyB0aGlzIG5ldyBzdGF0ZSB3aWxsIGZhaWwgZHJhbWF0aWNhbGx5ISAqL107XG5cbiAgICB2YXIgbGV4ZXI7XG4gICAgaWYgKHRoaXMuX19sZXhlcl9fKSB7XG4gICAgICAgIGxleGVyID0gdGhpcy5fX2xleGVyX187XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV4ZXIgPSB0aGlzLl9fbGV4ZXJfXyA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgfVxuXG4gICAgdmFyIHNoYXJlZFN0YXRlX3l5ID0ge1xuICAgICAgICBwYXJzZUVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIHF1b3RlTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBsZXhlcjogdW5kZWZpbmVkLFxuICAgICAgICBwYXJzZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlX3BhcnNlOiB1bmRlZmluZWQsXG4gICAgICAgIHBvc3RfcGFyc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlX2xleDogdW5kZWZpbmVkLFxuICAgICAgICBwb3N0X2xleDogdW5kZWZpbmVkICAgICAgLy8gV0FSTklORzogbXVzdCBiZSB3cml0dGVuIHRoaXMgd2F5IGZvciB0aGUgY29kZSBleHBhbmRlcnMgdG8gd29yayBjb3JyZWN0bHkgaW4gYm90aCBFUzUgYW5kIEVTNiBtb2RlcyFcbiAgICB9O1xuXG4gICAgdmFyIEFTU0VSVDtcbiAgICBpZiAodHlwZW9mIGFzc2VydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBBU1NFUlQgPSBmdW5jdGlvbiBKaXNvbkFzc2VydChjb25kLCBtc2cpIHtcbiAgICAgICAgICAgIGlmICghY29uZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0aW9uIGZhaWxlZDogJyArIChtc2cgfHwgJyoqKicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBBU1NFUlQgPSBhc3NlcnQ7XG4gICAgfVxuXG4gICAgdGhpcy55eUdldFNoYXJlZFN0YXRlID0gZnVuY3Rpb24geXlHZXRTaGFyZWRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5O1xuICAgIH07XG5cblxuICAgIC8vIHNoYWxsb3cgY2xvbmUgb2JqZWN0cywgc3RyYWlnaHQgY29weSBvZiBzaW1wbGUgYHNyY2AgdmFsdWVzXG4gICAgLy8gZS5nLiBgbGV4ZXIueXl0ZXh0YCBNQVkgYmUgYSBjb21wbGV4IHZhbHVlIG9iamVjdCxcbiAgICAvLyByYXRoZXIgdGhhbiBhIHNpbXBsZSBzdHJpbmcvdmFsdWUuXG4gICAgZnVuY3Rpb24gc2hhbGxvd19jb3B5KHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIoZHN0LCBzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHN0W2tdID09PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrKSkge1xuICAgICAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5X3l5bGxvYyhsb2MpIHtcbiAgICAgICAgdmFyIHJ2ID0gc2hhbGxvd19jb3B5KGxvYyk7XG4gICAgICAgIGlmIChydiAmJiBydi5yYW5nZSkge1xuICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuXG4gICAgLy8gY29weSBzdGF0ZVxuICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIoc2hhcmVkU3RhdGVfeXksIHRoaXMueXkpO1xuXG4gICAgc2hhcmVkU3RhdGVfeXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZV95eS5wYXJzZXIgPSB0aGlzO1xuXG5cblxuXG5cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgdGhhdCBhbHJlYWR5IGNvbWVzIHdpdGggdGhpcyBpbnN0YW5jZT9cbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlX3l5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gZnVuY3Rpb24gcGFyc2VFcnJvckFsdChzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uUGFyc2VyRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMub3JpZ2luYWxQYXJzZUVycm9yO1xuICAgIH1cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCB0aGF0IGFscmVhZHkgY29tZXMgd2l0aCB0aGlzIGluc3RhbmNlP1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGVfeXkucXVvdGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gZnVuY3Rpb24gcXVvdGVOYW1lQWx0KGlkX3N0cikge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5LnF1b3RlTmFtZS5jYWxsKHRoaXMsIGlkX3N0cik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSB0aGlzLm9yaWdpbmFsUXVvdGVOYW1lO1xuICAgIH1cblxuICAgIC8vIHNldCB1cCB0aGUgY2xlYW51cCBmdW5jdGlvbjsgbWFrZSBpdCBhbiBBUEkgc28gdGhhdCBleHRlcm5hbCBjb2RlIGNhbiByZS11c2UgdGhpcyBvbmUgaW4gY2FzZSBvZlxuICAgIC8vIGNhbGFtaXRpZXMgb3Igd2hlbiB0aGUgYCVvcHRpb25zIG5vLXRyeS1jYXRjaGAgb3B0aW9uIGhhcyBiZWVuIHNwZWNpZmllZCBmb3IgdGhlIGdyYW1tYXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB0aGlzIHBhcnNlKCkgQVBJIG1ldGhvZCBkb2Vzbid0IGNvbWUgd2l0aCBhIGBmaW5hbGx5IHsgLi4uIH1gIGJsb2NrIGFueSBtb3JlIVxuICAgIC8vXG4gICAgLy8gTk9URTogYXMgdGhpcyBBUEkgdXNlcyBwYXJzZSgpIGFzIGEgY2xvc3VyZSwgaXQgTVVTVCBiZSBzZXQgYWdhaW4gb24gZXZlcnkgcGFyc2UoKSBpbnZvY2F0aW9uLFxuICAgIC8vICAgICAgIG9yIGVsc2UgeW91ciBgc2hhcmVkU3RhdGVgLCBldGMuIHJlZmVyZW5jZXMgd2lsbCBiZSAqd3JvbmcqIVxuICAgIHRoaXMuY2xlYW51cEFmdGVyUGFyc2UgPSBmdW5jdGlvbiBwYXJzZXJfY2xlYW51cEFmdGVyUGFyc2UocmVzdWx0VmFsdWUsIGludm9rZV9wb3N0X21ldGhvZHMsIGRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgdmFyIHJ2O1xuXG4gICAgICAgIGlmIChpbnZva2VfcG9zdF9tZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIgaGFzaDtcblxuICAgICAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnBvc3RfcGFyc2UgfHwgdGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZTogd2UgcmUtdXNlIHRoaXMgQVBJIGluIGEgKipub24tZXJyb3Igc2l0dWF0aW9uKipcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGlzIG9uZSBkZWxpdmVycyBhbGwgcGFyc2VyIGludGVybmFscyByZWFkeSBmb3IgYWNjZXNzIGJ5IHVzZXJsYW5kIGNvZGUuXG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8obnVsbCAvKiBubyBlcnJvciEgKi8sIG51bGwgLyogbm8gZXhjZXB0aW9uISAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZSkge1xuICAgICAgICAgICAgICAgIHJ2ID0gc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5LCByZXN1bHRWYWx1ZSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFZhbHVlID0gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgcnYgPSB0aGlzLnBvc3RfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSwgcmVzdWx0VmFsdWUsIGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICd1bmRlZmluZWQnKSByZXN1bHRWYWx1ZSA9IHJ2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhbnVwOlxuICAgICAgICAgICAgaWYgKGhhc2ggJiYgaGFzaC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgaGFzaC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoID4gMSkgcmV0dXJuIHJlc3VsdFZhbHVlOyAgICAgICAgLy8gZG8gbm90ICh5ZXQpIGtpbGwgdGhlIHNoYXJlZFN0YXRlIHdoZW4gdGhpcyBpcyBhIHJlZW50cmFudCBydW4uXG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIGxpbmdlcmluZyBsZXhlciBzdHJ1Y3R1cmVzIGFzIHdlbGw6XG4gICAgICAgIGlmIChsZXhlci5jbGVhbnVwQWZ0ZXJMZXgpIHtcbiAgICAgICAgICAgIGxleGVyLmNsZWFudXBBZnRlckxleChkb19ub3RfbnVrZV9lcnJvcmluZm9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgbGluZ2VyaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgZnJvbSBjYXVzaW5nIG1lbW9yeSBsZWFrczpcbiAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5KSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5sZXhlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LnBhcnNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChsZXhlci55eSA9PT0gc2hhcmVkU3RhdGVfeXkpIHtcbiAgICAgICAgICAgICAgICBsZXhlci55eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGFyZWRTdGF0ZV95eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy5vcmlnaW5hbFBhcnNlRXJyb3I7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gdGhpcy5vcmlnaW5hbFF1b3RlTmFtZTtcblxuICAgICAgICAvLyBudWtlIHRoZSB2c3RhY2tbXSBhcnJheSBhdCBsZWFzdCBhcyB0aGF0IG9uZSB3aWxsIHN0aWxsIHJlZmVyZW5jZSBvYnNvbGV0ZWQgdXNlciB2YWx1ZXMuXG4gICAgICAgIC8vIFRvIGJlIHNhZmUsIHdlIG51a2UgdGhlIG90aGVyIGludGVybmFsIHN0YWNrIGNvbHVtbnMgYXMgd2VsbC4uLlxuICAgICAgICBzdGFjay5sZW5ndGggPSAwOyAgICAgICAgICAgICAgIC8vIGZhc3Rlc3Qgd2F5IHRvIG51a2UgYW4gYXJyYXkgd2l0aG91dCBvdmVybHkgYm90aGVyaW5nIHRoZSBHQ1xuICAgICAgICBzc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBzcCA9IDA7XG5cbiAgICAgICAgLy8gbnVrZSB0aGUgZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlcyBjcmVhdGVkIGR1cmluZyB0aGlzIHJ1bi5cbiAgICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgICAvLyBpbiB0aGUgZXJyb3IgaGFzaCBpbnN0YW5jZShzKSBpdCBpcyBtb3JlIHBlcm1hbmVudGx5IGludGVyZXN0ZWQgaW4uXG4gICAgICAgIGlmICghZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX19lcnJvcl9pbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggPSAwO1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gbWVyZ2UgeXlsbG9jIGluZm8gaW50byBhIG5ldyB5eWxsb2MgaW5zdGFuY2UuXG4gICAgLy9cbiAgICAvLyBgZmlyc3RfaW5kZXhgIGFuZCBgbGFzdF9pbmRleGAgTUFZIGJlIFVOREVGSU5FRC9OVUxMIG9yIHRoZXNlIGFyZSBpbmRleGVzIGludG8gdGhlIGBsc3RhY2tbXWAgbG9jYXRpb24gc3RhY2sgYXJyYXkuXG4gICAgLy9cbiAgICAvLyBgZmlyc3RfeXlsbG9jYCBhbmQgYGxhc3RfeXlsbG9jYCBNQVkgYmUgVU5ERUZJTkVEL05VTEwgb3IgZXhwbGljaXQgKGN1c3RvbSBvciByZWd1bGFyKSBgeXlsbG9jYCBpbnN0YW5jZXMsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB0aGVzZSBvdmVycmlkZSB0aGUgY29ycmVzcG9uZGluZyBmaXJzdC9sYXN0IGluZGV4ZXMuXG4gICAgLy9cbiAgICAvLyBgZG9udF9sb29rX2JhY2tgIGlzIGFuIG9wdGlvbmFsIGZsYWcgKGRlZmF1bHQ6IEZBTFNFKSwgd2hpY2ggaW5zdHJ1Y3RzIHRoaXMgbWVyZ2Ugb3BlcmF0aW9uIE5PVCB0byBzZWFyY2hcbiAgICAvLyB0aHJvdWdoIHRoZSBwYXJzZSBsb2NhdGlvbiBzdGFjayBmb3IgYSBsb2NhdGlvbiwgd2hpY2ggd291bGQgb3RoZXJ3aXNlIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSBuZXcgKGVwc2lsb24hKVxuICAgIC8vIHl5bGxvYyBpbmZvLlxuICAgIC8vXG4gICAgLy8gTm90ZTogZXBzaWxvbiBydWxlJ3MgeXlsbG9jIHNpdHVhdGlvbiBpcyBkZXRlY3RlZCBieSBwYXNzaW5nIGJvdGggYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AgYXMgVU5ERUZJTkVEL05VTEwuXG4gICAgdGhpcy55eU1lcmdlTG9jYXRpb25JbmZvID0gZnVuY3Rpb24gcGFyc2VyX3l5TWVyZ2VMb2NhdGlvbkluZm8oZmlyc3RfaW5kZXgsIGxhc3RfaW5kZXgsIGZpcnN0X3l5bGxvYywgbGFzdF95eWxsb2MsIGRvbnRfbG9va19iYWNrKSB7XG4gICAgICAgIHZhciBpMSA9IGZpcnN0X2luZGV4IHwgMCxcbiAgICAgICAgICAgIGkyID0gbGFzdF9pbmRleCB8IDA7XG4gICAgICAgIHZhciBsMSA9IGZpcnN0X3l5bGxvYyxcbiAgICAgICAgICAgIGwyID0gbGFzdF95eWxsb2M7XG4gICAgICAgIHZhciBydjtcblxuICAgICAgICAvLyBydWxlczpcbiAgICAgICAgLy8gLSBmaXJzdC9sYXN0IHl5bGxvYyBlbnRyaWVzIG92ZXJyaWRlIGZpcnN0L2xhc3QgaW5kZXhlc1xuXG4gICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGkxOyBpIDw9IGkyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbDEgPSBsc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWwyKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGkyOyBpID49IGkxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbDIgPSBsc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtIGRldGVjdCBpZiBhbiBlcHNpbG9uIHJ1bGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBhY3QgYWNjb3JkaW5nbHk6XG4gICAgICAgIGlmICghbDEgJiYgZmlyc3RfaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZXBzaWxvbiBydWxlIHNwYW4gbWVyZ2VyLiBXaXRoIG9wdGlvbmFsIGxvb2stYWhlYWQgaW4gbDIuXG4gICAgICAgICAgICBpZiAoIWRvbnRfbG9va19iYWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IChpMSB8fCBzcCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsMSA9IGxzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWwyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhbnkgdmFsaWQgeXlsbG9jIGluZm8sIHdlJ3JlIGxvb2tpbmcgYXQgYW4gZXBzaWxvbiBydWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgbG9vay1haGVhZCBhbmQgbm8gcHJlY2VkaW5nIHRlcm1zIGFuZC9vciBgZG9udF9sb29rX2JhY2tgIHNldDpcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhIGRvIG5vdGhpbmcgYnV0IHJldHVybiBOVUxML1VOREVGSU5FRDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDI6IGFmdGVyIGFsbCwgd2UgTUFZIGJlIGxvb2tpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdW5jb252ZW50aW9uYWwgeXlsbG9jIGluZm8gb2JqZWN0cy4uLlxuICAgICAgICAgICAgICAgICAgICBydiA9IHNoYWxsb3dfY29weShsMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHRoZSB5eWxsb2MgcmFuZ2VzIGluZm8gdG8gcHJldmVudCB1cyBmcm9tIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzJyBlbnRyaWVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2UgPSBydi5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDEsIHRoZW4gYWRqdXN0IGZpcnN0IGNvbC9yb3cgMSBjb2x1bW4gcGFzdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgIHJ2ID0gc2hhbGxvd19jb3B5KGwxKTtcbiAgICAgICAgICAgICAgICBydi5maXJzdF9saW5lID0gcnYubGFzdF9saW5lO1xuICAgICAgICAgICAgICAgIHJ2LmZpcnN0X2NvbHVtbiA9IHJ2Lmxhc3RfY29sdW1uO1xuICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFsbG93IGNvcHkgdGhlIHl5bGxvYyByYW5nZXMgaW5mbyB0byBwcmV2ZW50IHVzIGZyb20gbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMnIGVudHJpZXM6XG4gICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIHJ2LnJhbmdlWzBdID0gcnYucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGwyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoYWxsb3ctbWl4aW4gTDIsIHRoZW4gYWRqdXN0IGxhc3QgY29sL3JvdyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgc2hhbGxvd19jb3B5X25vY2xvYmJlcihydiwgbDIpO1xuICAgICAgICAgICAgICAgICAgICBydi5sYXN0X2xpbmUgPSBsMi5sYXN0X2xpbmU7XG4gICAgICAgICAgICAgICAgICAgIHJ2Lmxhc3RfY29sdW1uID0gbDIubGFzdF9jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChydi5yYW5nZSAmJiBsMi5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnYucmFuZ2VbMV0gPSBsMi5yYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWwxKSB7XG4gICAgICAgICAgICBsMSA9IGwyO1xuICAgICAgICAgICAgbDIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFsbG93LWNvcHkgTDF8TDIsIGJlZm9yZSB3ZSB0cnkgdG8gYWRqdXN0IHRoZSB5eWxsb2MgdmFsdWVzOiBhZnRlciBhbGwsIHdlIE1BWSBiZSBsb29raW5nXG4gICAgICAgIC8vIGF0IHVuY29udmVudGlvbmFsIHl5bGxvYyBpbmZvIG9iamVjdHMuLi5cbiAgICAgICAgcnYgPSBzaGFsbG93X2NvcHkobDEpO1xuXG4gICAgICAgIC8vIGZpcnN0X2xpbmU6IC4uLixcbiAgICAgICAgLy8gZmlyc3RfY29sdW1uOiAuLi4sXG4gICAgICAgIC8vIGxhc3RfbGluZTogLi4uLFxuICAgICAgICAvLyBsYXN0X2NvbHVtbjogLi4uLFxuICAgICAgICBpZiAocnYucmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIHNoYWxsb3cgY29weSB0aGUgeXlsbG9jIHJhbmdlcyBpbmZvIHRvIHByZXZlbnQgdXMgZnJvbSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cycgZW50cmllczpcbiAgICAgICAgICAgIHJ2LnJhbmdlID0gcnYucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobDIpIHtcbiAgICAgICAgICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIocnYsIGwyKTtcbiAgICAgICAgICAgIHJ2Lmxhc3RfbGluZSA9IGwyLmxhc3RfbGluZTtcbiAgICAgICAgICAgIHJ2Lmxhc3RfY29sdW1uID0gbDIubGFzdF9jb2x1bW47XG4gICAgICAgICAgICBpZiAocnYucmFuZ2UgJiYgbDIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBydi5yYW5nZVsxXSA9IGwyLnJhbmdlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH07XG5cbiAgICAvLyBOT1RFOiBhcyB0aGlzIEFQSSB1c2VzIHBhcnNlKCkgYXMgYSBjbG9zdXJlLCBpdCBNVVNUIGJlIHNldCBhZ2FpbiBvbiBldmVyeSBwYXJzZSgpIGludm9jYXRpb24sXG4gICAgLy8gICAgICAgb3IgZWxzZSB5b3VyIGBsZXhlcmAsIGBzaGFyZWRTdGF0ZWAsIGV0Yy4gcmVmZXJlbmNlcyB3aWxsIGJlICp3cm9uZyohXG4gICAgdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyA9IGZ1bmN0aW9uIHBhcnNlcl9jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhtc2csIGV4LCBleHBlY3RlZCwgcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgICAgIGVyclN0cjogbXNnLFxuICAgICAgICAgICAgZXhjZXB0aW9uOiBleCxcbiAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgdmFsdWU6IGxleGVyLnl5dGV4dCxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHN5bWJvbCkgfHwgc3ltYm9sLFxuICAgICAgICAgICAgdG9rZW5faWQ6IHN5bWJvbCxcbiAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgbG9jOiBjb3B5X3l5bGxvYyhsZXhlci55eWxsb2MpLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgcmVjb3ZlcmFibGU6IHJlY292ZXJhYmxlLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBuZXdfc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgc3ltYm9sX3N0YWNrOiBzdGFjayxcbiAgICAgICAgICAgIHN0YXRlX3N0YWNrOiBzc3RhY2ssXG4gICAgICAgICAgICB2YWx1ZV9zdGFjazogdnN0YWNrLFxuICAgICAgICAgICAgbG9jYXRpb25fc3RhY2s6IGxzdGFjayxcbiAgICAgICAgICAgIHN0YWNrX3BvaW50ZXI6IHNwLFxuICAgICAgICAgICAgeXk6IHNoYXJlZFN0YXRlX3l5LFxuICAgICAgICAgICAgbGV4ZXI6IGxleGVyLFxuICAgICAgICAgICAgcGFyc2VyOiB0aGlzLFxuXG4gICAgICAgICAgICAvLyBhbmQgbWFrZSBzdXJlIHRoZSBlcnJvciBpbmZvIGRvZXNuJ3Qgc3RheSBkdWUgdG8gcG90ZW50aWFsXG4gICAgICAgICAgICAvLyByZWYgY3ljbGUgdmlhIHVzZXJsYW5kIGNvZGUgbWFuaXB1bGF0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb25seSBhcnJheSBhbmQgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIG51a2VkIGFzIHRob3NlXG4gICAgICAgICAgICAvLyBjb25zdGl0dXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgd2hpY2ggY2FuIHByb2R1Y2UgYSBjeWNsaWMgcmVmLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdFBhcnNlRXJyb3JJbmZvKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjeWNsaWMgcmVmZXJlbmNlcyBhZGRlZCB0byBlcnJvciBpbmZvOlxuICAgICAgICAgICAgICAgIC8vIGluZm8ueXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8ubGV4ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWVfc3RhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgICAgICAgIHZhciByZWMgPSAhIXRoaXMucmVjb3ZlcmFibGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLnB1c2gocGVpKTtcbiAgICAgICAgcmV0dXJuIHBlaTtcbiAgICB9O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9uVGVybWluYWxGcm9tQ29kZShzeW1ib2wpIHtcbiAgICAgICAgdmFyIHRva2VuTmFtZSA9IHNlbGYuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgICAgICBpZiAoIXRva2VuTmFtZSkge1xuICAgICAgICAgICAgdG9rZW5OYW1lID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbk5hbWU7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleGVyLmxleCgpO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBFT0Y7XG4gICAgfVxuXG5cbiAgICB2YXIgc3RhdGUsIGFjdGlvbiwgciwgdDtcbiAgICB2YXIgeXl2YWwgPSB7XG4gICAgICAgICQ6IHRydWUsXG4gICAgICAgIF8kOiB1bmRlZmluZWQsXG4gICAgICAgIHl5OiBzaGFyZWRTdGF0ZV95eVxuICAgIH07XG4gICAgdmFyIHA7XG4gICAgdmFyIHl5cnVsZWxlbjtcbiAgICB2YXIgdGhpc19wcm9kdWN0aW9uO1xuICAgIHZhciBuZXdTdGF0ZTtcbiAgICB2YXIgcmV0dmFsID0gZmFsc2U7XG5cblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aCsrO1xuXG4gICAgICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZV95eSk7XG5cbiAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgIGxzdGFja1tzcF0gPSB5eWxvYztcbiAgICAgICAgdnN0YWNrW3NwXSA9IG51bGw7XG4gICAgICAgIHNzdGFja1tzcF0gPSAwO1xuICAgICAgICBzdGFja1tzcF0gPSAwO1xuICAgICAgICArK3NwO1xuXG5cblxuXG5cbiAgICAgICAgaWYgKHRoaXMucHJlX3BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnByZV9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucHJlX3BhcnNlKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5wcmVfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdTdGF0ZSA9IHNzdGFja1tzcCAtIDFdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgICAgIHN0YXRlID0gbmV3U3RhdGU7ICAgICAgICAgICAgICAgLy8gc3N0YWNrW3NwIC0gMV07XG5cbiAgICAgICAgICAgIC8vIHVzZSBkZWZhdWx0IGFjdGlvbnMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAyO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaW5nbGUgYD09YCBjb25kaXRpb24gYmVsb3cgY292ZXJzIGJvdGggdGhlc2UgYD09PWAgY29tcGFyaXNvbnMgaW4gYSBzaW5nbGVcbiAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb246XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09PSAndW5kZWZpbmVkJykgLi4uXG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgICAgIHQgPSAodGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdKSB8fCBOT19BQ1RJT047XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0WzFdO1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRbMF07XG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBwYXJzZSBlcnJvclxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJTdHI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJTeW1ib2xEZXNjciA9ICh0aGlzLmRlc2NyaWJlU3ltYm9sKHN5bWJvbCkgfHwgc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gdGhpcy5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV4ZXIueXlsaW5lbm8gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKGxleGVyLnl5bGluZW5vICsgMSkgKyAnOiAnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yOiAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV4ZXIuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ1xcbicgKyBsZXhlci5zaG93UG9zaXRpb24oNzkgLSAxMCwgMTApICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdFeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgdW5leHBlY3RlZCAnICsgZXJyU3ltYm9sRGVzY3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ1VuZXhwZWN0ZWQgJyArIGVyclN5bWJvbERlc2NyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCByZWNvdmVyIGZyb20gdGhlIGVycm9yIVxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhlcnJTdHIsIG51bGwsIGV4cGVjdGVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGNhdGNoIG1pc2MuIHBhcnNlIGZhaWx1cmVzOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZG4ndCBoYXBwZW4sIHVubGVzcyByZXNvbHZlIGRlZmF1bHRzIGFyZSBvZmZcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCwgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIGNhc2Ugb2YgYmV0dGVyIHNhZmUgdGhhbiBzb3JyeTogaW4gY2FzZSBzdGF0ZSB0cmFuc2l0aW9ucyBjb21lIG91dCBvZiBhbm90aGVyIGVycm9yIHJlY292ZXJ5IHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBvciBhIGJ1Z2d5IExVVCAoTG9va1VwIFRhYmxlKTpcbiAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2luZyBoYWx0ZWQuIE5vIHZpYWJsZSBlcnJvciByZWNvdmVyeSBhcHByb2FjaCBhdmFpbGFibGUgZHVlIHRvIGludGVybmFsIHN5c3RlbSBmYWlsdXJlLicsIG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0OlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHN0YWNrW3NwXSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICB2c3RhY2tbc3BdID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIGxzdGFja1tzcF0gPSBjb3B5X3l5bGxvYyhsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgICAgIHNzdGFja1tzcF0gPSBuZXdTdGF0ZTsgLy8gcHVzaCBzdGF0ZVxuXG4gICAgICAgICAgICAgICAgKytzcDtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGljayB1cCB0aGUgbGV4ZXIgZGV0YWlscyBmb3IgdGhlIGN1cnJlbnQgc3ltYm9sIGFzIHRoYXQgb25lIGlzIG5vdCAnbG9vay1haGVhZCcgYW55IG1vcmU6XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIFxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIHJlZHVjZTpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzX3Byb2R1Y3Rpb24gPSB0aGlzLnByb2R1Y3Rpb25zX1tuZXdTdGF0ZSAtIDFdOyAgLy8gYHRoaXMucHJvZHVjdGlvbnNfW11gIGlzIHplcm8tYmFzZWQgaW5kZXhlZCB3aGlsZSBzdGF0ZXMgc3RhcnQgZnJvbSAxIHVwd2FyZHMuLi5cbiAgICAgICAgICAgICAgICB5eXJ1bGVsZW4gPSB0aGlzX3Byb2R1Y3Rpb25bMV07XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoeXl2YWwsIHl5bG9jLCBuZXdTdGF0ZSwgc3AgLSAxLCB2c3RhY2ssIGxzdGFjayk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvcCBvZmYgc3RhY2tcbiAgICAgICAgICAgICAgICBzcCAtPSB5eXJ1bGVsZW47XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgdGhlIGBzeW1ib2xgIHZhcmlhYmxlOiB1c2UgYSBsb2NhbCB2YXIgdG8gc3BlZWQgdGhpbmdzIHVwOlxuICAgICAgICAgICAgICAgIHZhciBudHN5bWJvbCA9IHRoaXNfcHJvZHVjdGlvblswXTsgICAgLy8gcHVzaCBub250ZXJtaW5hbCAocmVkdWNlKVxuICAgICAgICAgICAgICAgIHN0YWNrW3NwXSA9IG50c3ltYm9sO1xuICAgICAgICAgICAgICAgIHZzdGFja1tzcF0gPSB5eXZhbC4kO1xuICAgICAgICAgICAgICAgIGxzdGFja1tzcF0gPSB5eXZhbC5fJDtcbiAgICAgICAgICAgICAgICAvLyBnb3RvIG5ldyBzdGF0ZSA9IHRhYmxlW1NUQVRFXVtOT05URVJNSU5BTF1cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3NzdGFja1tzcCAtIDFdXVtudHN5bWJvbF07XG4gICAgICAgICAgICAgICAgc3N0YWNrW3NwXSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgICsrc3A7XG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFjY2VwdDpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYCRhY2NlcHRgIHJ1bGUncyBgJCRgIHJlc3VsdCwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgSklTT04gYWx3YXlzIGFkZHMgdGhpcyB0b3AtbW9zdCBgJGFjY2VwdGAgcnVsZSAod2l0aCBpbXBsaWNpdCxcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhY3Rpb24pOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICRhY2NlcHQ6IDxzdGFydFN5bWJvbD4gJGVuZFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXsgJCQgPSAkMTsgQCQgPSBAMTsgJX1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoLCBjb21iaW5lZCB3aXRoIHRoZSBwYXJzZSBrZXJuZWwncyBgJGFjY2VwdGAgc3RhdGUgYmVoYXZpb3VyIGNvZGVkIGJlbG93LFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcHJvZHVjZSB0aGUgYCQkYCB2YWx1ZSBvdXRwdXQgb2YgdGhlIDxzdGFydFN5bWJvbD4gcnVsZSBhcyB0aGUgcGFyc2UgcmVzdWx0LFxuICAgICAgICAgICAgICAgIC8vIElGRiB0aGF0IHJlc3VsdCBpcyAqbm90KiBgdW5kZWZpbmVkYC4gKFNlZSBhbHNvIHRoZSBwYXJzZXIga2VybmVsIGNvZGUuKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gY29kZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBAJCA9IEAxOyAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uIHRyYWNraW5nIHN1cHBvcnQgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICQxICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAgICAvLyB0aGUgZGVmYXVsdCBwYXJzZSByZXN1bHQgaWYgdGhlIHJ1bGUgYWN0aW9ucyBkb24ndCBwcm9kdWNlIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAlfVxuICAgICAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2c3RhY2tbc3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB2c3RhY2tbc3BdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBicmVhayBvdXQgb2YgbG9vcDogd2UgYWNjZXB0IG9yIGZhaWwgd2l0aCBlcnJvclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyByZXBvcnQgZXhjZXB0aW9ucyB0aHJvdWdoIHRoZSBwYXJzZUVycm9yIGNhbGxiYWNrIHRvbywgYnV0IGtlZXAgdGhlIGV4Y2VwdGlvbiBpbnRhY3RcbiAgICAgICAgLy8gaWYgaXQgaXMgYSBrbm93biBwYXJzZXIgb3IgbGV4ZXIgZXJyb3Igd2hpY2ggaGFzIGJlZW4gdGhyb3duIGJ5IHBhcnNlRXJyb3IoKSBhbHJlYWR5OlxuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiB0aGlzLkppc29uUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxleGVyICYmIHR5cGVvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IgPT09ICdmdW5jdGlvbicgJiYgZXggaW5zdGFuY2VvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNpbmcgYWJvcnRlZCBkdWUgdG8gZXhjZXB0aW9uLicsIGV4LCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR2YWwgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXR2YWwgPSB0aGlzLmNsZWFudXBBZnRlclBhcnNlKHJldHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aC0tO1xuICAgIH0gICAvLyAvZmluYWxseVxuXG4gICAgcmV0dXJuIHJldHZhbDtcbn1cbn07XG5wYXJzZXIub3JpZ2luYWxQYXJzZUVycm9yID0gcGFyc2VyLnBhcnNlRXJyb3I7XG5wYXJzZXIub3JpZ2luYWxRdW90ZU5hbWUgPSBwYXJzZXIucXVvdGVOYW1lO1xuXG5cbi8qIGxleGVyIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC42LjEtMjAzICovXG5cbi8qXG4gKiBSZXR1cm5zIGEgTGV4ZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICpcbiAqICBMZXhlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRpcmVjdCByZWZlcmVuY2UhXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3Qgd2FzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYnkgd2F5IG9mIFxuICogICAgICAgICAgICAgICB0aGUgYGxleGVyLnNldElucHV0KHN0ciwgeXkpYCBBUEkgYmVmb3JlIHlvdSBtYXkgdXNlIGl0LlxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBcInNoYXJlZCBjb250ZXh0XCIgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYWN0aW9uIGNvZGUgaW4gYHBlcmZvcm1BY3Rpb24oKWBcbiAqICAgICAgICAgICAgICAgc28gdXNlcmxhbmQgY29kZSBpbiB0aGUgbGV4ZXIgYWN0aW9ucyBtYXkgY29tbXVuaWNhdGUgd2l0aCB0aGUgb3V0c2lkZSB3b3JsZCBcbiAqICAgICAgICAgICAgICAgYW5kL29yIG90aGVyIGxleGVyIHJ1bGVzJyBhY3Rpb25zIGluIG1vcmUgb3IgbGVzcyBjb21wbGV4IHdheXMuXG4gKlxuICogIH1cbiAqXG4gKiAgTGV4ZXIucHJvdG90eXBlOiB7XG4gKiAgICBFT0Y6IDEsXG4gKiAgICBFUlJPUjogMixcbiAqXG4gKiAgICB5eTogICAgICAgIFRoZSBvdmVyYWxsIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3QgcmVmZXJlbmNlLlxuICpcbiAqICAgIEppc29uTGV4ZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYGxleGVyYCBpbnN0YW5jZS4gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgeXlfYCBpcyBhbiBhbGlhcyBmb3IgYHRoaXNgIGxleGVyIGluc3RhbmNlIHJlZmVyZW5jZSB1c2VkIGludGVybmFsbHkuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWAgICAgICA6IGEgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIFwic2hhcmVkIHN0YXRlXCIgb2JqZWN0IHdoaWNoIHdhcyBwYXNzZWQgdG8gdGhlIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgd2F5IG9mIHRoZSBgbGV4ZXIuc2V0SW5wdXQoc3RyLCB5eSlgIEFQSSBiZWZvcmUuXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGU6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqcGFyc2VyKiogZ3JhbW1hciBkZWZpbml0aW9uIGZpbGUgYXJlIHBhc3NlZCB0byB0aGUgbGV4ZXIgdmlhIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlIGFzIG1lbWJlciB2YXJpYWJsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXJ1bGVudW1iZXJgICAgOiBpbmRleCBvZiB0aGUgbWF0Y2hlZCBsZXhlciBydWxlIChyZWdleCksIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYFlZX1NUQVJUYDogdGhlIGN1cnJlbnQgbGV4ZXIgXCJzdGFydCBjb25kaXRpb25cIiBzdGF0ZS5cbiAqXG4gKiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RMZXhFcnJvckluZm86IGZ1bmN0aW9uKGVycm9yX21lc3NhZ2UsIGlzX3JlY292ZXJhYmxlKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIGxleGVyIGtlcm5lbCBpbiBtYW55IHBsYWNlczsgZXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICB2YXIgaW5mb09iaiA9IGxleGVyLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdmYWlsIScsIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGxleGVyLnBhcnNlRXJyb3IoaW5mb09iai5lcnJTdHIsIGluZm9PYmosIGxleGVyLkppc29uTGV4ZXJFcnJvcik7XG4gKlxuICogICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgbGV4OiBmdW5jdGlvbigpLFxuICogICAgICAgICAgICAgICBQcm9kdWNlIG9uZSB0b2tlbiBvZiBsZXhlZCBpbnB1dCwgd2hpY2ggd2FzIHBhc3NlZCBpbiBlYXJsaWVyIHZpYSB0aGUgYGxleGVyLnNldElucHV0KClgIEFQSS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhlICoqbGV4ZXIqKiBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIExleGVyJ3MgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyAodmlhIGxleGVyJ3MgYCVwYXJzZS1wYXJhbWApIE1BWSBjb25mbGljdCB3aXRoXG4gKiAgICAgICAgICAgICAgIGFueSBhdHRyaWJ1dGVzIGFscmVhZHkgYWRkZWQgdG8gYHl5YCBieSB0aGUgKipwYXJzZXIqKiBvciB0aGUgamlzb24gcnVuLXRpbWU7IFxuICogICAgICAgICAgICAgICB3aGVuIHN1Y2ggYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgYW4gZXhjZXB0aW9uIGlzIHRocm93biB0byBwcmV2ZW50IHRoZSBnZW5lcmF0ZWQgcnVuLXRpbWUgXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uISBcbiAqXG4gKiAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKGRvX25vdF9udWtlX2Vycm9yaW5mb3MpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24uXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBBUEkgaXMgaW52b2tlZCB3aGVuIHRoZSAqKnBhcnNlIHByb2Nlc3MqKiBoYXMgY29tcGxldGVkOiBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcbiAqICAgICAgICAgICAgICAgb2YgdGhlICoqcGFyc2VyKiogKG9yIHRoZSBjYWxsaW5nIHVzZXJsYW5kIGNvZGUpIHRvIGludm9rZSB0aGlzIG1ldGhvZCBvbmNlIGNsZWFudXAgaXMgZGVzaXJlZC4gXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBtYXkgYmUgaW52b2tlZCBieSB1c2VyIGNvZGUgdG8gZW5zdXJlIHRoZSBpbnRlcm5hbCBsZXhlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICpcbiAqICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCwgW3l5XSksXG4gKlxuICpcbiAqICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqXG4gKlxuICogICAgbW9yZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgcmVqZWN0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgcGFzdElucHV0OiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24obiksXG4gKlxuICpcbiAqICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICpcbiAqXG4gKiAgICBuZXh0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqXG4gKlxuICogICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICpcbiAqXG4gKiAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSxcbiAqXG4gKlxuICogICAgcnVsZXM6IFsuLi5dLFxuICpcbiAqXG4gKiAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChgeXlsbG9jYCk6IHtcbiAqICAgIGZpcnN0X2xpbmU6IG4sXG4gKiAgICBsYXN0X2xpbmU6IG4sXG4gKiAgICBmaXJzdF9jb2x1bW46IG4sXG4gKiAgICBsYXN0X2NvbHVtbjogbixcbiAqICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXVxuICogICAgICAgICAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCB6ZXJvLWJhc2VkKVxuICogIH1cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGVycm9yczpcbiAqXG4gKiAge1xuICogICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gKiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICogICAgdG9rZW5faWQ6ICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4gbnVtZXJpYyBJRCwgaWYgYW55KVxuICogICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAqICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICogICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBNQVkgaGF2ZSBhbiBlcnJvciByZWNvdmVyeSBydWxlXG4gKiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlLlxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIGxleGVyLCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsXG4gKiBhdHRlbXB0IHRvIGludm9rZSBgeXkucGFyc2VyLnBhcnNlRXJyb3IoKWA7IHdoZW4gdGhpcyBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWRcbiAqIGl0IHdpbGwgdHJ5IHRvIGludm9rZSBgeXkucGFyc2VFcnJvcigpYCBpbnN0ZWFkLiBXaGVuIHRoYXQgY2FsbGJhY2sgaXMgYWxzbyBub3RcbiAqIHByb3ZpZGVkLCBhIGBKaXNvbkxleGVyRXJyb3JgIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBjb250YWluaW5nIHRoZSBlcnJvclxuICogbWVzc2FnZSBhbmQgYGhhc2hgLCBhcyBjb25zdHJ1Y3RlZCBieSB0aGUgYGNvbnN0cnVjdExleEVycm9ySW5mbygpYCBBUEkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBsZXhlcidzIGBKaXNvbkxleGVyRXJyb3JgIGVycm9yIGNsYXNzIGlzIHBhc3NlZCB2aWEgdGhlXG4gKiBgRXhjZXB0aW9uQ2xhc3NgIGFyZ3VtZW50LCB3aGljaCBpcyBpbnZva2VkIHRvIGNvbnN0cnVjdCB0aGUgZXhjZXB0aW9uXG4gKiBpbnN0YW5jZSB0byBiZSB0aHJvd24sIHNvIHRlY2huaWNhbGx5IGBwYXJzZUVycm9yYCB3aWxsIHRocm93IHRoZSBvYmplY3RcbiAqIHByb2R1Y2VkIGJ5IHRoZSBgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaClgIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgbGV4ZXIgb3B0aW9ucyBieSBzZXR0aW5nIC8gbW9kaWZ5aW5nIHRoZSBgLm9wdGlvbnNgIG9iamVjdCBvZiB5b3VyIExleGVyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqIChPcHRpb25zIGFyZSBwZXJtYW5lbnQuKVxuICogIFxuICogIHl5OiB7XG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgfVxuICpcbiAqICBsZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiBXQVJOSU5HOiB0aGUgbmV4dCBzZXQgb2Ygb3B0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIGNoYW5nZWQuIFRoZXkgZWNobyB0aGUgYWJpbGl0aWVzIG9mXG4gKiB0aGUgbGV4ZXIgYXMgcGVyIHdoZW4gaXQgd2FzIGNvbXBpbGVkIVxuICpcbiAqICAgICAgcmFuZ2VzOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIuXG4gKiAgICAgIGZsZXg6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZFxuICogICAgICAgICAgICAgICAgIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoLlxuICogICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBpbnZva2VkO1xuICogICAgICAgICAgICAgICAgIHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUuXG4gKiAgICAgIHhyZWdleHA6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciBydWxlIHJlZ2V4ZXMgYXJlIFwiZXh0ZW5kZWQgcmVnZXggZm9ybWF0XCIgcmVxdWlyaW5nIHRoZVxuICogICAgICAgICAgICAgICAgIGBYUmVnRXhwYCBsaWJyYXJ5LiBXaGVuIHRoaXMgJW9wdGlvbiBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG5cbnZhciBsZXhlciA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogU2VlIGFsc286XG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0LyMzNTg4MTUwOFxuICAgKiBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHVzZXJsYW5kIGNvZGUgd2hpY2ggbWlnaHQgYWNjZXNzIHRoZSBkZXJpdmVkIGNsYXNzIGluIGEgJ2NsYXNzaWMnIHdheS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIGZ1bmN0aW9uIEppc29uTGV4ZXJFcnJvcihtc2csIGhhc2gpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAnSmlzb25MZXhlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKVxuICAgICAgbXNnID0gJz8/Pyc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG1zZ1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB2YXIgc3RhY2t0cmFjZTtcblxuICAgIGlmIChoYXNoICYmIGhhc2guZXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHZhciBleDIgPSBoYXNoLmV4Y2VwdGlvbjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgIHN0YWNrdHJhY2UgPSBleDIuc3RhY2s7XG4gICAgfVxuXG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHtcbiAgICAgICAgLy8gVjhcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja3RyYWNlID0gbmV3IEVycm9yKG1zZykuc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrdHJhY2UpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzdGFja3RyYWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIH1cblxuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25MZXhlckVycm9yO1xuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25MZXhlckVycm9yJztcblxuICB2YXIgbGV4ZXIgPSB7XG4gICAgXG4vLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vIE9wdGlvbnM6XG4vL1xuLy8gICBiYWNrdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIGxvY2F0aW9uLnJhbmdlczogLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgbG9jYXRpb24gbGluZStjb2x1bW4gdHJhY2tpbmc6IC4uLiB0cnVlXG4vL1xuLy9cbi8vIEZvcndhcmRlZCBQYXJzZXIgQW5hbHlzaXMgZmxhZ3M6XG4vL1xuLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgbGV4ZXIgdmFsdWVzOiAuLi4uLi4uLi4uLi4uLi4gdHJ1ZSAvIHRydWVcbi8vICAgbG9jYXRpb24gdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLiB0cnVlXG4vLyAgIGxvY2F0aW9uIGFzc2lnbm1lbnQ6IC4uLi4uLi4uLi4uLi4gdHJ1ZVxuLy9cbi8vXG4vLyBMZXhlciBBbmFseXNpcyBmbGFnczpcbi8vXG4vLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXl0ZXh0OiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgUGFyc2VFcnJvciBBUEk6IC4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgeXllcnJvcjogLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgbG9jYXRpb24gdHJhY2tpbmcgJiBlZGl0aW5nOiAgPz8/XG4vLyAgIHVzZXMgbW9yZSgpIEFQSTogLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgdW5wdXQoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgcmVqZWN0KCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgbGVzcygpIEFQSTogLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgZGlzcGxheSBBUElzIHBhc3RJbnB1dCgpLCB1cGNvbWluZ0lucHV0KCksIHNob3dQb3NpdGlvbigpOlxuLy8gICAgICAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGRlc2NyaWJlWVlMTE9DKCkgQVBJOiAuLi4uLi4uID8/P1xuLy9cbi8vIC0tLS0tLS0tLSBFTkQgT0YgUkVQT1JUIC0tLS0tLS0tLS0tXG5cbkVPRjogMSxcbiAgICBFUlJPUjogMixcblxuICAgIC8vIEppc29uTGV4ZXJFcnJvcjogSmlzb25MZXhlckVycm9yLCAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSB0aGUgY29kZSBnZW5lcmF0b3JcblxuICAgIC8vIG9wdGlvbnM6IHt9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSB0aGUgY29kZSBnZW5lcmF0b3JcblxuICAgIC8vIHl5OiAuLi4sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIDwtLSBpbmplY3RlZCBieSBzZXRJbnB1dCgpXG5cbiAgICBfX2N1cnJlbnRSdWxlU2V0X186IG51bGwsICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogaW50ZXJuYWwgcnVsZSBzZXQgY2FjaGUgZm9yIHRoZSBjdXJyZW50IGxleGVyIHN0YXRlICBcblxuICAgIF9fZXJyb3JfaW5mb3M6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiB0aGUgc2V0IG9mIGxleEVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cCAgXG4gICAgX19kZWNvbXByZXNzZWQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IG1hcmsgd2hldGhlciB0aGUgbGV4ZXIgaW5zdGFuY2UgaGFzIGJlZW4gJ3VuZm9sZGVkJyBjb21wbGV0ZWx5IGFuZCBpcyBub3cgcmVhZHkgZm9yIHVzZSAgXG4gICAgZG9uZTogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9iYWNrdHJhY2s6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfaW5wdXQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX21vcmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9zaWduYWxlZF9lcnJvcl90b2tlbjogZmFsc2UsICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBjb25kaXRpb25TdGFjazogW10sICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTsgbWFuYWdlZCB2aWEgYHB1c2hTdGF0ZSgpYCwgYHBvcFN0YXRlKClgLCBgdG9wU3RhdGUoKWAgYW5kIGBzdGF0ZVN0YWNrU2l6ZSgpYCAgXG4gICAgbWF0Y2g6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBsZXhlciB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24uIGBtYXRjaGAgaXMgaWRlbnRpY2FsIHRvIGB5eXRleHRgIGV4Y2VwdCB0aGF0IHRoaXMgb25lIHN0aWxsIGNvbnRhaW5zIHRoZSBtYXRjaGVkIGlucHV0IHN0cmluZyBhZnRlciBgbGV4ZXIucGVyZm9ybUFjdGlvbigpYCBoYXMgYmVlbiBpbnZva2VkLCB3aGVyZSB1c2VybGFuZCBjb2RlIE1BWSBoYXZlIGNoYW5nZWQvcmVwbGFjZWQgdGhlIGB5eXRleHRgIHZhbHVlIGVudGlyZWx5ISAgXG4gICAgbWF0Y2hlZDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgZW50aXJlIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyICBcbiAgICBtYXRjaGVzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBSRSBtYXRjaCByZXN1bHQgZm9yIGxhc3QgKHN1Y2Nlc3NmdWwpIG1hdGNoIGF0dGVtcHQgIFxuICAgIHl5dGV4dDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBsZXhlciB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb247IHRoaXMgdmFsdWUgaXMgdHJhbnNmZXJyZWQgdG8gdGhlIHBhcnNlciBhcyB0aGUgJ3Rva2VuIHZhbHVlJyB3aGVuIHRoZSBwYXJzZXIgY29uc3VtZXMgdGhlIGxleGVyIHRva2VuIHByb2R1Y2VkIHRocm91Z2ggYSBjYWxsIHRvIHRoZSBgbGV4KClgIEFQSS4gIFxuICAgIG9mZnNldDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIHRoZSAnY3Vyc29yIHBvc2l0aW9uJyBpbiB0aGUgaW5wdXQgc3RyaW5nLCBpLmUuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBtYXRjaGVkIHNvIGZhciAgXG4gICAgeXlsZW5nOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiBsZW5ndGggb2YgbWF0Y2hlZCBpbnB1dCBmb3IgdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiAoYHl5dGV4dGApICBcbiAgICB5eWxpbmVubzogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6ICdsaW5lIG51bWJlcicgYXQgd2hpY2ggdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiBpcyBsb2NhdGVkICBcbiAgICB5eWxsb2M6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBsb2NhdGlvbiBpbmZvIChsaW5lcyArIGNvbHVtbnMpIGZvciB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uICBcblxuICAgIC8qKlxuICAgICAqIElOVEVSTkFMIFVTRTogY29uc3RydWN0IGEgc3VpdGFibGUgZXJyb3IgaW5mbyBoYXNoIG9iamVjdCBpbnN0YW5jZSBmb3IgYHBhcnNlRXJyb3JgLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY29uc3RydWN0TGV4RXJyb3JJbmZvOiBmdW5jdGlvbiBsZXhlcl9jb25zdHJ1Y3RMZXhFcnJvckluZm8obXNnLCByZWNvdmVyYWJsZSkge1xuICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgZXJyU3RyOiBtc2csXG4gICAgICAgIHJlY292ZXJhYmxlOiAhIXJlY292ZXJhYmxlLFxuICAgICAgICB0ZXh0OiB0aGlzLm1hdGNoLCAgICAgICAgICAgLy8gVGhpcyBvbmUgTUFZIGJlIGVtcHR5OyB1c2VybGFuZCBjb2RlIHNob3VsZCB1c2UgdGhlIGB1cGNvbWluZ0lucHV0YCBBUEkgdG8gb2J0YWluIG1vcmUgdGV4dCB3aGljaCBmb2xsb3dzIHRoZSAnbGV4ZXIgY3Vyc29yIHBvc2l0aW9uJy4uLiAgXG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICBsb2M6IHRoaXMueXlsbG9jLFxuICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgbGV4ZXI6IHRoaXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuZCBtYWtlIHN1cmUgdGhlIGVycm9yIGluZm8gZG9lc24ndCBzdGF5IGR1ZSB0byBwb3RlbnRpYWxcbiAgICAgICAgICogcmVmIGN5Y2xlIHZpYSB1c2VybGFuZCBjb2RlIG1hbmlwdWxhdGlvbnMuXG4gICAgICAgICAqIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICogXG4gICAgICAgICAqIE5vdGUgdGhhdCBvbmx5IGFycmF5IGFuZCBvYmplY3QgcmVmZXJlbmNlcyBhcmUgbnVrZWQgYXMgdGhvc2VcbiAgICAgICAgICogY29uc3RpdHV0ZSB0aGUgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGNhbiBwcm9kdWNlIGEgY3ljbGljIHJlZi5cbiAgICAgICAgICogVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEB0aGlzIHtMZXhFcnJvckluZm99XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdExleEVycm9ySW5mbygpIHtcbiAgICAgICAgICAvLyByZW1vdmUgY3ljbGljIHJlZmVyZW5jZXMgYWRkZWQgdG8gZXJyb3IgaW5mbzpcbiAgICAgICAgICAvLyBpbmZvLnl5ID0gbnVsbDtcbiAgICAgICAgICAvLyBpbmZvLmxleGVyID0gbnVsbDtcbiAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICB2YXIgcmVjID0gISF0aGlzLnJlY292ZXJhYmxlO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5wdXNoKHBlaSk7XG5cbiAgICAgIHJldHVybiBwZWk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXIgd2hpY2ggaXMgaW52b2tlZCB3aGVuIGEgbGV4ZXIgZXJyb3Igb2NjdXJzLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gbGV4ZXJfcGFyc2VFcnJvcihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvbkxleGVyRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5KSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlciAmJiB0eXBlb2YgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHx8IHRoaXMuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZCB3aGljaCBpbXBsZW1lbnRzIGB5eWVycm9yKHN0ciwgLi4uYXJncylgIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZSBpbnNpZGUgbGV4ZXIgYWN0aW9ucy5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHl5ZXJyb3I6IGZ1bmN0aW9uIHl5RXJyb3Ioc3RyIC8qLCAuLi5hcmdzICovKSB7XG4gICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6ICcgKyBzdHIsXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZXhlckVycm9yc0FyZVJlY292ZXJhYmxlXG4gICAgICApO1xuXG4gICAgICAvLyBBZGQgYW55IGV4dHJhIGFyZ3MgdG8gdGhlIGhhc2ggdW5kZXIgdGhlIG5hbWUgYGV4dHJhX2Vycm9yX2F0dHJpYnV0ZXNgOlxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcC5leHRyYV9lcnJvcl9hdHRyaWJ1dGVzID0gYXJncztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmFsIGNsZWFudXAgZnVuY3Rpb24gZm9yIHdoZW4gd2UgaGF2ZSBjb21wbGV0ZWQgbGV4aW5nIHRoZSBpbnB1dDtcbiAgICAgKiBtYWtlIGl0IGFuIEFQSSBzbyB0aGF0IGV4dGVybmFsIGNvZGUgY2FuIHVzZSB0aGlzIG9uZSBvbmNlIHVzZXJsYW5kXG4gICAgICogY29kZSBoYXMgZGVjaWRlZCBpdCdzIHRpbWUgdG8gZGVzdHJveSBhbnkgbGluZ2VyaW5nIGxleGVyIGVycm9yXG4gICAgICogaGFzaCBvYmplY3QgaW5zdGFuY2VzIGFuZCB0aGUgbGlrZTogdGhpcyBmdW5jdGlvbiBoZWxwcyB0byBjbGVhblxuICAgICAqIHVwIHRoZXNlIGNvbnN0cnVjdHMsIHdoaWNoICptYXkqIGNhcnJ5IGN5Y2xpYyByZWZlcmVuY2VzIHdoaWNoIHdvdWxkXG4gICAgICogb3RoZXJ3aXNlIHByZXZlbnQgdGhlIGluc3RhbmNlcyBmcm9tIGJlaW5nIHByb3Blcmx5IGFuZCB0aW1lbHlcbiAgICAgKiBnYXJiYWdlLWNvbGxlY3RlZCwgaS5lLiB0aGlzIGZ1bmN0aW9uIGhlbHBzIHByZXZlbnQgbWVtb3J5IGxlYWtzIVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2xlYW51cEFmdGVyTGV4OiBmdW5jdGlvbiBsZXhlcl9jbGVhbnVwQWZ0ZXJMZXgoZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgLy8gcHJldmVudCBsaW5nZXJpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBmcm9tIGNhdXNpbmcgbWVtb3J5IGxlYWtzOlxuICAgICAgdGhpcy5zZXRJbnB1dCgnJywge30pO1xuXG4gICAgICAvLyBudWtlIHRoZSBlcnJvciBoYXNoIGluZm8gaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcnVuLlxuICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgLy8gaW4gdGhlIGVycm9yIGhhc2ggaW5zdGFuY2UocykgaXQgaXMgbW9yZSBwZXJtYW5lbnRseSBpbnRlcmVzdGVkIGluLlxuICAgICAgaWYgKCFkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9fZXJyb3JfaW5mb3NbaV07XG5cbiAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNsZWFyIHRoZSBsZXhlciB0b2tlbiBjb250ZXh0OyBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiBsZXhlcl9jbGVhcigpIHtcbiAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICB0aGlzLm1hdGNoID0gJyc7XG5cbiAgICAgIC8vIC0gRE8gTk9UIHJlc2V0IGB0aGlzLm1hdGNoZWRgXG4gICAgICB0aGlzLm1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB2YXIgY29sID0gKHRoaXMueXlsbG9jID8gdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gOiAwKTtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICBmaXJzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgbGFzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgcmFuZ2U6IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXRdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc2V0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3NldElucHV0KGlucHV0LCB5eSkge1xuICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG5cbiAgICAgIC8vIGFsc28gY2hlY2sgaWYgd2UndmUgZnVsbHkgaW5pdGlhbGl6ZWQgdGhlIGxleGVyIGluc3RhbmNlLFxuICAgICAgLy8gaW5jbHVkaW5nIGV4cGFuc2lvbiB3b3JrIHRvIGJlIGRvbmUgdG8gZ28gZnJvbSBhIGxvYWRlZFxuICAgICAgLy8gbGV4ZXIgdG8gYSB1c2FibGUgbGV4ZXI6XG4gICAgICBpZiAoIXRoaXMuX19kZWNvbXByZXNzZWQpIHtcbiAgICAgICAgLy8gc3RlcCAxOiBkZWNvbXByZXNzIHRoZSByZWdleCBsaXN0OlxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBydWxlX3JlID0gcnVsZXNbaV07XG5cbiAgICAgICAgICAvLyBjb21wcmVzc2lvbjogaXMgdGhlIFJFIGFuIHhyZWYgdG8gYW5vdGhlciBSRSBzbG90IGluIHRoZSBydWxlc1tdIHRhYmxlP1xuICAgICAgICAgIGlmICh0eXBlb2YgcnVsZV9yZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJ1bGVzW2ldID0gcnVsZXNbcnVsZV9yZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RlcCAyOiB1bmZvbGQgdGhlIGNvbmRpdGlvbnNbXSBzZXQgdG8gbWFrZSB0aGVzZSByZWFkeSBmb3IgdXNlOlxuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IHRoaXMuY29uZGl0aW9ucztcblxuICAgICAgICBmb3IgKHZhciBrIGluIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc3BlYyA9IGNvbmRpdGlvbnNba107XG4gICAgICAgICAgdmFyIHJ1bGVfaWRzID0gc3BlYy5ydWxlcztcbiAgICAgICAgICB2YXIgbGVuID0gcnVsZV9pZHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBydWxlX3JlZ2V4ZXMgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgIC8vIHNsb3QgMCBpcyB1bnVzZWQ7IHdlIHVzZSBhIDEtYmFzZWQgaW5kZXggYXBwcm9hY2ggaGVyZSB0byBrZWVwIHRoZSBob3R0ZXN0IGNvZGUgaW4gYGxleGVyX25leHQoKWAgZmFzdCBhbmQgc2ltcGxlISBcbiAgICAgICAgICB2YXIgcnVsZV9uZXdfaWRzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHJ1bGVfaWRzW2ldO1xuICAgICAgICAgICAgdmFyIHJ1bGVfcmUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgcnVsZV9yZWdleGVzW2kgKyAxXSA9IHJ1bGVfcmU7XG4gICAgICAgICAgICBydWxlX25ld19pZHNbaSArIDFdID0gaWR4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwZWMucnVsZXMgPSBydWxlX25ld19pZHM7XG4gICAgICAgICAgc3BlYy5fX3J1bGVfcmVnZXhlcyA9IHJ1bGVfcmVnZXhlcztcbiAgICAgICAgICBzcGVjLl9fcnVsZV9jb3VudCA9IGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19kZWNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8ICcnO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy55eWxpbmVubyA9IDA7XG4gICAgICB0aGlzLm1hdGNoZWQgPSAnJztcbiAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogMCxcbiAgICAgICAgcmFuZ2U6IFswLCAwXVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVkaXQgdGhlIHJlbWFpbmluZyBpbnB1dCB2aWEgdXNlci1zcGVjaWZpZWQgY2FsbGJhY2suXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBmb3J3YXJkLWFkanVzdCB0aGUgaW5wdXQtdG8tcGFyc2UsIFxuICAgICAqIGUuZy4gaW5zZXJ0aW5nIG1hY3JvIGV4cGFuc2lvbnMgYW5kIGFsaWtlIGluIHRoZVxuICAgICAqIGlucHV0IHdoaWNoIGhhcyB5ZXQgdG8gYmUgbGV4ZWQuXG4gICAgICogVGhlIGJlaGF2aW91ciBvZiB0aGlzIEFQSSBjb250cmFzdHMgdGhlIGB1bnB1dCgpYCBldCBhbFxuICAgICAqIEFQSXMgYXMgdGhvc2UgYWN0IG9uIHRoZSAqY29uc3VtZWQqIGlucHV0LCB3aGlsZSB0aGlzXG4gICAgICogb25lIGFsbG93cyBvbmUgdG8gbWFuaXB1bGF0ZSB0aGUgZnV0dXJlLCB3aXRob3V0IGltcGFjdGluZ1xuICAgICAqIHRoZSBjdXJyZW50IGB5eWxvY2AgY3Vyc29yIGxvY2F0aW9uIG9yIGFueSBoaXN0b3J5LiBcbiAgICAgKiBcbiAgICAgKiBVc2UgdGhpcyBBUEkgdG8gaGVscCBpbXBsZW1lbnQgQy1wcmVwcm9jZXNzb3ItbGlrZVxuICAgICAqIGAjaW5jbHVkZWAgc3RhdGVtZW50cywgZXRjLlxuICAgICAqIFxuICAgICAqIFRoZSBwcm92aWRlZCBjYWxsYmFjayBtdXN0IGJlIHN5bmNocm9ub3VzIGFuZCBpc1xuICAgICAqIGV4cGVjdGVkIHRvIHJldHVybiB0aGUgZWRpdGVkIGlucHV0IChzdHJpbmcpLlxuICAgICAqXG4gICAgICogVGhlIGBjcHNBcmdgIGFyZ3VtZW50IHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKiBhcy1pcy5cbiAgICAgKlxuICAgICAqIGBjYWxsYmFja2AgaW50ZXJmYWNlOiBcbiAgICAgKiBgZnVuY3Rpb24gY2FsbGJhY2soaW5wdXQsIGNwc0FyZylgXG4gICAgICogXG4gICAgICogLSBgaW5wdXRgIHdpbGwgY2FycnkgdGhlIHJlbWFpbmluZy1pbnB1dC10by1sZXggc3RyaW5nXG4gICAgICogICBmcm9tIHRoZSBsZXhlci5cbiAgICAgKiAtIGBjcHNBcmdgIGlzIGBjcHNBcmdgIHBhc3NlZCBpbnRvIHRoaXMgQVBJLlxuICAgICAqIFxuICAgICAqIFRoZSBgdGhpc2AgcmVmZXJlbmNlIGZvciB0aGUgY2FsbGJhY2sgd2lsbCBiZSBzZXQgdG9cbiAgICAgKiByZWZlcmVuY2UgdGhpcyBsZXhlciBpbnN0YW5jZSBzbyB0aGF0IHVzZXJsYW5kIGNvZGVcbiAgICAgKiBpbiB0aGUgY2FsbGJhY2sgY2FuIGVhc2lseSBhbmQgcXVpY2tseSBhY2Nlc3MgYW55IGxleGVyXG4gICAgICogQVBJLiBcbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgZmFsc2V5IHZhbHVlLFxuICAgICAqIHdlIGFzc3VtZSB0aGUgY2FsbGJhY2sgZGlkIG5vdCBlZGl0IHRoZSBpbnB1dCBhbmQgd2VcbiAgICAgKiB3aWxsIHVzaW5nIHRoZSBpbnB1dCBhcy1pcy5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgdmFsdWUsIGl0XG4gICAgICogaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGZvciBsZXhpbmcgdmlhIHRoZSBgXCJcIiArIHJldHZhbGBcbiAgICAgKiBvcGVyYXRpb24uIChTZWUgYWxzbyB3aHk6IGh0dHA6Ly8yYWxpdHkuY29tLzIwMTIvMDMvY29udmVydGluZy10by1zdHJpbmcuaHRtbCBcbiAgICAgKiAtLSB0aGF0IHdheSBhbnkgcmV0dXJuZWQgb2JqZWN0J3MgYHRvVmFsdWUoKWAgYW5kIGB0b1N0cmluZygpYFxuICAgICAqIG1ldGhvZHMgd2lsbCBiZSBpbnZva2VkIGluIGEgcHJvcGVyL2Rlc2lyYWJsZSBvcmRlci4pXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBlZGl0UmVtYWluaW5nSW5wdXQ6IGZ1bmN0aW9uIGxleGVyX2VkaXRSZW1haW5pbmdJbnB1dChjYWxsYmFjaywgY3BzQXJnKSB7XG4gICAgICB2YXIgcnYgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2lucHV0LCBjcHNBcmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocnYpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9ICcnICsgcnY7XG4gICAgICAgIH0gXG4gICAgICAgIC8vIGVsc2U6IGtlZXAgYHRoaXMuX2lucHV0YCBhcyBpcy4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBydjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBpbnB1dDogZnVuY3Rpb24gbGV4ZXJfaW5wdXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIC8vdGhpcy5kb25lID0gdHJ1ZTsgICAgLS0gZG9uJ3Qgc2V0IGBkb25lYCBhcyB3ZSB3YW50IHRoZSBsZXgoKS9uZXh0KCkgQVBJIHRvIGJlIGFibGUgdG8gcHJvZHVjZSBvbmUgY3VzdG9tIEVPRiB0b2tlbiBtYXRjaCBhZnRlciB0aGlzIGFueWhvdy4gKGxleGVyIGNhbiBtYXRjaCBzcGVjaWFsIDw8RU9GPj4gdG9rZW5zIGFuZCBwZXJmb3JtIHVzZXIgYWN0aW9uIGNvZGUgZm9yIGEgPDxFT0Y+PiBtYXRjaCwgYnV0IG9ubHkgZG9lcyBzbyAqb25jZSopXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuXG4gICAgICAvLyBDb3VudCB0aGUgbGluZW51bWJlciB1cCB3aGVuIHdlIGhpdCB0aGUgTEYgKG9yIGEgc3RhbmQtYWxvbmUgQ1IpLlxuICAgICAgLy8gT24gQ1JMRiwgdGhlIGxpbmVudW1iZXIgaXMgaW5jcmVtZW50ZWQgd2hlbiB5b3UgZmV0Y2ggdGhlIENSIG9yIHRoZSBDUkxGIGNvbWJvXG4gICAgICAvLyBhbmQgd2UgYWR2YW5jZSBpbW1lZGlhdGVseSBwYXN0IHRoZSBMRiBhcyB3ZWxsLCByZXR1cm5pbmcgYm90aCB0b2dldGhlciBhcyBpZlxuICAgICAgLy8gaXQgd2FzIGFsbCBhIHNpbmdsZSAnY2hhcmFjdGVyJyBvbmx5LlxuICAgICAgdmFyIHNsaWNlX2xlbiA9IDE7XG5cbiAgICAgIHZhciBsaW5lcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNoMiA9IHRoaXMuX2lucHV0WzFdO1xuXG4gICAgICAgIGlmIChjaDIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgc2xpY2VfbGVuKys7XG4gICAgICAgICAgY2ggKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDI7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShzbGljZV9sZW4pO1xuICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYW4gZW50aXJlIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHVucHV0OiBmdW5jdGlvbiBsZXhlcl91bnB1dChjaCkge1xuICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gbGVuKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vICsgMTtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMubWF0Y2g7XG4gICAgICAgIHZhciBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICBpZiAocHJlX2xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHByZSA9IHRoaXMubWF0Y2hlZDtcbiAgICAgICAgICBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gcHJlX2xpbmVzW3ByZV9saW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiAtPSBsZW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdID0gdGhpcy55eWxsb2MucmFuZ2VbMF0gKyB0aGlzLnl5bGVuZztcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhY2hlIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kIGl0IG9uIG5leHQgYWN0aW9uXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBtb3JlOiBmdW5jdGlvbiBsZXhlcl9tb3JlKCkge1xuICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2lnbmFsIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZVxuICAgICAqIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHJlamVjdDogZnVuY3Rpb24gbGV4ZXJfcmVqZWN0KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIGBwYXJzZUVycm9yKClgIGNhbGwgcmV0dXJucywgd2UgTVVTVCBlbnN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgcmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2UgYWNjb21wbGlzaCB0aGlzIGJ5IHNpZ25hbGluZyBhbiAnZXJyb3InIHRva2VuIHRvIGJlIHByb2R1Y2VkIGZvciB0aGUgY3VycmVudFxuICAgICAgICAvLyBgLmxleCgpYCBydW4uXG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3Nfc3RyID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHBvc19zdHIgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLicgKyBwb3Nfc3RyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxlc3M6IGZ1bmN0aW9uIGxleGVyX2xlc3Mobikge1xuICAgICAgcmV0dXJuIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3JcbiAgICAgKiBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZlxuICAgICAqIGlucHV0IChkZWZhdWx0OiAxKS5cbiAgICAgKiBcbiAgICAgKiBOZWdhdGl2ZSBsaW1pdCB2YWx1ZXMgZXF1YWwgKnVubGltaXRlZCouXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3Bhc3RJbnB1dChtYXhTaXplLCBtYXhMaW5lcykge1xuICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyaW5nKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IHBhc3QubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBwYXN0Lmxlbmd0aDsgICAgICAgICAgLy8gY2FuJ3QgZXZlciBoYXZlIG1vcmUgaW5wdXQgbGluZXMgdGhhbiB0aGlzISBcbiAgICAgIGVsc2UgaWYgKCFtYXhMaW5lcylcbiAgICAgICAgbWF4TGluZXMgPSAxO1xuXG4gICAgICAvLyBgc3Vic3RyYCBhbnRpY2lwYXRpb246IHRyZWF0IFxcclxcbiBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRha2UgYSBsaXR0bGVcbiAgICAgIC8vIG1vcmUgdGhhbiBuZWNlc3Nhcnkgc28gdGhhdCB3ZSBjYW4gc3RpbGwgcHJvcGVybHkgY2hlY2sgYWdhaW5zdCBtYXhTaXplXG4gICAgICAvLyBhZnRlciB3ZSd2ZSB0cmFuc2Zvcm1lZCBhbmQgbGltaXRlZCB0aGUgbmV3TGluZXMgaW4gaGVyZTpcbiAgICAgIHBhc3QgPSBwYXN0LnN1YnN0cigtbWF4U2l6ZSAqIDIgLSAyKTtcblxuICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSBhIHNpZ25pZmljYW50bHkgcmVkdWNlZCBzdHJpbmcgdG8gcHJvY2VzcywgdHJhbnNmb3JtIHRoZSBuZXdsaW5lc1xuICAgICAgLy8gYW5kIGNob3AgdGhlbSwgdGhlbiBsaW1pdCB0aGVtOlxuICAgICAgdmFyIGEgPSBwYXN0LnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgYSA9IGEuc2xpY2UoLW1heExpbmVzKTtcbiAgICAgIHBhc3QgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcHJlZml4Li4uXG4gICAgICBpZiAocGFzdC5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgICAgIHBhc3QgPSAnLi4uJyArIHBhc3Quc3Vic3RyKC1tYXhTaXplKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZiBpbnB1dCAoZGVmYXVsdDogMSkuXG4gICAgICogXG4gICAgICogTmVnYXRpdmUgbGltaXQgdmFsdWVzIGVxdWFsICp1bmxpbWl0ZWQqLlxuICAgICAqXG4gICAgICogPiAjIyMgTk9URSAjIyNcbiAgICAgKiA+XG4gICAgICogPiAqXCJ1cGNvbWluZyBpbnB1dFwiKiBpcyBkZWZpbmVkIGFzIHRoZSB3aG9sZSBvZiB0aGUgYm90aFxuICAgICAqID4gdGhlICpjdXJyZW50bHkgbGV4ZWQqIGlucHV0LCB0b2dldGhlciB3aXRoIGFueSByZW1haW5pbmcgaW5wdXRcbiAgICAgKiA+IGZvbGxvd2luZyB0aGF0LiAqXCJjdXJyZW50bHkgbGV4ZWRcIiogaW5wdXQgaXMgdGhlIGlucHV0IFxuICAgICAqID4gYWxyZWFkeSByZWNvZ25pemVkIGJ5IHRoZSBsZXhlciBidXQgbm90IHlldCByZXR1cm5lZCB3aXRoXG4gICAgICogPiB0aGUgbGV4ZXIgdG9rZW4uIFRoaXMgaGFwcGVucyB3aGVuIHlvdSBhcmUgaW52b2tpbmcgdGhpcyBBUElcbiAgICAgKiA+IGZyb20gaW5zaWRlIGFueSBsZXhlciBydWxlIGFjdGlvbiBjb2RlIGJsb2NrLiBcbiAgICAgKiA+XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiBsZXhlcl91cGNvbWluZ0lucHV0KG1heFNpemUsIG1heExpbmVzKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IG5leHQubGVuZ3RoICsgdGhpcy5faW5wdXQubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBtYXhTaXplOyAgICAgICAgICAvLyBjYW4ndCBldmVyIGhhdmUgbW9yZSBpbnB1dCBsaW5lcyB0aGFuIHRoaXMhIFxuICAgICAgZWxzZSBpZiAoIW1heExpbmVzKVxuICAgICAgICBtYXhMaW5lcyA9IDE7XG5cbiAgICAgIC8vIGBzdWJzdHJpbmdgIGFudGljaXBhdGlvbjogdHJlYXQgXFxyXFxuIGFzIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGFrZSBhIGxpdHRsZVxuICAgICAgLy8gbW9yZSB0aGFuIG5lY2Vzc2FyeSBzbyB0aGF0IHdlIGNhbiBzdGlsbCBwcm9wZXJseSBjaGVjayBhZ2FpbnN0IG1heFNpemVcbiAgICAgIC8vIGFmdGVyIHdlJ3ZlIHRyYW5zZm9ybWVkIGFuZCBsaW1pdGVkIHRoZSBuZXdMaW5lcyBpbiBoZXJlOlxuICAgICAgaWYgKG5leHQubGVuZ3RoIDwgbWF4U2l6ZSAqIDIgKyAyKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKDAsIG1heFNpemUgKiAyICsgMik7ICAgLy8gc3Vic3RyaW5nIGlzIGZhc3RlciBvbiBDaHJvbWUvVjggXG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYSBzaWduaWZpY2FudGx5IHJlZHVjZWQgc3RyaW5nIHRvIHByb2Nlc3MsIHRyYW5zZm9ybSB0aGUgbmV3bGluZXNcbiAgICAgIC8vIGFuZCBjaG9wIHRoZW0sIHRoZW4gbGltaXQgdGhlbTpcbiAgICAgIHZhciBhID0gbmV4dC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGEgPSBhLnNsaWNlKDAsIG1heExpbmVzKTtcbiAgICAgIG5leHQgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcG9zdGZpeC4uLlxuICAgICAgaWYgKG5leHQubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5zdWJzdHJpbmcoMCwgbWF4U2l6ZSkgKyAnLi4uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHN0cmluZyB3aGljaCBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gbGV4ZXJfc2hvd1Bvc2l0aW9uKG1heFByZWZpeCwgbWF4UG9zdGZpeCkge1xuICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KG1heFByZWZpeCkucmVwbGFjZSgvXFxzL2csICcgJyk7XG4gICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbignLScpO1xuICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dChtYXhQb3N0Zml4KS5yZXBsYWNlKC9cXHMvZywgJyAnKSArICdcXG4nICsgYyArICdeJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgc3RyaW5nIHdoaWNoIGRpc3BsYXlzIHRoZSBsaW5lcyAmIGNvbHVtbnMgb2YgaW5wdXQgd2hpY2ggYXJlIHJlZmVyZW5jZWQgXG4gICAgICogYnkgdGhlIGdpdmVuIGxvY2F0aW9uIGluZm8gcmFuZ2UsIHBsdXMgYSBmZXcgbGluZXMgb2YgY29udGV4dC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByZXR0eS1wcmludHMgdGhlIGluZGljYXRlZCBzZWN0aW9uIG9mIHRoZSBpbnB1dCwgd2l0aCBsaW5lIG51bWJlcnMgXG4gICAgICogYW5kIGV2ZXJ5dGhpbmchXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHVzZWZ1bCB0byBwcm92aWRlIGhpZ2hseSByZWFkYWJsZSBlcnJvciByZXBvcnRzLCB3aGlsZVxuICAgICAqIHRoZSBsb2NhdGlvbiByYW5nZSBtYXkgYmUgc3BlY2lmaWVkIGluIHZhcmlvdXMgZmxleGlibGUgd2F5czpcbiAgICAgKiBcbiAgICAgKiAtIGBsb2NgIGlzIHRoZSBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGljaCByZWZlcmVuY2VzIHRoZSBhcmVhIHdoaWNoIHNob3VsZCBiZVxuICAgICAqICAgZGlzcGxheWVkIGFuZCAnbWFya2VkIHVwJzogdGhlc2UgbGluZXMgJiBjb2x1bW5zIG9mIHRleHQgYXJlIG1hcmtlZCB1cCBieSBgXmBcbiAgICAgKiAgIGNoYXJhY3RlcnMgYmVsb3cgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGVudGlyZSBpbnB1dCByYW5nZS5cbiAgICAgKiBcbiAgICAgKiAtIGBjb250ZXh0X2xvY2AgaXMgdGhlICpvcHRpb25hbCogbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hpY2ggaW5zdHJ1Y3RzIHRoaXNcbiAgICAgKiAgIHByZXR0eS1wcmludGVyIGhvdyBtdWNoICpsZWFkaW5nKiBjb250ZXh0IHNob3VsZCBiZSBkaXNwbGF5ZWQgYWxvbmdzaWRlXG4gICAgICogICB0aGUgYXJlYSByZWZlcmVuY2VkIGJ5IGBsb2NgLiBUaGlzIGNhbiBoZWxwIHByb3ZpZGUgY29udGV4dCBmb3IgdGhlIGRpc3BsYXllZFxuICAgICAqICAgZXJyb3IsIGV0Yy5cbiAgICAgKiBcbiAgICAgKiAgIFdoZW4gdGhpcyBsb2NhdGlvbiBpbmZvIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbnRleHQgb2YgMyBsaW5lcyBpc1xuICAgICAqICAgdXNlZC5cbiAgICAgKiBcbiAgICAgKiAtIGBjb250ZXh0X2xvYzJgIGlzIGFub3RoZXIgKm9wdGlvbmFsKiBsb2NhdGlvbiBpbmZvIG9iamVjdCwgd2hpY2ggc2VydmVzXG4gICAgICogICBhIHNpbWlsYXIgcHVycG9zZSB0byBgY29udGV4dF9sb2NgOiBpdCBzcGVjaWZpZXMgdGhlIGFtb3VudCBvZiAqdHJhaWxpbmcqXG4gICAgICogICBjb250ZXh0IGxpbmVzIHRvIGRpc3BsYXkgaW4gdGhlIHByZXR0eS1wcmludCBvdXRwdXQuXG4gICAgICogXG4gICAgICogICBXaGVuIHRoaXMgbG9jYXRpb24gaW5mbyBpcyBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBjb250ZXh0IG9mIDEgbGluZSBvbmx5IGlzXG4gICAgICogICB1c2VkLlxuICAgICAqIFxuICAgICAqIFNwZWNpYWwgTm90ZXM6XG4gICAgICogXG4gICAgICogLSB3aGVuIHRoZSBgbG9jYC1pbmRpY2F0ZWQgcmFuZ2UgaXMgdmVyeSBsYXJnZSAoYWJvdXQgNSBsaW5lcyBvciBtb3JlKSwgdGhlblxuICAgICAqICAgb25seSB0aGUgZmlyc3QgYW5kIGxhc3QgZmV3IGxpbmVzIG9mIHRoaXMgYmxvY2sgYXJlIHByaW50ZWQgd2hpbGUgYVxuICAgICAqICAgYC4uLmNvbnRpbnVlZC4uLmAgbWVzc2FnZSB3aWxsIGJlIHByaW50ZWQgYmV0d2VlbiB0aGVtLlxuICAgICAqIFxuICAgICAqICAgVGhpcyBzZXJ2ZXMgdGhlIHB1cnBvc2Ugb2Ygbm90IHByaW50aW5nIGEgaHVnZSBhbW91bnQgb2YgdGV4dCB3aGVuIHRoZSBgbG9jYFxuICAgICAqICAgcmFuZ2UgaGFwcGVucyB0byBiZSBodWdlOiB0aGlzIHdheSBhIG1hbmFnZWFibGUgJiByZWFkYWJsZSBvdXRwdXQgcmVzdWx0c1xuICAgICAqICAgZm9yIGFyYml0cmFyeSBsYXJnZSByYW5nZXMuXG4gICAgICogXG4gICAgICogLSB0aGlzIGZ1bmN0aW9uIGNhbiBkaXNwbGF5IGxpbmVzIG9mIGlucHV0IHdoaWNoIHdoYXZlIG5vdCB5ZXQgYmVlbiBsZXhlZC5cbiAgICAgKiAgIGBwcmV0dHlQcmludFJhbmdlKClgIGNhbiBhY2Nlc3MgdGhlIGVudGlyZSBpbnB1dCFcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHByZXR0eVByaW50UmFuZ2U6IGZ1bmN0aW9uIGxleGVyX3ByZXR0eVByaW50UmFuZ2UobG9jLCBjb250ZXh0X2xvYywgY29udGV4dF9sb2MyKSB7XG4gICAgICB2YXIgZXJyb3Jfc2l6ZSA9IGxvYy5sYXN0X2xpbmUgLSBsb2MuZmlyc3RfbGluZTtcbiAgICAgIGNvbnN0IENPTlRFWFQgPSAzO1xuICAgICAgY29uc3QgQ09OVEVYVF9UQUlMID0gMTtcbiAgICAgIGNvbnN0IE1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UID0gMjtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMubWF0Y2hlZCArIHRoaXMuX2lucHV0O1xuICAgICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAvL3ZhciBzaG93X2NvbnRleHQgPSAoZXJyb3Jfc2l6ZSA8IDUgfHwgY29udGV4dF9sb2MpO1xuICAgICAgdmFyIGwwID0gTWF0aC5tYXgoMSwgKGNvbnRleHRfbG9jID8gY29udGV4dF9sb2MuZmlyc3RfbGluZSA6IGxvYy5maXJzdF9saW5lIC0gQ09OVEVYVCkpO1xuXG4gICAgICB2YXIgbDEgPSBNYXRoLm1heCgxLCAoY29udGV4dF9sb2MyID8gY29udGV4dF9sb2MyLmxhc3RfbGluZSA6IGxvYy5sYXN0X2xpbmUgKyBDT05URVhUX1RBSUwpKTtcbiAgICAgIHZhciBsaW5lbm9fZGlzcGxheV93aWR0aCA9IDEgKyBNYXRoLmxvZzEwKGwxIHwgMSkgfCAwO1xuICAgICAgdmFyIHdzX3ByZWZpeCA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCkuam9pbignICcpO1xuICAgICAgdmFyIG5vbmVtcHR5X2xpbmVfaW5kZXhlcyA9IFtdO1xuXG4gICAgICB2YXIgcnYgPSBsaW5lcy5zbGljZShsMCAtIDEsIGwxICsgMSkubWFwKGZ1bmN0aW9uIGluamVjdExpbmVOdW1iZXIobGluZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxubyA9IGluZGV4ICsgbDA7XG4gICAgICAgIHZhciBsbm9fcGZ4ID0gKHdzX3ByZWZpeCArIGxubykuc3Vic3RyKC1saW5lbm9fZGlzcGxheV93aWR0aCk7XG4gICAgICAgIHZhciBydiA9IGxub19wZnggKyAnOiAnICsgbGluZTtcbiAgICAgICAgdmFyIGVycnBmeCA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJ14nKTtcblxuICAgICAgICBpZiAobG5vID09PSBsb2MuZmlyc3RfbGluZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBsb2MuZmlyc3RfY29sdW1uICsgMjtcblxuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heChcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAoKGxubyA9PT0gbG9jLmxhc3RfbGluZSA/IGxvYy5sYXN0X2NvbHVtbiA6IGxpbmUubGVuZ3RoKSkgLSBsb2MuZmlyc3RfY29sdW1uICsgMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID09PSBsb2MubGFzdF9saW5lKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDIgKyAxO1xuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgyLCBsb2MubGFzdF9jb2x1bW4gKyAxKTtcbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID4gbG9jLmZpcnN0X2xpbmUgJiYgbG5vIDwgbG9jLmxhc3RfbGluZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAyICsgMTtcbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMiwgbGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydiA9IHJ2LnJlcGxhY2UoL1xcdC9nLCAnICcpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9KTtcblxuICAgICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBwcmludCBhbiBvdmVybHkgbGFyZ2UgYW1vdW50IG9mIGVycm9yIGFyZWE6IGxpbWl0IGl0IFxuICAgICAgLy8gdG8gdGhlIHRvcCBhbmQgYm90dG9tIGxpbmUgY291bnQ6XG4gICAgICBpZiAobm9uZW1wdHlfbGluZV9pbmRleGVzLmxlbmd0aCA+IDIgKiBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCkge1xuICAgICAgICB2YXIgY2xpcF9zdGFydCA9IG5vbmVtcHR5X2xpbmVfaW5kZXhlc1tNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCAtIDFdICsgMTtcbiAgICAgICAgdmFyIGNsaXBfZW5kID0gbm9uZW1wdHlfbGluZV9pbmRleGVzW25vbmVtcHR5X2xpbmVfaW5kZXhlcy5sZW5ndGggLSBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVF0gLSAxO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdjbGlwIG9mZjogJywge1xuICAgICAgICAgIHN0YXJ0OiBjbGlwX3N0YXJ0LFxuICAgICAgICAgIGVuZDogY2xpcF9lbmQsXG4gICAgICAgICAgbGVuOiBjbGlwX2VuZCAtIGNsaXBfc3RhcnQgKyAxLFxuICAgICAgICAgIGFycjogbm9uZW1wdHlfbGluZV9pbmRleGVzLFxuICAgICAgICAgIHJ2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpbnRlcm1lZGlhdGVfbGluZSA9IG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJyAnKSArICcgICguLi5jb250aW51ZWQuLi4pJztcbiAgICAgICAgaW50ZXJtZWRpYXRlX2xpbmUgKz0gJ1xcbicgKyBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCctJykgKyAnICAoLS0tLS0tLS0tLS0tLS0tKSc7XG4gICAgICAgIHJ2LnNwbGljZShjbGlwX3N0YXJ0LCBjbGlwX2VuZCAtIGNsaXBfc3RhcnQgKyAxLCBpbnRlcm1lZGlhdGVfbGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydi5qb2luKCdcXG4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIGZ1bmN0aW9uLCB1c2VkIHRvIHByb2R1Y2UgYSBodW1hbiByZWFkYWJsZSBkZXNjcmlwdGlvbiBhcyBhIHN0cmluZywgZ2l2ZW5cbiAgICAgKiB0aGUgaW5wdXQgYHl5bGxvY2AgbG9jYXRpb24gb2JqZWN0LlxuICAgICAqIFxuICAgICAqIFNldCBgZGlzcGxheV9yYW5nZV90b29gIHRvIFRSVUUgdG8gaW5jbHVkZSB0aGUgc3RyaW5nIGNoYXJhY3RlciBpbmRleCBwb3NpdGlvbihzKVxuICAgICAqIGluIHRoZSBkZXNjcmlwdGlvbiBpZiB0aGUgYHl5bGxvYy5yYW5nZWAgaXMgYXZhaWxhYmxlLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgZGVzY3JpYmVZWUxMT0M6IGZ1bmN0aW9uIGxleGVyX2Rlc2NyaWJlX3l5bGxvYyh5eWxsb2MsIGRpc3BsYXlfcmFuZ2VfdG9vKSB7XG4gICAgICB2YXIgbDEgPSB5eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHZhciBsMiA9IHl5bGxvYy5sYXN0X2xpbmU7XG4gICAgICB2YXIgYzEgPSB5eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgICAgdmFyIGMyID0geXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdmFyIGRsID0gbDIgLSBsMTtcbiAgICAgIHZhciBkYyA9IGMyIC0gYzE7XG4gICAgICB2YXIgcnY7XG5cbiAgICAgIGlmIChkbCA9PT0gMCkge1xuICAgICAgICBydiA9ICdsaW5lICcgKyBsMSArICcsICc7XG5cbiAgICAgICAgaWYgKGRjIDw9IDEpIHtcbiAgICAgICAgICBydiArPSAnY29sdW1uICcgKyBjMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydiArPSAnY29sdW1ucyAnICsgYzEgKyAnIC4uICcgKyBjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnYgPSAnbGluZXMgJyArIGwxICsgJyhjb2x1bW4gJyArIGMxICsgJykgLi4gJyArIGwyICsgJyhjb2x1bW4gJyArIGMyICsgJyknO1xuICAgICAgfVxuXG4gICAgICBpZiAoeXlsbG9jLnJhbmdlICYmIGRpc3BsYXlfcmFuZ2VfdG9vKSB7XG4gICAgICAgIHZhciByMSA9IHl5bGxvYy5yYW5nZVswXTtcbiAgICAgICAgdmFyIHIyID0geXlsbG9jLnJhbmdlWzFdIC0gMTtcblxuICAgICAgICBpZiAocjIgPD0gcjEpIHtcbiAgICAgICAgICBydiArPSAnIHtTdHJpbmcgT2Zmc2V0OiAnICsgcjEgKyAnfSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnYgKz0gJyB7U3RyaW5nIE9mZnNldCByYW5nZTogJyArIHIxICsgJyAuLiAnICsgcjIgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW4uXG4gICAgICogXG4gICAgICogYG1hdGNoYCBpcyBzdXBwb3NlZCB0byBiZSBhbiBhcnJheSBjb21pbmcgb3V0IG9mIGEgcmVnZXggbWF0Y2gsIGkuZS4gYG1hdGNoWzBdYFxuICAgICAqIGNvbnRhaW5zIHRoZSBhY3R1YWxseSBtYXRjaGVkIHRleHQgc3RyaW5nLlxuICAgICAqIFxuICAgICAqIEFsc28gbW92ZSB0aGUgaW5wdXQgY3Vyc29yIGZvcndhcmQgYW5kIHVwZGF0ZSB0aGUgbWF0Y2ggY29sbGVjdG9yczpcbiAgICAgKiBcbiAgICAgKiAtIGB5eXRleHRgXG4gICAgICogLSBgeXlsZW5nYFxuICAgICAqIC0gYG1hdGNoYFxuICAgICAqIC0gYG1hdGNoZXNgXG4gICAgICogLSBgeXlsbG9jYFxuICAgICAqIC0gYG9mZnNldGBcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uIGxleGVyX3Rlc3RfbWF0Y2gobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgdmFyIHRva2VuLCBsaW5lcywgYmFja3VwLCBtYXRjaF9zdHIsIG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG5cbiAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgcmFuZ2U6IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcblxuICAgICAgICAgIC8vX3NpZ25hbGVkX2Vycm9yX3Rva2VuOiB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbixcbiAgICAgICAgICB5eTogdGhpcy55eSxcblxuICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtYXRjaF9zdHIgPSBtYXRjaFswXTtcbiAgICAgIG1hdGNoX3N0cl9sZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuXG4gICAgICAvLyBpZiAobWF0Y2hfc3RyLmluZGV4T2YoJ1xcbicpICE9PSAtMSB8fCBtYXRjaF9zdHIuaW5kZXhPZignXFxyJykgIT09IC0xKSB7XG4gICAgICBsaW5lcyA9IG1hdGNoX3N0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsaW5lbm8gKyAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICs9IG1hdGNoX3N0cl9sZW47XG4gICAgICB9XG5cbiAgICAgIC8vIH1cbiAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoX3N0cjtcblxuICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaF9zdHI7XG4gICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hfc3RyO1xuICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdICs9IG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIC8vIHByZXZpb3VzIGxleCBydWxlcyBNQVkgaGF2ZSBpbnZva2VkIHRoZSBgbW9yZSgpYCBBUEkgcmF0aGVyIHRoYW4gcHJvZHVjaW5nIGEgdG9rZW46XG4gICAgICAvLyB0aG9zZSBydWxlcyB3aWxsIGFscmVhZHkgaGF2ZSBtb3ZlZCB0aGlzIGBvZmZzZXRgIGZvcndhcmQgbWF0Y2hpbmcgdGhlaXIgbWF0Y2ggbGVuZ3RocyxcbiAgICAgIC8vIGhlbmNlIHdlIG11c3Qgb25seSBhZGQgb3VyIG93biBtYXRjaCBsZW5ndGggbm93OlxuICAgICAgdGhpcy5vZmZzZXQgKz0gbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoX3N0cl9sZW4pO1xuXG4gICAgICAvLyBjYWxsaW5nIHRoaXMgbWV0aG9kOlxuICAgICAgLy9cbiAgICAgIC8vICAgZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpIHsuLi59XG4gICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLnl5LFxuICAgICAgICBpbmRleGVkX3J1bGUsXG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSAvKiA9IFlZX1NUQVJUICovXG4gICAgICApO1xuXG4gICAgICAvLyBvdGhlcndpc2UsIHdoZW4gdGhlIGFjdGlvbiBjb2RlcyBhcmUgYWxsIHNpbXBsZSByZXR1cm4gdG9rZW4gc3RhdGVtZW50czpcbiAgICAgIC8vdG9rZW4gPSB0aGlzLnNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyc1tpbmRleGVkX3J1bGVdO1xuXG4gICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLiBcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4pIHtcbiAgICAgICAgLy8gcHJvZHVjZSBvbmUgJ2Vycm9yJyB0b2tlbiBhcyBgLnBhcnNlRXJyb3IoKWAgaW4gYHJlamVjdCgpYFxuICAgICAgICAvLyBkaWQgbm90IGd1YXJhbnRlZSBhIGZhaWx1cmUgc2lnbmFsIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbiFcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbjtcblxuICAgICAgICB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uIGxleGVyX25leHQoKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXg7XG5cbiAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVjID0gdGhpcy5fX2N1cnJlbnRSdWxlU2V0X187XG5cbiAgICAgIGlmICghc3BlYykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJ1bGVzZXQgY2FjaGUgYXMgd2UgYXBwYXJlbnRseSBlbmNvdW50ZXJlZCBhIHN0YXRlIGNoYW5nZSBvciBqdXN0IHN0YXJ0ZWQgbGV4aW5nLlxuICAgICAgICAvLyBUaGUgY2FjaGUgaXMgc2V0IHVwIGZvciBmYXN0IGxvb2t1cCAtLSB3ZSBhc3N1bWUgYSBsZXhlciB3aWxsIHN3aXRjaCBzdGF0ZXMgbXVjaCBsZXNzIG9mdGVuIHRoYW4gaXQgd2lsbFxuICAgICAgICAvLyBpbnZva2UgdGhlIGBsZXgoKWAgdG9rZW4tcHJvZHVjaW5nIEFQSSBhbmQgcmVsYXRlZCBBUElzLCBoZW5jZSBjYWNoaW5nIHRoZSBzZXQgZm9yIGRpcmVjdCBhY2Nlc3MgaGVscHNcbiAgICAgICAgLy8gc3BlZWQgdXAgdGhvc2UgYWN0aXZpdGllcyBhIHRpbnkgYml0LlxuICAgICAgICBzcGVjID0gdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGEgKnNhbmUqIGNvbmRpdGlvbiBoYXMgYmVlbiBwdXNoZWQgYmVmb3JlOiB0aGlzIG1ha2VzIHRoZSBsZXhlciByb2J1c3QgYWdhaW5zdFxuICAgICAgICAvLyB1c2VyLXByb2dyYW1tZXIgYnVncyBzdWNoIGFzIGh0dHBzOi8vZ2l0aHViLmNvbS96YWFjaC9qaXNvbi1sZXgvaXNzdWVzLzE5XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5ydWxlcykge1xuICAgICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvc19zdHIgPSAnJztcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAocG9zX3N0ciAmJiBwb3Nfc3RyWzBdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICBwb3Nfc3RyID0gJ1xcbicgKyBwb3Nfc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgICAnSW50ZXJuYWwgbGV4ZXIgZW5naW5lIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBUaGUgbGV4IGdyYW1tYXIgcHJvZ3JhbW1lciBwdXNoZWQgYSBub24tZXhpc3RpbmcgY29uZGl0aW9uIG5hbWUgXCInICsgdGhpcy50b3BTdGF0ZSgpICsgJ1wiOyB0aGlzIGlzIGEgZmF0YWwgZXJyb3IgYW5kIHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgYXBwbGljYXRpb24gcHJvZ3JhbW1lciB0ZWFtIScgKyBwb3Nfc3RyLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gcHJvZHVjZSBvbmUgJ2Vycm9yJyB0b2tlbiB1bnRpbCB0aGlzIHNpdHVhdGlvbiBoYXMgYmVlbiByZXNvbHZlZCwgbW9zdCBwcm9iYWJseSBieSBwYXJzZSB0ZXJtaW5hdGlvbiFcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcnVsZV9pZHMgPSBzcGVjLnJ1bGVzO1xuICAgICAgdmFyIHJlZ2V4ZXMgPSBzcGVjLl9fcnVsZV9yZWdleGVzO1xuICAgICAgdmFyIGxlbiA9IHNwZWMuX19ydWxlX2NvdW50O1xuXG4gICAgICAvLyBOb3RlOiB0aGUgYXJyYXlzIGFyZSAxLWJhc2VkLCB3aGlsZSBgbGVuYCBpdHNlbGYgaXMgYSB2YWxpZCBpbmRleCxcbiAgICAgIC8vIGhlbmNlIHRoZSBub24tc3RhbmRhcmQgbGVzcy1vci1lcXVhbCBjaGVjayBpbiB0aGUgbmV4dCBsb29wIGNvbmRpdGlvbiFcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHJlZ2V4ZXNbaV0pO1xuXG4gICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVfaWRzW2ldKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICBtYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29udGludWU7ICAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLiBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlX2lkc1tpbmRleF0pO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3Nfc3RyID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHBvc19zdHIgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHBvc19zdHIgPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogVW5yZWNvZ25pemVkIHRleHQuJyArIHBvc19zdHIsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGVcbiAgICAgICAgKTtcblxuICAgICAgICB0b2tlbiA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG5cbiAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLkVSUk9SKSB7XG4gICAgICAgICAgLy8gd2UgY2FuIHRyeSB0byByZWNvdmVyIGZyb20gYSBsZXhlciBlcnJvciB0aGF0IGBwYXJzZUVycm9yKClgIGRpZCBub3QgJ3JlY292ZXInIGZvciB1c1xuICAgICAgICAgIC8vIGJ5IG1vdmluZyBmb3J3YXJkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lOlxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxleDogZnVuY3Rpb24gbGV4ZXJfbGV4KCkge1xuICAgICAgdmFyIHI7XG5cbiAgICAgIC8vIGFsbG93IHRoZSBQUkUvUE9TVCBoYW5kbGVycyBzZXQvbW9kaWZ5IHRoZSByZXR1cm4gdG9rZW4gZm9yIG1heGltdW0gZmxleGliaWxpdHkgb2YgdGhlIGdlbmVyYXRlZCBsZXhlcjpcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnByZV9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgciA9IHRoaXMub3B0aW9ucy5wcmVfbGV4LmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghcikge1xuICAgICAgICByID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIChhbHNvIGFjY291bnQgZm9yIGEgdXNlcmRlZiBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlOiBrZWVwIHRoZSB0b2tlbiBhcyBpcylcbiAgICAgICAgciA9IHRoaXMub3B0aW9ucy5wb3N0X2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiYWNrd2FyZHMgY29tcGF0aWJsZSBhbGlhcyBmb3IgYHB1c2hTdGF0ZSgpYDtcbiAgICAgKiB0aGUgbGF0dGVyIGlzIHN5bW1ldHJpY2FsIHdpdGggYHBvcFN0YXRlKClgIGFuZCB3ZSBhZHZpc2UgdG8gdXNlXG4gICAgICogdGhvc2UgQVBJcyBpbiBhbnkgbW9kZXJuIGxleGVyIGNvZGUsIHJhdGhlciB0aGFuIGBiZWdpbigpYC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGJlZ2luOiBmdW5jdGlvbiBsZXhlcl9iZWdpbihjb25kaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGF0ZShjb25kaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlclxuICAgICAqIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3B1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uXG4gICAgICogc3RhY2tcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHBvcFN0YXRlOiBmdW5jdGlvbiBsZXhlcl9wb3BTdGF0ZSgpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4XG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLFxuICAgICAqIGlmIGF2YWlsYWJsZVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdG9wU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3RvcFN0YXRlKG4pIHtcbiAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuXG4gICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdJTklUSUFMJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogKGludGVybmFsKSBkZXRlcm1pbmUgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIGxleGVyX19jdXJyZW50UnVsZXMoKSB7XG4gICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbJ0lOSVRJQUwnXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbiBsZXhlcl9zdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgZmxleDogdHJ1ZSxcbiAgICAgIHRyYWNrUG9zaXRpb246IHRydWUsXG4gICAgICBwYXJzZUFjdGlvbnNVc2VZWU1FUkdFTE9DQVRJT05JTkZPOiB0cnVlXG4gICAgfSxcblxuICAgIEppc29uTGV4ZXJFcnJvcjogSmlzb25MZXhlckVycm9yLFxuXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpIHtcbiAgICAgIHZhciB5eV8gPSB0aGlzO1xuICAgICAgdmFyIFlZU1RBVEUgPSBZWV9TVEFSVDtcblxuICAgICAgc3dpdGNoICh5eXJ1bGVudW1iZXIpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFxzKyAqL1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7JSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT05UUk9MJyk7XG5cbiAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA8IS0tICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTU1FTlQnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFwvPiAqL1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICA+ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NISUxEUkVOJyk7XG5cbiAgICAgICAgcmV0dXJuIDE0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyMDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjM6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHtcXHsgKi9cbiAgICAgICAgdGhpcy5iZWdpbignRVhQUkVTU0lPTicpO1xuXG4gICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHslICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0NPTlRST0wnKTtcblxuICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPCEtLSAqL1xuICAgICAgICB0aGlzLmJlZ2luKCdDT01NRU5UJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNjpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDxcXC8gKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDM3O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNzpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG5cbiAgICAgICAgdGhpcy5iZWdpbignQ09OVFJPTF9DSElMRCcpO1xuICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICVcXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgIDwgKi9cbiAgICAgICAgdGhpcy5iZWdpbignVEFHJyk7XG5cbiAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2NDpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MX0NISUxEICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFx7XFx7ICovXG4gICAgICAgIHRoaXMuYmVnaW4oJ0VYUFJFU1NJT04nKTtcblxuICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAlXFx9ICovXG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcblxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDgzOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH1cXH0gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiA0MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgODY6XG4gICAgICAgIC8qISBDb25kaXRpb25zOjogQ09NTUVOVCAqL1xuICAgICAgICAvKiEgUnVsZTo6ICAgICAgICgufFxccnxcXG4pKj8tLT4gKi9cbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTE1OlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICAuICovXG4gICAgICAgIGNvbnNvbGUubG9nKCcnLCB5eV8ueXl0ZXh0KTtcblxuICAgICAgICAvKiBgZmxleGAgbGV4aW5nIG1vZGU6IHRoZSBsYXN0IHJlc29ydCBydWxlISAqL1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW3l5cnVsZW51bWJlcl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyczoge1xuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGltcG9ydCAqL1xuICAgICAgMTogMjUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmcm9tICovXG4gICAgICAyOiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHVzaW5nICovXG4gICAgICAzOiAnVVNJTkcnLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDQ6IDI3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgOTogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDEwOiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgMTE6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDEyOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IFRBRyAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB0cnVlICovXG4gICAgICAxMzogNTMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZhbHNlICovXG4gICAgICAxNDogNTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDE1OiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICAxNjogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogVEFHICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcLyAqL1xuICAgICAgMTg6ICdOT1NFJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICAyMTogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBUQUcgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx9ICovXG4gICAgICAyMjogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDSElMRFJFTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHsgKi9cbiAgICAgIDI4OiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENISUxEUkVOICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgMjk6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ0hJTERSRU4gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgW14vPD57JX1dKyAqL1xuICAgICAgMzA6IDQ3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgbWFpbiAqL1xuICAgICAgMzE6IDI5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kbWFpbiAqL1xuICAgICAgMzI6IDMxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgbWFjcm8gKi9cbiAgICAgIDMzOiAnTUFDUk8nLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZW5kbWFjcm8gKi9cbiAgICAgIDM0OiAnRU5ETUFDUk8nLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZm9yICovXG4gICAgICAzNTogNDEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRmb3IgKi9cbiAgICAgIDM2OiA0MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGlmICovXG4gICAgICAzNzogNDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBlbmRpZiAqL1xuICAgICAgMzg6IDQ2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZSAqL1xuICAgICAgMzk6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZWlmICovXG4gICAgICA0MDogJ0VMU0VJRicsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpbiAqL1xuICAgICAgNDE6IDQyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgY2FzZSAqL1xuICAgICAgNDI6ICdDQVNFJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZGNhc2UgKi9cbiAgICAgIDQzOiAnRU5EQ0FTRScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBleHBvcnQgKi9cbiAgICAgIDQ0OiAzMixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZyb20gKi9cbiAgICAgIDQ1OiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHZpZXcgKi9cbiAgICAgIDQ2OiAzMyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHVzaW5nICovXG4gICAgICA0NzogJ1VTSU5HJyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZHZpZXcgKi9cbiAgICAgIDQ4OiAzNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGluc3RhbmNlb2YgKi9cbiAgICAgIDQ5OiA2MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRoaXMgKi9cbiAgICAgIDUwOiAnVEhJUycsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBmdW4gKi9cbiAgICAgIDUxOiAzNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGVuZGZ1biAqL1xuICAgICAgNTI6IDM2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0wgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDUzOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIDo6ICovXG4gICAgICA1NDogJzo6JyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDU1OiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKFxcKSAqL1xuICAgICAgNTY6ICcoKScsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7Q29uc3RydWN0b3J9ICovXG4gICAgICA1ODogNTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7SWRlbnRpZmllcn0gKi9cbiAgICAgIDU5OiA1NSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBDT05UUk9MICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxceyAqL1xuICAgICAgNjE6IDQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXH0gKi9cbiAgICAgIDYyOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0NvbnN0cnVjdG9yfSAqL1xuICAgICAgNjY6IDU2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAge0lkZW50aWZpZXJ9ICovXG4gICAgICA2NzogNTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogQ09OVFJPTF9DSElMRCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHsgKi9cbiAgICAgIDY4OiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IENPTlRST0xfQ0hJTEQgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx9ICovXG4gICAgICA2OTogNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfCAqL1xuICAgICAgNzA6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPT4gKi9cbiAgICAgIDcxOiA1MCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIC0+ICovXG4gICAgICA3MjogJy0+JyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIEAgKi9cbiAgICAgIDczOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGluc3RhbmNlb2YgKi9cbiAgICAgIDc0OiA2MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHRydWUgKi9cbiAgICAgIDc1OiA1MyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIGZhbHNlICovXG4gICAgICA3NjogNTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogRVhQUkVTU0lPTiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBpZiAqL1xuICAgICAgNzc6IDQ1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgdGhlbiAqL1xuICAgICAgNzg6IDQ4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgZWxzZSAqL1xuICAgICAgNzk6IDQ0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgYXMgKi9cbiAgICAgIDgwOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtDb25zdHJ1Y3Rvcn0gKi9cbiAgICAgIDgxOiA1NixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtJZGVudGlmaWVyfSAqL1xuICAgICAgODI6IDU1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IEVYUFJFU1NJT04gKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFx7ICovXG4gICAgICA4NDogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBFWFBSRVNTSU9OICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcfSAqL1xuICAgICAgODU6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICB7TnVtYmVyTGl0ZXJhbH0gKi9cbiAgICAgIDg3OiA1MixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIHtTdHJpbmdMaXRlcmFsfSAqL1xuICAgICAgODg6IDUxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPiAqL1xuICAgICAgODk6IDE0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPCAqL1xuICAgICAgOTA6IDEzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwoICovXG4gICAgICA5MTogNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKSAqL1xuICAgICAgOTI6IDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFsgKi9cbiAgICAgIDkzOiAxMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcXSAqL1xuICAgICAgOTQ6IDExLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOyAqL1xuICAgICAgOTU6IDIwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgOiAqL1xuICAgICAgOTY6IDEyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPSAqL1xuICAgICAgOTc6IDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICA9PSAqL1xuICAgICAgOTg6IDU5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgIT0gKi9cbiAgICAgIDk5OiA2MCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiAqICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgID49ICovXG4gICAgICAxMDA6IDU3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgPD0gKi9cbiAgICAgIDEwMTogNTgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCsgKi9cbiAgICAgIDEwMjogMjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAtICovXG4gICAgICAxMDM6IDIzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwqICovXG4gICAgICAxMDQ6IDMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8gKi9cbiAgICAgIDEwNTogMjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXFxcICovXG4gICAgICAxMDY6IDQ5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgJiYgKi9cbiAgICAgIDEwNzogNjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHxcXHwgKi9cbiAgICAgIDEwODogNjIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXF4gKi9cbiAgICAgIDEwOTogMjQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogKiAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAhICovXG4gICAgICAxMTA6IDE2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLCAqL1xuICAgICAgMTExOiA2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFw/ICovXG4gICAgICAxMTI6IDE4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwuICovXG4gICAgICAxMTM6IDE3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6ICogKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgJCAqL1xuICAgICAgMTE0OiAxXG4gICAgfSxcblxuICAgIHJ1bGVzOiBbXG4gICAgICAvKiAgIDA6ICovICAvXig/OlxccyspLyxcbiAgICAgIC8qICAgMTogKi8gIC9eKD86aW1wb3J0KS8sXG4gICAgICAvKiAgIDI6ICovICAvXig/OmZyb20pLyxcbiAgICAgIC8qICAgMzogKi8gIC9eKD86dXNpbmcpLyxcbiAgICAgIC8qICAgNDogKi8gIC9eKD86YXMpLyxcbiAgICAgIC8qICAgNTogKi8gIC9eKD86XFx7JSkvLFxuICAgICAgLyogICA2OiAqLyAgL14oPzo8IS0tKS8sXG4gICAgICAvKiAgIDc6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICAgODogKi8gIC9eKD86XFx7XFx7KS8sXG4gICAgICAvKiAgIDk6ICovICAvXig/OihbQS1aXVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTA6ICovICAvXig/OihbJF9hLXpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICAxMTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgMTI6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDEzOiAqLyAgL14oPzp0cnVlKS8sXG4gICAgICAvKiAgMTQ6ICovICAvXig/OmZhbHNlKS8sXG4gICAgICAvKiAgMTU6ICovICAvXig/OihbQS1aXVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgMTY6ICovICAvXig/OihbJF9hLXpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICAxNzogKi8gIC9eKD86XFwvPikvLFxuICAgICAgLyogIDE4OiAqLyAgL14oPzpcXC8pLyxcbiAgICAgIC8qICAxOTogKi8gIC9eKD86PikvLFxuICAgICAgLyogIDIwOiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICAyMTogKi8gIC9eKD86XFx7KS8sXG4gICAgICAvKiAgMjI6ICovICAvXig/OlxcfSkvLFxuICAgICAgLyogIDIzOiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICAyNDogKi8gIC9eKD86XFx7JSkvLFxuICAgICAgLyogIDI1OiAqLyAgL14oPzo8IS0tKS8sXG4gICAgICAvKiAgMjY6ICovICAvXig/OjxcXC8pLyxcbiAgICAgIC8qICAyNzogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDI4OiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICAyOTogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgMzA6ICovICAvXig/OlteXFwvPD57JX1dKykvLFxuICAgICAgLyogIDMxOiAqLyAgL14oPzptYWluKS8sXG4gICAgICAvKiAgMzI6ICovICAvXig/OmVuZG1haW4pLyxcbiAgICAgIC8qICAzMzogKi8gIC9eKD86bWFjcm8pLyxcbiAgICAgIC8qICAzNDogKi8gIC9eKD86ZW5kbWFjcm8pLyxcbiAgICAgIC8qICAzNTogKi8gIC9eKD86Zm9yKS8sXG4gICAgICAvKiAgMzY6ICovICAvXig/OmVuZGZvcikvLFxuICAgICAgLyogIDM3OiAqLyAgL14oPzppZikvLFxuICAgICAgLyogIDM4OiAqLyAgL14oPzplbmRpZikvLFxuICAgICAgLyogIDM5OiAqLyAgL14oPzplbHNlKS8sXG4gICAgICAvKiAgNDA6ICovICAvXig/OmVsc2VpZikvLFxuICAgICAgLyogIDQxOiAqLyAgL14oPzppbikvLFxuICAgICAgLyogIDQyOiAqLyAgL14oPzpjYXNlKS8sXG4gICAgICAvKiAgNDM6ICovICAvXig/OmVuZGNhc2UpLyxcbiAgICAgIC8qICA0NDogKi8gIC9eKD86ZXhwb3J0KS8sXG4gICAgICAvKiAgNDU6ICovICAvXig/OmZyb20pLyxcbiAgICAgIC8qICA0NjogKi8gIC9eKD86dmlldykvLFxuICAgICAgLyogIDQ3OiAqLyAgL14oPzp1c2luZykvLFxuICAgICAgLyogIDQ4OiAqLyAgL14oPzplbmR2aWV3KS8sXG4gICAgICAvKiAgNDk6ICovICAvXig/Omluc3RhbmNlb2YpLyxcbiAgICAgIC8qICA1MDogKi8gIC9eKD86dGhpcykvLFxuICAgICAgLyogIDUxOiAqLyAgL14oPzpmdW4pLyxcbiAgICAgIC8qICA1MjogKi8gIC9eKD86ZW5kZnVuKS8sXG4gICAgICAvKiAgNTM6ICovICAvXig/OmFzKS8sXG4gICAgICAvKiAgNTQ6ICovICAvXig/Ojo6KS8sXG4gICAgICAvKiAgNTU6ICovICAvXig/OkApLyxcbiAgICAgIC8qICA1NjogKi8gIC9eKD86XFwoXFwpKS8sXG4gICAgICAvKiAgNTc6ICovICAvXig/Oj0pLyxcbiAgICAgIC8qICA1ODogKi8gIC9eKD86KFtBLVpdW1xcdyRcXC1dKikpLyxcbiAgICAgIC8qICA1OTogKi8gIC9eKD86KFskX2Etel1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDYwOiAqLyAgL14oPzolXFx9KS8sXG4gICAgICAvKiAgNjE6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDYyOiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICA2MzogKi8gIC9eKD86PCkvLFxuICAgICAgLyogIDY0OiAqLyAgL14oPzpcXHtcXHspLyxcbiAgICAgIC8qICA2NTogKi8gIC9eKD86JVxcfSkvLFxuICAgICAgLyogIDY2OiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDY3OiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgNjg6ICovICAvXig/OlxceykvLFxuICAgICAgLyogIDY5OiAqLyAgL14oPzpcXH0pLyxcbiAgICAgIC8qICA3MDogKi8gIC9eKD86XFx8KS8sXG4gICAgICAvKiAgNzE6ICovICAvXig/Oj0+KS8sXG4gICAgICAvKiAgNzI6ICovICAvXig/Oi0+KS8sXG4gICAgICAvKiAgNzM6ICovICAvXig/OkApLyxcbiAgICAgIC8qICA3NDogKi8gIC9eKD86aW5zdGFuY2VvZikvLFxuICAgICAgLyogIDc1OiAqLyAgL14oPzp0cnVlKS8sXG4gICAgICAvKiAgNzY6ICovICAvXig/OmZhbHNlKS8sXG4gICAgICAvKiAgNzc6ICovICAvXig/OmlmKS8sXG4gICAgICAvKiAgNzg6ICovICAvXig/OnRoZW4pLyxcbiAgICAgIC8qICA3OTogKi8gIC9eKD86ZWxzZSkvLFxuICAgICAgLyogIDgwOiAqLyAgL14oPzphcykvLFxuICAgICAgLyogIDgxOiAqLyAgL14oPzooW0EtWl1bXFx3JFxcLV0qKSkvLFxuICAgICAgLyogIDgyOiAqLyAgL14oPzooWyRfYS16XVtcXHckXFwtXSopKS8sXG4gICAgICAvKiAgODM6ICovICAvXig/OlxcfVxcfSkvLFxuICAgICAgLyogIDg0OiAqLyAgL14oPzpcXHspLyxcbiAgICAgIC8qICA4NTogKi8gIC9eKD86XFx9KS8sXG4gICAgICAvKiAgODY6ICovICAvXig/OigufFxccnxcXG4pKj8tLT4pLyxcbiAgICAgIC8qICA4NzogKi8gIC9eKD86KCg/OihbLV0/KD86Wy1dPyhbMF18KCg/OlsxLTldKSg/OlxcZCspKikpKVxcLig/OlxcZCspKig/Oig/OltFZV0pKD86WystXT9cXGQrKSk/KXwoXFwuKD86XFxkKykoPzooPzpbRWVdKSg/OlsrLV0/XFxkKykpPyl8KCg/OlstXT8oWzBdfCgoPzpbMS05XSkoPzpcXGQrKSopKSkoPzooPzpbRWVdKSg/OlsrLV0/XFxkKykpPykpfCg/OlswXVtYeF0oPzpbXFxkQS1GYS1mXSkrKXwoPzpbMF0oPzpbMC03XSkrKSkpLyxcbiAgICAgIC8qICA4ODogKi8gIC9eKD86KChcIig/OihbXlxcblxcclwiXFxcXF0rKXwoXFxcXCg/Oig/Oig/OltcIidcXFxcYmZucnR2XSl8KD86W15cXGRcIidcXFxcYmZucnQtdnhdKSl8KD86KD86WzEtN11bMC03XXswLDJ9fFswLTddezIsM30pKXwoPzpbeF0oPzpbXFxkQS1GYS1mXSl7Mn0pfCg/Olt1XSg/OltcXGRBLUZhLWZdKXs0fSkpKXwoPzpcXFxcKFxcclxcbnxcXHJ8XFxuKSkpKlwiKXwoJyg/OihbXlxcblxccidcXFxcXSspfChcXFxcKD86KD86KD86W1wiJ1xcXFxiZm5ydHZdKXwoPzpbXlxcZFwiJ1xcXFxiZm5ydC12eF0pKXwoPzooPzpbMS03XVswLTddezAsMn18WzAtN117MiwzfSkpfCg/Olt4XSg/OltcXGRBLUZhLWZdKXsyfSl8KD86W3VdKD86W1xcZEEtRmEtZl0pezR9KSkpfCg/OlxcXFwoXFxyXFxufFxccnxcXG4pKSkqJyl8KGAoPzooW15cXG5cXHJcXFxcYF0rKXwoXFxcXCg/Oig/Oig/OltcIidcXFxcYmZucnR2XSl8KD86W15cXGRcIidcXFxcYmZucnQtdnhdKSl8KD86KD86WzEtN11bMC03XXswLDJ9fFswLTddezIsM30pKXwoPzpbeF0oPzpbXFxkQS1GYS1mXSl7Mn0pfCg/Olt1XSg/OltcXGRBLUZhLWZdKXs0fSkpKXwoPzpcXFxcKFxcclxcbnxcXHJ8XFxuKSkpKmApKSkvLFxuICAgICAgLyogIDg5OiAqLyAgL14oPzo+KS8sXG4gICAgICAvKiAgOTA6ICovICAvXig/OjwpLyxcbiAgICAgIC8qICA5MTogKi8gIC9eKD86XFwoKS8sXG4gICAgICAvKiAgOTI6ICovICAvXig/OlxcKSkvLFxuICAgICAgLyogIDkzOiAqLyAgL14oPzpcXFspLyxcbiAgICAgIC8qICA5NDogKi8gIC9eKD86XFxdKS8sXG4gICAgICAvKiAgOTU6ICovICAvXig/OjspLyxcbiAgICAgIC8qICA5NjogKi8gIC9eKD86OikvLFxuICAgICAgLyogIDk3OiAqLyAgL14oPzo9KS8sXG4gICAgICAvKiAgOTg6ICovICAvXig/Oj09KS8sXG4gICAgICAvKiAgOTk6ICovICAvXig/OiE9KS8sXG4gICAgICAvKiAxMDA6ICovICAvXig/Oj49KS8sXG4gICAgICAvKiAxMDE6ICovICAvXig/Ojw9KS8sXG4gICAgICAvKiAxMDI6ICovICAvXig/OlxcKykvLFxuICAgICAgLyogMTAzOiAqLyAgL14oPzotKS8sXG4gICAgICAvKiAxMDQ6ICovICAvXig/OlxcKikvLFxuICAgICAgLyogMTA1OiAqLyAgL14oPzpcXC8pLyxcbiAgICAgIC8qIDEwNjogKi8gIC9eKD86XFxcXCkvLFxuICAgICAgLyogMTA3OiAqLyAgL14oPzomJikvLFxuICAgICAgLyogMTA4OiAqLyAgL14oPzpcXHxcXHwpLyxcbiAgICAgIC8qIDEwOTogKi8gIC9eKD86XFxeKS8sXG4gICAgICAvKiAxMTA6ICovICAvXig/OiEpLyxcbiAgICAgIC8qIDExMTogKi8gIC9eKD86LCkvLFxuICAgICAgLyogMTEyOiAqLyAgL14oPzpcXD8pLyxcbiAgICAgIC8qIDExMzogKi8gIC9eKD86XFwuKS8sXG4gICAgICAvKiAxMTQ6ICovICAvXig/OiQpLyxcbiAgICAgIC8qIDExNTogKi8gIC9eKD86LikvXG4gICAgXSxcblxuICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICdDSElMRFJFTic6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDIzLFxuICAgICAgICAgIDI0LFxuICAgICAgICAgIDI1LFxuICAgICAgICAgIDI2LFxuICAgICAgICAgIDI3LFxuICAgICAgICAgIDI4LFxuICAgICAgICAgIDI5LFxuICAgICAgICAgIDMwLFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTU1FTlQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA4NixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdDT05UUk9MJzoge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgIDAsXG4gICAgICAgICAgMzEsXG4gICAgICAgICAgMzIsXG4gICAgICAgICAgMzMsXG4gICAgICAgICAgMzQsXG4gICAgICAgICAgMzUsXG4gICAgICAgICAgMzYsXG4gICAgICAgICAgMzcsXG4gICAgICAgICAgMzgsXG4gICAgICAgICAgMzksXG4gICAgICAgICAgNDAsXG4gICAgICAgICAgNDEsXG4gICAgICAgICAgNDIsXG4gICAgICAgICAgNDMsXG4gICAgICAgICAgNDQsXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgNDYsXG4gICAgICAgICAgNDcsXG4gICAgICAgICAgNDgsXG4gICAgICAgICAgNDksXG4gICAgICAgICAgNTAsXG4gICAgICAgICAgNTEsXG4gICAgICAgICAgNTIsXG4gICAgICAgICAgNTMsXG4gICAgICAgICAgNTQsXG4gICAgICAgICAgNTUsXG4gICAgICAgICAgNTYsXG4gICAgICAgICAgNTcsXG4gICAgICAgICAgNTgsXG4gICAgICAgICAgNTksXG4gICAgICAgICAgNjAsXG4gICAgICAgICAgNjEsXG4gICAgICAgICAgNjIsXG4gICAgICAgICAgODcsXG4gICAgICAgICAgODgsXG4gICAgICAgICAgODksXG4gICAgICAgICAgOTAsXG4gICAgICAgICAgOTEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTQsXG4gICAgICAgICAgOTUsXG4gICAgICAgICAgOTYsXG4gICAgICAgICAgOTcsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTAwLFxuICAgICAgICAgIDEwMSxcbiAgICAgICAgICAxMDIsXG4gICAgICAgICAgMTAzLFxuICAgICAgICAgIDEwNCxcbiAgICAgICAgICAxMDUsXG4gICAgICAgICAgMTA2LFxuICAgICAgICAgIDEwNyxcbiAgICAgICAgICAxMDgsXG4gICAgICAgICAgMTA5LFxuICAgICAgICAgIDExMCxcbiAgICAgICAgICAxMTEsXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMTRcbiAgICAgICAgXSxcblxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAnRVhQUkVTU0lPTic6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDcwLFxuICAgICAgICAgIDcxLFxuICAgICAgICAgIDcyLFxuICAgICAgICAgIDczLFxuICAgICAgICAgIDc0LFxuICAgICAgICAgIDc1LFxuICAgICAgICAgIDc2LFxuICAgICAgICAgIDc3LFxuICAgICAgICAgIDc4LFxuICAgICAgICAgIDc5LFxuICAgICAgICAgIDgwLFxuICAgICAgICAgIDgxLFxuICAgICAgICAgIDgyLFxuICAgICAgICAgIDgzLFxuICAgICAgICAgIDg0LFxuICAgICAgICAgIDg1LFxuICAgICAgICAgIDg3LFxuICAgICAgICAgIDg4LFxuICAgICAgICAgIDg5LFxuICAgICAgICAgIDkwLFxuICAgICAgICAgIDkxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk0LFxuICAgICAgICAgIDk1LFxuICAgICAgICAgIDk2LFxuICAgICAgICAgIDk3LFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDEwMCxcbiAgICAgICAgICAxMDEsXG4gICAgICAgICAgMTAyLFxuICAgICAgICAgIDEwMyxcbiAgICAgICAgICAxMDQsXG4gICAgICAgICAgMTA1LFxuICAgICAgICAgIDEwNixcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMTA4LFxuICAgICAgICAgIDEwOSxcbiAgICAgICAgICAxMTAsXG4gICAgICAgICAgMTExLFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTE0XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgJ0NPTlRST0xfQ0hJTEQnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICA2MyxcbiAgICAgICAgICA2NCxcbiAgICAgICAgICA2NSxcbiAgICAgICAgICA2NixcbiAgICAgICAgICA2NyxcbiAgICAgICAgICA2OCxcbiAgICAgICAgICA2OSxcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdUQUcnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAxNCxcbiAgICAgICAgICAxNSxcbiAgICAgICAgICAxNixcbiAgICAgICAgICAxNyxcbiAgICAgICAgICAxOCxcbiAgICAgICAgICAxOSxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAyMSxcbiAgICAgICAgICAyMixcbiAgICAgICAgICA4NyxcbiAgICAgICAgICA4OCxcbiAgICAgICAgICA4OSxcbiAgICAgICAgICA5MCxcbiAgICAgICAgICA5MSxcbiAgICAgICAgICA5MixcbiAgICAgICAgICA5MyxcbiAgICAgICAgICA5NCxcbiAgICAgICAgICA5NSxcbiAgICAgICAgICA5NixcbiAgICAgICAgICA5NyxcbiAgICAgICAgICA5OCxcbiAgICAgICAgICA5OSxcbiAgICAgICAgICAxMDAsXG4gICAgICAgICAgMTAxLFxuICAgICAgICAgIDEwMixcbiAgICAgICAgICAxMDMsXG4gICAgICAgICAgMTA0LFxuICAgICAgICAgIDEwNSxcbiAgICAgICAgICAxMDYsXG4gICAgICAgICAgMTA3LFxuICAgICAgICAgIDEwOCxcbiAgICAgICAgICAxMDksXG4gICAgICAgICAgMTEwLFxuICAgICAgICAgIDExMSxcbiAgICAgICAgICAxMTIsXG4gICAgICAgICAgMTEzLFxuICAgICAgICAgIDExNFxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgICdJTklUSUFMJzoge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAyLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcbiAgICAgICAgICA1LFxuICAgICAgICAgIDYsXG4gICAgICAgICAgNyxcbiAgICAgICAgICA4LFxuICAgICAgICAgIDksXG4gICAgICAgICAgMTAsXG4gICAgICAgICAgMTEsXG4gICAgICAgICAgMTIsXG4gICAgICAgICAgODcsXG4gICAgICAgICAgODgsXG4gICAgICAgICAgODksXG4gICAgICAgICAgOTAsXG4gICAgICAgICAgOTEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTQsXG4gICAgICAgICAgOTUsXG4gICAgICAgICAgOTYsXG4gICAgICAgICAgOTcsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTAwLFxuICAgICAgICAgIDEwMSxcbiAgICAgICAgICAxMDIsXG4gICAgICAgICAgMTAzLFxuICAgICAgICAgIDEwNCxcbiAgICAgICAgICAxMDUsXG4gICAgICAgICAgMTA2LFxuICAgICAgICAgIDEwNyxcbiAgICAgICAgICAxMDgsXG4gICAgICAgICAgMTA5LFxuICAgICAgICAgIDExMCxcbiAgICAgICAgICAxMTEsXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMTQsXG4gICAgICAgICAgMTE1XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsZXhlcjtcbn0oKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuXG5mdW5jdGlvbiBQYXJzZXIoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7XG5wYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xuXG5yZXR1cm4gbmV3IFBhcnNlcigpO1xufSkoKTtcblxuICAgICAgICBcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLnBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXIuUGFyc2VyO1xuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UuYXBwbHkoUGFyc2VyLCBhcmd1bWVudHMpO1xuICB9O1xuICBcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5vZGVzID0gcmVxdWlyZShcIi4vQVNUXCIpO1xudmFyIGFmcGwgPSByZXF1aXJlKFwiYWZwbFwiKTtcbnZhciBDT05URVhUID0gJ19fX2NvbnRleHQnO1xudmFyIFZJRVcgPSAnX19fdmlldyc7XG52YXIgV01MID0gJ19fX3dtbCc7XG52YXIgcHJpbXMgPSBbJ1N0cmluZycsICdCb29sZWFuJywgJ051bWJlcicsICdPYmplY3QnLCAnVW5kZWZpbmVkJywgJ051bGwnLCAnVm9pZCcsICdOZXZlcicsICdBbnknXTtcbi8qKlxuICogVHlwZXMgYW5kIGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyB0eXBlc2NyaXB0IHByb2dyYW0gdGV4dC5cbiAqL1xudmFyIF90aHJvd05vdEtub3duID0gZnVuY3Rpb24gKG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBU1Qgbm9kZSBcIiArICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgPyBuLmNvbnN0cnVjdG9yLm5hbWUgOiBuKSArIFwiIVwiKTtcbn07XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiZnVuY3Rpb24gKCkge31cIjsgfTtcbi8qKlxuICogdmlldyB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0cy52aWV3ID0gZnVuY3Rpb24gKGlkLCB0eXBlQ2xhc3NlcywgcGFyYW1zLCBjdHgsIHRhZykge1xuICAgIHJldHVybiBcImV4cG9ydCBjbGFzcyBcIiArIGlkICsgdHlwZUNsYXNzZXMgKyBcIiBleHRlbmRzIFwiICsgV01MICsgXCIuQXBwVmlldzxcIiArIGN0eCArIFwiPiB7XFxuXFxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQ6IFwiICsgY3R4ICsgKHBhcmFtcyA/ICcsJyArIHBhcmFtcyA6ICcnKSArIFwiKSB7XFxuXFxuICAgICAgICBzdXBlcihjb250ZXh0KTtcXG5cXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSAoXCIgKyBDT05URVhUICsgXCI6XCIgKyBjdHggKyBcIiwgXCIgKyBWSUVXICsgXCI6XCIgKyBXTUwgKyBcIi5BcHBWaWV3PFwiICsgY3R4ICsgXCI+KSA9PlxcbiAgICAgICAgICBcIiArICh0YWcgPyB0YWcgOiAnPE5vZGU+ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpJykgKyBcIjtcXG5cXG4gICAgICAgfVxcblxcbiAgICAgfVxcblwiO1xufTtcbi8qKlxuICogY29kZSB0dXJucyBhbiBBU1QgaW50byB0eXBlc2NyaXB0IGNvZGUuXG4gKi9cbmV4cG9ydHMuY29kZSA9IGZ1bmN0aW9uIChuLCBvKSB7IHJldHVybiBleHBvcnRzLm1vZHVsZTJUUyhuLCBvKTsgfTtcbi8qKlxuICogbW9kdWxlMlRTIGNvbnZlcnRzIGEgbW9kdWxlIHRvIGEgdHlwZXNjcmlwdCBtb2R1bGUuXG4gKi9cbmV4cG9ydHMubW9kdWxlMlRTID0gZnVuY3Rpb24gKG4sIF9hKSB7XG4gICAgdmFyIG1vZHVsZSA9IF9hLm1vZHVsZTtcbiAgICByZXR1cm4gXCJcXG5pbXBvcnQgKiBhcyBcIiArIFdNTCArIFwiIGZyb20gJ1wiICsgbW9kdWxlICsgXCInO1xcblwiICsgbi5pbXBvcnRzLm1hcChleHBvcnRzLmltcG9ydFN0YXRlbWVudDJUUykuam9pbignO1xcbicpICsgXCJcXG5cXG5cIiArIG4uZXhwb3J0cy5tYXAoZXhwb3J0cy5leHBvcnRzMlRTKS5qb2luKCc7XFxuJykgKyBcIlxcblxcblwiICsgKG4ubWFpbiA/IGV4cG9ydHMubWFpbjJUUyhuLm1haW4pIDogJycpICsgXCJcXG5cIjtcbn07XG4vKipcbiAqIGV4cG9ydHMyVFMgY29udmVydHMgdmFyaW91cyBleHBvcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZXhwb3J0czJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5FeHBvcnRTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRnVuU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5TdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdTdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBpbXBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gaW1wb3J0IHN0YXRlbWVudC5cbiAqL1xuZXhwb3J0cy5pbXBvcnRTdGF0ZW1lbnQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcImltcG9ydCBcIiArIGV4cG9ydHMuaW1wb3J0TWVtYmVyMlRTKG4ubWVtYmVyKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7IFwiO1xufTtcbi8qKlxuICogaW1wb3J0TWVtYmVyMlRTIGNvbnZlcnRzIHRoZSBtZW1iZXJzIG9mIGFuIGltcG9ydCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmltcG9ydE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5BZ2dyZWdhdGVNZW1iZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmFnZ3JlZ2F0ZU1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQWxpYXNlZE1lbWJlcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29tcG9zaXRlTWVtYmVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiBhbGlhc2VkTWVtYmVyMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGFsaWFzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5tZW1iZXIpICsgXCIgYXMgXCIgKyBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uYWxpYXMpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBhZ2dyZWdhdGVNZW1iZXIyVFMgY29udmVydHMgYSBxdWFsaWZpZWQgbWVtYmVyIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuYWdncmVnYXRlTWVtYmVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIqIGFzIFwiICsgZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyhuLmlkKSArIFwiIFwiO1xufTtcbi8qKlxuICogY29tcG9zaXRlTWVtYmVyMlRTIGNvdmVydHMgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAneycgKyAobi5tZW1iZXJzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKG0gaW5zdGFuY2VvZiBub2Rlcy5BbGlhc2VkTWVtYmVyKSA/XG4gICAgICAgIGV4cG9ydHMuYWxpYXNlZE1lbWJlcjJUUyhtKSA6XG4gICAgICAgIGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobSk7IH0pLmpvaW4oJywnKSkgKyAnfSc7XG59O1xuLyoqXG4gKiBtYWluMlRTIGNvbnZlcnRzIHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMubWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRNYWluKSA/XG4gICAgICAgIGV4cG9ydHMudHlwZWRNYWluMlRTKG4pIDpcbiAgICAgICAgZXhwb3J0cy51bnR5cGVkTWFpbjJUUyhuKTtcbn07XG4vKipcbiAqIHR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhIHR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnR5cGVkTWFpbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhuLmlkID8gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobi5pZCkgOiAnTWFpbicsIGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcyksIG4ucGFyYW1ldGVycy5tYXAoZXhwb3J0cy5wYXJhbWV0ZXIyVFMpLmpvaW4oJywnKSwgZXhwb3J0cy50eXBlMlRTKG4uY29udGV4dCksIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiB1bnR5cGVkTWFpbjJUUyBjb252ZXJ0cyBhbiB1bnR5cGVkIG1haW4gZmlsZSB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVudHlwZWRNYWluMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy52aWV3KCdNYWluJywgJycsICcnLCAndm9pZCcsIGV4cG9ydHMudGFnMlRTKG4udGFnKSk7XG59O1xuLyoqXG4gKiBleHBvcnRTdGF0ZW1lbnQyVFMgY29udmVydHMgYW4gZXhwb3J0IHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmV4cG9ydFN0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiZXhwb3J0IFwiICsgZXhwb3J0cy5jb21wb3NpdGVNZW1iZXIyVFMobi5tZW1iZXJzKSArIFwiIGZyb20gJ1wiICsgbi5tb2R1bGUudmFsdWUgKyBcIic7XFxuXCI7XG59O1xuLyoqXG4gKiB2aWV3U3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgdmlldyBzdGF0ZW1lbnQgaW50byBhIHR5cGVzY3JpcHQgY2xhc3MuXG4gKi9cbmV4cG9ydHMudmlld1N0YXRlbWVudDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmlldyhleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4uaWQpLCBleHBvcnRzLnR5cGVDbGFzc2VzMlRTKG4udHlwZUNsYXNzZXMpLCBuLnBhcmFtZXRlcnMubWFwKGV4cG9ydHMucGFyYW1ldGVyMlRTKS5qb2luKCcsJyksIGV4cG9ydHMudHlwZTJUUyhuLmNvbnRleHQpLCBleHBvcnRzLnRhZzJUUyhuLnRhZykpO1xufTtcbnZhciBfZnVuQ29udGV4dCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIihcIiArIENPTlRFWFQgKyBcIjpcIiArIGV4cG9ydHMudHlwZTJUUyhuKSArIFwiKT0+XCI7IH07XG52YXIgX2Z1blZpZXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIihcIiArIFZJRVcgKyBcIjpcIiArIFdNTCArIFwiLlZpZXcpPT5cIjsgfTtcbi8qKlxuICogZnVuU3RhdGVtZW50MlRTIGNvbnZlcnRzIGEgZnVuY3Rpb24gc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZnVuU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJleHBvcnQgY29uc3QgXCIgKyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuLmlkKSArIFwiID0gXCIgK1xuICAgICAgICAoZXhwb3J0cy50eXBlQ2xhc3NlczJUUyhuLnR5cGVDbGFzc2VzKSArIFwiKFwiICsgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpPT5cIikgK1xuICAgICAgICAoKG4uY29udGV4dCAhPSBudWxsKSA/IF9mdW5Db250ZXh0KG4uY29udGV4dCkgOiAnJykgK1xuICAgICAgICBfZnVuVmlldygpICtcbiAgICAgICAgKChBcnJheS5pc0FycmF5KG4uYm9keSkgPyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uYm9keSkgOiBleHBvcnRzLmNoaWxkMlRTKG4uYm9keSkpICsgXCI7XCIpO1xufTtcbi8qKlxuICogdHlwZUNsYXNzZXMyVFMgY29udmVydHMgYSBsaXN0IG9mIHR5cGVjbGFzc2VzIGludG8gdGhlIGEgbGlzdCBvZiB0eXBlc2NyaXB0IHR5cGVjbGFzc2VzLlxuICovXG5leHBvcnRzLnR5cGVDbGFzc2VzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBcIjwgXCIgKyBucy5tYXAoZXhwb3J0cy50eXBlQ2xhc3MyVFMpLmpvaW4oJywnKSArIFwiPlwiO1xufTtcbi8qKlxuICogdHlwZUNsYXNzMlRTIGNvbnZlcnRzIGEgdHlwZWNsYXNzIGludG8gYSB0eXBlc2NyaXB0IHR5cGVjbGFzcy5cbiAqL1xuZXhwb3J0cy50eXBlQ2xhc3MyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpICsgXCIgXCIgK1xuICAgICAgICAoKG4uY29uc3RyYWludCA/ICdleHRlbmRzICcgKyBleHBvcnRzLnR5cGUyVFMobi5jb25zdHJhaW50KSA6ICcnKSArIFwiIFwiKTtcbn07XG52YXIgX3RvUHJpbSA9IGZ1bmN0aW9uICh0eXApIHtcbiAgICByZXR1cm4gcHJpbXMuaW5kZXhPZih0eXApID4gLTEgPyB0eXAudG9Mb3dlckNhc2UoKSA6IHR5cDtcbn07XG4vKipcbiAqIHR5cGUyVFMgY29udmVydHMgYSB0eXBlIGhpbnQgdG8gYSB0eXBlc2NyaXB0IHR5cGUgaGludC5cbiAqL1xuZXhwb3J0cy50eXBlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gX3RvUHJpbShleHBvcnRzLmlkZW50aWZpZXJPckNvbnN0cnVjdG9yMlRTKG4uaWQpKSArIFwiIFwiICtcbiAgICAgICAgKGV4cG9ydHMudHlwZUNsYXNzZXMyVFMobi50eXBlQ2xhc3NlcykgKyBcIiBcIiArIChuLmxpc3QgPyAnW10nIDogJycpKTtcbn07XG4vKipcbiAqIHBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHBhcmFtZXRlciB0byBhIHR5cGVzY3JpcHQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLnBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuVHlwZWRQYXJhbWV0ZXIpID8gZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW50eXBlZFBhcmFtZXRlcikgPyBleHBvcnRzLnVudHlwZWRQYXJhbWV0ZXIyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd247XG59O1xuLyoqXG4gKiB0eXBlZFBhcmFtZXRlcjJUUyBjb252ZXJ0cyBhIHR5cGVkIHBhcmFtZXRlciBpbnRvIGEgbm9uLWFueSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy50eXBlZFBhcmFtZXRlcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLmlkKSArIFwiOlwiICsgZXhwb3J0cy50eXBlMlRTKG4uaGludCkgKyBcIiBcIjtcbn07XG4vKipcbiAqIHVudHlwZWRQYXJhbWV0ZXIyVFMgY29udmVydHMgYW4gdHlwZSBpbmZlcnJlZCBwYXJhbWV0ZXIgdG8gYSB0eXBlc2NyaXB0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy51bnR5cGVkUGFyYW1ldGVyMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4uaWQpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBjaGlsZHJlbjJUUyBjb252ZXJ0cyBhIGxpc3Qgb2YgY2hpbGRyZW4gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jaGlsZHJlbjJUUyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgcmV0dXJuIChsaXN0Lmxlbmd0aCA9PT0gMCkgPyAnZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOycgOlxuICAgICAgICAobGlzdC5sZW5ndGggPT09IDEpID8gZXhwb3J0cy5jaGlsZDJUUyhsaXN0WzBdKSA6XG4gICAgICAgICAgICBXTUwgKyBcIi5ib3goXCIgKyBsaXN0Lm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gZXhwb3J0cy5jaGlsZDJUUyhsKTsgfSkuam9pbignLCcpICsgXCIpIFwiO1xufTtcbi8qKlxuICogY2hpbGQyVFMgY29udmVydHMgY2hpbGRyZW4gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5jaGlsZDJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSkgfHwgKG4gaW5zdGFuY2VvZiBub2Rlcy5XaWRnZXQpKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50YWcyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkludGVycG9sYXRpb24pXG4gICAgICAgIHJldHVybiBXTUwgKyBcIi5kb21pZnkoXCIgKyBleHBvcnRzLmludGVycG9sYXRpb24yVFMobikgKyBcIikgXCI7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLklmU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5pZlN0YXRlbWVudDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuRm9yU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mb3JTdGF0ZW1lbnQyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNoYXJhY3RlcnMpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNoYXJhY3RlcnMyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkNvbnRleHRQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29udGV4dFByb3BlcnR5MlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlVucXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRJZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogdGFnMlRTIGNvbnZlcnRzIGEgdGFnIChub2RlL3dpZGdldCkgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy50YWcyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBjaGlsZHJlbiA9IG4uY2hpbGRyZW4ubWFwKGV4cG9ydHMuY2hpbGQyVFMpO1xuICAgIHZhciBhdHRycyA9IGV4cG9ydHMuYXR0cnMyU3RyaW5nKGV4cG9ydHMuZ3JvdXBBdHRycyhuLmF0dHJpYnV0ZXMpKTtcbiAgICB2YXIgbmFtZSA9IGV4cG9ydHMuaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFMobi5vcGVuKTtcbiAgICByZXR1cm4gKG4udHlwZSA9PT0gJ3dpZGdldCcpID8gV01MICsgXCIud2lkZ2V0KFwiICsgbmFtZSArIFwiLCBcIiArIGF0dHJzICsgXCIsIFtcIiArIGNoaWxkcmVuICsgXCJdLCBcIiArIFZJRVcgKyBcIilcIiA6XG4gICAgICAgIFdNTCArIFwiLm5vZGUoJ1wiICsgbmFtZSArIFwiJywgXCIgKyBhdHRycyArIFwiLCBbXCIgKyBjaGlsZHJlbiArIFwiXSwgXCIgKyBWSUVXICsgXCIpIFwiO1xufTtcbi8qKlxuICogYXR0cnMyU3RyaW5nXG4gKi9cbmV4cG9ydHMuYXR0cnMyU3RyaW5nID0gZnVuY3Rpb24gKGF0dHJzKSB7IHJldHVybiAneycgK1xuICAgIChPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChucykgeyByZXR1cm4gbnMgKyBcIiA6IHsgXCIgKyBhdHRyc1tuc10uam9pbignLCcpICsgXCIgfSBcIjsgfSkpICsgJ30nOyB9O1xuLyoqXG4gKiBncm91cEF0dHJzIGdyb3VwcyBhdHRyaWJ1dGVzIGFjY29yZGluZyB0byB0aGVpciBuYW1lc3BhY2UuXG4gKi9cbmV4cG9ydHMuZ3JvdXBBdHRycyA9IGZ1bmN0aW9uIChucykgeyByZXR1cm4gbnMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIGFmcGwudXRpbC5tZXJnZShwLCAoX2EgPSB7fSxcbiAgICAgICAgX2FbYy5uYW1lc3BhY2UuaWQgfHwgJ2h0bWwnXSA9IChwW2MubmFtZXNwYWNlLmlkIHx8ICdodG1sJ10gfHwgW10pLmNvbmNhdChleHBvcnRzLmF0dHJpYnV0ZTJUUyhjKSksXG4gICAgICAgIF9hKSk7XG4gICAgdmFyIF9hO1xufSwgeyBodG1sOiBbXSwgd21sOiBbXSB9KTsgfTtcbi8qKlxuICogYXR0cmlidXRlMlZhbHVlXG4gKi9cbmV4cG9ydHMuYXR0cmlidXRlMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCInXCIgKyBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuLm5hbWUpICsgXCInIDogXCIgKyBleHBvcnRzLmF0dHJpYnV0ZVZhbHVlMlRTKG4udmFsdWUpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBhdHRyaWJ1dGVWYWx1ZTJUUyBjb252ZXJ0cyBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5hdHRyaWJ1dGVWYWx1ZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuSW50ZXJwb2xhdGlvbikgPyBleHBvcnRzLmludGVycG9sYXRpb24yVFMobikgOiBleHBvcnRzLmxpdGVyYWwyVFMobik7XG59O1xuLyoqXG4gKiBpbnRlcnBvbGF0aW9uMlRTIGNvbnZlcnRzIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pbnRlcnBvbGF0aW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5maWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAocCwgYykgeyByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKGMpICsgXCIgKFwiICsgcCArIFwiKVwiOyB9LCBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5leHByZXNzaW9uKSk7XG59O1xuLyoqXG4gKiBmb3JTdGF0ZW1lbnQyVFMgY29udmVydHMgYSBmb3Igc3RhdGVtZW50IHRvIHR5cGVzY3JpcHQuXG4gKi9cbmV4cG9ydHMuZm9yU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gV01MICsgXCIubWFwKFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4ubGlzdCkgKyBcIiwgZnVuY3Rpb24gX21hcFwiICtcbiAgICAgICAgKFwiKFwiICsgW24udmFyaWFibGUsIG4uaW5kZXgsIG4uYWxsXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpIFwiKSArXG4gICAgICAgIChcInsgcmV0dXJuIFwiICsgZXhwb3J0cy5jaGlsZHJlbjJUUyhuLmJvZHkpICsgXCIgfSwgXCIpICtcbiAgICAgICAgKFwiZnVuY3Rpb24gb3RoZXJ3aXNlKCkgeyByZXR1cm4gXCIgKyBleHBvcnRzLmNoaWxkcmVuMlRTKG4ub3RoZXJ3aXNlKSArIFwiIH0pIFwiKTtcbn07XG4vKipcbiAqIGlmU3RhdGVtZW50MlRTIGNvbnZlcnRzIGFuIGlmIHN0YXRlbWVudCB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLmlmU3RhdGVtZW50MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIpPyBcIiArXG4gICAgICAgIChleHBvcnRzLmNoaWxkcmVuMlRTKG4udGhlbikgKyBcIjpcIikgK1xuICAgICAgICAoXCJcIiArIChuLmVsc2VDbGF1c2UgPyBlbHNlMlRTKG4uZWxzZUNsYXVzZSkgOiBub29wKCkpKTtcbn07XG52YXIgZWxzZTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuRWxzZUNsYXVzZSkgPyBleHBvcnRzLmNoaWxkcmVuMlRTKG4uY2hpbGRyZW4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5FbHNlSWZDbGF1c2UpID8gZXhwb3J0cy5pZlN0YXRlbWVudDJUUyhuKSA6XG4gICAgICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGNoYXJhY3RlcnMyVFMgY29udmVydHMgY2hhcmFjdGVyIHRleHQgdG8gYSB0eXBlc2NyaXB0IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5jaGFyYWN0ZXJzMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFdNTCArIFwiLnRleHQoYFwiICsgbi52YWx1ZSArIFwiYClcIjsgfTtcbi8qKlxuICogZXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIHdtbCBleHByZXNzaW9uIHRvIGEgdHlwZXNjcmlwdCBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuSWZUaGVuRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaWZUaGVuRXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQmluYXJ5RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYmluYXJ5RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5hcnlFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bmFyeUV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLlZpZXdDb25zdHJ1Y3Rpb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLnZpZXdDb25zdHJ1Y3Rpb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bkFwcGxpY2F0aW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29uc3RydWN0RXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uc3RydWN0RXhwcmVzc2lvbjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5NZW1iZXJFeHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWFkRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVhZEV4cHJlc3Npb24yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLkZ1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZnVuY3Rpb25FeHByZXNzaW9uMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5SZWNvcmQpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlY29yZDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuTGlzdClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGlzdDJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQm9vbGVhbkxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJvb2xlYW4yVFMobik7XG4gICAgZWxzZSBpZiAobiBpbnN0YW5jZW9mIG5vZGVzLk51bWJlckxpdGVyYWwpXG4gICAgICAgIHJldHVybiBleHBvcnRzLm51bWJlcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbClcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3RyaW5nMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5Db250ZXh0UHJvcGVydHkpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnRleHRQcm9wZXJ0eTJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBleHBvcnRzLnVucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucXVhbGlmaWVkSWRlbnRpZmllcjJUUyhuKTtcbiAgICBlbHNlIGlmIChuIGluc3RhbmNlb2Ygbm9kZXMuQ29udGV4dFZhcmlhYmxlKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb250ZXh0VmFyaWFibGUyVFMobik7XG4gICAgZWxzZVxuICAgICAgICBfdGhyb3dOb3RLbm93bihuKTtcbn07XG4vKipcbiAqIGlmVGhlbkV4cHJlc3Npb24yVFMgY29udmVydHMgYW4gaWYtdGhlbi1lbHNlIGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5pZlRoZW5FeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5jb25kaXRpb24pICsgXCIpID8gXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5pZnRydWUpICsgXCIgOiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLmlmZmFsc2UpICsgXCIgXCI7XG59O1xuLyoqXG4gKiBiaW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgYmluYXJ5IGV4cHJlc3Npb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5iaW5hcnlFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5sZWZ0KSArIFwiIFwiICsgZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3Iobi5vcGVyYXRvcikgKyBcIiBcIiArIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnJpZ2h0KSArIFwiKSBcIjtcbn07XG4vKipcbiAqIGNvbnZlcnRPcGVyYXRvciBmb3Igc3RyaWN0bmVzcy5cbiAqL1xuZXhwb3J0cy5jb252ZXJ0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICByZXR1cm4gKG9wID09PSAnPT0nKSA/ICc9PT0nIDpcbiAgICAgICAgKG9wID09PSAnIT0nKSA/ICchPT0nIDpcbiAgICAgICAgICAgIG9wO1xufTtcbi8qKlxuICogdW5hcnlFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgdW5hcnkgZXhwcmVzc2lvbiB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnVuYXJ5RXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ub3BlcmF0b3IgKyBcIiAoXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5leHByZXNzaW9uKSArIFwiKVwiO1xufTtcbi8qKlxuICogdmlld0NvbnN0cnVjdGlvbjJUUyBjb252ZXJzIGEgdmlldyBjb25zdHJ1Y3Rpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy52aWV3Q29uc3RydWN0aW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCIobmV3IFwiICsgZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyhuLmNvbnMpICsgXCIoXCIgKyBleHBvcnRzLmFyZ3MyVFMobi5jb250ZXh0KSArIFwiKSkucmVuZGVyKClcIjtcbn07XG52YXIgX2FwcGx5RnVuID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gKGNvbnRleHQubGVuZ3RoID4gMCA/IFwiKFwiICsgZXhwb3J0cy5hcmdzMlRTKGNvbnRleHQpICsgXCIpXCIgOiAnJykgKyAoXCIoXCIgKyBWSUVXICsgXCIpXCIpO1xufTtcbi8qKlxuICogZnVuQXBwbGljYXRpb24yVFMgY29udmVydHMgYSBmdW4gYXBwbGljYXRpb24gdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5mdW5BcHBsaWNhdGlvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIiBcIiArIGV4cG9ydHMudHlwZUFyZ3MyVFMobi50eXBlQXJncykgKyBcIiBcIiArXG4gICAgICAgIChcIihcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCIgKyBfYXBwbHlGdW4obi5jb250ZXh0KSk7XG59O1xuLyoqXG4gKiBjb25zdHJ1Y3RFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgY29uc3RydWN0IGV4cHJlc3Npb24gdG8gYSB0eXBlc2NyaXB0IG5ldyBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmNvbnN0cnVjdEV4cHJlc3Npb24yVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIm5ldyBcIiArIGV4cG9ydHMuY29uc3RydWN0b3IyVFMobi5jb25zKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiBjYWxsRXhwcmVzc2lvbjJUUyBjb252ZXJ0cyBhIGNhbGwgZXhwcmVzc2lvbiAoYXBwbHkpIHRvIGEgdHlwZXNjcmlwdCBpbnZvY2F0aW9uLlxuICovXG5leHBvcnRzLmNhbGxFeHByZXNzaW9uMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5leHByZXNzaW9uMlRTKG4udGFyZ2V0KSArIFwiIFwiICsgZXhwb3J0cy50eXBlQXJnczJUUyhuLnR5cGVBcmdzKSArIFwiIChcIiArIGV4cG9ydHMuYXJnczJUUyhuLmFyZ3MpICsgXCIpXCI7XG59O1xuLyoqXG4gKiB0eXBlQXJnczJUUyBjb252ZXJ0cyBwYXNzZWQgdHlwZSBhcmd1bWVudHMgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnR5cGVBcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIG5zLmxlbmd0aCA9PT0gMCA/ICcnIDogXCI8IFwiICsgbnMubWFwKGV4cG9ydHMudHlwZTJUUykuam9pbignLCcpICsgXCI+XCI7XG59O1xuLyoqXG4gKiBhcmdzMlRTIGNvbnZlcnRzIGEgbGlzdCBvZiBhcmd1bWVudHMgdG8gYSB0eXBlc2NyaXB0IGFyZ3VtZW50IHR1cHBsZS5cbiAqL1xuZXhwb3J0cy5hcmdzMlRTID0gZnVuY3Rpb24gKG5zKSB7XG4gICAgcmV0dXJuIChucy5sZW5ndGggPT09IDApID8gJycgOiBucy5tYXAoZXhwb3J0cy5leHByZXNzaW9uMlRTKS5qb2luKCcsJyk7XG59O1xuLyoqXG4gKiBtZW1iZXJFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgbWVtYmVyIGV4cHJlc3Npb24gaW50byBhIHR5cGVzY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uXG4gKi9cbmV4cG9ydHMubWVtYmVyRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhwcmVzc2lvbjJUUyhuLnRhcmdldCkgKyBcIi5cIiArIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLm1lbWJlcikgKyBcIiBcIjtcbn07XG4vKipcbiAqIHJlYWRFeHByZXNzaW9uMlRTIGNvbnZlcnRzIGEgcmVhZCBleHByZXNzaW9uIHRvIHNpZGUgZWZmZWN0IGZ1bGwgcHJvcGVydHkgbG9vayB1cC5cbiAqXG4gKiBOT1RFOiB0aGlzIHBhcnQgb2YgdGhlIGxhbmd1YWdlIGlzIG1vc3QgbGlrZWx5IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0cy5yZWFkRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFdNTCArIFwiLnJlYWQgPCBcIiArIGV4cG9ydHMudHlwZTJUUyhuLmhpbnQpICsgXCI+KFwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4ucGF0aCkgKyBcIiwgXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi50YXJnZXQpICsgXCIgXCIgK1xuICAgICAgICAoKG4uZGVmYXVsdHMgPyAnLCcgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi5kZWZhdWx0cykgOiAnJykgKyBcIilcIik7XG59O1xuLyoqXG4gKiBmdW5jdGlvbkV4cHJlc3Npb24yVFMgY29udmVydHMgYSBmdW5jdGlvbiBleHByZXNzaW9uIHRvIGEgdHlwZXNjcmlwdCBmdW5jdGlvbiBleHByZXNzaW9uLlxuICovXG5leHBvcnRzLmZ1bmN0aW9uRXhwcmVzc2lvbjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgbi5wYXJhbWV0ZXJzLm1hcChleHBvcnRzLnBhcmFtZXRlcjJUUykuam9pbignLCcpICsgXCIpPT5cIiArXG4gICAgICAgIChcIlwiICsgZXhwb3J0cy5leHByZXNzaW9uMlRTKG4uYm9keSkpO1xufTtcbi8qKlxuICogbGl0ZXJhbDJUUyBjb252ZXJ0cyBsaXRlcmFscy5cbiAqL1xuZXhwb3J0cy5saXRlcmFsMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBub2Rlcy5Cb29sZWFuTGl0ZXJhbCkgPyBleHBvcnRzLmJvb2xlYW4yVFMobikgOlxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlN0cmluZ0xpdGVyYWwpID8gZXhwb3J0cy5zdHJpbmcyVFMobikgOlxuICAgICAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5OdW1iZXJMaXRlcmFsKSA/IGV4cG9ydHMubnVtYmVyMlRTKG4pIDpcbiAgICAgICAgICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlJlY29yZCkgPyBleHBvcnRzLnJlY29yZDJUUyhuKSA6XG4gICAgICAgICAgICAgICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuTGlzdCkgPyBleHBvcnRzLmxpc3QyVFMobikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBib29sZWFuMlRTIGNvbnZlcnRzIGEgYm9vbGVhbiBsaXRlcmFsIHRvIGEgdHlwZXNjcmlwdCBib29sZWFuIGxpdGVyYWwuXG4gKi9cbmV4cG9ydHMuYm9vbGVhbjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZhbHVlICsgXCIgXCI7IH07XG4vKipcbiAqIHN0cmluZzJUUyBjb252ZXJ0cyBhIHN0cmluZyBsaXRlcmFsIHRvIGEgdHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5zdHJpbmcyVFMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gXCJgXCIgKyBuLnZhbHVlICsgXCJgXCI7IH07XG4vKipcbiAqIG51bWJlcjJUUyBjb252ZXJ0cyBhIG51bWJlciBsaXRlcmFsIHRvIGEgdHlwZWNyaXB0IG51bWJlciBsaXRlcmFsLlxuICovXG5leHBvcnRzLm51bWJlcjJUUyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIlwiICsgcGFyc2VGbG9hdChuLnZhbHVlKTsgfTtcbi8qKlxuICogcmVjb3JkMlRTIGNvbnZlcnRzIGEgcmVjb3JkIHRvIGEgdHlwZXNjcmlwdCBvYmplY3QgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5yZWNvcmQyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIntcIiArIG4ucHJvcGVydGllcy5tYXAoZXhwb3J0cy5wcm9wZXJ0eTJUUykuam9pbignLCcpICsgXCJ9XCI7XG59O1xuLyoqXG4gKiBsaXN0MlRTIGNvbnZlcnRzIGEgbGlzdCB0byBhIHR5cGVzY3JpcHQgYXJyYXkgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0cy5saXN0MlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJbXCIgKyBuLm1lbWJlcnMubWFwKGV4cG9ydHMuZXhwcmVzc2lvbjJUUykuam9pbignLCcpICsgXCJdXCI7XG59O1xuLyoqXG4gKiBwcm9wZXJ0eTJUUyBjb252ZXJ0cyBhIHByb3BlcnR5IG9mIGEgYSByZWNvcmQgdG8gdHlwZXNjcmlwdC5cbiAqL1xuZXhwb3J0cy5wcm9wZXJ0eTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFwiJ1wiICsgZXhwb3J0cy5rZXkyVFMobi5rZXkpICsgXCInIDogXCIgKyBleHBvcnRzLmV4cHJlc3Npb24yVFMobi52YWx1ZSk7XG59O1xuLyoqXG4gKiBrZXkyVFMgY29udmVydHMgYSBzaW5nbGUga2V5IG9uIGEgcmVjb3JkLlxuICovXG5leHBvcnRzLmtleTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuU3RyaW5nTGl0ZXJhbCkgPyBleHBvcnRzLnN0cmluZzJUUyhuKSA6IGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuKTtcbn07XG4vKipcbiAqIGNvbnRleHRQcm9wZXJ0eTJUUyB0dXJucyBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIGNvbnRleHQgdG8gcmVndWxhciBUU1xuICogcHJvcGVydHkgYWNjZXNzLlxuICovXG5leHBvcnRzLmNvbnRleHRQcm9wZXJ0eTJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIENPTlRFWFQgKyBcIi5cIiArIGV4cG9ydHMuaWRlbnRpZmllcjJUUyhuLm1lbWJlcik7XG59O1xuLyoqXG4gKiBjb250ZXh0VmFyaWFibGUyVFMgdHVybnMgdGhlIGNvbnRleHQgdmFyaWFibGUgaW50byB0aGUgY29udGV4dCBpZGVudGlmaWVyLlxuICovXG5leHBvcnRzLmNvbnRleHRWYXJpYWJsZTJUUyA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBcIlwiICsgQ09OVEVYVDsgfTtcbi8qKlxuICogaWRlbnRpZmllck9yQ29uc3RydWN0b3IyVFNcbiAqL1xuZXhwb3J0cy5pZGVudGlmaWVyT3JDb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRJZGVudGlmaWVyKSB8fFxuICAgICAgICAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5pZGVudGlmaWVyMlRTKG4pO1xuICAgIGVsc2UgaWYgKChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcikgfHxcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5RdWFsaWZpZWRDb25zdHJ1Y3RvcikpXG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbnN0cnVjdG9yMlRTKG4pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIF90aHJvd05vdEtub3duKG4pO1xufTtcbi8qKlxuICogY29uc3RydWN0b3IyVFMgdHVybnMgYSBjb25zdHJ1Y3RvciB0byBhIHR5cGVzY3JpcHQgaWRlbnRpZmllci5cbiAqXG4gKiBSZW1lbWJlciBjb25zdHJ1Y3RvcnMgYXJlIHByb3BlciBjYXNlZC5cbiAqL1xuZXhwb3J0cy5jb25zdHJ1Y3RvcjJUUyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIGluc3RhbmNlb2Ygbm9kZXMuUXVhbGlmaWVkQ29uc3RydWN0b3IpID8gZXhwb3J0cy5xdWFsaWZpZWRDb25zdHJ1Y3RvcjJUUyhuKSA6XG4gICAgICAgIChuIGluc3RhbmNlb2Ygbm9kZXMuVW5xdWFsaWZpZWRDb25zdHJ1Y3RvcikgPyBleHBvcnRzLnVucXVhbGlmaWVkQ29uc3RydWN0b3IyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiB1bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTIGNvbnZlcnRzIGFuIHVucXVhbGlmaWVkIGNvbnN0cnVjdG9yIHRvIHR5cGVzY3JpcHRcbiAqL1xuZXhwb3J0cy51bnF1YWxpZmllZENvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBuLmlkOyB9O1xuLyoqXG4gKiBxdWFsaWZpZWRDb25zdHJ1Y3RvciBjb252ZXJ0cyBhIHF1YWxpZmllZCBjb25zdHJ1Y3RvciB0byB0eXBlc2NyaXB0LlxuICovXG5leHBvcnRzLnF1YWxpZmllZENvbnN0cnVjdG9yMlRTID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5xdWFsaWZpZXIgKyBcIi5cIiArIG4ubWVtYmVyO1xufTtcbi8qKlxuICogaWRlbnRpZmllcjJUUyB0dXJucyBhbiBpZGVudGlmaWVyIHRvIGEgdHlwZXNjcmlwdCBpZGVudGlmaWVyLlxuICovXG5leHBvcnRzLmlkZW50aWZpZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiBpbnN0YW5jZW9mIG5vZGVzLlF1YWxpZmllZElkZW50aWZpZXIpID8gZXhwb3J0cy5xdWFsaWZpZWRJZGVudGlmaWVyMlRTKG4pIDpcbiAgICAgICAgKG4gaW5zdGFuY2VvZiBub2Rlcy5VbnF1YWxpZmllZElkZW50aWZpZXIpID8gZXhwb3J0cy51bnF1YWxpZmllZElkZW50aWZpZXIyVFMobikgOlxuICAgICAgICAgICAgX3Rocm93Tm90S25vd24obik7XG59O1xuLyoqXG4gKiBxdWFsaWZpZWRJZGVudGlmaWVyMlRTIGNvbnZlcnRzIGEgcXVhbGlmaWVkIGlkZW50aWZpZXIgdG8gdHlwZXNjcmlwdFxuICovXG5leHBvcnRzLnF1YWxpZmllZElkZW50aWZpZXIyVFMgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLnF1YWxpZmllciArIFwiLlwiICsgbi5tZW1iZXI7XG59O1xuLyoqXG4gKiB1bnF1YWxpZmllZElkZW50aWZpZXIyVFMgY29udmVydHMgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciB0byB0eXBlc2NyaXB0XG4gKi9cbmV4cG9ydHMudW5xdWFsaWZpZWRJZGVudGlmaWVyMlRTID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBuLmlkOyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHlwZVNjcmlwdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9wZXJ0eSA9IHJlcXVpcmUoXCJwcm9wZXJ0eS1zZWVrXCIpO1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiYWZwbC9saWIvbW9uYWQvTWF5YmVcIik7XG52YXIgQ29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL0NvbXBpbGVyXCIpO1xuZXhwb3J0cy5wYXJzZSA9IENvbXBpbGVyXzEucGFyc2U7XG5leHBvcnRzLmNvbXBpbGUgPSBDb21waWxlcl8xLmNvbXBpbGU7XG47XG4vKipcbiAqIENvbXBvbmVudCBpcyBhbiBhYnN0cmFjdCBXaWRnZXQgaW1wbGVtZW50YXRpb25cbiAqIHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBtYW51YWxseSBpbXBsZW1lbnRpbmcgdGhlIHdob2xlIGludGVyZmFjZS5cbiAqXG4gKi9cbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogYXR0cnMgaXMgdGhlIGF0dHJpYnV0ZXMgdGhpcyBDb21wb25lbnQgZXhjZXB0cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBjaGlsZHJlbiBpcyBhbiBhcnJheSBvZiBjb250ZW50IHBhc3NlZCB0byB0aGlzIENvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21wb25lbnQoYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcmVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoKTsgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuO1xuLyoqXG4gKiByZWFkIGEgdmFsdWUgZm9ybSBhbiBvYmplY3QuXG4gKlxuICogVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byByZWd1bGFyIHByb3BlcnR5IGFjY2VzcyB0aGF0IHdpbGwgdGhyb3cgZXhjZXB0aW9uc1xuICogaWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHBhcnQgYXJlIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIGxvb2sgdXAgb24gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvIC0gVGhlIG9iamVjdFxuICogQHBhcmFtIHtBfSBbZGVmYXVsdFZhbHVlXSAtIFRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAocGF0aCwgbywgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHByb3BlcnR5LmdldChwYXRoLnNwbGl0KCc6Jykuam9pbignLicpLCBvKTtcbiAgICByZXR1cm4gKHJldCAhPSBudWxsKSA/IHJldCA6IGRlZmF1bHRWYWx1ZTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZG9wdCA9IGZ1bmN0aW9uIChjaGlsZCwgZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIGNoaWxkKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyArIGNoaWxkKSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgYWRvcHQgY2hpbGQgXCIgKyBjaGlsZCArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgY2hpbGQpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZW50ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY29udGVudFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoYyk7IH0pO1xuICAgIHJldHVybiBmcmFnO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5kb21pZnkgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYm94LmFwcGx5KG51bGwsIGEubWFwKGV4cG9ydHMuZG9taWZ5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHx8XG4gICAgICAgICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHx8XG4gICAgICAgICh0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50ZXh0KGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCB1c2UgJ1wiICsgYSArIFwiJyh0eXBlb2YgXCIgKyB0eXBlb2YgYSArIFwiKSBhcyBDb250ZW50IVwiKTtcbiAgICB9XG59O1xuLyoqXG4gKiB0ZXh0IGNyZWF0ZXMgYSBuZXcgVGV4dE5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyB2YWx1ZSk7XG59O1xuLyoqXG4gKiBub2RlIGlzIGNhbGxlZCB0byBjcmVhdGUgYSByZWd1bGFyIERPTSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLm5vZGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1snaHRtbCddID09PSAnb2JqZWN0JylcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc1snaHRtbCddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbJ2h0bWwnXVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGFkb3B0KGMsIGUpOyB9KTtcbiAgICB2YXIgaWQgPSBhdHRyaWJ1dGVzWyd3bWwnXS5pZDtcbiAgICB2YXIgZ3JvdXAgPSBhdHRyaWJ1dGVzLndtbC5ncm91cDtcbiAgICBpZiAoaWQpXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUlkKGlkLCBlKTtcbiAgICBpZiAoZ3JvdXApXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUdyb3VwKGdyb3VwLCBlKTtcbiAgICByZXR1cm4gZTtcbn07XG4vKipcbiAqIHdpZGdldCBjcmVhdGVzIGFuZCByZW5kZXJzIGEgbmV3IHdtbCB3aWRnZXQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDb25zdHJ1dG9yXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICogQHBhcmFtIHthcnJheTxzdHJpbmd8bnVtYmVyfFdpZGdldD59IGNoaWxkcmVuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXdcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtXaWRnZXR9XG4gKi9cbmV4cG9ydHMud2lkZ2V0ID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuICAgIHZhciBjaGlsZHMgPSBbXTtcbiAgICB2YXIgdztcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKGNoaWxkIGluc3RhbmNlb2YgQXJyYXkpID9cbiAgICAgICAgY2hpbGRzLnB1c2guYXBwbHkoY2hpbGRzLCBjaGlsZCkgOiBjaGlsZHMucHVzaChjaGlsZCk7IH0pO1xuICAgIHcgPSBuZXcgQ29uc3RydWN0b3IoYXR0cmlidXRlcywgY2hpbGRzKTtcbiAgICB2YXIgaWQgPSBhdHRyaWJ1dGVzLndtbC5pZDtcbiAgICB2YXIgZ3JvdXAgPSBhdHRyaWJ1dGVzLndtbC5ncm91cDtcbiAgICBpZiAoaWQpXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUlkKGlkLCB3KTtcbiAgICBpZiAoZ3JvdXApXG4gICAgICAgIHZpZXcucmVnaXN0ZXJCeUdyb3VwKGdyb3VwLCB3KTtcbiAgICB2aWV3LnJlZ2lzdGVyV2lkZ2V0KHcpO1xuICAgIHJldHVybiB3LnJlbmRlcigpO1xufTtcbi8qKlxuICogaWZ0aGVuIHByb3ZpZGVzIGFuIGlmIHRoZW4gZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pZnRoZW4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBwb3NpdGl2ZSwgbmVnYXRpdmUpIHtcbiAgICByZXR1cm4gKHByZWRpY2F0ZSkgPyBwb3NpdGl2ZSgpIDogbmVnYXRpdmUoKTtcbn07XG4vKipcbiAqIGZvckUgcHJvdmlkZXMgYSBmb3IgZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tYXAgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgY2IsIGNiMikge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID4gMClcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAodiwgaywgYSkgeyByZXR1cm4gZnJhZy5hcHBlbmRDaGlsZChjYih2LCBrLCBhKSk7IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNiMigpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBsID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGlmIChsLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBsLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGZyYWcuYXBwZW5kQ2hpbGQoY2IoY29sbGVjdGlvbltrXSwgaywgY29sbGVjdGlvbikpOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjYjIoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xufTtcbi8qKlxuICogQXBwVmlldyBpcyB0aGUgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYSBWaWV3LlxuICpcbiAqIEBwcm9wZXJ0eSB7PEM+fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdGhlIHZpZXcgaXMgcmVuZGVyZWQgaW4uXG4gKi9cbnZhciBBcHBWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcFZpZXcoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICB9XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVnaXN0ZXJXaWRnZXQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlckJ5SWQgPSBmdW5jdGlvbiAoaWQsIHcpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZCAnXCIgKyBpZCArIFwiJyBkZXRlY3RlZCFcIik7XG4gICAgICAgIHRoaXMuaWRzW2lkXSA9IHc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVnaXN0ZXJCeUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwXSA9IHRoaXMuZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBdLnB1c2goZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmVcbiAgICAgICAgICAgIC5mcm9tQW55KHRoaXMuaWRzW2lkXSlcbiAgICAgICAgICAgIC5vckVsc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGlkICdcIiArIGlkICsgXCInIGlzIG1pc3NpbmchXCIpO1xuICAgICAgICAgICAgcmV0dXJuIE1heWJlXzEuTWF5YmUubm90aGluZygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmZpbmRHcm91cEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBNYXliZV8xLk1heWJlLmZyb21BcnJheSh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMuZ3JvdXBzW25hbWVdIDogW10pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcztcbiAgICAgICAgdmFyIHJlYWxGaXJzdENoaWxkSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHRyZWUgPSAodGhpcy5fZnJhZ1Jvb3QpID8gdGhpcy5fZnJhZ1Jvb3QgOiB0aGlzLnRyZWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0cmVlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0cmVlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ludmFsaWRhdGUoKTogQ2Fubm90IGludmFsaWRhdGUgYSB2aWV3IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIScpO1xuICAgICAgICBpZiAodHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ludmFsaWRhdGUoKTogQXR0ZW1wdCB0byBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiBpbnNlcnRlZCB0byBET00hJyk7XG4gICAgICAgIGNoaWxkcyA9IHRyZWUucGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIHRyZWUgb2NjYXNpb25hbGx5IGVuZHMgdXAgd2l0aCBhIG51bGwgcGFyZW50Tm9kZVxuICAgICAgICAvLyB3aGVuIHdlIGF0dGVtcHQgdG8gY2FsbCByZXBsYWNlQ2hpbGQuIE5vdGljZWFibHkgYWZ0ZXIgZG9pbmcgd29yayBvbiBhbiBhcnJheS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyB0byB1c2UgdGhlIGluZGV4IGluc3RlYWQgb2YgcGFzc2luZyB0aGUgcmVmZXJlbmNlIGRpcmVjdGx5LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGlsZHNbaV0gPT09IHRyZWUpXG4gICAgICAgICAgICAgICAgcmVhbEZpcnN0Q2hpbGRJbmRleCA9IGk7XG4gICAgICAgIC8vIGp1c3QgaW4gY2FzZSB3ZSBuZXZlciBnb3QgdGhlIGluZGV4LlxuICAgICAgICBpZiAocmVhbEZpcnN0Q2hpbGRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsZGlhdGUoKTogQ2Fubm90IGludmFsaWRhdGUgdmlldywgRE9NIHRyZWUgYXBwZWFycyB0byBoYXZlIG5vIHBhcmVudCEnKTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCBwYXJlbnQuY2hpbGRyZW5bcmVhbEZpcnN0Q2hpbGRJbmRleF0pO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy5yZW1vdmVkKCk7IH0pO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZnJhZ1Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlKHRoaXMuY29udGV4dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaWRzWydyb290J10gPSAodGhpcy5pZHNbJ3Jvb3QnXSkgPyB0aGlzLmlkc1sncm9vdCddIDogdGhpcy50cmVlO1xuICAgICAgICBpZiAodGhpcy50cmVlLm5vZGVOYW1lID09PSAoZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKS5ub2RlTmFtZSlcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdSb290ID0gdGhpcy50cmVlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnJlbmRlcmVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcFZpZXc7XG59KCkpO1xuZXhwb3J0cy5BcHBWaWV3ID0gQXBwVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mMSA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmOyB9O1xuZXhwb3J0cy5mMiA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGYoYSwgYik7IH07IH07IH07XG5leHBvcnRzLmYzID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZihhLCBiLCBjKTsgfTsgfTsgfTtcbn07XG5leHBvcnRzLmY0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGYoYSwgYiwgYywgZCk7IH07IH07IH07IH07XG59O1xuZXhwb3J0cy5mNSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZihhLCBiLCBjLCBkLCBlKTsgfTsgfTsgfTsgfTsgfTtcbn07XG5leHBvcnRzLmY2ID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHJldHVybiBmdW5jdGlvbiAoX2YpIHsgcmV0dXJuIGYoYSwgYiwgYywgZCwgZSwgX2YpOyB9OyB9OyB9OyB9OyB9OyB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciBjdXJyeSA9IHJlcXVpcmUoXCIuL2N1cnJ5XCIpO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xudmFyIElkZW50aXR5XzEgPSByZXF1aXJlKFwiLi9tb25hZC9JZGVudGl0eVwiKTtcbmV4cG9ydHMuSWRlbnRpdHkgPSBJZGVudGl0eV8xLklkZW50aXR5O1xudmFyIE1heWJlXzEgPSByZXF1aXJlKFwiLi9tb25hZC9NYXliZVwiKTtcbmV4cG9ydHMuTWF5YmUgPSBNYXliZV8xLk1heWJlO1xudmFyIEVpdGhlcl8xID0gcmVxdWlyZShcIi4vbW9uYWQvRWl0aGVyXCIpO1xuZXhwb3J0cy5FaXRoZXIgPSBFaXRoZXJfMS5FaXRoZXI7XG52YXIgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL21vbmFkL1N0YXRlXCIpO1xuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlXzEuU3RhdGU7XG52YXIgRnJlZV8xID0gcmVxdWlyZShcIi4vbW9uYWQvRnJlZVwiKTtcbmV4cG9ydHMuRnJlZSA9IEZyZWVfMS5GcmVlO1xudmFyIElPXzEgPSByZXF1aXJlKFwiLi9tb25hZC9JT1wiKTtcbmV4cG9ydHMuSU8gPSBJT18xLklPO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogbGVmdCB3cmFwcyBhIHZhbHVlIG9uIHRoZSBsZWZ0IHNpZGUuXG4gKi9cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgTGVmdChhKTsgfTtcbi8qKlxuICogcmlnaHQgd3JhcHMgYSB2YWx1ZSBvbiB0aGUgcmlnaHQgc2lkZS5cbiAqL1xuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uIChiKSB7IHJldHVybiBuZXcgUmlnaHQoYik7IH07XG4vKipcbiAqIGZyb21Cb29sZWFuIGNvbnN0cnVjdHMgYW4gRWl0aGVyIHVzaW5nIGEgYm9vbGVhbiB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5mcm9tQm9vbGVhbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIGIgPyBleHBvcnRzLnJpZ2h0KHRydWUpIDogZXhwb3J0cy5sZWZ0KGZhbHNlKTtcbn07XG4vKipcbiAqIEVpdGhlciBtb25hZCBpbXBsZW1lbnRhdGlvblxuICovXG52YXIgRWl0aGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFaXRoZXIoKSB7XG4gICAgfVxuICAgIEVpdGhlci5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2h0KHYpO1xuICAgIH07XG4gICAgRWl0aGVyLmxlZnQgPSBleHBvcnRzLmxlZnQ7XG4gICAgRWl0aGVyLnJpZ2h0ID0gZXhwb3J0cy5yaWdodDtcbiAgICBFaXRoZXIuZnJvbUJvb2xlYW4gPSBleHBvcnRzLmZyb21Cb29sZWFuO1xuICAgIHJldHVybiBFaXRoZXI7XG59KCkpO1xuZXhwb3J0cy5FaXRoZXIgPSBFaXRoZXI7XG52YXIgTGVmdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlZnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVmdChsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmwgPSBsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExlZnQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVmdCh0aGlzLmwpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUubWFwTGVmdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVmdChmKHRoaXMubCkpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuYmltYXAgPSBmdW5jdGlvbiAoZiwgXykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5sZWZ0KGYodGhpcy5sKSk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVmdCh0aGlzLmwpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5sKTtcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLm9yUmlnaHQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2h0KGYodGhpcy5sKSk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5hcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVmdCh0aGlzLmwpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUudGFrZUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmw7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS50YWtlUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgcmlnaHQhXCIpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChmLCBfKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMubCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGVmdDtcbn0oRWl0aGVyKSk7XG5leHBvcnRzLkxlZnQgPSBMZWZ0O1xudmFyIFJpZ2h0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmlnaHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmlnaHQocikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yID0gcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSaWdodC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodChmKHRoaXMucikpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLm1hcExlZnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2h0KHRoaXMucik7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuYmltYXAgPSBmdW5jdGlvbiAoXywgZykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5yaWdodChnKHRoaXMucikpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9yRWxzZSByZXR1cm5zIHRoZSByZXN1bHQgb2YgZiBpZiB0aGUgRWl0aGVyIGlzIGxlZnQuXG4gICAgICovXG4gICAgUmlnaHQucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLm9yUmlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFwXG4gICAgICovXG4gICAgUmlnaHQucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGUubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKF90aGlzLnIpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgKiB0YWtlTGVmdCBleHRyYWN0cyB0aGUgbGVmdCB2YWx1ZSBvZiBhbiBFaXRoZXIsIHRocm93aW5nIGFuIGVycm9yIGlmIHRoZSBFaXRoZXIgaXMgcmlnaHQuXG4gICAgICAqL1xuICAgIFJpZ2h0LnByb3RvdHlwZS50YWtlTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBsZWZ0IVwiKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS50YWtlUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjYXRhXG4gICAgICovXG4gICAgUmlnaHQucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiAoXywgZykge1xuICAgICAgICByZXR1cm4gZyh0aGlzLnIpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpZ2h0O1xufShFaXRoZXIpKTtcbmV4cG9ydHMuUmlnaHQgPSBSaWdodDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVpdGhlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEVpdGhlcl8xID0gcmVxdWlyZShcIi4vRWl0aGVyXCIpO1xuLyoqXG4gKiBmcmVlIHdyYXBzIGEgdmFsdWUgaW4gYSBmcmVlXG4gKi9cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgUmV0dXJuKGEpOyB9O1xuLyoqXG4gKiBzdXNwZW5kIGxpZnRzIGEgZnVuY3Rpb24gaW50byBhIEZyZWUgbW9uYWQgdG8gbWltaWMgdGFpbCBjYWxsIHJlY3Vyc2lvbi5cbiAqL1xuZXhwb3J0cy5zdXNwZW5kID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5ldyBTdXNwZW5kKHV0aWxfMS5jb21wb3NlKGV4cG9ydHMuZnJlZSwgZikpOyB9O1xuLyoqXG4gKiBsaWZ0RiBsaWZ0cyBhIEZ1bmN0b3IgaW50byBhIEZyZWUuXG4gKi9cbmV4cG9ydHMubGlmdEYgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gbmV3IFN1c3BlbmQoZi5tYXAoZXhwb3J0cy5mcmVlKSk7IH07XG4vKipcbiAqIEZyZWUgaXMgYSBGcmVlIG1vbmFkIHRoYXQgYWxzbyBpbXBsZW1lbnRzIGEgRnJlZSBBcHBsaWNhdGl2ZSAoYWxtb3N0KS5cbiAqXG4gKiBJbnNwaXJlZCBieSBodHRwczovL2N3bXllcnMuZ2l0aHViLmlvL21vbmV0LmpzLyNmcmVlXG4gKi9cbnZhciBGcmVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmVlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvZlxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm4oYSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtYXBcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbihmdW5jdGlvbiAoYSkgeyByZXR1cm4gZXhwb3J0cy5mcmVlKGYoYSkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluXG4gICAgICovXG4gICAgRnJlZS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN1c3BlbmQpIHtcbiAgICAgICAgICAgIHZhciBmXzEgPSB0aGlzLmY7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBmXzEgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICBuZXcgU3VzcGVuZChmdW5jdGlvbiAoeCkgeyByZXR1cm4gZl8xKHgpLmNoYWluKGcpOyB9KSA6XG4gICAgICAgICAgICAgICAgbmV3IFN1c3BlbmQoZl8xLm1hcChmdW5jdGlvbiAoZnJlZSkgeyByZXR1cm4gZnJlZS5jaGFpbihnKTsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZXR1cm4pIHtcbiAgICAgICAgICAgIGcodGhpcy5hKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVzdW1lIHRoZSBuZXh0IHN0YWdlIG9mIHRoZSBjb21wdXRhdGlvblxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdXNwZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gRWl0aGVyXzEubGVmdCh0aGlzLmYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZXR1cm4pIHtcbiAgICAgICAgICAgIHJldHVybiBFaXRoZXJfMS5yaWdodCh0aGlzLmEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBob2lzdFxuICAgIGhvaXN0PEI+KGZ1bmM6IChmYjogRnVuY3RvcjxCPikgPT4gRnVuY3RvcjxCPik6IEZyZWU8RiwgQT4ge1xuXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VzcGVuZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1c3BlbmQoKGZ1bmModGhpcy5mKSlcbiAgICAgICAgICAgICAgICAubWFwKChmcjogRnJlZTxGLCBCPikgPT4gZnIuaG9pc3Q8YW55PihmdW5jKSkpXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIGNhdGFcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKGYsIGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdW1lKCkuY2F0YShmLCBnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdvIHJ1bnMgdGhlIGNvbXB1dGF0aW9uIHRvIGNvbXBsZXRpb24gdXNpbmcgZiB0byBleHRyYWN0IGVhY2ggc3RhZ2UuXG4gICAgICogQHN1bW1tYXJ5IGdvIDo6IEZyZWU8RjwqPiwgQT4g4oaSICAoRjxGcmVlPEYsQT4+IOKGkiAgRnJlZTxGLEE+KSDihpIgIEFcbiAgICAgKi9cbiAgICBGcmVlLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VzcGVuZCkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHIgaW5zdGFuY2VvZiBFaXRoZXJfMS5MZWZ0KVxuICAgICAgICAgICAgICAgIHIgPSAoZihyLnRha2VMZWZ0KCkpKS5yZXN1bWUoKTtcbiAgICAgICAgICAgIHJldHVybiByLnRha2VSaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZXR1cm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgRnJlZSBjaGFpbiB0byBjb21wbGV0aW9uXG4gICAgICogQHN1bW1hcnkgcnVuIDo6IEZyZWU8QeKGkiBBLEE+IOKGkiAgQVxuICAgICAqL1xuICAgIEZyZWUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ28oZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgfTtcbiAgICBGcmVlLmZyZWUgPSBleHBvcnRzLmZyZWU7XG4gICAgRnJlZS5zdXNwZW5kID0gZXhwb3J0cy5zdXNwZW5kO1xuICAgIEZyZWUubGlmdEYgPSBleHBvcnRzLmxpZnRGO1xuICAgIHJldHVybiBGcmVlO1xufSgpKTtcbmV4cG9ydHMuRnJlZSA9IEZyZWU7XG52YXIgU3VzcGVuZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1c3BlbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VzcGVuZChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmYgPSBmO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdXNwZW5kO1xufShGcmVlKSk7XG5leHBvcnRzLlN1c3BlbmQgPSBTdXNwZW5kO1xudmFyIFJldHVybiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHVybiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXR1cm4oYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hID0gYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmV0dXJuO1xufShGcmVlKSk7XG5leHBvcnRzLlJldHVybiA9IFJldHVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIHdyYXBJTyBhIHZhbHVlIGluIHRoZSBJTyBtb25hZFxuICovXG5leHBvcnRzLndyYXBJTyA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBuZXcgSU8oZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfSk7IH07XG4vKipcbiAqIHNhZmVJTyBhY2NlcHRzIGEgZnVuY3Rpb24gdGhhdCBoYXMgc2lkZSBlZmZlY3RzIGFuZCB3cmFwSU9zIGl0IGluIGFuIElPIE1vbmFkLlxuICovXG5leHBvcnRzLnNhZmVJTyA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBuZXcgSU8oZik7IH07XG5leHBvcnRzLnB1cmUgPSBleHBvcnRzLndyYXBJTztcbmV4cG9ydHMuc3VzcGVuZCA9IGV4cG9ydHMuc2FmZUlPO1xuLyoqXG4gKiBJTyBtb25hZGljIHR5cGUgZm9yIGNvbnRhaW5pbmcgaW50ZXJhY3Rpb25zIHdpdGggdGhlICdyZWFsIHdvcmxkJy5cbiAqL1xudmFyIElPID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJTyhlZmZlY3QpIHtcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICAgIElPLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgSU8oZnVuY3Rpb24gKCkgeyByZXR1cm4gdjsgfSk7XG4gICAgfTtcbiAgICBJTy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBJTyhmdW5jdGlvbiAoKSB7IHJldHVybiBmKF90aGlzLmVmZmVjdCgpKTsgfSk7XG4gICAgfTtcbiAgICBJTy5wcm90b3R5cGUubWFwSW4gPSBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gYjsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFpblxuICAgICAqL1xuICAgIElPLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSU8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZihfdGhpcy5lZmZlY3QoKSkucnVuKCk7IH0pO1xuICAgIH07XG4gICAgSU8ucHJvdG90eXBlLmNoYWluSW4gPSBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbihmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLndyYXBJTyhiKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBydW5cbiAgICAgKi9cbiAgICBJTy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3QoKTtcbiAgICB9O1xuICAgIElPLnNhZmVJTyA9IGV4cG9ydHMuc2FmZUlPO1xuICAgIElPLnB1cmUgPSBleHBvcnRzLnB1cmU7XG4gICAgSU8uc3VzcGVuZCA9IGV4cG9ydHMuc3VzcGVuZDtcbiAgICBJTy5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5jaGFpbihmKTsgfTsgfTtcbiAgICByZXR1cm4gSU87XG59KCkpO1xuZXhwb3J0cy5JTyA9IElPO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SU8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIElkZW50aXR5XG4gKi9cbnZhciBJZGVudGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpdHkoYSkge1xuICAgICAgICB0aGlzLmEgPSBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvZlxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHkoYSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtYXBcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eShmKHRoaXMuZ2V0KCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoYWluXG4gICAgICovXG4gICAgSWRlbnRpdHkucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5nZXQoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhcFxuICAgICAqL1xuICAgIElkZW50aXR5LnByb3RvdHlwZS5hcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZihfdGhpcy5nZXQoKSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBvZiBhbiBJZGVudGl0eVxuICAgICAqIEBzdW1tYXJ5IGdldCA6OiBJZGVudGl0eTxBPiDihpIgIEFcbiAgICAgKi9cbiAgICBJZGVudGl0eS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH07XG4gICAgcmV0dXJuIElkZW50aXR5O1xufSgpKTtcbmV4cG9ydHMuSWRlbnRpdHkgPSBJZGVudGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlkZW50aXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRWl0aGVyXzEgPSByZXF1aXJlKFwiLi9FaXRoZXJcIik7XG4vKipcbiAqIGp1c3Qgd3JhcHMgYSB2YWx1ZSBpbiBhIEp1c3RcbiAqL1xuZXhwb3J0cy5qdXN0ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG5ldyBKdXN0KGEpOyB9O1xuO1xuLyoqXG4gKiBub3RoaW5nIGNvbnN0cnVjdHMgbm90aGluZ1xuICovXG5leHBvcnRzLm5vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTm90aGluZygpOyB9O1xuLyoqXG4gKiBmcm9tQW55IGNvbnN0cnVjdHMgYSBNYXliZSBmcm9tIGEgdmFsdWUgdGhhdCBtYXkgYmUgbnVsbC5cbiAqL1xuZXhwb3J0cy5mcm9tQW55ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT0gbnVsbCA/IGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KGEpOyB9O1xuLyoqXG4gKiBmcm9tQXJyYXkgY2hlY2tzIGFuIGFycmF5IHRvIHNlZSBpZiBpdCdzIGVtcHR5IChvciBmdWxsIG9mIG51bGxzKVxuICogYW5kIHJldHVybnMgYSBNYXliZS5cbiAqL1xuZXhwb3J0cy5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAoKGEubGVuZ3RoID09PSAwKSB8fCAoYS5yZWR1Y2UoZnVuY3Rpb24gKGMsIHYpIHsgcmV0dXJuICh2ID09IG51bGwpID8gYyArIDEgOiBjOyB9LCAwKSA9PT0gYS5sZW5ndGgpKSA/XG4gICAgICAgIGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KGEpO1xufTtcbi8qKlxuICogZnJvbU9CamVjdCB1c2VzIE9iamVjdC5rZXlzIHRvIHR1cm4gc2VlIGlmIGFuIG9iamVjdCBoYXMgYW55IG93biBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnRzLmZyb21PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDAgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChvKTtcbn07XG4vKipcbiAqIGZyb21TdHJpbmcgY29uc3RydWN0cyBub3RoaW5nIGlmIHRoZSBzdHJpbmcgaXMgZW1wdHkgb3IganVzdCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIChzID09PSAnJykgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChzKTtcbn07XG4vKipcbiAqIGZyb21Cb29sZWFuIGNvbnN0cnVjdHMgbm90aGluZyBpZiBiIGlzIGZhbHNlLCBqdXN0IG90aGVyd2lzZVxuICovXG5leHBvcnRzLmZyb21Cb29sZWFuID0gZnVuY3Rpb24gKGIpIHtcbiAgICByZXR1cm4gKGIgPT09IGZhbHNlKSA/IGV4cG9ydHMubm90aGluZygpIDogZXhwb3J0cy5qdXN0KGIpO1xufTtcbi8qKlxuICogZnJvbU51bWJlciBjb25zdHJ1Y3RzIG5vdGhpbmcgaWYgbiBpcyAwIGp1c3Qgb3RoZXJ3aXNlLlxuICovXG5leHBvcnRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAobiA9PT0gMCkgPyBleHBvcnRzLm5vdGhpbmcoKSA6IGV4cG9ydHMuanVzdChuKTtcbn07XG4vKipcbiAqIE1heWJlXG4gKi9cbnZhciBNYXliZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF5YmUoKSB7XG4gICAgfVxuICAgIE1heWJlLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnVzdChhKTtcbiAgICB9O1xuICAgIE1heWJlLmp1c3QgPSBleHBvcnRzLmp1c3Q7XG4gICAgTWF5YmUubm90aGluZyA9IGV4cG9ydHMubm90aGluZztcbiAgICBNYXliZS5mcm9tQW55ID0gZXhwb3J0cy5mcm9tQW55O1xuICAgIE1heWJlLmZyb21PYmplY3QgPSBleHBvcnRzLmZyb21PYmplY3Q7XG4gICAgTWF5YmUuZnJvbUFycmF5ID0gZXhwb3J0cy5mcm9tQXJyYXk7XG4gICAgTWF5YmUuZnJvbVN0cmluZyA9IGV4cG9ydHMuZnJvbVN0cmluZztcbiAgICBNYXliZS5mcm9tQm9vbGVhbiA9IGV4cG9ydHMuZnJvbUJvb2xlYW47XG4gICAgTWF5YmUuZnJvbU51bWJlciA9IGV4cG9ydHMuZnJvbU51bWJlcjtcbiAgICByZXR1cm4gTWF5YmU7XG59KCkpO1xuZXhwb3J0cy5NYXliZSA9IE1heWJlO1xuLyoqXG4gKiBOb3RoaW5nXG4gKi9cbnZhciBOb3RoaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RoaW5nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5vdGhpbmcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aGluZygpO1xuICAgIH07XG4gICAgTm90aGluZy5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGhpbmcoKTtcbiAgICB9O1xuICAgIE5vdGhpbmcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGdldCBhbnl0aGluZyBmcm9tIE5vdGhpbmchJyk7XG4gICAgfTtcbiAgICBOb3RoaW5nLnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogb3JKdXN0IHdpbGwgdHVybiBOb3RoaW5nIGludG8gSnVzdCwgd3JhcHBpbmcgdGhlIHZhbHVlIHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBOb3RoaW5nLnByb3RvdHlwZS5vckp1c3QgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5qdXN0KGYoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjYXRhIGFwcGxpZXMgdGhlIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gdG8gdGhlIE1heWJlXG4gICAgICovXG4gICAgTm90aGluZy5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIChmLCBfZykge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH07XG4gICAgTm90aGluZy5wcm90b3R5cGUudG9FaXRoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBFaXRoZXJfMS5sZWZ0KHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aGluZztcbn0oTWF5YmUpKTtcbmV4cG9ydHMuTm90aGluZyA9IE5vdGhpbmc7XG4vKipcbiAqIEp1c3RcbiAqL1xudmFyIEp1c3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKdXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEp1c3QoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hID0gYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBKdXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IEp1c3QoZih0aGlzLmEpKTtcbiAgICB9O1xuICAgIEp1c3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmE7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMuYSk7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmE7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5vckp1c3QgPSBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS5jYXRhID0gZnVuY3Rpb24gKF9mLCBnKSB7XG4gICAgICAgIHJldHVybiBnKHRoaXMuYSk7XG4gICAgfTtcbiAgICBKdXN0LnByb3RvdHlwZS50b0VpdGhlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEVpdGhlcl8xLnJpZ2h0KHRoaXMuYSk7XG4gICAgfTtcbiAgICByZXR1cm4gSnVzdDtcbn0oTWF5YmUpKTtcbmV4cG9ydHMuSnVzdCA9IEp1c3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXliZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogZ2V0IHRoZSBzdGF0ZSBmcm9tIHRoZSBpbnRlcm5hbHMgb2YgdGhlIG1vbmFkXG4gKi9cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoW3MsIHNdKTsgfSk7IH07XG4vKipcbiAqIHB1dFxuICovXG5leHBvcnRzLnB1dCA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gKFtudWxsLCBzXSk7IH0pOyB9O1xuLyoqXG4gKiBtb2RpZnkgdGhlIHN0YXRlXG4gKiBAc3VtbWFyeSAgKFMg4oaSICBTKSDihpIgIFN0YXRlPFMg4oaSICB7QSwgU30gPlxuICovXG5leHBvcnRzLm1vZGlmeSA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBleHBvcnRzLmdldCgpLmNoYWluKGZ1bmN0aW9uIChzKSB7IHJldHVybiBleHBvcnRzLnB1dChmKHMpKTsgfSk7IH07XG4vKipcbiAqIGdldHMgYXBwbGllcyBhIGZ1bmN0aW9uIHRvIHRoZSBzdGF0ZSBwdXR0aW5nIHVzaW5nIHRoZSByZXN1bHRcbiAqIGFzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICogQHN1bW1hcnkgKFMg4oaSICBBKSDihpIgIFN0YXRlPFMg4oaSICB7QSwgU30+XG4gKi9cbmV4cG9ydHMuZ2V0cyA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBleHBvcnRzLmdldCgpLmNoYWluKGZ1bmN0aW9uIChzKSB7IHJldHVybiBleHBvcnRzLnN0YXRlKGYocykpOyB9KTsgfTtcbi8qKlxuICogc3RhdGUgY3JlYXRlIGEgbmV3IFN0YXRlIG1vbmFkXG4gKi9cbmV4cG9ydHMuc3RhdGUgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoW2EsIHNdKTsgfSk7IH07XG4vKipcbiAqIFN0YXRlIGlzIGEgbW9uYWRpYyBjbGFzcyB0aGF0IHdlIHVzZSB0byBob2xkIGluZm9ybWF0aW9uIHRoYXQgY2hhbmdlc1xuICogZHVyaW5nIGNvbXB1dGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaW5mbHVlbmNlZCBieTpcbiAqIEBsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbmFkXyhmdW5jdGlvbmFsX3Byb2dyYW1taW5nKSNTdGF0ZV9tb25hZHNcbiAqIEBwcm9wZXJ0eSB7cyDihpIgIChhLCBzKX0gYVxuICovXG52YXIgU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlKGYpIHtcbiAgICAgICAgdGhpcy5mID0gZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb2Ygd3JhcHMgYSB2YWx1ZSBpbiB0aGUgU3RhdGUgbW9uYWQuXG4gICAgICogQHN1bW1hcnkgQSDihpIgIFN0YXRlPFPihpIge0EsU30+XG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZShmdW5jdGlvbiAocykgeyByZXR1cm4gKFthLCBzXSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWFwXG4gICAgICogQHN1bW1hcnkgU3RhdGU8UyDihpIge0EsU30+IOKGkiAgKEEg4oaSICBCKSDihpIgIFN0YXRlPFMg4oaSICB7QywgU30+XG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5ydW4oeHMpLCBhID0gX2FbMF0sIHMgPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiBbZihhKSwgc107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogam9pbiByZXBsYWNlcyB0aGUgb3V0ZXIgU3RhdGUgd2l0aCBhbiBpbm5lciBTdGF0ZVxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlKGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucnVuKHhzKSwgYSA9IF9hWzBdLCBzID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gYS5ydW4ocyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhaW5cbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZikuam9pbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXZhbHVhdGUgdGhlIFN0YXRlIHJldHVybmluZyB0aGUgZmluYWwgdmFsdWVcbiAgICAgKi9cbiAgICBTdGF0ZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW4ocylbMF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleGVjdXRlIHRoZSBTdGF0ZSByZXR1cm5pbmcgdGhlIGZpbmFsIHN0YXRlLlxuICAgICAqL1xuICAgIFN0YXRlLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuKHMpWzFdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcnVuIHRoZSBTdGF0ZSB5aWVsZGluZyB0aGUgZmluYWwgdmFsdWUgYW5kIHN0YXRlLlxuICAgICAqIEBzdW1tYXJ5IFN0YXRlPFPihpIge0E8U30+IOKGkiAgUyDihpIgIHtBLFN9XG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmYocyk7XG4gICAgfTtcbiAgICBTdGF0ZS5nZXQgPSBleHBvcnRzLmdldDtcbiAgICBTdGF0ZS5wdXQgPSBleHBvcnRzLnB1dDtcbiAgICBTdGF0ZS5tb2RpZnkgPSBleHBvcnRzLm1vZGlmeTtcbiAgICBTdGF0ZS5nZXRzID0gZXhwb3J0cy5nZXRzO1xuICAgIFN0YXRlLnN0YXRlID0gZXhwb3J0cy5zdGF0ZTtcbiAgICByZXR1cm4gU3RhdGU7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG47XG4vKipcbiAqIGlkZW50aXR5IGlzIHRoZSBmYW1lZCBpZGVudGl0eSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0cy5pZGVudGl0eSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhOyB9O1xuLyoqXG4gKiBtZXJnZSB0d28gb2JqZWN0cyBlYXNpbHlcbiAqL1xuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbe31dLmNvbmNhdChvKSk7XG59O1xuLyoqXG4gKiBmdXNlIGlzIHRoZSBkZWVwIHZlcnNpb24gb2YgbWVyZ2VcbiAqL1xuZXhwb3J0cy5mdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKG8sIGMpIHtcbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMCkgeyBjID0ge307IH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKGMsIGZ1bmN0aW9uIChjbywgY2MsIGspIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNjKSA/XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29ba10pID9cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjbywgKF9hID0ge30sIF9hW2tdID0gKGNvW2tdKS5tYXAoZXhwb3J0cy5jb3B5KS5jb25jYXQoY2MubWFwKGV4cG9ydHMuY29weSkpLCBfYSkpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjbywgKF9iID0ge30sIF9iW2tdID0gY2MubWFwKGV4cG9ydHMuY29weSksIF9iKSkpIDpcbiAgICAgICAgICAgICAgICB0eXBlb2YgY2MgIT09ICdvYmplY3QnID9cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZShjbywgKF9jID0ge30sIF9jW2tdID0gY2MsIF9jKSkgOlxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKGNvLCAoX2QgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kW2tdID0gKHR5cGVvZiBjb1trXSAhPT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKGNvW2tdLCBjYykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuZnVzZShjb1trXSwgY2MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2QpKTtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgfSwgbyk7XG4gICAgfSwge30pO1xufTtcbmV4cG9ydHMuY29weSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG8pKSA/XG4gICAgICAgIG8ubWFwKGV4cG9ydHMuY29weSkgOlxuICAgICAgICAodHlwZW9mIG8gPT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICBleHBvcnRzLnJlZHVjZShvLCBmdW5jdGlvbiAocCwgYywgaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLm1lcmdlKHAsIChfYSA9IHt9LCBfYVtrXSA9IGV4cG9ydHMuY29weShjKSwgX2EpKTtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB9LCB7fSkgOiBvO1xufTtcbi8qKlxuICogcmVkdWNlIGFuIG9iamVjdCdzIGtleXMgKGluIG5vIGd1YXJhbnRlZWQgb3JkZXIpXG4gKi9cbmV4cG9ydHMucmVkdWNlID0gZnVuY3Rpb24gKG8sIGYsIGFjY3VtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZShmdW5jdGlvbiAocCwgaykgeyByZXR1cm4gZihwLCBvW2tdLCBrLCBvKTsgfSwgYWNjdW0pO1xufTtcbi8qKlxuICogbWFwIG92ZXIgYW4gb2JqZWN0IChpbiBubyBndWFyYW50ZWVkIG9yZWRlcilcbiAqL1xuZXhwb3J0cy5tYXAgPSBmdW5jdGlvbiAobywgZikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5tYXAoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmKG9ba10sIGssIG8pOyB9KSk7XG59O1xuLyoqXG4gKiBjb21wb3NlIHR3byBmdW5jdGlvbnMgaW50byBvbmUuXG4gKi9cbmV4cG9ydHMuY29tcG9zZSA9IGZ1bmN0aW9uIChmLCBnKSB7IHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gZihnKHgpKTsgfTsgfTtcbi8qKlxuICogZmxpbmcgcmVtb3ZlcyBhIGtleSBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHN1bW1hcnkgeyhzdHJpbmcsT2JqZWN0KSDihpIgIE9iamVjdH1cbiAqL1xuZXhwb3J0cy5mbGluZyA9IGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgaWYgKChvID09IG51bGwpIHx8IChvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmbGluZygpOiBvbmx5IHdvcmtzIHdpdGggb2JqZWN0IGxpdGVyYWxzIScpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24gKG8yLCBrKSB7XG4gICAgICAgIHJldHVybiBrID09PSBzID8gbzIgOiBleHBvcnRzLm1lcmdlKG8yLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW2tdID0gb1trXSxcbiAgICAgICAgICAgIF9hKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBoZWFkIHJldHVybnMgdGhlIGl0ZW0gYXQgaW5kZXggMCBvZiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzdW1tYXJ5IHsgQXJyYXkg4oaSICAqIH1cbiAqL1xuZXhwb3J0cy5oZWFkID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3RbMF07IH07XG4vKipcbiAqIHRhaWwgcmV0dXJucyB0aGUgbGFzdCBpdGVtIGluIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHN1bW1hcnkge0FycmF5IOKGkiAgKn1cbiAqL1xuZXhwb3J0cy50YWlsID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3RbbGlzdC5sZW5ndGggLSAxXTsgfTtcbi8qKlxuICogY29uc3RhbnQgZ2l2ZW4gYSB2YWx1ZSwgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGlzIHZhbHVlLlxuICogQHN1bW1hcnkgY29uc3RhbnQgWCDihpIgICog4oaSICBYXG4gKlxuICovXG5leHBvcnRzLmNvbnN0YW50ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH07IH07XG4vKipcbiAqIGYxIHBhcnRpYWwgYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydHMuZjEgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEpKTsgfTtcbn07XG4vKipcbiAqIGYyIHBhcnRpYWwgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5mMiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYSkgeyByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhLCBhYSkpOyB9OyB9O1xufTtcbi8qKlxuICogZjMgcGFydGlhbCBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmYzID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhKSB7IHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGEsIGFhLCBhYWEpKTsgfTsgfTsgfTtcbn07XG4vKipcbiAqIGY0IHBhcnRpYWwgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5mNCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYSkgeyByZXR1cm4gZnVuY3Rpb24gKGFhYWEpIHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSwgYWEsIGFhYSwgYWFhYSkpO1xuICAgIH07IH07IH07IH07XG59O1xuLyoqXG4gKiBmNSBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZjUgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhYWFhKSB7IHJldHVybiBmdW5jdGlvbiAoYWFhYWEpIHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYSwgYWEsIGFhYSwgYWFhYSwgYWFhYWEpKTtcbiAgICB9OyB9OyB9OyB9OyB9O1xufTtcbi8qKlxuICogZXhjZXB0IGNvcGllcyBhbiBvYmplY3QgcmVtb3ZpbmcgYSBzaW5nbGUga2V5LlxuICovXG5leHBvcnRzLmV4Y2VwdCA9IGZ1bmN0aW9uIChrZXlzLCBvKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVkdWNlKG8sIGZ1bmN0aW9uIChwLCBjLCBrKSB7XG4gICAgICAgIHJldHVybiBrZXlzLmluZGV4T2YoaykgPiAtMSA/IHAgOiBleHBvcnRzLm1lcmdlKHAsIChfYSA9IHt9LCBfYVtrXSA9IGMsIF9hKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9LCB7fSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4vKipcblRoZSBmb2xsb3dpbmcgYmF0Y2hlcyBhcmUgZXF1aXZhbGVudDpcblxudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKTtcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanM7XG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzX2JlYXV0aWZ5O1xuXG52YXIgYmVhdXRpZnlfY3NzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5jc3M7XG52YXIgYmVhdXRpZnlfY3NzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5jc3NfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9odG1sID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5odG1sO1xudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWxfYmVhdXRpZnk7XG5cbkFsbCBtZXRob2RzIHJldHVybmVkIGFjY2VwdCB0d28gYXJndW1lbnRzLCB0aGUgc291cmNlIHN0cmluZyBhbmQgYW4gb3B0aW9ucyBvYmplY3QuXG4qKi9cblxuZnVuY3Rpb24gZ2V0X2JlYXV0aWZ5KGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpIHtcbiAgICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICAgIHZhciBiZWF1dGlmeSA9IGZ1bmN0aW9uKHNyYywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gICAgfTtcblxuICAgIC8vIHNob3J0IGFsaWFzZXNcbiAgICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5LmNzcyA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuaHRtbCA9IGh0bWxfYmVhdXRpZnkuaHRtbF9iZWF1dGlmeTtcblxuICAgIC8vIGxlZ2FjeSBhbGlhc2VzXG4gICAgYmVhdXRpZnkuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeS5qc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgICByZXR1cm4gYmVhdXRpZnk7XG59XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXG4gICAgICAgIFwiLi9saWIvYmVhdXRpZnlcIixcbiAgICAgICAgXCIuL2xpYi9iZWF1dGlmeS1jc3NcIixcbiAgICAgICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgICBdLCBmdW5jdGlvbihqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gICAgICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gICAgfSk7XG59IGVsc2Uge1xuICAgIChmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9saWIvYmVhdXRpZnknKTtcbiAgICAgICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5LWNzcycpO1xuICAgICAgICB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5LWh0bWwnKTtcblxuICAgICAgICBtb2QuZXhwb3J0cyA9IGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KTtcblxuICAgIH0pKG1vZHVsZSk7XG59IiwiLypqc2hpbnQgY3VybHk6ZmFsc2UsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBDU1MgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBXcml0dGVuIGJ5IEhhcnV0eXVuIEFtaXJqYW55YW4sIChhbWlyamFueWFuQGdtYWlsLmNvbSlcblxuICAgIEJhc2VkIG9uIGNvZGUgaW5pdGlhbGx5IGRldmVsb3BlZCBieTogRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAanNiZWF1dGlmaWVyLm9yZz5cbiAgICAgICAgaHR0cDovL2pzYmVhdXRpZmllci5vcmcvXG5cbiAgICBVc2FnZTpcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0KTtcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICAgIFRoZSBvcHRpb25zIGFyZSAoZGVmYXVsdCBpbiBicmFja2V0cyk6XG4gICAgICAgIGluZGVudF9zaXplICg0KSAgICAgICAgICAgICAgICAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXIgKHNwYWNlKSAgICAgICAgICAgICAgICAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgICAgIHNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICh0cnVlKSAgICAgICAtIHNlcGFyYXRlIHNlbGVjdG9ycyB3aXRoIG5ld2xpbmUgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IChlLmcuIFwiYSxcXG5iclwiIG9yIFwiYSwgYnJcIilcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgICAgIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAodHJ1ZSkgICAgICAgICAgICAtIGFkZCBhIG5ldyBsaW5lIGFmdGVyIGV2ZXJ5IGNzcyBydWxlXG4gICAgICAgIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgKGZhbHNlKSAtIGVuc3VyZSBzcGFjZSBhcm91bmQgc2VsZWN0b3Igc2VwYXJhdG9yczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nLCAnKycsICd+JyAoZS5nLiBcImE+YlwiIC0+IFwiYSA+IGJcIilcbiAgICBlLmdcblxuICAgIGNzc19iZWF1dGlmeShjc3Nfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0JyxcbiAgICAgICdzZWxlY3Rvcl9zZXBhcmF0b3InOiAnICcsXG4gICAgICAnZW5kX3dpdGhfbmV3bGluZSc6IGZhbHNlLFxuICAgICAgJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcyc6IHRydWUsXG4gICAgICAnc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcic6IHRydWVcbiAgICB9KTtcbiovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN0b2tlbml6YXRpb25cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4L1xuXG4oZnVuY3Rpb24oKSB7XG52YXIgbGVnYWN5X2JlYXV0aWZ5X2NzcyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxudmFyIG1lcmdlT3B0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikubWVyZ2VPcHRzO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBPdXRwdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLk91dHB1dDtcblxuXG52YXIgbGluZUJyZWFrID0gYWNvcm4ubGluZUJyZWFrO1xudmFyIGFsbExpbmVCcmVha3MgPSBhY29ybi5hbGxMaW5lQnJlYWtzO1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAgIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdHMob3B0aW9ucywgJ2NzcycpO1xuXG4gICAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcblxuICAgIHZhciBuZXdsaW5lc0Zyb21MYXN0V1NFYXQgPSAwO1xuICAgIHZhciBpbmRlbnRTaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZSA/IHBhcnNlSW50KG9wdGlvbnMuaW5kZW50X3NpemUsIDEwKSA6IDQ7XG4gICAgdmFyIGluZGVudENoYXJhY3RlciA9IG9wdGlvbnMuaW5kZW50X2NoYXIgfHwgJyAnO1xuICAgIHZhciBwcmVzZXJ2ZV9uZXdsaW5lcyA9IChvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuICAgIHZhciBzZWxlY3RvclNlcGFyYXRvck5ld2xpbmUgPSAob3B0aW9ucy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lO1xuICAgIHZhciBlbmRfd2l0aF9uZXdsaW5lID0gKG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZSA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICAgIHZhciBuZXdsaW5lX2JldHdlZW5fcnVsZXMgPSAob3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXM7XG4gICAgdmFyIHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gKG9wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3I7XG4gICAgc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgPSBzcGFjZV9hcm91bmRfY29tYmluYXRvciB8fCAoKG9wdGlvbnMuc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5zcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yKTtcbiAgICB2YXIgZW9sID0gb3B0aW9ucy5lb2wgPyBvcHRpb25zLmVvbCA6ICdhdXRvJztcblxuICAgIGlmIChvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICAgICAgaW5kZW50Q2hhcmFjdGVyID0gJ1xcdCc7XG4gICAgICAgIGluZGVudFNpemUgPSAxO1xuICAgIH1cblxuICAgIGlmIChlb2wgPT09ICdhdXRvJykge1xuICAgICAgICBlb2wgPSAnXFxuJztcbiAgICAgICAgaWYgKHNvdXJjZV90ZXh0ICYmIGxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2gobGluZUJyZWFrKVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVvbCA9IGVvbC5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKTtcblxuICAgIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gICAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAgIC8vIHRva2VuaXplclxuICAgIHZhciB3aGl0ZVJlID0gL15cXHMrJC87XG5cbiAgICB2YXIgcG9zID0gLTEsXG4gICAgICAgIGNoO1xuICAgIHZhciBwYXJlbkxldmVsID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGNoID0gc291cmNlX3RleHQuY2hhckF0KCsrcG9zKTtcbiAgICAgICAgcmV0dXJuIGNoIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZWsoc2tpcFdoaXRlc3BhY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgcHJldl9wb3MgPSBwb3M7XG4gICAgICAgIGlmIChza2lwV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHNvdXJjZV90ZXh0LmNoYXJBdChwb3MgKyAxKSB8fCAnJztcbiAgICAgICAgcG9zID0gcHJldl9wb3MgLSAxO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWF0U3RyaW5nKGVuZENoYXJzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcztcbiAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zICsgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVla1N0cmluZyhlbmRDaGFyKSB7XG4gICAgICAgIHZhciBwcmV2X3BvcyA9IHBvcztcbiAgICAgICAgdmFyIHN0ciA9IGVhdFN0cmluZyhlbmRDaGFyKTtcbiAgICAgICAgcG9zID0gcHJldl9wb3MgLSAxO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWF0V2hpdGVzcGFjZShwcmVzZXJ2ZV9uZXdsaW5lc19sb2NhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgd2hpbGUgKHdoaXRlUmUudGVzdChwZWVrKCkpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nICYmIHByZXNlcnZlX25ld2xpbmVzX2xvY2FsICYmIHByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdsaW5lc0Zyb21MYXN0V1NFYXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgaWYgKGNoICYmIHdoaXRlUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh3aGl0ZVJlLnRlc3QobmV4dCgpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWF0Q29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zO1xuICAgICAgICB2YXIgc2luZ2xlTGluZSA9IHBlZWsoKSA9PT0gXCIvXCI7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgaWYgKCFzaW5nbGVMaW5lICYmIGNoID09PSBcIipcIiAmJiBwZWVrKCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaW5nbGVMaW5lICYmIGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcykgKyBjaDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGxvb2tCYWNrKHN0cikge1xuICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHBvcyAtIHN0ci5sZW5ndGgsIHBvcykudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgIHN0cjtcbiAgICB9XG5cbiAgICAvLyBOZXN0ZWQgcHNldWRvLWNsYXNzIGlmIHdlIGFyZSBpbnNpZGVSdWxlXG4gICAgLy8gYW5kIHRoZSBuZXh0IHNwZWNpYWwgY2hhcmFjdGVyIGZvdW5kIG9wZW5zXG4gICAgLy8gYSBuZXcgYmxvY2tcbiAgICBmdW5jdGlvbiBmb3VuZE5lc3RlZFBzZXVkb0NsYXNzKCkge1xuICAgICAgICB2YXIgb3BlblBhcmVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBvcyArIDE7IGkgPCBzb3VyY2VfdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlX3RleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgLy8gcHNldWRvY2xhc3NlcyBjYW4gY29udGFpbiAoKVxuICAgICAgICAgICAgICAgIG9wZW5QYXJlbiArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5QYXJlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wZW5QYXJlbiAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCI7XCIgfHwgY2ggPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBwcmludGVyXG4gICAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSAnJztcbiAgICB2YXIgcHJlaW5kZW50X2luZGV4ID0gMDtcbiAgICBpZiAoc291cmNlX3RleHQgJiYgc291cmNlX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICgoc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCkgPT09ICcgJyB8fFxuICAgICAgICAgICAgICAgIHNvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpID09PSAnXFx0JykpIHtcbiAgICAgICAgICAgIHByZWluZGVudF9pbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoMCwgcHJlaW5kZW50X2luZGV4KTtcbiAgICAgICAganNfc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5zdWJzdHJpbmcocHJlaW5kZW50X2luZGV4KTtcbiAgICB9XG5cblxuICAgIHZhciBzaW5nbGVJbmRlbnQgPSBuZXcgQXJyYXkoaW5kZW50U2l6ZSArIDEpLmpvaW4oaW5kZW50Q2hhcmFjdGVyKTtcbiAgICB2YXIgaW5kZW50TGV2ZWw7XG4gICAgdmFyIG5lc3RlZExldmVsO1xuICAgIHZhciBvdXRwdXQ7XG5cbiAgICBmdW5jdGlvbiBwcmludF9zdHJpbmcob3V0cHV0X3N0cmluZykge1xuICAgICAgICBpZiAob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc2V0X2luZGVudChpbmRlbnRMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZF90b2tlbihvdXRwdXRfc3RyaW5nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSkge1xuICAgICAgICBpZiAoaXNBZnRlclNwYWNlKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGVudCgpIHtcbiAgICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvdXRkZW50KCkge1xuICAgICAgICBpZiAoaW5kZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBpbmRlbnRMZXZlbC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypfX19fX19fX19fX19fX19fX19fX18tLS0tLS0tLS0tLS0tLS0tLS0tLV9fX19fX19fX19fX19fX19fX19fXyovXG5cbiAgICB0aGlzLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIG91dHB1dCA9IG5ldyBPdXRwdXQoc2luZ2xlSW5kZW50LCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgICAgICAgaW5kZW50TGV2ZWwgPSAwO1xuICAgICAgICBuZXN0ZWRMZXZlbCA9IDA7XG5cbiAgICAgICAgcG9zID0gLTE7XG4gICAgICAgIGNoID0gbnVsbDtcbiAgICAgICAgcGFyZW5MZXZlbCA9IDA7XG5cbiAgICAgICAgdmFyIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICAgICAgICB2YXIgdG9wX2NoID0gJyc7XG4gICAgICAgIHZhciBsYXN0X3RvcF9jaCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgd2hpdGVzcGFjZSA9IHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICB2YXIgaXNBZnRlclNwYWNlID0gd2hpdGVzcGFjZSAhPT0gJyc7XG4gICAgICAgICAgICB2YXIgaXNBZnRlck5ld2xpbmUgPSB3aGl0ZXNwYWNlLmluZGV4T2YoJ1xcbicpICE9PSAtMTtcbiAgICAgICAgICAgIGxhc3RfdG9wX2NoID0gdG9wX2NoO1xuICAgICAgICAgICAgdG9wX2NoID0gY2g7XG5cbiAgICAgICAgICAgIGlmICghY2gpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJyAmJiBwZWVrKCkgPT09ICcqJykgeyAvKiBjc3MgY29tbWVudCAqL1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBpbmRlbnRMZXZlbCA9PT0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChpc0FmdGVyTmV3bGluZSB8fCBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRDb21tZW50KCkpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nICYmIHBlZWsoKSA9PT0gJy8nKSB7IC8vIHNpbmdsZSBsaW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWZ0ZXJOZXdsaW5lICYmIGxhc3RfdG9wX2NoICE9PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRDb21tZW50KCkpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcblxuICAgICAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBsZXNzIHByb3BlcnkgbWl4aW5zIEB7Li4ufVxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoZWF0U3RyaW5nKCd9JykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVPclJ1bGUgPSBwZWVrU3RyaW5nKFwiOiAsO3t9KClbXS89J1xcXCJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlLm1hdGNoKC9bIDpdJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgdmFyaWFibGUgb3IgcHNldWRvLWNsYXNzLCBhZGQgaXQgYW5kIGluc2VydCBvbmUgc3BhY2UgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gZWF0U3RyaW5nKFwiOiBcIikucmVwbGFjZSgvXFxzJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyh2YXJpYWJsZU9yUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdmFyaWFibGVPclJ1bGUucmVwbGFjZSgvXFxzJC8sICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBiZSBhIG5lc3RpbmcgYXQtcnVsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5ORVNURURfQVRfUlVMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkTGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLkNPTkRJVElPTkFMX0dST1VQX1JVTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyMnICYmIHBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhlYXRTdHJpbmcoJ30nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVlayh0cnVlKSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKFwie31cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWF0V2hpdGVzcGFjZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld2xpbmVzRnJvbUxhc3RXU0VhdCA8IDIgJiYgbmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluZGVudExldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gZW50ZXJpbmcgY29uZGl0aW9uYWwgZ3JvdXBzLCBvbmx5IHJ1bGVzZXRzIGFyZSBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlUnVsZSA9IChpbmRlbnRMZXZlbCA+IG5lc3RlZExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZGVjbGFyYXRpb25zIGFyZSBhbHNvIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSAoaW5kZW50TGV2ZWwgPj0gbmVzdGVkTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgb3V0ZGVudCgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoY2gpO1xuICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZExldmVsLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3bGluZXNGcm9tTGFzdFdTRWF0IDwgMiAmJiBuZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgaW5kZW50TGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGluc2lkZVJ1bGUgfHwgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKGxvb2tCYWNrKFwiJlwiKSB8fCBmb3VuZE5lc3RlZFBzZXVkb0NsYXNzKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICFsb29rQmFjayhcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ3Byb3BlcnR5OiB2YWx1ZScgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNvdWxkIGJlIGluIGEgY29uZGl0aW9uYWwgZ3JvdXAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNhc3MvbGVzcyBwYXJlbnQgcmVmZXJlbmNlIGRvbid0IHVzZSBhIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhc3MgbmVzdGVkIHBzZXVkby1jbGFzcyBkb24ndCB1c2UgYSBzcGFjZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHNwYWNlIGJlZm9yZSBwc2V1ZG9jbGFzc2VzL3BzZXVkb2VsZW1lbnRzLCBhcyBpdCBtZWFucyBcImluIGFueSBjaGlsZFwiXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rQmFjayhcIiBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKFwiOjpcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZygnOicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdFN0cmluZyhjaCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlYXRXaGl0ZXNwYWNlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHsgLy8gbWF5IGJlIGEgdXJsXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrKFwidXJsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoICE9PSAnKScgJiYgY2ggIT09ICdcIicgJiYgY2ggIT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGVhdFN0cmluZygnKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICAgICAgcGFyZW5MZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVhdFdoaXRlc3BhY2UodHJ1ZSkgJiYgc2VsZWN0b3JTZXBhcmF0b3JOZXdsaW5lICYmICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjaCA9PT0gJz4nIHx8IGNoID09PSAnKycgfHwgY2ggPT09ICd+JykgJiZcbiAgICAgICAgICAgICAgICAhaW5zaWRlUHJvcGVydHlWYWx1ZSAmJiBwYXJlbkxldmVsIDwgMSkge1xuICAgICAgICAgICAgICAgIC8vaGFuZGxlIGNvbWJpbmF0b3Igc3BhY2luZ1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZV9hcm91bmRfY29tYmluYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzcXVhc2ggZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgd2hpdGVSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIHByaW50X3N0cmluZyhjaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICc9JykgeyAvLyBubyB3aGl0ZXNwYWNlIGJlZm9yZSBvciBhZnRlclxuICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBwcmludF9zdHJpbmcoJz0nKTtcbiAgICAgICAgICAgICAgICBpZiAod2hpdGVSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRfc3RyaW5nKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzd2VldENvZGUgPSBvdXRwdXQuZ2V0X2NvZGUoZW5kX3dpdGhfbmV3bGluZSwgZW9sKTtcblxuICAgICAgICByZXR1cm4gc3dlZXRDb2RlO1xuICAgIH07XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXQtcnVsZVxuICAgIHRoaXMuTkVTVEVEX0FUX1JVTEUgPSB7XG4gICAgICAgIFwiQHBhZ2VcIjogdHJ1ZSxcbiAgICAgICAgXCJAZm9udC1mYWNlXCI6IHRydWUsXG4gICAgICAgIFwiQGtleWZyYW1lc1wiOiB0cnVlLFxuICAgICAgICAvLyBhbHNvIGluIENPTkRJVElPTkFMX0dST1VQX1JVTEUgYmVsb3dcbiAgICAgICAgXCJAbWVkaWFcIjogdHJ1ZSxcbiAgICAgICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICAgICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFID0ge1xuICAgICAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgICAgICBcIkBzdXBwb3J0c1wiOiB0cnVlLFxuICAgICAgICBcIkBkb2N1bWVudFwiOiB0cnVlXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGpzaGludCBjdXJseTogZmFsc2UgKi9cbi8vIFRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbi8vIFdoZXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyIGRlbm90ZXMgYSBuZXdsaW5lLlxuXG5leHBvcnRzLm5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWsgPSBuZXcgUmVnRXhwKCdcXHJcXG58JyArIGV4cG9ydHMubmV3bGluZS5zb3VyY2UpO1xuZXhwb3J0cy5hbGxMaW5lQnJlYWtzID0gbmV3IFJlZ0V4cChleHBvcnRzLmxpbmVCcmVhay5zb3VyY2UsICdnJyk7XG5cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gcGVybWl0ICQgKDM2KSBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2IHx8IGNvZGUgPT09IDY0O1xuICAgIC8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIC8vIHBlcm1pdCBfICg5NSkuXG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIC8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBtZXJnZU9wdHMoYWxsT3B0aW9ucywgdGFyZ2V0VHlwZSkge1xuICAgIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSB0YXJnZXRUeXBlXG4gICAgaWYgKHRhcmdldFR5cGUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBtZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gICAgdmFyIF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAgIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIGxpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgICB2YXIgX2luZGVudF9jb3VudCA9IC0xO1xuXG4gICAgdmFyIF9pdGVtcyA9IFtdO1xuICAgIHZhciBfZW1wdHkgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCA9IHBhcmVudC5iYXNlSW5kZW50TGVuZ3RoICsgbGV2ZWwgKiBwYXJlbnQuaW5kZW50X2xlbmd0aDtcbiAgICAgICAgX2luZGVudF9jb3VudCA9IGxldmVsO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jaGFyYWN0ZXJfY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgfTtcblxuICAgIHRoaXMuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9O1xuXG4gICAgdGhpcy5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaXRlbXNbX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgX2l0ZW1zLnB1c2goaW5wdXQpO1xuICAgICAgICBfY2hhcmFjdGVyX2NvdW50ICs9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgX2VtcHR5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gbnVsbDtcbiAgICAgICAgaWYgKCFfZW1wdHkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfaW5kZW50X2NvdW50ID4gMCkge1xuICAgICAgICAgICAgX2luZGVudF9jb3VudCAtPSAxO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBwYXJlbnQuaW5kZW50X2xlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICAgICAgICAgIF9pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBfZW1wdHkgPSBfaXRlbXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eSkge1xuICAgICAgICAgICAgaWYgKF9pbmRlbnRfY291bnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudC5pbmRlbnRfY2FjaGVbX2luZGVudF9jb3VudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gX2l0ZW1zLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gT3V0cHV0KGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgICB0aGlzLmluZGVudF9jYWNoZSA9IFtiYXNlSW5kZW50U3RyaW5nXTtcbiAgICB0aGlzLmJhc2VJbmRlbnRMZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbiAgICB0aGlzLmluZGVudF9sZW5ndGggPSBpbmRlbnRfc3RyaW5nLmxlbmd0aDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuXG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdGhpcy5iYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgICB0aGlzLmluZGVudF9zdHJpbmcgPSBpbmRlbnRfc3RyaW5nO1xuICAgIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG5cbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbiAgICB9O1xuXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcblxuXG4gICAgdGhpcy5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLy8gVXNpbmcgb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nIHRvIGFsbG93IGZvciBsYXRlciBleHBhbnNpb24gb2YgaW5mbyBhYm91dCBlYWNoIGxpbmVcbiAgICB0aGlzLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0X2xpbmVfbnVtYmVyKCkgPT09IDEgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBubyBuZXdsaW5lIG9uIHN0YXJ0IG9mIGZpbGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZV9uZXdsaW5lIHx8ICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmF3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0X2NvZGUgPSBmdW5jdGlvbihlbmRfd2l0aF9uZXdsaW5lLCBlb2wpIHtcbiAgICAgICAgdmFyIHN3ZWV0X2NvZGUgPSBsaW5lcy5qb2luKCdcXG4nKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRfY29kZSArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB3aGlsZSAobGV2ZWwgPj0gdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY2FjaGUucHVzaCh0aGlzLmluZGVudF9jYWNoZVt0aGlzLmluZGVudF9jYWNoZS5sZW5ndGggLSAxXSArIHRoaXMuaW5kZW50X3N0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQobGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgICAgICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgICAgICAgdGhpcy5hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBvdXRwdXRfbGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lc1tpbmRleF0ucmVtb3ZlX2luZGVudCgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgICAgICAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oaW5kZW50X3N0cmluZywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgICAgICAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiBsaW5lcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBsaW5lcy5sZW5ndGggPiAxID8gbGluZXNbbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzdGFydCBvZiB0aGUgZmlsZSBhbmQgbmV3bGluZSA9IGJsYW5rXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gbGluZS5pc19lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkJlYXV0aWZpZXI7XG5cbmZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzX2JlYXV0aWZ5O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG52YXIgY3NzX2JlYXV0aWZ5ID0gbGVnYWN5X2JlYXV0aWZ5X2Nzcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNzc19iZWF1dGlmeTogY3NzX2JlYXV0aWZ5XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuIiwiLypqc2hpbnQgY3VybHk6ZmFsc2UsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBTdHlsZSBIVE1MXG4tLS0tLS0tLS0tLS0tLS1cblxuICBXcml0dGVuIGJ5IE5vY2h1bSBTb3Nzb25rbywgKG5zb3Nzb25rb0Bob3RtYWlsLmNvbSlcblxuICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGpzYmVhdXRpZmllci5vcmc+XG4gICAgaHR0cDovL2pzYmVhdXRpZmllci5vcmcvXG5cbiAgVXNhZ2U6XG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSk7XG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zKTtcblxuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgaW5kZW50X2lubmVyX2h0bWwgKGRlZmF1bHQgZmFsc2UpICDigJQgaW5kZW50IDxoZWFkPiBhbmQgPGJvZHk+IHNlY3Rpb25zLFxuICAgIGluZGVudF9zaXplIChkZWZhdWx0IDQpICAgICAgICAgIOKAlCBpbmRlbnRhdGlvbiBzaXplLFxuICAgIGluZGVudF9jaGFyIChkZWZhdWx0IHNwYWNlKSAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgd3JhcF9saW5lX2xlbmd0aCAoZGVmYXVsdCAyNTApICAgICAgICAgICAgLSAgbWF4aW11bSBhbW91bnQgb2YgY2hhcmFjdGVycyBwZXIgbGluZSAoMCA9IGRpc2FibGUpXG4gICAgYnJhY2Vfc3R5bGUgKGRlZmF1bHQgXCJjb2xsYXBzZVwiKSAtIFwiY29sbGFwc2VcIiB8IFwiZXhwYW5kXCIgfCBcImVuZC1leHBhbmRcIiB8IFwibm9uZVwiXG4gICAgICAgICAgICBwdXQgYnJhY2VzIG9uIHRoZSBzYW1lIGxpbmUgYXMgY29udHJvbCBzdGF0ZW1lbnRzIChkZWZhdWx0KSwgb3IgcHV0IGJyYWNlcyBvbiBvd24gbGluZSAoQWxsbWFuIC8gQU5TSSBzdHlsZSksIG9yIGp1c3QgcHV0IGVuZCBicmFjZXMgb24gb3duIGxpbmUsIG9yIGF0dGVtcHQgdG8ga2VlcCB0aGVtIHdoZXJlIHRoZXkgYXJlLlxuICAgIHVuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBpbmxpbmUgdGFncykgLSBsaXN0IG9mIHRhZ3MsIHRoYXQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgY29udGVudF91bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gcHJlIHRhZykgLSBsaXN0IG9mIHRhZ3MsIHdob3NlIGNvbnRlbnQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgaW5kZW50X3NjcmlwdHMgKGRlZmF1bHQgbm9ybWFsKSAgLSBcImtlZXBcInxcInNlcGFyYXRlXCJ8XCJub3JtYWxcIlxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBiZWZvcmUgZWxlbWVudHMgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgYmVmb3JlIGVsZW1lbnRzLCBub3QgaW5zaWRlIHRhZ3Mgb3IgZm9yIHRleHQuXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rXG4gICAgaW5kZW50X2hhbmRsZWJhcnMgKGRlZmF1bHQgZmFsc2UpIC0gZm9ybWF0IGFuZCBpbmRlbnQge3sjZm9vfX0gYW5kIHt7L2Zvb319XG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgZXh0cmFfbGluZXJzIChkZWZhdWx0IFtoZWFkLGJvZHksL2h0bWxdKSAtTGlzdCBvZiB0YWdzIHRoYXQgc2hvdWxkIGhhdmUgYW4gZXh0cmEgbmV3bGluZSBiZWZvcmUgdGhlbS5cblxuICAgIGUuZy5cblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIHtcbiAgICAgICdpbmRlbnRfaW5uZXJfaHRtbCc6IGZhbHNlLFxuICAgICAgJ2luZGVudF9zaXplJzogMixcbiAgICAgICdpbmRlbnRfY2hhcic6ICcgJyxcbiAgICAgICd3cmFwX2xpbmVfbGVuZ3RoJzogNzgsXG4gICAgICAnYnJhY2Vfc3R5bGUnOiAnZXhwYW5kJyxcbiAgICAgICdwcmVzZXJ2ZV9uZXdsaW5lcyc6IHRydWUsXG4gICAgICAnbWF4X3ByZXNlcnZlX25ld2xpbmVzJzogNSxcbiAgICAgICdpbmRlbnRfaGFuZGxlYmFycyc6IGZhbHNlLFxuICAgICAgJ2V4dHJhX2xpbmVycyc6IFsnL2h0bWwnXVxuICAgIH0pO1xuKi9cblxuKGZ1bmN0aW9uKCkge1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9odG1sID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG52YXIgbWVyZ2VPcHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5tZXJnZU9wdHM7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbnZhciBsaW5lQnJlYWsgPSBhY29ybi5saW5lQnJlYWs7XG52YXIgYWxsTGluZUJyZWFrcyA9IGFjb3JuLmFsbExpbmVCcmVha3M7XG5cbi8vIGZ1bmN0aW9uIHRyaW0ocykge1xuLy8gICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbi8vIH1cblxuZnVuY3Rpb24gbHRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuZnVuY3Rpb24gcnRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1xccyskL2csICcnKTtcbn1cblxuZnVuY3Rpb24gQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSkge1xuICAgIC8vV3JhcHBlciBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHRoZSBuZWNlc3NhcnkgY29uc3RydWN0b3JzIGFuZCBkZWFsIHdpdGggdGhlIG91dHB1dC5cbiAgICBodG1sX3NvdXJjZSA9IGh0bWxfc291cmNlIHx8ICcnO1xuXG4gICAgdmFyIG11bHRpX3BhcnNlcixcbiAgICAgICAgaW5kZW50X2lubmVyX2h0bWwsXG4gICAgICAgIGluZGVudF9ib2R5X2lubmVyX2h0bWwsXG4gICAgICAgIGluZGVudF9oZWFkX2lubmVyX2h0bWwsXG4gICAgICAgIGluZGVudF9zaXplLFxuICAgICAgICBpbmRlbnRfY2hhcmFjdGVyLFxuICAgICAgICB3cmFwX2xpbmVfbGVuZ3RoLFxuICAgICAgICBicmFjZV9zdHlsZSxcbiAgICAgICAgdW5mb3JtYXR0ZWQsXG4gICAgICAgIGNvbnRlbnRfdW5mb3JtYXR0ZWQsXG4gICAgICAgIHByZXNlcnZlX25ld2xpbmVzLFxuICAgICAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMsXG4gICAgICAgIGluZGVudF9oYW5kbGViYXJzLFxuICAgICAgICB3cmFwX2F0dHJpYnV0ZXMsXG4gICAgICAgIHdyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSxcbiAgICAgICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlLFxuICAgICAgICBpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSxcbiAgICAgICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQsXG4gICAgICAgIGVuZF93aXRoX25ld2xpbmUsXG4gICAgICAgIGV4dHJhX2xpbmVycyxcbiAgICAgICAgZW9sO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAgIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdHMob3B0aW9ucywgJ2h0bWwnKTtcblxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIDEuMy40XG4gICAgaWYgKChvcHRpb25zLndyYXBfbGluZV9sZW5ndGggPT09IHVuZGVmaW5lZCB8fCBwYXJzZUludChvcHRpb25zLndyYXBfbGluZV9sZW5ndGgsIDEwKSA9PT0gMCkgJiZcbiAgICAgICAgKG9wdGlvbnMubWF4X2NoYXIgIT09IHVuZGVmaW5lZCAmJiBwYXJzZUludChvcHRpb25zLm1heF9jaGFyLCAxMCkgIT09IDApKSB7XG4gICAgICAgIG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMubWF4X2NoYXI7XG4gICAgfVxuXG4gICAgaW5kZW50X2lubmVyX2h0bWwgPSAob3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbDtcbiAgICBpbmRlbnRfYm9keV9pbm5lcl9odG1sID0gKG9wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWw7XG4gICAgaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IChvcHRpb25zLmluZGVudF9oZWFkX2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sO1xuICAgIGluZGVudF9zaXplID0gKG9wdGlvbnMuaW5kZW50X3NpemUgPT09IHVuZGVmaW5lZCkgPyA0IDogcGFyc2VJbnQob3B0aW9ucy5pbmRlbnRfc2l6ZSwgMTApO1xuICAgIGluZGVudF9jaGFyYWN0ZXIgPSAob3B0aW9ucy5pbmRlbnRfY2hhciA9PT0gdW5kZWZpbmVkKSA/ICcgJyA6IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gICAgYnJhY2Vfc3R5bGUgPSAob3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gdW5kZWZpbmVkKSA/ICdjb2xsYXBzZScgOiBvcHRpb25zLmJyYWNlX3N0eWxlO1xuICAgIHdyYXBfbGluZV9sZW5ndGggPSBwYXJzZUludChvcHRpb25zLndyYXBfbGluZV9sZW5ndGgsIDEwKSA9PT0gMCA/IDMyNzg2IDogcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoIHx8IDI1MCwgMTApO1xuICAgIHVuZm9ybWF0dGVkID0gb3B0aW9ucy51bmZvcm1hdHRlZCB8fCBbXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gICAgICAgICdhJywgJ2FiYnInLCAnYXJlYScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjaXRlJyxcbiAgICAgICAgJ2NvZGUnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZWwnLCAnZGZuJywgJ2VtJywgJ2VtYmVkJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsXG4gICAgICAgICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdtYXAnLCAnbWFyaycsICdtYXRoJywgJ21ldGVyJywgJ25vc2NyaXB0JyxcbiAgICAgICAgJ29iamVjdCcsICdvdXRwdXQnLCAncHJvZ3Jlc3MnLCAncScsICdydWJ5JywgJ3MnLCAnc2FtcCcsIC8qICdzY3JpcHQnLCAqLyAnc2VsZWN0JywgJ3NtYWxsJyxcbiAgICAgICAgJ3NwYW4nLCAnc3Ryb25nJywgJ3N1YicsICdzdXAnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3RpbWUnLCAndScsICd2YXInLFxuICAgICAgICAndmlkZW8nLCAnd2JyJywgJ3RleHQnLFxuICAgICAgICAvLyBwcmV4aXN0aW5nIC0gbm90IHN1cmUgb2YgZnVsbCBlZmZlY3Qgb2YgcmVtb3ZpbmcsIGxlYXZpbmcgaW5cbiAgICAgICAgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdiaWcnLCAnZHQnLCAnaW5zJywgJ3N0cmlrZScsICd0dCcsXG4gICAgXTtcbiAgICBjb250ZW50X3VuZm9ybWF0dGVkID0gb3B0aW9ucy5jb250ZW50X3VuZm9ybWF0dGVkIHx8IFtcbiAgICAgICAgJ3ByZScsXG4gICAgXTtcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyA9IChvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXM7XG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzID0gcHJlc2VydmVfbmV3bGluZXMgP1xuICAgICAgICAoaXNOYU4ocGFyc2VJbnQob3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMsIDEwKSkgPyAzMjc4NiA6IHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCkpIDpcbiAgICAgICAgMDtcbiAgICBpbmRlbnRfaGFuZGxlYmFycyA9IChvcHRpb25zLmluZGVudF9oYW5kbGViYXJzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmluZGVudF9oYW5kbGViYXJzO1xuICAgIHdyYXBfYXR0cmlidXRlcyA9IChvcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSA/ICdhdXRvJyA6IG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzO1xuICAgIHdyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSA9IChpc05hTihwYXJzZUludChvcHRpb25zLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSwgMTApKSkgPyBpbmRlbnRfc2l6ZSA6IHBhcnNlSW50KG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplLCAxMCk7XG4gICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlID0gd3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAnZm9yY2UnLmxlbmd0aCkgPT09ICdmb3JjZSc7XG4gICAgaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgPSAod3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScpO1xuICAgIGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkID0gKHdyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWFsaWduZWQnKTtcbiAgICBlbmRfd2l0aF9uZXdsaW5lID0gKG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZSA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICAgIGV4dHJhX2xpbmVycyA9ICh0eXBlb2Ygb3B0aW9ucy5leHRyYV9saW5lcnMgPT09ICdvYmplY3QnKSAmJiBvcHRpb25zLmV4dHJhX2xpbmVycyA/XG4gICAgICAgIG9wdGlvbnMuZXh0cmFfbGluZXJzLmNvbmNhdCgpIDogKHR5cGVvZiBvcHRpb25zLmV4dHJhX2xpbmVycyA9PT0gJ3N0cmluZycpID9cbiAgICAgICAgb3B0aW9ucy5leHRyYV9saW5lcnMuc3BsaXQoJywnKSA6ICdoZWFkLGJvZHksL2h0bWwnLnNwbGl0KCcsJyk7XG4gICAgZW9sID0gb3B0aW9ucy5lb2wgPyBvcHRpb25zLmVvbCA6ICdhdXRvJztcblxuICAgIGlmIChvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICAgICAgaW5kZW50X2NoYXJhY3RlciA9ICdcXHQnO1xuICAgICAgICBpbmRlbnRfc2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGVvbCA9ICdcXG4nO1xuICAgICAgICBpZiAoaHRtbF9zb3VyY2UgJiYgbGluZUJyZWFrLnRlc3QoaHRtbF9zb3VyY2UgfHwgJycpKSB7XG4gICAgICAgICAgICBlb2wgPSBodG1sX3NvdXJjZS5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW9sID0gZW9sLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpO1xuXG4gICAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgICBodG1sX3NvdXJjZSA9IGh0bWxfc291cmNlLnJlcGxhY2UoYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuXG4gICAgICAgIHRoaXMucG9zID0gMDsgLy9QYXJzZXIgcG9zaXRpb25cbiAgICAgICAgdGhpcy50b2tlbiA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJzsgLy9yZWZsZWN0cyB0aGUgY3VycmVudCBQYXJzZXIgbW9kZTogVEFHL0NPTlRFTlRcbiAgICAgICAgdGhpcy50YWdzID0geyAvL0FuIG9iamVjdCB0byBob2xkIHRhZ3MsIHRoZWlyIHBvc2l0aW9uLCBhbmQgdGhlaXIgcGFyZW50LXRhZ3MsIGluaXRpYXRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICBwYXJlbnQ6ICdwYXJlbnQxJyxcbiAgICAgICAgICAgIHBhcmVudGNvdW50OiAxLFxuICAgICAgICAgICAgcGFyZW50MTogJydcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50YWdfdHlwZSA9ICcnO1xuICAgICAgICB0aGlzLnRva2VuX3RleHQgPSB0aGlzLmxhc3RfdG9rZW4gPSB0aGlzLmxhc3RfdGV4dCA9IHRoaXMudG9rZW5fdHlwZSA9ICcnO1xuICAgICAgICB0aGlzLm5ld2xpbmVzID0gMDtcbiAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IGluZGVudF9pbm5lcl9odG1sO1xuICAgICAgICB0aGlzLmluZGVudF9ib2R5X2lubmVyX2h0bWwgPSBpbmRlbnRfYm9keV9pbm5lcl9odG1sO1xuICAgICAgICB0aGlzLmluZGVudF9oZWFkX2lubmVyX2h0bWwgPSBpbmRlbnRfaGVhZF9pbm5lcl9odG1sO1xuXG4gICAgICAgIHRoaXMuVXRpbHMgPSB7IC8vVWlsaXRpZXMgbWFkZSBhdmFpbGFibGUgdG8gdGhlIHZhcmlvdXMgZnVuY3Rpb25zXG4gICAgICAgICAgICB3aGl0ZXNwYWNlOiBcIlxcblxcclxcdCBcIi5zcGxpdCgnJyksXG5cbiAgICAgICAgICAgIHNpbmdsZV90b2tlbjogb3B0aW9ucy52b2lkX2VsZW1lbnRzIHx8IFtcbiAgICAgICAgICAgICAgICAvLyBIVExNIHZvaWQgZWxlbWVudHMgLSBha2Egc2VsZi1jbG9zaW5nIHRhZ3MgLSBha2Egc2luZ2xldG9uc1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9zeW50YXguaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgICAgICAgICAgICAgJ2FyZWEnLCAnYmFzZScsICdicicsICdjb2wnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsXG4gICAgICAgICAgICAgICAgJ2xpbmsnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdwYXJhbScsICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJyxcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBPcHRpb25hbCB0YWdzIC0gYXJlIG5vdCB1bmRlcnN0b29kLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJ1bGVzIGZvciBvcHRpb25hbCB0YWdzIGFyZSB0b28gY29tcGxleCBmb3IgYSBzaW1wbGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIEFsc28sIHRoZSBjb250ZW50IG9mIHRoZXNlIHRhZ3Mgc2hvdWxkIHN0aWxsIGJlIGluZGVudGVkIGluIG1hbnkgY2FzZXMuXG4gICAgICAgICAgICAgICAgLy8gJ2xpJyBpcyBhIGdvb2QgZXhtcGxlLlxuXG4gICAgICAgICAgICAgICAgLy8gRG9jdHlwZSBhbmQgeG1sIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgJyFkb2N0eXBlJywgJz94bWwnLFxuICAgICAgICAgICAgICAgIC8vID9waHAgdGFnXG4gICAgICAgICAgICAgICAgJz9waHAnLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHRhZ3MgdGhhdCB3ZXJlIGluIHRoaXMgbGlzdCwga2VlcGluZyBqdXN0IGluIGNhc2VcbiAgICAgICAgICAgICAgICAnYmFzZWZvbnQnLCAnaXNpbmRleCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHRyYV9saW5lcnM6IGV4dHJhX2xpbmVycywgLy9mb3IgdGFncyB0aGF0IG5lZWQgYSBsaW5lIG9mIHdoaXRlc3BhY2UgYmVmb3JlIHRoZW1cbiAgICAgICAgICAgIGluX2FycmF5OiBmdW5jdGlvbih3aGF0LCBhcnIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2hhdCA9PT0gYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHRleHQgaXMgY29tcG9zZWQgZW50aXJlbHkgb2Ygd2hpdGVzcGFjZS5cbiAgICAgICAgdGhpcy5pc193aGl0ZXNwYWNlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0ZXh0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLlV0aWxzLmluX2FycmF5KHRleHQuY2hhckF0KG4pLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJyc7XG5cbiAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdsaW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVfbmV3bGluZXMgJiYgaW5wdXRfY2hhciA9PT0gJ1xcbicgJiYgdGhpcy5uZXdsaW5lcyA8PSBtYXhfcHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFwcGVuZCBhIHNwYWNlIHRvIHRoZSBnaXZlbiBjb250ZW50IChzdHJpbmcgYXJyYXkpIG9yLCBpZiB3ZSBhcmVcbiAgICAgICAgLy8gYXQgdGhlIHdyYXBfbGluZV9sZW5ndGgsIGFwcGVuZCBhIG5ld2xpbmUvaW5kZW50YXRpb24uXG4gICAgICAgIC8vIHJldHVybiB0cnVlIGlmIGEgbmV3bGluZSB3YXMgYWRkZWQsIGZhbHNlIGlmIGEgc3BhY2Ugd2FzIGFkZGVkXG4gICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVfY2hhcl9jb3VudCA+PSB0aGlzLndyYXBfbGluZV9sZW5ndGgpIHsgLy9pbnNlcnQgYSBsaW5lIHdoZW4gdGhlIHdyYXBfbGluZV9sZW5ndGggaXMgcmVhY2hlZFxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbihjb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfY29udGVudCA9IGZ1bmN0aW9uKCkgeyAvL2Z1bmN0aW9uIHRvIGNhcHR1cmUgcmVndWxhciBjb250ZW50IGJldHdlZW4gdGFnc1xuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJyxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW10sXG4gICAgICAgICAgICAgICAgaGFuZGxlYmFyc1N0YXJ0ZWQgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpICE9PSAnPCcgfHwgaGFuZGxlYmFyc1N0YXJ0ZWQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQubGVuZ3RoID8gY29udGVudC5qb2luKCcnKSA6IFsnJywgJ1RLX0VPRiddO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGViYXJzU3RhcnRlZCA8IDIgJiYgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWJhcnNTdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlYmFyc1N0YXJ0ZWQgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGViYXJzU3RhcnRlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJ30nICYmIGhhbmRsZWJhcnNTdGFydGVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZWJhcnNTdGFydGVkLS0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGViYXJzIHBhcnNpbmcgaXMgY29tcGxpY2F0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIHt7I2Zvb319IGFuZCB7ey9mb299fSBhcmUgZm9ybWF0dGVkIHRhZ3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIHt7c29tZXRoaW5nfX0gc2hvdWxkIGdldCB0cmVhdGVkIGFzIGNvbnRlbnQsIGV4Y2VwdDpcbiAgICAgICAgICAgICAgICAgICAgLy8ge3tlbHNlfX0gc3BlY2lmaWNhbGx5IGJlaGF2ZXMgbGlrZSB7eyNpZn19IGFuZCB7ey9pZn19XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZWVrMyA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWszID09PSAne3sjJyB8fCBwZWVrMyA9PT0gJ3t7LycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0YWdzIGFuZCBub3QgY29udGVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlZWszID09PSAne3shJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdldF90YWcoKSwgJ1RLX1RBR19IQU5ETEVCQVJTX0NPTU1FTlQnXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgMikgPT09ICd7eycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldF90YWcodHJ1ZSkgPT09ICd7e2Vsc2V9fScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goaW5wdXRfY2hhcik7IC8vbGV0dGVyIGF0LWEtdGltZSAob3Igc3RyaW5nKSBpbnNlcnRlZCB0byBhbiBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQubGVuZ3RoID8gY29udGVudC5qb2luKCcnKSA6ICcnO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X2NvbnRlbnRzX3RvID0gZnVuY3Rpb24obmFtZSkgeyAvL2dldCB0aGUgZnVsbCBjb250ZW50IG9mIGEgc2NyaXB0IG9yIHN0eWxlIHRvIHBhc3MgdG8ganNfYmVhdXRpZnlcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCAnVEtfRU9GJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICAgICAgdmFyIHJlZ19tYXRjaCA9IG5ldyBSZWdFeHAoJzwvJyArIG5hbWUgKyAnXFxcXHMqPicsICdpZ20nKTtcbiAgICAgICAgICAgIHJlZ19tYXRjaC5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciByZWdfYXJyYXkgPSByZWdfbWF0Y2guZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgICAgICAgIHZhciBlbmRfc2NyaXB0ID0gcmVnX2FycmF5ID8gcmVnX2FycmF5LmluZGV4IDogdGhpcy5pbnB1dC5sZW5ndGg7IC8vYWJzb2x1dGUgZW5kIG9mIHNjcmlwdFxuICAgICAgICAgICAgaWYgKHRoaXMucG9zIDwgZW5kX3NjcmlwdCkgeyAvL2dldCBldmVyeXRoaW5nIGluIGJldHdlZW4gdGhlIHNjcmlwdCB0YWdzXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmRfc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVuZF9zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlY29yZF90YWcgPSBmdW5jdGlvbih0YWcpIHsgLy9mdW5jdGlvbiB0byByZWNvcmQgYSB0YWcgYW5kIGl0cyBwYXJlbnQgaW4gdGhpcy50YWdzIE9iamVjdFxuICAgICAgICAgICAgaWYgKHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSkgeyAvL2NoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoaXMgdGFnIHR5cGVcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10rKztcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXSA9IHRoaXMuaW5kZW50X2xldmVsOyAvL2FuZCByZWNvcmQgdGhlIHByZXNlbnQgaW5kZW50IGxldmVsXG4gICAgICAgICAgICB9IGVsc2UgeyAvL290aGVyd2lzZSBpbml0aWFsaXplIHRoaXMgdGFnIHR5cGVcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dID0gdGhpcy5pbmRlbnRfbGV2ZWw7IC8vYW5kIHJlY29yZCB0aGUgcHJlc2VudCBpbmRlbnQgbGV2ZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gKyAncGFyZW50J10gPSB0aGlzLnRhZ3MucGFyZW50OyAvL3NldCB0aGUgcGFyZW50IChpLmUuIGluIHRoZSBjYXNlIG9mIGEgZGl2IHRoaXMudGFncy5kaXYxcGFyZW50KVxuICAgICAgICAgICAgdGhpcy50YWdzLnBhcmVudCA9IHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXTsgLy9hbmQgbWFrZSB0aGlzIHRoZSBjdXJyZW50IHBhcmVudCAoaS5lLiBpbiB0aGUgY2FzZSBvZiBhIGRpdiAnZGl2MScpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXRyaWV2ZV90YWcgPSBmdW5jdGlvbih0YWcpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gICAgICAgICAgICBpZiAodGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7IC8vaWYgdGhlIG9wZW5lbmVyIGlzIG5vdCBpbiB0aGUgT2JqZWN0IHdlIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgIHZhciB0ZW1wX3BhcmVudCA9IHRoaXMudGFncy5wYXJlbnQ7IC8vY2hlY2sgdG8gc2VlIGlmIGl0J3MgYSBjbG9zYWJsZSB0YWcuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRlbXBfcGFyZW50KSB7IC8vdGlsbCB3ZSByZWFjaCAnJyAodGhlIGluaXRpYWwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddID09PSB0ZW1wX3BhcmVudCkgeyAvL2lmIHRoaXMgaXMgaXQgdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW1wX3BhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTsgLy9vdGhlcndpc2Uga2VlcCBvbiBjbGltYmluZyB1cCB0aGUgRE9NIFRyZWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBfcGFyZW50KSB7IC8vaWYgd2UgY2F1Z2h0IHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dOyAvL3NldCB0aGUgaW5kZW50X2xldmVsIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5wYXJlbnQgPSB0aGlzLnRhZ3NbdGVtcF9wYXJlbnQgKyAncGFyZW50J107IC8vYW5kIHNldCB0aGUgY3VycmVudCBwYXJlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gKyAncGFyZW50J107IC8vZGVsZXRlIHRoZSBjbG9zZWQgdGFncyBwYXJlbnQgcmVmZXJlbmNlLi4uXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dOyAvLy4uLmFuZCB0aGUgdGFnIGl0c2VsZlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pbmRlbnRfdG9fdGFnID0gZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAvLyBNYXRjaCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdGhlIGxhc3QgdXNlIG9mIHRoaXMgdGFnLCBidXQgZG9uJ3QgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3MucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHRlbXBfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gdGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzW3RlbXBfcGFyZW50ICsgJ3BhcmVudCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXBfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF90YWcgPSBmdW5jdGlvbihwZWVrKSB7IC8vZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCB0YWcgYW5kIHBhcnNlIGl0cyB0eXBlXG4gICAgICAgICAgICB2YXIgaW5wdXRfY2hhciA9ICcnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbXSxcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gJycsXG4gICAgICAgICAgICAgICAgc3BhY2UgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9hdHRyID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBoYXNfd3JhcHBlZF9hdHRycyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhZ19zdGFydCwgdGFnX2VuZCxcbiAgICAgICAgICAgICAgICB0YWdfc3RhcnRfY2hhcixcbiAgICAgICAgICAgICAgICBvcmlnX3BvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgICAgIG9yaWdfbGluZV9jaGFyX2NvdW50ID0gdGhpcy5saW5lX2NoYXJfY291bnQsXG4gICAgICAgICAgICAgICAgaXNfdGFnX2Nsb3NlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhaWw7XG5cbiAgICAgICAgICAgIHBlZWsgPSBwZWVrICE9PSB1bmRlZmluZWQgPyBwZWVrIDogZmFsc2U7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gb3JpZ19wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IG9yaWdfbGluZV9jaGFyX2NvdW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7IC8vZG9uJ3Qgd2FudCB0byBpbnNlcnQgdW5uZWNlc3Nhcnkgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gXCInXCIgfHwgaW5wdXRfY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyICs9IHRoaXMuZ2V0X3VuZm9ybWF0dGVkKGlucHV0X2NoYXIpO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICc9JykgeyAvL25vIHNwYWNlIGJlZm9yZSA9XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhaWwgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSAmJiBoYXNfd3JhcHBlZF9hdHRycyAmJiAhaXNfdGFnX2Nsb3NlZCAmJiAoaW5wdXRfY2hhciA9PT0gJz4nIHx8IGlucHV0X2NoYXIgPT09ICcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhaWwubWF0Y2goL15cXC8/XFxzKj4vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX3RhZ19jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24oY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSAhPT0gJz0nICYmIGlucHV0X2NoYXIgIT09ICc+JyAmJiBzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAvL25vIHNwYWNlIGFmdGVyID0gb3IgYmVmb3JlID5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB0aGlzLnNwYWNlX29yX3dyYXAoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRlbnRBdHRycyA9IHdyYXBwZWQgJiYgaW5wdXRfY2hhciAhPT0gJy8nICYmICFpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2U7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3dyYXBfYXR0cmlidXRlc19mb3JjZSAmJiBpbnB1dF9jaGFyICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZV9maXJzdF9hdHRyX3dyYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSAmJiBmaXJzdF9hdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX29ubHlfYXR0cmlidXRlID0gdGFpbC5tYXRjaCgvXlxcUyooPVwiKFteXCJdfFxcXFxcIikqXCIpP1xccypcXC8/XFxzKj4vKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZV9maXJzdF9hdHRyX3dyYXAgPSAhaXNfb25seV9hdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0X2F0dHIgfHwgZm9yY2VfZmlyc3RfYXR0cl93cmFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudEF0dHJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc193cmFwcGVkX2F0dHJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbmRlbnQgYXR0cmlidXRlcyBhbiBhdXRvLCBmb3JjZWQsIG9yIGZvcmNlZC1hbGlnbiBsaW5lLXdyYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGlnbm1lbnRfc2l6ZSA9IHdyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudF9zaXplID0gY29udGVudC5pbmRleE9mKCcgJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudCA9IDA7IGNvdW50IDwgYWxpZ25tZW50X3NpemU7IGNvdW50KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGV2ZXIgZnVydGhlciBpbmRlbnQgd2l0aCBzcGFjZXMgc2luY2Ugd2UncmUgdHJ5aW5nIHRvIGFsaWduIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RfYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbaV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9hdHRyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiB0YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaW5zaWRlIGFuIGFuZ2xlLWJyYWNrZXQgdGFnLCBwdXQgc3BhY2VzIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGViYXJzIG5vdCBpbnNpZGUgb2Ygc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChpbnB1dF9jaGFyICsgdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpKSA9PT0gJ3t7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciArPSB0aGlzLmdldF91bmZvcm1hdHRlZCgnfX0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICcgJyAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSAnICcgKyBpbnB1dF9jaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICc8JyAmJiAhdGFnX3N0YXJ0X2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0ID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnRfY2hhciA9ICc8JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgIXRhZ19zdGFydF9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+PSAyICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9PT0gJ3snICYmIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAyXSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJyMnIHx8IGlucHV0X2NoYXIgPT09ICcvJyB8fCBpbnB1dF9jaGFyID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnQgPSB0aGlzLnBvcyAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydF9jaGFyID0gJ3snO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goaW5wdXRfY2hhcik7IC8vaW5zZXJ0cyBjaGFyYWN0ZXIgYXQtYS10aW1lIChvciBzdHJpbmcpXG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFsxXSAmJiAoY29udGVudFsxXSA9PT0gJyEnIHx8IGNvbnRlbnRbMV0gPT09ICc/JyB8fCBjb250ZW50WzFdID09PSAnJScpKSB7IC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gW3RoaXMuZ2V0X2NvbW1lbnQodGFnX3N0YXJ0KV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiBjb250ZW50WzFdICYmIGNvbnRlbnRbMV0gPT09ICd7JyAmJiBjb250ZW50WzJdICYmIGNvbnRlbnRbMl0gPT09ICchJykgeyAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFt0aGlzLmdldF9jb21tZW50KHRhZ19zdGFydCldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiBjb250ZW50Lmxlbmd0aCA+IDIgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDJdID09PSAnfScgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoaW5wdXRfY2hhciAhPT0gJz4nKTtcblxuICAgICAgICAgICAgdmFyIHRhZ19jb21wbGV0ZSA9IGNvbnRlbnQuam9pbignJyk7XG4gICAgICAgICAgICB2YXIgdGFnX2luZGV4O1xuICAgICAgICAgICAgdmFyIHRhZ19vZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vIG11c3QgY2hlY2sgZm9yIHNwYWNlIGZpcnN0IG90aGVyd2lzZSB0aGUgdGFnIGNvdWxkIGhhdmUgdGhlIGZpcnN0IGF0dHJpYnV0ZSBpbmNsdWRlZCwgYW5kXG4gICAgICAgICAgICAvLyB0aGVuIG5vdCB1bi1pbmRlbnQgY29ycmVjdGx5XG4gICAgICAgICAgICBpZiAodGFnX2NvbXBsZXRlLmluZGV4T2YoJyAnKSAhPT0gLTEpIHsgLy9pZiB0aGVyZSdzIHdoaXRlc3BhY2UsIHRoYXRzIHdoZXJlIHRoZSB0YWcgbmFtZSBlbmRzXG4gICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJyAnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NvbXBsZXRlLmluZGV4T2YoJ1xcbicpICE9PSAtMSkgeyAvL2lmIHRoZXJlJ3MgYSBsaW5lIGJyZWFrLCB0aGF0cyB3aGVyZSB0aGUgdGFnIG5hbWUgZW5kc1xuICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NvbXBsZXRlLmNoYXJBdCgwKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJ30nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vb3RoZXJ3aXNlIGdvIHdpdGggdGhlIHRhZyBlbmRpbmdcbiAgICAgICAgICAgICAgICB0YWdfaW5kZXggPSB0YWdfY29tcGxldGUuaW5kZXhPZignPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZ19jb21wbGV0ZS5jaGFyQXQoMCkgPT09ICc8JyB8fCAhaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICAgICAgICAgICAgICB0YWdfb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFnX29mZnNldCA9IHRhZ19jb21wbGV0ZS5jaGFyQXQoMikgPT09ICcjJyA/IDMgOiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZ19jaGVjayA9IHRhZ19jb21wbGV0ZS5zdWJzdHJpbmcodGFnX29mZnNldCwgdGFnX2luZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHRhZ19jb21wbGV0ZS5jaGFyQXQodGFnX2NvbXBsZXRlLmxlbmd0aCAtIDIpID09PSAnLycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLlV0aWxzLmluX2FycmF5KHRhZ19jaGVjaywgdGhpcy5VdGlscy5zaW5nbGVfdG9rZW4pKSB7IC8vaWYgdGhpcyB0YWcgbmFtZSBpcyBhIHNpbmdsZSB0YWcgdHlwZSAoZWl0aGVyIGluIHRoZSBsaXN0IG9yIGhhcyBhIGNsb3NpbmcgLylcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTSU5HTEUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX2NvbXBsZXRlLmNoYXJBdCgwKSA9PT0gJ3snICYmIHRhZ19jaGVjayA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X3RvX3RhZygnaWYnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdIQU5ETEVCQVJTX0VMU0UnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9jb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX3VuZm9ybWF0dGVkKHRhZ19jaGVjaywgdW5mb3JtYXR0ZWQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pc191bmZvcm1hdHRlZCh0YWdfY2hlY2ssIGNvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHJlZm9ybWF0IHRoZSBcInVuZm9ybWF0dGVkXCIgb3IgXCJjb250ZW50X3VuZm9ybWF0dGVkXCIgdGFnc1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB0aGlzLmdldF91bmZvcm1hdHRlZCgnPC8nICsgdGFnX2NoZWNrICsgJz4nLCB0YWdfY29tcGxldGUpOyAvLy4uLmRlbGVnYXRlIHRvIGdldF91bmZvcm1hdHRlZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB0YWdfZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NoZWNrID09PSAnc2NyaXB0JyAmJlxuICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgICh0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPiAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2NvbXBsZXRlLnNlYXJjaCgvXFxiKHRleHR8YXBwbGljYXRpb258ZG9qbylcXC8oeC0pPyhqYXZhc2NyaXB0fGVjbWFzY3JpcHR8anNjcmlwdHxsaXZlc2NyaXB0fChsZFxcKyk/anNvbnxtZXRob2R8YXNwZWN0KS8pID4gLTEpKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZF90YWcodGFnX2NoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTQ1JJUFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NoZWNrID09PSAnc3R5bGUnICYmXG4gICAgICAgICAgICAgICAgKHRhZ19jb21wbGV0ZS5zZWFyY2goJ3R5cGUnKSA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRhZ19jb21wbGV0ZS5zZWFyY2goJ3R5cGUnKSA+IC0xICYmIHRhZ19jb21wbGV0ZS5zZWFyY2goJ3RleHQvY3NzJykgPiAtMSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkX3RhZyh0YWdfY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NUWUxFJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjay5jaGFyQXQoMCkgPT09ICchJykgeyAvL3BlZWsgZm9yIDwhIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tbWVudHMgY29udGVudCBpcyBhbHJlYWR5IGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgIGlmICh0YWdfY2hlY2suY2hhckF0KDApID09PSAnLycpIHsgLy90aGlzIHRhZyBpcyBhIGRvdWJsZSB0YWcgc28gY2hlY2sgZm9yIHRhZy1lbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyaWV2ZV90YWcodGFnX2NoZWNrLnN1YnN0cmluZygxKSk7IC8vcmVtb3ZlIGl0IGFuZCBhbGwgYW5jZXN0b3JzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnRU5EJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL290aGVyd2lzZSBpdCdzIGEgc3RhcnQtdGFnXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkX3RhZyh0YWdfY2hlY2spOyAvL3B1c2ggaXQgb24gdGhlIHRhZyBzdGFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnX2NoZWNrLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTVEFSVCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgcHJlc2VydmluZyBvZiBuZXdsaW5lcyBhZnRlciBhIHN0YXJ0IG9yIGVuZCB0YWdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLlV0aWxzLmluX2FycmF5KHRhZ19jaGVjaywgdGhpcy5VdGlscy5leHRyYV9saW5lcnMpKSB7IC8vY2hlY2sgaWYgdGhpcyBkb3VibGUgbmVlZHMgYW4gZXh0cmEgbGluZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAmJiB0aGlzLm91dHB1dFt0aGlzLm91dHB1dC5sZW5ndGggLSAyXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwZWVrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBvcmlnX3BvcztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IG9yaWdfbGluZV9jaGFyX2NvdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29udGVudC5qb2luKCcnKTsgLy9yZXR1cm5zIGZ1bGx5IGZvcm1hdHRlZCB0YWdcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldF9jb21tZW50ID0gZnVuY3Rpb24oc3RhcnRfcG9zKSB7IC8vZnVuY3Rpb24gdG8gcmV0dXJuIGNvbW1lbnQgY29udGVudCBpbiBpdHMgZW50aXJldHlcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgd2lsbCBoYXZlIHZlcnkgcG9vciBwZXJmLCBidXQgd2lsbCB3b3JrIGZvciBub3cuXG4gICAgICAgICAgICB2YXIgY29tbWVudCA9ICcnLFxuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICc+JyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRfcG9zO1xuICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3MgPD0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9IGlucHV0X2NoYXI7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgZm9yIHRoZSBkZWxpbWl0ZXIgaWYgdGhlIGxhc3QgY2hhcnMgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5jaGFyQXQoY29tbWVudC5sZW5ndGggLSAxKSA9PT0gZGVsaW1pdGVyLmNoYXJBdChkZWxpbWl0ZXIubGVuZ3RoIC0gMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5pbmRleE9mKGRlbGltaXRlcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgbmVlZCB0byBzZWFyY2ggZm9yIGN1c3RvbSBkZWxpbWl0ZXIgZm9yIHRoZSBmaXJzdCBmZXcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCAmJiBjb21tZW50Lmxlbmd0aCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmluZGV4T2YoJzwhW2lmJykgPT09IDApIHsgLy9wZWVrIGZvciA8IVtpZiBjb25kaXRpb25hbCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnPCFbZW5kaWZdPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhW2NkYXRhWycpID09PSAwKSB7IC8vaWYgaXQncyBhIDxbY2RhdGFbIGNvbW1lbnQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICddXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8IVsnKSA9PT0gMCkgeyAvLyBzb21lIG90aGVyICFbIGNvbW1lbnQ/IC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ10+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnQuaW5kZXhPZignPCEtLScpID09PSAwKSB7IC8vIDwhLS0gY29tbWVudCAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICctLT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCd7eyEtLScpID09PSAwKSB7IC8vIHt7IS0tIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJy0tfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCd7eyEnKSA9PT0gMCkgeyAvLyB7eyEgaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5sZW5ndGggPT09IDUgJiYgY29tbWVudC5pbmRleE9mKCd7eyEtLScpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICd9fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8PycpID09PSAwKSB7IC8vIHt7ISBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICc/Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwlJykgPT09IDApIHsgLy8ge3shIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJyU+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB0b2tlbk1hdGNoZXIoZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSAnJztcblxuICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdUb2tlbiA9IHRva2VuICsgc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXdUb2tlbi5sZW5ndGggPD0gZGVsaW1pdGVyLmxlbmd0aCA/IG5ld1Rva2VuIDogbmV3VG9rZW4uc3Vic3RyKG5ld1Rva2VuLmxlbmd0aCAtIGRlbGltaXRlci5sZW5ndGgsIGRlbGltaXRlci5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRvZXNOb3RNYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5pbmRleE9mKGRlbGltaXRlcikgPT09IC0xO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgICAgICAgICBkb2VzTm90TWF0Y2g6IGRvZXNOb3RNYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0X3VuZm9ybWF0dGVkID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBvcmlnX3RhZykgeyAvL2Z1bmN0aW9uIHRvIHJldHVybiB1bmZvcm1hdHRlZCBjb250ZW50IGluIGl0cyBlbnRpcmV0eVxuICAgICAgICAgICAgaWYgKG9yaWdfdGFnICYmIG9yaWdfdGFnLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihkZWxpbWl0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJyc7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGRlbGltaXRlck1hdGNoZXIgPSB0b2tlbk1hdGNoZXIoZGVsaW1pdGVyKTtcblxuICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnXFxuJyB8fCBpbnB1dF9jaGFyID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qICBEb24ndCBjaGFuZ2UgdGFiIGluZGVudGlvbiBmb3IgdW5mb3JtYXR0ZWQgYmxvY2tzLiAgSWYgdXNpbmcgY29kZSBmb3IgaHRtbCBlZGl0aW5nLCB0aGlzIHdpbGwgZ3JlYXRseSBhZmZlY3QgPHByZT4gdGFncyBpZiB0aGV5IGFyZSBzcGVjaWZpZWQgaW4gdGhlICd1bmZvcm1hdHRlZCBhcnJheSdcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmluZGVudF9sZXZlbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5pbmRlbnRfc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BhY2UgPSBmYWxzZTsgLy8uLi5hbmQgbWFrZSBzdXJlIG90aGVyIGluZGVudGF0aW9uIGlzIGVyYXNlZFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gaW5wdXRfY2hhcjtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJNYXRjaGVyLmFkZChpbnB1dF9jaGFyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiBpbnB1dF9jaGFyID09PSAneycgJiYgY29udGVudC5sZW5ndGggJiYgY29udGVudC5jaGFyQXQoY29udGVudC5sZW5ndGggLSAyKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWJhcnMgZXhwcmVzc2lvbnMgaW4gc3RyaW5ncyBzaG91bGQgYWxzbyBiZSB1bmZvcm1hdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSB0aGlzLmdldF91bmZvcm1hdHRlZCgnfX0nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc2lkZXIgd2hlbiBzdG9wcGluZyBmb3IgZGVsaW1pdGVycy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChkZWxpbWl0ZXJNYXRjaGVyLmRvZXNOb3RNYXRjaCgpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRfdG9rZW4gPSBmdW5jdGlvbigpIHsgLy9pbml0aWFsIGhhbmRsZXIgZm9yIHRva2VuLXJldHJpZXZhbFxuICAgICAgICAgICAgdmFyIHRva2VuO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X3Rva2VuID09PSAnVEtfVEFHX1NDUklQVCcgfHwgdGhpcy5sYXN0X3Rva2VuID09PSAnVEtfVEFHX1NUWUxFJykgeyAvL2NoZWNrIGlmIHdlIG5lZWQgdG8gZm9ybWF0IGphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMubGFzdF90b2tlbi5zdWJzdHIoNyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF9jb250ZW50c190byh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sICdUS18nICsgdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50X21vZGUgPT09ICdDT05URU5UJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfY29udGVudCgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuLCAnVEtfQ09OVEVOVCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9tb2RlID09PSAnVEFHJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdfbmFtZV90eXBlID0gJ1RLX1RBR18nICsgdGhpcy50YWdfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlbiwgdGFnX25hbWVfdHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0X2Z1bGxfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgICAgICAgIGxldmVsID0gdGhpcy5pbmRlbnRfbGV2ZWwgKyBsZXZlbCB8fCAwO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbih0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNfdW5mb3JtYXR0ZWQgPSBmdW5jdGlvbih0YWdfY2hlY2ssIHVuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAvL2lzIHRoaXMgYW4gSFRNTDUgYmxvY2stbGV2ZWwgbGluaz9cbiAgICAgICAgICAgIGlmICghdGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhZ19jaGVjay50b0xvd2VyQ2FzZSgpICE9PSAnYScgfHwgIXRoaXMuVXRpbHMuaW5fYXJyYXkoJ2EnLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9hdCB0aGlzIHBvaW50IHdlIGhhdmUgYW4gIHRhZzsgaXMgaXRzIGZpcnN0IGNoaWxkIHNvbWV0aGluZyB3ZSB3YW50IHRvIHJlbWFpblxuICAgICAgICAgICAgLy91bmZvcm1hdHRlZD9cbiAgICAgICAgICAgIHZhciBuZXh0X3RhZyA9IHRoaXMuZ2V0X3RhZyh0cnVlIC8qIHBlZWsuICovICk7XG5cbiAgICAgICAgICAgIC8vIHRlc3QgbmV4dF90YWcgdG8gc2VlIGlmIGl0IGlzIGp1c3QgaHRtbCB0YWcgKG5vIGV4dGVybmFsIGNvbnRlbnQpXG4gICAgICAgICAgICB2YXIgdGFnID0gKG5leHRfdGFnIHx8IFwiXCIpLm1hdGNoKC9eXFxzKjxcXHMqXFwvPyhbYS16XSopXFxzKltePl0qPlxccyokLyk7XG5cbiAgICAgICAgICAgIC8vIGlmIG5leHRfdGFnIGNvbWVzIGJhY2sgYnV0IGlzIG5vdCBhbiBpc29sYXRlZCB0YWcsIHRoZW5cbiAgICAgICAgICAgIC8vIGxldCdzIHRyZWF0IHRoZSAnYScgdGFnIGFzIGhhdmluZyBjb250ZW50XG4gICAgICAgICAgICAvLyBhbmQgcmVzcGVjdCB0aGUgdW5mb3JtYXR0ZWQgb3B0aW9uXG4gICAgICAgICAgICBpZiAoIXRhZyB8fCB0aGlzLlV0aWxzLmluX2FycmF5KHRhZ1sxXSwgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnByaW50ZXIgPSBmdW5jdGlvbihqc19zb3VyY2UsIGluZGVudF9jaGFyYWN0ZXIsIGluZGVudF9zaXplLCB3cmFwX2xpbmVfbGVuZ3RoLCBicmFjZV9zdHlsZSkgeyAvL2hhbmRsZXMgaW5wdXQvb3V0cHV0IGFuZCBzb21lIG90aGVyIHByaW50aW5nIGZ1bmN0aW9uc1xuXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0ganNfc291cmNlIHx8ICcnOyAvL2dldHMgdGhlIGlucHV0IGZvciB0aGUgUGFyc2VyXG5cbiAgICAgICAgICAgIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5pbnB1dC5yZXBsYWNlKC9cXHJcXG58W1xcclxcdTIwMjhcXHUyMDI5XS9nLCAnXFxuJyk7XG5cbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmluZGVudF9jaGFyYWN0ZXIgPSBpbmRlbnRfY2hhcmFjdGVyO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfc3RyaW5nID0gJyc7XG4gICAgICAgICAgICB0aGlzLmluZGVudF9zaXplID0gaW5kZW50X3NpemU7XG4gICAgICAgICAgICB0aGlzLmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGU7XG4gICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbCA9IDA7XG4gICAgICAgICAgICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB3cmFwX2xpbmVfbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSAwOyAvL2NvdW50IHRvIHNlZSBpZiB3cmFwX2xpbmVfbGVuZ3RoIHdhcyBleGNlZWRlZFxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5kZW50X3NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X3N0cmluZyArPSB0aGlzLmluZGVudF9jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSA9IGZ1bmN0aW9uKGZvcmNlLCBhcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFhcnIgfHwgIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgKGFyclthcnIubGVuZ3RoIC0gMV0gIT09ICdcXG4nKSkgeyAvL3dlIG1pZ2h0IHdhbnQgdGhlIGV4dHJhIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKChhcnJbYXJyLmxlbmd0aCAtIDFdICE9PSAnXFxuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoIC0gMV0gPSBydHJpbShhcnJbYXJyLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmRlbnRfbGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCArPSB0aGlzLmluZGVudF9zdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRfdG9rZW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgcHJpbnRpbmcgaW5pdGlhbCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzX3doaXRlc3BhY2UodGV4dCkgJiYgIXRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0IHx8IHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggJiYgdGhpcy5vdXRwdXRbdGhpcy5vdXRwdXQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBsdHJpbSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuX3Jhdyh0ZXh0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRfdG9rZW5fcmF3ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBnb2luZyB0byBwcmludCBuZXdsaW5lcywgdHJ1bmNhdGUgdHJhaWxpbmdcbiAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLCBhcyB0aGUgbmV3bGluZXMgd2lsbCByZXByZXNlbnQgdGhlIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld2xpbmVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gcnRyaW0odGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRleHQgJiYgdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiB0ZXh0LmNoYXJBdCh0ZXh0Lmxlbmd0aCAtIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5mb3JtYXR0ZWQgdGFncyBjYW4gZ3JhYiBuZXdsaW5lcyBhcyB0aGVpciBsYXN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0ZXh0LnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMubmV3bGluZXM7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUobiA+IDAsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdsaW5lcyA9IDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsKys7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnVuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50X2xldmVsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9sZXZlbC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qX19fX19fX19fX19fX19fX19fX19fLS0tLS0tLS0tLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX18qL1xuXG4gICAgdGhpcy5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtdWx0aV9wYXJzZXIgPSBuZXcgUGFyc2VyKCk7IC8vd3JhcHBpbmcgZnVuY3Rpb25zIFBhcnNlclxuICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRlcihodG1sX3NvdXJjZSwgaW5kZW50X2NoYXJhY3RlciwgaW5kZW50X3NpemUsIHdyYXBfbGluZV9sZW5ndGgsIGJyYWNlX3N0eWxlKTsgLy9pbml0aWFsaXplIHN0YXJ0aW5nIHZhbHVlc1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBtdWx0aV9wYXJzZXIuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCA9IHRbMF07XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSA9IHRbMV07XG5cbiAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSA9PT0gJ1RLX0VPRicpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19TVEFSVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5pbmRlbnRfY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtdWx0aV9wYXJzZXIuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCB8fCAhbXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goLzxib2R5KD86LiopPi8pKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdWx0aV9wYXJzZXIuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCB8fCAhbXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goLzxoZWFkKD86LiopPi8pKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU1RZTEUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19TQ1JJUFQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19FTkQnOlxuICAgICAgICAgICAgICAgICAgICAvL1ByaW50IG5ldyBsaW5lIG9ubHkgaWYgdGhlIHRhZyBoYXMgbm8gY29udGVudCBhbmQgaGFzIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIubGFzdF90b2tlbiA9PT0gJ1RLX0NPTlRFTlQnICYmIG11bHRpX3BhcnNlci5sYXN0X3RleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX25hbWUgPSAobXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goL1xcdysvKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9IG11bHRpX3BhcnNlci5vdXRwdXRbbXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGggLSAxXS5tYXRjaCgvKD86PHx7eyMpXFxzKihcXHcrKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXRbMV0gIT09IHRhZ19uYW1lICYmICFtdWx0aV9wYXJzZXIuVXRpbHMuaW5fYXJyYXkodGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0WzFdLCB1bmZvcm1hdHRlZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19TSU5HTEUnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGJlZm9yZSBlbGVtZW50cyB0aGF0IHNob3VsZCByZW1haW4gdW5mb3JtYXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdfY2hlY2sgPSBtdWx0aV9wYXJzZXIudG9rZW5fdGV4dC5tYXRjaCgvXlxccyo8KFthLXotXSspL2kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhZ19jaGVjayB8fCAhbXVsdGlfcGFyc2VyLlV0aWxzLmluX2FycmF5KHRhZ19jaGVja1sxXSwgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX0hBTkRMRUJBUlNfRUxTRSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgaWYgb3BlbmluZyB7eyNpZn19IHRhZyBpcyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZElmT25DdXJyZW50TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IG11bHRpX3BhcnNlci5vdXRwdXQubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5vdXRwdXRbbGFzdENoZWNrZWRPdXRwdXRdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLm91dHB1dFtsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2goL3t7I2lmLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJZk9uQ3VycmVudExpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZElmT25DdXJyZW50TGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19IQU5ETEVCQVJTX0NPTU1FTlQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ1RBRyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX0NPTlRFTlQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ1RBRyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1NUWUxFJzpcbiAgICAgICAgICAgICAgICBjYXNlICdUS19TQ1JJUFQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3RleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iZWF1dGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90eXBlID09PSAnVEtfU0NSSVBUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iZWF1dGlmaWVyID0gdHlwZW9mIGpzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nICYmIGpzX2JlYXV0aWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdHlwZSA9PT0gJ1RLX1NUWUxFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iZWF1dGlmaWVyID0gdHlwZW9mIGNzc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJyAmJiBjc3NfYmVhdXRpZnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcImtlZXBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcInNlcGFyYXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gLW11bHRpX3BhcnNlci5pbmRlbnRfbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IG11bHRpX3BhcnNlci5nZXRfZnVsbF9pbmRlbnQoc2NyaXB0X2luZGVudF9sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2JlYXV0aWZpZXIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhlIEJlYXV0aWZpZXIgaWYgYXZhbGlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENoaWxkX29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lb2wgPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoaWxkX29wdGlvbnMucHJvdG90eXBlID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRfb3B0aW9ucyA9IG5ldyBDaGlsZF9vcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9iZWF1dGlmaWVyKHRleHQucmVwbGFjZSgvXlxccyovLCBpbmRlbnRhdGlvbiksIGNoaWxkX29wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgaW5kZW50IHRoZSBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlID0gdGV4dC5tYXRjaCgvXlxccyovKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2xldmVsID0gd2hpdGUubWF0Y2goL1teXFxuXFxyXSokLylbMF0uc3BsaXQobXVsdGlfcGFyc2VyLmluZGVudF9zdHJpbmcpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlaW5kZW50ID0gbXVsdGlfcGFyc2VyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsIC0gX2xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxzKi8sIGluZGVudGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxccnxcXG4vZywgJ1xcbicgKyByZWluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW5fcmF3KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKHRydWUsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnVEFHJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBiZSBnZXR0aW5nIGhlcmUgYnV0IHdlIGRvbid0IHdhbnQgdG8gZHJvcCBpbnB1dCBvbiB0aGUgZmxvb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBvdXRwdXQgdGhlIHRleHQgYW5kIG1vdmUgb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpX3BhcnNlci5sYXN0X3Rva2VuID0gbXVsdGlfcGFyc2VyLnRva2VuX3R5cGU7XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIubGFzdF90ZXh0ID0gbXVsdGlfcGFyc2VyLnRva2VuX3RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN3ZWV0X2NvZGUgPSBtdWx0aV9wYXJzZXIub3V0cHV0LmpvaW4oJycpLnJlcGxhY2UoL1tcXHJcXG5cXHQgXSskLywgJycpO1xuXG4gICAgICAgIC8vIGVzdGFibGlzaCBlbmRfd2l0aF9uZXdsaW5lXG4gICAgICAgIGlmIChlbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dlZXRfY29kZTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoganNoaW50IGN1cmx5OiBmYWxzZSAqL1xuLy8gVGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBwZXJtaXQgJCAoMzYpIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzYgfHwgY29kZSA9PT0gNjQ7XG4gICAgLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgLy8gcGVybWl0IF8gKDk1KS5cbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIG1lcmdlT3B0cyhhbGxPcHRpb25zLCB0YXJnZXRUeXBlKSB7XG4gICAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICAgIHZhciBuYW1lO1xuXG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhcmdldFR5cGUpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIHRhcmdldFR5cGVcbiAgICBpZiAodGFyZ2V0VHlwZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW3RhcmdldFR5cGVdKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW3RhcmdldFR5cGVdW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IG1lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG52YXIgQmVhdXRpZmllciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQmVhdXRpZmllcjtcblxuZnVuY3Rpb24gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpO1xuICAgIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIHN0eWxlX2h0bWwgPSBsZWdhY3lfYmVhdXRpZnlfaHRtbDtcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCIuL2JlYXV0aWZ5XCIsIFwiLi9iZWF1dGlmeS1jc3NcIl0sIGZ1bmN0aW9uKHJlcXVpcmVhbWQpIHtcbiAgICAgICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnlcIik7XG4gICAgICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlYW1kKFwiLi9iZWF1dGlmeS1jc3NcIik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGh0bWxfYmVhdXRpZnk6IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmh0bWxfYmVhdXRpZnlgLlxuICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnkuanMnKTtcbiAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9iZWF1dGlmeS1jc3MuanMnKTtcblxuICAgIGV4cG9ydHMuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCB3aW5kb3cuanNfYmVhdXRpZnksIHdpbmRvdy5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGdsb2JhbC5qc19iZWF1dGlmeSwgZ2xvYmFsLmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn1cblxufSgpKTtcbiIsIi8qanNoaW50IGN1cmx5OmZhbHNlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKiBzZWUganMvc3JjL2phdmFzY3JpcHQvaW5kZXguanMgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4gSlMgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cblxuICBXcml0dGVuIGJ5IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGpzYmVhdXRpZmllci5vcmc+XG4gICAgICBodHRwOi8vanNiZWF1dGlmaWVyLm9yZy9cblxuICBPcmlnaW5hbGx5IGNvbnZlcnRlZCB0byBqYXZhc2NyaXB0IGJ5IFZpdGFsLCA8dml0YWw3NkBnbWFpbC5jb20+XG4gIFwiRW5kIGJyYWNlcyBvbiBvd24gbGluZVwiIGFkZGVkIGJ5IENocmlzIEouIFNodWxsLCA8Y2hyaXNqc2h1bGxAZ21haWwuY29tPlxuICBQYXJzaW5nIGltcHJvdmVtZW50cyBmb3IgYnJhY2UtbGVzcyBzdGF0ZW1lbnRzIGJ5IExpYW0gTmV3bWFuIDxiaXR3aXNlbWFuQGdtYWlsLmNvbT5cblxuXG4gIFVzYWdlOlxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0KTtcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9zaXplIChkZWZhdWx0IDQpICAgICAgICAgIC0gaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICAtIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3Mgc2hvdWxkIGJlIHByZXNlcnZlZCxcbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmssXG5cbiAgICBqc2xpbnRfaGFwcHkgKGRlZmF1bHQgZmFsc2UpIC0gaWYgdHJ1ZSwgdGhlbiBqc2xpbnQtc3RyaWN0ZXIgbW9kZSBpcyBlbmZvcmNlZC5cblxuICAgICAgICAgICAganNsaW50X2hhcHB5ICAgICAgICAhanNsaW50X2hhcHB5XG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpICAgICAgICAgZnVuY3Rpb24oKVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCkgeyAgICAgICAgIHN3aXRjaCgpIHtcbiAgICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24ncyBwYXJlbnMgYmUgYWRkZWQsIFwiZnVuY3Rpb24oKVwiIHZzIFwiZnVuY3Rpb24gKClcIixcbiAgICAgICAgICBOT1RFOiBUaGlzIG9wdGlvbiBpcyBvdmVycmlkZW4gYnkganNsaW50X2hhcHB5IChpLmUuIGlmIGpzbGludF9oYXBweSBpcyB0cnVlLCBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIGlzIHRydWUgYnkgZGVzaWduKVxuXG4gICAgYnJhY2Vfc3R5bGUgKGRlZmF1bHQgXCJjb2xsYXBzZVwiKSAtIFwiY29sbGFwc2VcIiB8IFwiZXhwYW5kXCIgfCBcImVuZC1leHBhbmRcIiB8IFwibm9uZVwiIHwgYW55IG9mIHRoZSBmb3JtZXIgKyBcIixwcmVzZXJ2ZS1pbmxpbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICAgICAgICAgIHByZXNlcnZlLWlubGluZSB3aWxsIHRyeSB0byBwcmVzZXJ2ZSBpbmxpbmUgYmxvY2tzIG9mIGN1cmx5IGJyYWNlc1xuXG4gICAgc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsIChkZWZhdWx0IHRydWUpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgY29uZGl0aW9uYWwgc3RhdGVtZW50IGJlIGFkZGVkLCBcImlmKHRydWUpXCIgdnMgXCJpZiAodHJ1ZSlcIixcblxuICAgIHVuZXNjYXBlX3N0cmluZ3MgKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHByaW50YWJsZSBjaGFyYWN0ZXJzIGluIHN0cmluZ3MgZW5jb2RlZCBpbiBcXHhOTiBub3RhdGlvbiBiZSB1bmVzY2FwZWQsIFwiZXhhbXBsZVwiIHZzIFwiXFx4NjVcXHg3OFxceDYxXFx4NmRcXHg3MFxceDZjXFx4NjVcIlxuXG4gICAgd3JhcF9saW5lX2xlbmd0aCAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbGluZXMgc2hvdWxkIHdyYXAgYXQgbmV4dCBvcHBvcnR1bml0eSBhZnRlciB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgIE5PVEU6IFRoaXMgaXMgbm90IGEgaGFyZCBsaW1pdC4gTGluZXMgd2lsbCBjb250aW51ZSB1bnRpbCBhIHBvaW50IHdoZXJlIGEgbmV3bGluZSB3b3VsZFxuICAgICAgICAgICAgICAgIGJlIHByZXNlcnZlZCBpZiBpdCB3ZXJlIHByZXNlbnQuXG5cbiAgICBlbmRfd2l0aF9uZXdsaW5lIChkZWZhdWx0IGZhbHNlKSAgLSBlbmQgb3V0cHV0IHdpdGggYSBuZXdsaW5lXG5cblxuICAgIGUuZ1xuXG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0J1xuICAgIH0pO1xuXG4qL1xuXG4oZnVuY3Rpb24oKSB7XG52YXIgbGVnYWN5X2JlYXV0aWZ5X2pzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBqc2hpbnQgY3VybHk6IGZhbHNlICovXG4vLyBUaGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIHBlcm1pdCAkICgzNikgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNiB8fCBjb2RlID09PSA2NDtcbiAgICAvLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBwZXJtaXQgXyAoOTUpLlxuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAvLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNyBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgIFNPRlRXQVJFLlxuKi9cblxudmFyIG1lcmdlT3B0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMykubWVyZ2VPcHRzO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBPdXRwdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLk91dHB1dDtcbnZhciBUb2tlbml6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLlRva2VuaXplcjtcblxuZnVuY3Rpb24gcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihvdXRwdXQsIGZyYW1lKSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBlZmZlY3RpdmUgYnV0IGhhcyBzb21lIGlzc3VlczpcbiAgICAvLyAgICAgLSBjYW4gY2F1c2UgbGluZSB3cmFwIHRvIGhhcHBlbiB0b28gc29vbiBkdWUgdG8gaW5kZW50IHJlbW92YWxcbiAgICAvLyAgICAgICAgICAgYWZ0ZXIgd3JhcCBwb2ludHMgYXJlIGNhbGN1bGF0ZWRcbiAgICAvLyBUaGVzZSBpc3N1ZXMgYXJlIG1pbm9yIGNvbXBhcmVkIHRvIHVnbHkgaW5kZW50YXRpb24uXG5cbiAgICBpZiAoZnJhbWUubXVsdGlsaW5lX2ZyYW1lIHx8XG4gICAgICAgIGZyYW1lLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHxcbiAgICAgICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG9uZSBpbmRlbnQgZnJvbSBlYWNoIGxpbmUgaW5zaWRlIHRoaXMgc2VjdGlvblxuICAgIHZhciBzdGFydF9pbmRleCA9IGZyYW1lLnN0YXJ0X2xpbmVfaW5kZXg7XG5cbiAgICBvdXRwdXQucmVtb3ZlX2luZGVudChzdGFydF9pbmRleCk7XG59XG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IHdoYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccysvZywgJycpO1xufVxuXG4vLyBmdW5jdGlvbiBydHJpbShzKSB7XG4vLyAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxzKyQvZywgJycpO1xuLy8gfVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFwRnJvbVN0cmluZ3MobGlzdCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGxpc3QubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgbWFwcGVkIG5hbWVzIHVuZGVyc2NvcmVkIGluc3RlYWQgb2YgZGFzaFxuICAgICAgICByZXN1bHRbbGlzdFt4XS5yZXBsYWNlKC8tL2csICdfJyldID0gbGlzdFt4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVPcGVyYXRvclBvc2l0aW9uKG9wUG9zaXRpb24pIHtcbiAgICBvcFBvc2l0aW9uID0gb3BQb3NpdGlvbiB8fCBPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZTtcblxuICAgIGlmICghaW5fYXJyYXkob3BQb3NpdGlvbiwgdmFsaWRQb3NpdGlvblZhbHVlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ29wZXJhdG9yX3Bvc2l0aW9uJyBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlc1xcblwiICtcbiAgICAgICAgICAgIHZhbGlkUG9zaXRpb25WYWx1ZXMgK1xuICAgICAgICAgICAgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyBvcFBvc2l0aW9uICsgXCInXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBvcFBvc2l0aW9uO1xufVxuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbi8vIEdlbmVyYXRlIG1hcCBmcm9tIGFycmF5XG52YXIgT1BFUkFUT1JfUE9TSVRJT04gPSBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKHZhbGlkUG9zaXRpb25WYWx1ZXMpO1xuXG52YXIgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFID0gW09QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lLCBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lXTtcblxudmFyIE1PREUgPSB7XG4gICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsIC8vICdCTE9DSydcbiAgICBTdGF0ZW1lbnQ6ICdTdGF0ZW1lbnQnLCAvLyAnU1RBVEVNRU5UJ1xuICAgIE9iamVjdExpdGVyYWw6ICdPYmplY3RMaXRlcmFsJywgLy8gJ09CSkVDVCcsXG4gICAgQXJyYXlMaXRlcmFsOiAnQXJyYXlMaXRlcmFsJywgLy8nW0VYUFJFU1NJT05dJyxcbiAgICBGb3JJbml0aWFsaXplcjogJ0ZvckluaXRpYWxpemVyJywgLy8nKEZPUi1FWFBSRVNTSU9OKScsXG4gICAgQ29uZGl0aW9uYWw6ICdDb25kaXRpb25hbCcsIC8vJyhDT05ELUVYUFJFU1NJT04pJyxcbiAgICBFeHByZXNzaW9uOiAnRXhwcmVzc2lvbicgLy8nKEVYUFJFU1NJT04pJ1xufTtcblxuZnVuY3Rpb24gQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBvdXRwdXQ7XG4gICAgdmFyIHRva2VucyA9IFtdLFxuICAgICAgICB0b2tlbl9wb3M7XG4gICAgdmFyIHRva2VuaXplcjtcbiAgICB2YXIgY3VycmVudF90b2tlbjtcbiAgICB2YXIgbGFzdF90eXBlLCBsYXN0X2xhc3RfdGV4dCwgaW5kZW50X3N0cmluZztcbiAgICB2YXIgZmxhZ3MsIHByZXZpb3VzX2ZsYWdzLCBmbGFnX3N0b3JlO1xuICAgIHZhciBwcmVmaXg7XG5cbiAgICB2YXIgaGFuZGxlcnMsIG9wdDtcbiAgICB2YXIgYmFzZUluZGVudFN0cmluZyA9ICcnO1xuXG4gICAgaGFuZGxlcnMgPSB7XG4gICAgICAgICdUS19TVEFSVF9FWFBSJzogaGFuZGxlX3N0YXJ0X2V4cHIsXG4gICAgICAgICdUS19FTkRfRVhQUic6IGhhbmRsZV9lbmRfZXhwcixcbiAgICAgICAgJ1RLX1NUQVJUX0JMT0NLJzogaGFuZGxlX3N0YXJ0X2Jsb2NrLFxuICAgICAgICAnVEtfRU5EX0JMT0NLJzogaGFuZGxlX2VuZF9ibG9jayxcbiAgICAgICAgJ1RLX1dPUkQnOiBoYW5kbGVfd29yZCxcbiAgICAgICAgJ1RLX1JFU0VSVkVEJzogaGFuZGxlX3dvcmQsXG4gICAgICAgICdUS19TRU1JQ09MT04nOiBoYW5kbGVfc2VtaWNvbG9uLFxuICAgICAgICAnVEtfU1RSSU5HJzogaGFuZGxlX3N0cmluZyxcbiAgICAgICAgJ1RLX0VRVUFMUyc6IGhhbmRsZV9lcXVhbHMsXG4gICAgICAgICdUS19PUEVSQVRPUic6IGhhbmRsZV9vcGVyYXRvcixcbiAgICAgICAgJ1RLX0NPTU1BJzogaGFuZGxlX2NvbW1hLFxuICAgICAgICAnVEtfQkxPQ0tfQ09NTUVOVCc6IGhhbmRsZV9ibG9ja19jb21tZW50LFxuICAgICAgICAnVEtfQ09NTUVOVCc6IGhhbmRsZV9jb21tZW50LFxuICAgICAgICAnVEtfRE9UJzogaGFuZGxlX2RvdCxcbiAgICAgICAgJ1RLX1VOS05PV04nOiBoYW5kbGVfdW5rbm93bixcbiAgICAgICAgJ1RLX0VPRic6IGhhbmRsZV9lb2ZcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlX2ZsYWdzKGZsYWdzX2Jhc2UsIG1vZGUpIHtcbiAgICAgICAgdmFyIG5leHRfaW5kZW50X2xldmVsID0gMDtcbiAgICAgICAgaWYgKGZsYWdzX2Jhc2UpIHtcbiAgICAgICAgICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5pbmRlbnRhdGlvbl9sZXZlbDtcbiAgICAgICAgICAgIGlmICghb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA+IG5leHRfaW5kZW50X2xldmVsKSB7XG4gICAgICAgICAgICAgICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRfZmxhZ3MgPSB7XG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgcGFyZW50OiBmbGFnc19iYXNlLFxuICAgICAgICAgICAgbGFzdF90ZXh0OiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3RleHQgOiAnJywgLy8gbGFzdCB0b2tlbiB0ZXh0XG4gICAgICAgICAgICBsYXN0X3dvcmQ6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3Rfd29yZCA6ICcnLCAvLyBsYXN0ICdUS19XT1JEJyBwYXNzZWRcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uX3N0YXRlbWVudDogZmFsc2UsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbl9hc3NpZ25tZW50OiBmYWxzZSxcbiAgICAgICAgICAgIG11bHRpbGluZV9mcmFtZTogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVfZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgaWZfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZWxzZV9ibG9jazogZmFsc2UsXG4gICAgICAgICAgICBkb19ibG9jazogZmFsc2UsXG4gICAgICAgICAgICBkb193aGlsZTogZmFsc2UsXG4gICAgICAgICAgICBpbXBvcnRfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgaW5fY2FzZV9zdGF0ZW1lbnQ6IGZhbHNlLCAvLyBzd2l0Y2goLi4peyBJTlNJREUgSEVSRSB9XG4gICAgICAgICAgICBpbl9jYXNlOiBmYWxzZSwgLy8gd2UncmUgb24gdGhlIGV4YWN0IGxpbmUgd2l0aCBcImNhc2UgMDpcIlxuICAgICAgICAgICAgY2FzZV9ib2R5OiBmYWxzZSwgLy8gdGhlIGluZGVudGVkIGNhc2UtYWN0aW9uIGJsb2NrXG4gICAgICAgICAgICBpbmRlbnRhdGlvbl9sZXZlbDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgICAgICAgICBsaW5lX2luZGVudF9sZXZlbDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgOiBuZXh0X2luZGVudF9sZXZlbCxcbiAgICAgICAgICAgIHN0YXJ0X2xpbmVfaW5kZXg6IG91dHB1dC5nZXRfbGluZV9udW1iZXIoKSxcbiAgICAgICAgICAgIHRlcm5hcnlfZGVwdGg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5leHRfZmxhZ3M7XG4gICAgfVxuXG4gICAgLy8gU29tZSBpbnRlcnByZXRlcnMgaGF2ZSB1bmV4cGVjdGVkIHJlc3VsdHMgd2l0aCBmb28gPSBiYXogfHwgYmFyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgICBvcHRpb25zID0gbWVyZ2VPcHRzKG9wdGlvbnMsICdqcycpO1xuXG4gICAgb3B0ID0ge307XG5cbiAgICAvLyBjb21wYXRpYmlsaXR5LCByZVxuICAgIGlmIChvcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZC1zdHJpY3RcIikgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgICAgIG9wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImV4cGFuZFwiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJjb2xsYXBzZS1wcmVzZXJ2ZS1pbmxpbmVcIikgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgICAgIG9wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlLHByZXNlcnZlLWlubGluZVwiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgIT09IHVuZGVmaW5lZCkgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgICAgIG9wdGlvbnMuYnJhY2Vfc3R5bGUgPSBvcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSA/IFwiZXhwYW5kXCIgOiBcImNvbGxhcHNlXCI7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5icmFjZV9zdHlsZSkgLy9Ob3RoaW5nIGV4aXN0cyB0byBzZXQgaXRcbiAgICB7XG4gICAgICAgIG9wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG4gICAgfVxuXG5cbiAgICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSBvcHRpb25zLmJyYWNlX3N0eWxlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC1dKy8pO1xuICAgIG9wdC5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlX3NwbGl0WzBdO1xuICAgIG9wdC5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgPSBicmFjZV9zdHlsZV9zcGxpdFsxXSA/IGJyYWNlX3N0eWxlX3NwbGl0WzFdIDogZmFsc2U7XG5cbiAgICBvcHQuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplID8gcGFyc2VJbnQob3B0aW9ucy5pbmRlbnRfc2l6ZSwgMTApIDogNDtcbiAgICBvcHQuaW5kZW50X2NoYXIgPSBvcHRpb25zLmluZGVudF9jaGFyID8gb3B0aW9ucy5pbmRlbnRfY2hhciA6ICcgJztcbiAgICBvcHQuZW9sID0gb3B0aW9ucy5lb2wgPyBvcHRpb25zLmVvbCA6ICdhdXRvJztcbiAgICBvcHQucHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuICAgIG9wdC51bmluZGVudF9jaGFpbmVkX21ldGhvZHMgPSAob3B0aW9ucy51bmluZGVudF9jaGFpbmVkX21ldGhvZHMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzO1xuICAgIG9wdC5icmVha19jaGFpbmVkX21ldGhvZHMgPSAob3B0aW9ucy5icmVha19jaGFpbmVkX21ldGhvZHMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzO1xuICAgIG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSAob3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyAwIDogcGFyc2VJbnQob3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMsIDEwKTtcbiAgICBvcHQuc3BhY2VfaW5fcGFyZW4gPSAob3B0aW9ucy5zcGFjZV9pbl9wYXJlbiA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5zcGFjZV9pbl9wYXJlbjtcbiAgICBvcHQuc3BhY2VfaW5fZW1wdHlfcGFyZW4gPSAob3B0aW9ucy5zcGFjZV9pbl9lbXB0eV9wYXJlbiA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5zcGFjZV9pbl9lbXB0eV9wYXJlbjtcbiAgICBvcHQuanNsaW50X2hhcHB5ID0gKG9wdGlvbnMuanNsaW50X2hhcHB5ID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmpzbGludF9oYXBweTtcbiAgICBvcHQuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9IChvcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbjtcbiAgICBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IChvcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbjtcbiAgICBvcHQuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsID0gKG9wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgIG9wdC51bmVzY2FwZV9zdHJpbmdzID0gKG9wdGlvbnMudW5lc2NhcGVfc3RyaW5ncyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy51bmVzY2FwZV9zdHJpbmdzO1xuICAgIG9wdC53cmFwX2xpbmVfbGVuZ3RoID0gKG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCA9PT0gdW5kZWZpbmVkKSA/IDAgOiBwYXJzZUludChvcHRpb25zLndyYXBfbGluZV9sZW5ndGgsIDEwKTtcbiAgICBvcHQuZTR4ID0gKG9wdGlvbnMuZTR4ID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBvcHRpb25zLmU0eDtcbiAgICBvcHQuZW5kX3dpdGhfbmV3bGluZSA9IChvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgICBvcHQuY29tbWFfZmlyc3QgPSAob3B0aW9ucy5jb21tYV9maXJzdCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy5jb21tYV9maXJzdDtcbiAgICBvcHQub3BlcmF0b3JfcG9zaXRpb24gPSBzYW5pdGl6ZU9wZXJhdG9yUG9zaXRpb24ob3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbik7XG5cbiAgICAvLyBGb3IgdGVzdGluZyBvZiBiZWF1dGlmeSBpZ25vcmU6c3RhcnQgZGlyZWN0aXZlXG4gICAgb3B0LnRlc3Rfb3V0cHV0X3JhdyA9IChvcHRpb25zLnRlc3Rfb3V0cHV0X3JhdyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG5cbiAgICAvLyBmb3JjZSBvcHQuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiB0byB0cnVlIGlmIG9wdC5qc2xpbnRfaGFwcHlcbiAgICBpZiAob3B0LmpzbGludF9oYXBweSkge1xuICAgICAgICBvcHQuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgICAgICBvcHQuaW5kZW50X2NoYXIgPSAnXFx0JztcbiAgICAgICAgb3B0LmluZGVudF9zaXplID0gMTtcbiAgICB9XG5cbiAgICBpZiAob3B0LmVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIG9wdC5lb2wgPSAnXFxuJztcbiAgICAgICAgaWYgKGpzX3NvdXJjZV90ZXh0ICYmIGFjb3JuLmxpbmVCcmVhay50ZXN0KGpzX3NvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgICAgICAgb3B0LmVvbCA9IGpzX3NvdXJjZV90ZXh0Lm1hdGNoKGFjb3JuLmxpbmVCcmVhaylbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcHQuZW9sID0gb3B0LmVvbC5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGluZGVudF9zdHJpbmcgPSAnJztcbiAgICB3aGlsZSAob3B0LmluZGVudF9zaXplID4gMCkge1xuICAgICAgICBpbmRlbnRfc3RyaW5nICs9IG9wdC5pbmRlbnRfY2hhcjtcbiAgICAgICAgb3B0LmluZGVudF9zaXplIC09IDE7XG4gICAgfVxuXG4gICAgdmFyIHByZWluZGVudF9pbmRleCA9IDA7XG4gICAgaWYgKGpzX3NvdXJjZV90ZXh0ICYmIGpzX3NvdXJjZV90ZXh0Lmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAoKGpzX3NvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpID09PSAnICcgfHxcbiAgICAgICAgICAgICAgICBqc19zb3VyY2VfdGV4dC5jaGFyQXQocHJlaW5kZW50X2luZGV4KSA9PT0gJ1xcdCcpKSB7XG4gICAgICAgICAgICBwcmVpbmRlbnRfaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlSW5kZW50U3RyaW5nID0ganNfc291cmNlX3RleHQuc3Vic3RyaW5nKDAsIHByZWluZGVudF9pbmRleCk7XG4gICAgICAgIGpzX3NvdXJjZV90ZXh0ID0ganNfc291cmNlX3RleHQuc3Vic3RyaW5nKHByZWluZGVudF9pbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdF90eXBlID0gJ1RLX1NUQVJUX0JMT0NLJzsgLy8gbGFzdCB0b2tlbiB0eXBlXG4gICAgbGFzdF9sYXN0X3RleHQgPSAnJzsgLy8gcHJlLWxhc3QgdG9rZW4gdGV4dFxuICAgIG91dHB1dCA9IG5ldyBPdXRwdXQoaW5kZW50X3N0cmluZywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgICAvLyBJZiB0ZXN0aW5nIHRoZSBpZ25vcmUgZGlyZWN0aXZlLCBzdGFydCB3aXRoIG91dHB1dCBkaXNhYmxlIHNldCB0byB0cnVlXG4gICAgb3V0cHV0LnJhdyA9IG9wdC50ZXN0X291dHB1dF9yYXc7XG5cblxuICAgIC8vIFN0YWNrIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBzdGF0ZXMsIGluY2x1ZGluZyBNT0RFLlxuICAgIC8vIFdlIHRva2VuaXplLCBwYXJzZSwgYW5kIG91dHB1dCBpbiBhbiBhbG1vc3QgcHVyZWx5IGEgZm9yd2FyZC1vbmx5IHN0cmVhbSBvZiB0b2tlbiBpbnB1dFxuICAgIC8vIGFuZCBmb3JtYXR0ZWQgb3V0cHV0LiAgVGhpcyBtYWtlcyB0aGUgYmVhdXRpZmllciBsZXNzIGFjY3VyYXRlIHRoYW4gZnVsbCBwYXJzZXJzXG4gICAgLy8gYnV0IGFsc28gZmFyIG1vcmUgdG9sZXJhbnQgb2Ygc3ludGF4IGVycm9ycy5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBtb2RlIGlzIE1PREUuQmxvY2tTdGF0ZW1lbnQuIElmIHdlIHNlZSBhICd7JyB3ZSBwdXNoIGEgbmV3IGZyYW1lIG9mIHR5cGVcbiAgICAvLyBNT0RFLkJsb2NrU3RhdGVtZW50IG9uIHRoZSB0aGUgc3RhY2ssIGV2ZW4gdGhvdWdoIGl0IGNvdWxkIGJlIG9iamVjdCBsaXRlcmFsLiAgSWYgd2UgbGF0ZXJcbiAgICAvLyBlbmNvdW50ZXIgYSBcIjpcIiwgd2UnbGwgc3dpdGNoIHRvIHRvIE1PREUuT2JqZWN0TGl0ZXJhbC4gIElmIHdlIHRoZW4gc2VlIGEgXCI7XCIsXG4gICAgLy8gbW9zdCBmdWxsIHBhcnNlcnMgd291bGQgZGllLCBidXQgdGhlIGJlYXV0aWZpZXIgZ3JhY2VmdWxseSBmYWxscyBiYWNrIHRvXG4gICAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBhbmQgY29udGludWVzIG9uLlxuICAgIGZsYWdfc3RvcmUgPSBbXTtcbiAgICBzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcblxuICAgIHRoaXMuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvKmpzaGludCBvbmV2YXI6dHJ1ZSAqL1xuICAgICAgICB2YXIgc3dlZXRfY29kZTtcbiAgICAgICAgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihqc19zb3VyY2VfdGV4dCwgb3B0LCBpbmRlbnRfc3RyaW5nKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKCk7XG4gICAgICAgIHRva2VuX3BvcyA9IDA7XG5cbiAgICAgICAgY3VycmVudF90b2tlbiA9IGdldF90b2tlbigpO1xuICAgICAgICB3aGlsZSAoY3VycmVudF90b2tlbikge1xuICAgICAgICAgICAgaGFuZGxlcnNbY3VycmVudF90b2tlbi50eXBlXSgpO1xuXG4gICAgICAgICAgICBsYXN0X2xhc3RfdGV4dCA9IGZsYWdzLmxhc3RfdGV4dDtcbiAgICAgICAgICAgIGxhc3RfdHlwZSA9IGN1cnJlbnRfdG9rZW4udHlwZTtcbiAgICAgICAgICAgIGZsYWdzLmxhc3RfdGV4dCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcblxuICAgICAgICAgICAgdG9rZW5fcG9zICs9IDE7XG4gICAgICAgICAgICBjdXJyZW50X3Rva2VuID0gZ2V0X3Rva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2VldF9jb2RlID0gb3V0cHV0LmdldF9jb2RlKG9wdC5lbmRfd2l0aF9uZXdsaW5lLCBvcHQuZW9sKTtcblxuICAgICAgICByZXR1cm4gc3dlZXRfY29kZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGxvY2FsX3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgdmFyIG5ld2xpbmVzID0gbG9jYWxfdG9rZW4ubmV3bGluZXM7XG4gICAgICAgIHZhciBrZWVwX3doaXRlc3BhY2UgPSBvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJiBpc19hcnJheShmbGFncy5tb2RlKTtcbiAgICAgICAgdmFyIHRlbXBfdG9rZW4gPSBjdXJyZW50X3Rva2VuO1xuXG4gICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgbG9jYWxfdG9rZW4uY29tbWVudHNfYmVmb3JlLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgICAvLyBUaGUgY2xlYW5lc3QgaGFuZGxpbmcgb2YgaW5saW5lIGNvbW1lbnRzIGlzIHRvIHRyZWF0IHRoZW0gYXMgdGhvdWdoIHRoZXkgYXJlbid0IHRoZXJlLlxuICAgICAgICAgICAgLy8gSnVzdCBjb250aW51ZSBmb3JtYXR0aW5nIGFuZCB0aGUgYmVoYXZpb3Igc2hvdWxkIGJlIGxvZ2ljYWwuXG4gICAgICAgICAgICAvLyBBbHNvIGlnbm9yZSB1bmtub3duIHRva2Vucy4gIEFnYWluLCB0aGlzIHNob3VsZCByZXN1bHQgaW4gYmV0dGVyIGJlaGF2aW9yLlxuICAgICAgICAgICAgY3VycmVudF90b2tlbiA9IGxvY2FsX3Rva2VuLmNvbW1lbnRzX2JlZm9yZVtoXTtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgaGFuZGxlcnNbY3VycmVudF90b2tlbi50eXBlXShwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRfdG9rZW4gPSB0ZW1wX3Rva2VuO1xuXG4gICAgICAgIGlmIChrZWVwX3doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3bGluZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoaSA+IDAsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0Lm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBuZXdsaW5lcyA+IG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdsaW5lcyA9IG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHQucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxfdG9rZW4ubmV3bGluZXMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgbmV3bGluZXM7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSh0cnVlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB3ZSBjb3VsZCB1c2UganVzdCBzdHJpbmcuc3BsaXQsIGJ1dFxuICAgIC8vIElFIGRvZXNuJ3QgbGlrZSByZXR1cm5pbmcgZW1wdHkgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIHNwbGl0X2xpbmVicmVha3Mocykge1xuICAgICAgICAvL3JldHVybiBzLnNwbGl0KC9cXHgwZFxceDBhfFxceDBhLyk7XG5cbiAgICAgICAgcyA9IHMucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICAgIHZhciBvdXQgPSBbXSxcbiAgICAgICAgICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgd2hpbGUgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHMuc3Vic3RyaW5nKDAsIGlkeCkpO1xuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGlkeCArIDEpO1xuICAgICAgICAgICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0LnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICB2YXIgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucyA9IFsnYnJlYWsnLCAnY29udGludWUnLCAncmV0dXJuJywgJ3Rocm93JywgJ3lpZWxkJ107XG5cbiAgICBmdW5jdGlvbiBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGZvcmNlX2xpbmV3cmFwKSB7XG4gICAgICAgIGZvcmNlX2xpbmV3cmFwID0gKGZvcmNlX2xpbmV3cmFwID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBmb3JjZV9saW5ld3JhcDtcblxuICAgICAgICAvLyBOZXZlciB3cmFwIHRoZSBmaXJzdCB0b2tlbiBvbiBhIGxpbmVcbiAgICAgICAgaWYgKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZFByZXNlcnZlT3JGb3JjZSA9IChvcHQucHJlc2VydmVfbmV3bGluZXMgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkgfHwgZm9yY2VfbGluZXdyYXA7XG4gICAgICAgIHZhciBvcGVyYXRvckxvZ2ljQXBwbGllcyA9IGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpIHx8IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xuXG4gICAgICAgIGlmIChvcGVyYXRvckxvZ2ljQXBwbGllcykge1xuICAgICAgICAgICAgdmFyIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lID0gKFxuICAgICAgICAgICAgICAgICAgICBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbl9hcnJheShvcHQub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSlcbiAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG4gICAgICAgICAgICBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgJiYgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUHJlc2VydmVPckZvcmNlKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdG9rZW5zIHNob3VsZCBuZXZlciBoYXZlIGEgbmV3bGluZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlbSBhbmQgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wb3NlZF9saW5lX2xlbmd0aCA9IG91dHB1dC5jdXJyZW50X2xpbmUuZ2V0X2NoYXJhY3Rlcl9jb3VudCgpICsgY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCArXG4gICAgICAgICAgICAgICAgKG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAocHJvcG9zZWRfbGluZV9sZW5ndGggPj0gb3B0LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50X25ld2xpbmUoZm9yY2VfbmV3bGluZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIGlmICghcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MubGFzdF90ZXh0ICE9PSAnOycgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnLCcgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnPScgJiYgbGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBnZXRfdG9rZW4oMSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICEoZmxhZ3MuaWZfYmxvY2sgJiYgbmV4dF90b2tlbiAmJiBuZXh0X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnZWxzZScpICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5kb19ibG9jaykge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0cHV0LmFkZF9uZXdfbGluZShmb3JjZV9uZXdsaW5lKSkge1xuICAgICAgICAgICAgZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oKSB7XG4gICAgICAgIGlmIChvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJiBpc19hcnJheShmbGFncy5tb2RlKSAmJiBjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmN1cnJlbnRfbGluZS5wdXNoKGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnNldF9pbmRlbnQoZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MubGluZV9pbmRlbnRfbGV2ZWwgPSBmbGFncy5pbmRlbnRhdGlvbl9sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50X3Rva2VuKHByaW50YWJsZV90b2tlbikge1xuICAgICAgICBpZiAob3V0cHV0LnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0LmNvbW1hX2ZpcnN0ICYmIGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJyAmJlxuICAgICAgICAgICAgb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LnByZXZpb3VzX2xpbmUubGFzdCgpID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9wcGVkID0gb3V0cHV0LnByZXZpb3VzX2xpbmUucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbW1hIHdhcyBhbHJlYWR5IGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZSxcbiAgICAgICAgICAgICAgICAvLyBwdWxsIGJhY2sgb250byB0aGF0IGxpbmUgYW5kIHJlcHJpbnQgdGhlIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByZXZpb3VzX2xpbmUucHVzaChwb3BwZWQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNvbW1hIGluIGZyb250IG9mIHRoZSBuZXh0IHRva2VuXG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfdG9rZW4oJywnKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50YWJsZV90b2tlbiA9IHByaW50YWJsZV90b2tlbiB8fCBjdXJyZW50X3Rva2VuLnRleHQ7XG4gICAgICAgIHByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oKTtcbiAgICAgICAgb3V0cHV0LmFkZF90b2tlbihwcmludGFibGVfdG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGVudCgpIHtcbiAgICAgICAgZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgKz0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWluZGVudCgpIHtcbiAgICAgICAgaWYgKGZsYWdzLmluZGVudGF0aW9uX2xldmVsID4gMCAmJlxuICAgICAgICAgICAgKCghZmxhZ3MucGFyZW50KSB8fCBmbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IGZsYWdzLnBhcmVudC5pbmRlbnRhdGlvbl9sZXZlbCkpIHtcbiAgICAgICAgICAgIGZsYWdzLmluZGVudGF0aW9uX2xldmVsIC09IDE7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldF9tb2RlKG1vZGUpIHtcbiAgICAgICAgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgICBmbGFnX3N0b3JlLnB1c2goZmxhZ3MpO1xuICAgICAgICAgICAgcHJldmlvdXNfZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzID0gY3JlYXRlX2ZsYWdzKG51bGwsIG1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhZ3MgPSBjcmVhdGVfZmxhZ3MocHJldmlvdXNfZmxhZ3MsIG1vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2FycmF5KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGUgPT09IE1PREUuQXJyYXlMaXRlcmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2V4cHJlc3Npb24obW9kZSkge1xuICAgICAgICByZXR1cm4gaW5fYXJyYXkobW9kZSwgW01PREUuRXhwcmVzc2lvbiwgTU9ERS5Gb3JJbml0aWFsaXplciwgTU9ERS5Db25kaXRpb25hbF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc3RvcmVfbW9kZSgpIHtcbiAgICAgICAgaWYgKGZsYWdfc3RvcmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHJldmlvdXNfZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgIGZsYWdzID0gZmxhZ19zdG9yZS5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiAhb3B0LnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBwcmV2aW91c19mbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIChcbiAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICc6JyAmJiBmbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydnZXQnLCAnc2V0J10pKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRfb2Zfc3RhdGVtZW50KCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1dPUkQnKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdkbycpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykgJiYgIWN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGZsYWdzLmxhc3RfdGV4dCA9PT0gJ2Vsc2UnICYmXG4gICAgICAgICAgICAgICAgIShjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnaWYnICYmICFjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGgpKSB8fFxuICAgICAgICAgICAgKGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9FWFBSJyAmJiAocHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fCBwcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSkgfHxcbiAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19XT1JEJyAmJiBmbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmluX2Nhc2UgJiZcbiAgICAgICAgICAgICAgICAhKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpICYmXG4gICAgICAgICAgICAgICAgbGFzdF9sYXN0X3RleHQgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgIT09ICdUS19XT1JEJyAmJiBjdXJyZW50X3Rva2VuLnR5cGUgIT09ICdUS19SRVNFUlZFRCcpIHx8XG4gICAgICAgICAgICAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIChcbiAgICAgICAgICAgICAgICAoZmxhZ3MubGFzdF90ZXh0ID09PSAnOicgJiYgZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZ2V0JywgJ3NldCddKSkpKVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5TdGF0ZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFvcHQudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gSXNzdWUgIzI3NjpcbiAgICAgICAgICAgIC8vIElmIHN0YXJ0aW5nIGEgbmV3IHN0YXRlbWVudCB3aXRoIFtpZiwgZm9yLCB3aGlsZSwgZG9dLCBwdXNoIHRvIGEgbmV3IGxpbmUuXG4gICAgICAgICAgICAvLyBpZiAoYSkgaWYgKGIpIGlmKGMpIGQoKTsgZWxzZSBlKCk7IGVsc2UgZigpO1xuICAgICAgICAgICAgaWYgKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnZG8nLCAnZm9yJywgJ2lmJywgJ3doaWxlJ10pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gdHJpbShsaW5lc1tpXSk7XG4gICAgICAgICAgICBpZiAobGluZS5jaGFyQXQoMCkgIT09IGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaF9saW5lX21hdGNoZXNfaW5kZW50KGxpbmVzLCBpbmRlbnQpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoLFxuICAgICAgICAgICAgbGluZTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgLy8gYWxsb3cgZW1wdHkgbGluZXMgdG8gcGFzcyB0aHJvdWdoXG4gICAgICAgICAgICBpZiAobGluZSAmJiBsaW5lLmluZGV4T2YoaW5kZW50KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19zcGVjaWFsX3dvcmQod29yZCkge1xuICAgICAgICByZXR1cm4gaW5fYXJyYXkod29yZCwgWydjYXNlJywgJ3JldHVybicsICdkbycsICdpZicsICd0aHJvdycsICdlbHNlJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF90b2tlbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdG9rZW5fcG9zICsgKG9mZnNldCB8fCAwKTtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdG9rZW5zLmxlbmd0aCkgPyBudWxsIDogdG9rZW5zW2luZGV4XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc3RhcnRfZXhwcigpIHtcbiAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICBpZiAoIXN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycpIHtcblxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1dPUkQnIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhcnJheSBpbmRleCBzcGVjaWZpZXIsIGJyZWFrIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgLy8gYVt4XSwgZm4oKVt4XVxuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCB0b2tlbml6ZXIubGluZV9zdGFydGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldF9tb2RlKG5leHRfbW9kZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHRfbW9kZSA9IE1PREUuQXJyYXlMaXRlcmFsO1xuICAgICAgICAgICAgaWYgKGlzX2FycmF5KGZsYWdzLm1vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJ1snIHx8XG4gICAgICAgICAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICcsJyAmJiAobGFzdF9sYXN0X3RleHQgPT09ICddJyB8fCBsYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXSwgWyBnb2VzIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIH0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZm9yJykge1xuICAgICAgICAgICAgICAgIG5leHRfbW9kZSA9IE1PREUuRm9ySW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnaWYnLCAnd2hpbGUnXSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkNvbmRpdGlvbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0X21vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MubGFzdF90ZXh0ID09PSAnOycgfHwgbGFzdF90eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX0VORF9CTE9DSycgfHwgZmxhZ3MubGFzdF90ZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHdoZXRoZXIgZm9yY2luZyB0aGlzIGlzIHJlcXVpcmVkLiAgUmV2aWV3IGZhaWxpbmcgdGVzdHMgd2hlbiByZW1vdmVkLlxuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKTtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgb24gKCggYW5kICkoIGFuZCBdWyBhbmQgXSggYW5kIC4oXG4gICAgICAgIH0gZWxzZSBpZiAoIShsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKCcpICYmIGxhc3RfdHlwZSAhPT0gJ1RLX1dPUkQnICYmIGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJykge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiAoZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nIHx8IGZsYWdzLmxhc3Rfd29yZCA9PT0gJ3R5cGVvZicpKSB8fFxuICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgKGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsneycsICcsJ10pKSkpKSB7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbigpIHZzIGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAvLyB5aWVsZCooKSB2cyB5aWVsZCogKClcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uKigpIHZzIGZ1bmN0aW9uKiAoKVxuICAgICAgICAgICAgaWYgKG9wdC5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIChpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSB8fCBmbGFncy5sYXN0X3RleHQgPT09ICdjYXRjaCcpKSB7XG4gICAgICAgICAgICBpZiAob3B0LnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGEgc3BhY2UgYmV0d2VlbiBhd2FpdCBhbmQgYW4gSUlGRSwgb3IgYXN5bmMgYW5kIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcoJyAmJiBsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF93b3JkLCBbJ2F3YWl0JywgJ2FzeW5jJ10pKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQgb2YgdGhpcyBraW5kIG9mIG5ld2xpbmUgcHJlc2VydmF0aW9uLlxuICAgICAgICAvLyBhID0gKGIgJiZcbiAgICAgICAgLy8gICAgIChjIHx8IGQpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJygnKSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfRVFVQUxTJyB8fCBsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0IHByZXNlcnZpbmcgd3JhcHBlZCBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uc1xuICAgICAgICAvLyBhLmIoJ2MnLFxuICAgICAgICAvLyAgICAgKCkgPT4gZC5lXG4gICAgICAgIC8vIClcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJygnICYmIGxhc3RfdHlwZSAhPT0gJ1RLX1dPUkQnICYmIGxhc3RfdHlwZSAhPT0gJ1RLX1JFU0VSVkVEJykge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgaWYgKG9wdC5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBhbGwgY2FzZXMsIGlmIHdlIG5ld2xpbmUgd2hpbGUgaW5zaWRlIGFuIGV4cHJlc3Npb24gaXQgc2hvdWxkIGJlIGluZGVudGVkLlxuICAgICAgICBpbmRlbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZW5kX2V4cHIoKSB7XG4gICAgICAgIC8vIHN0YXRlbWVudHMgaW5zaWRlIGV4cHJlc3Npb25zIGFyZSBub3QgdmFsaWQgc3ludGF4LCBidXQuLi5cbiAgICAgICAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gICAgICAgIHdoaWxlIChmbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgaWYgKGZsYWdzLm11bHRpbGluZV9mcmFtZSkge1xuICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBpc19hcnJheShmbGFncy5tb2RlKSAmJiAhb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdC5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInICYmICFvcHQuc3BhY2VfaW5fZW1wdHlfcGFyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyAoKSBbXSBubyBpbm5lciBzcGFjZSBpbiBlbXB0eSBwYXJlbnMgbGlrZSB0aGVzZSwgZXZlciwgcmVmICMzMjBcbiAgICAgICAgICAgICAgICBvdXRwdXQudHJpbSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ10nICYmIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgcmVzdG9yZV9tb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihvdXRwdXQsIHByZXZpb3VzX2ZsYWdzKTtcblxuICAgICAgICAvLyBkbyB7fSB3aGlsZSAoKSAvLyBubyBzdGF0ZW1lbnQgcmVxdWlyZWQgYWZ0ZXJcbiAgICAgICAgaWYgKGZsYWdzLmRvX3doaWxlICYmIHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgIHByZXZpb3VzX2ZsYWdzLm1vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgICAgICAgICBmbGFncy5kb19ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgZmxhZ3MuZG9fd2hpbGUgPSBmYWxzZTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3N0YXJ0X2Jsb2NrKCkge1xuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIE9iamVjdExpdGVyYWxcbiAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBnZXRfdG9rZW4oMSk7XG4gICAgICAgIHZhciBzZWNvbmRfdG9rZW4gPSBnZXRfdG9rZW4oMik7XG4gICAgICAgIGlmIChzZWNvbmRfdG9rZW4gJiYgKFxuICAgICAgICAgICAgICAgIChpbl9hcnJheShzZWNvbmRfdG9rZW4udGV4dCwgWyc6JywgJywnXSkgJiYgaW5fYXJyYXkobmV4dF90b2tlbi50eXBlLCBbJ1RLX1NUUklORycsICdUS19XT1JEJywgJ1RLX1JFU0VSVkVEJ10pKSB8fFxuICAgICAgICAgICAgICAgIChpbl9hcnJheShuZXh0X3Rva2VuLnRleHQsIFsnZ2V0JywgJ3NldCcsICcuLi4nXSkgJiYgaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnR5cGUsIFsnVEtfV09SRCcsICdUS19SRVNFUlZFRCddKSlcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgVHlwZVNjcmlwdCxidXQgd2UgZGlkbid0IGJyZWFrIGl0IGZvciBhIHZlcnkgbG9uZyB0aW1lLlxuICAgICAgICAgICAgLy8gV2UnbGwgdHJ5IHRvIGtlZXAgbm90IGJyZWFraW5nIGl0LlxuICAgICAgICAgICAgaWYgKCFpbl9hcnJheShsYXN0X2xhc3RfdGV4dCwgWydjbGFzcycsICdpbnRlcmZhY2UnXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnPT4nKSB7XG4gICAgICAgICAgICAvLyBhcnJvdyBmdW5jdGlvbjogKHBhcmFtMSwgcGFyYW1OKSA9PiB7IHN0YXRlbWVudHMgfVxuICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkobGFzdF90eXBlLCBbJ1RLX0VRVUFMUycsICdUS19TVEFSVF9FWFBSJywgJ1RLX0NPTU1BJywgJ1RLX09QRVJBVE9SJ10pIHx8XG4gICAgICAgICAgICAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydyZXR1cm4nLCAndGhyb3cnLCAnaW1wb3J0JywgJ2RlZmF1bHQnXSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIHNob3J0aGFuZCBmdW5jdGlvbiBzeW50YXggaXMgZGlmZmljdWx0IGJ5IHNjYW5uaW5nIGZvcndhcmQsXG4gICAgICAgICAgICAvLyAgICAgc28gY2hlY2sgdGhlIHN1cnJvdW5kaW5nIGNvbnRleHQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYmxvY2sgaXMgYmVpbmcgcmV0dXJuZWQsIGltcG9ydGVkLCBleHBvcnQgZGVmYXVsdCwgcGFzc2VkIGFzIGFyZyxcbiAgICAgICAgICAgIC8vICAgICBhc3NpZ25lZCB3aXRoID0gb3IgYXNzaWduZWQgaW4gYSBuZXN0ZWQgb2JqZWN0LCB0cmVhdCBhcyBhbiBPYmplY3RMaXRlcmFsLlxuICAgICAgICAgICAgc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVtcHR5X2JyYWNlcyA9ICFuZXh0X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5sZW5ndGggJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnfSc7XG4gICAgICAgIHZhciBlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gPSBlbXB0eV9icmFjZXMgJiYgZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUic7XG5cbiAgICAgICAgaWYgKG9wdC5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUpIC8vIGNoZWNrIGZvciBpbmxpbmUsIHNldCBpbmxpbmVfZnJhbWUgaWYgc29cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIGEgbmV3bGluZSB3YW50ZWQgaW5zaWRlIHRoaXMgYmxvY2tcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgY2hlY2tfdG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgZmxhZ3MuaW5saW5lX2ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGNoZWNrX3Rva2VuID0gZ2V0X3Rva2VuKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tfdG9rZW4ud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuaW5saW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGNoZWNrX3Rva2VuLnR5cGUgIT09ICdUS19FT0YnICYmXG4gICAgICAgICAgICAgICAgIShjaGVja190b2tlbi50eXBlID09PSAnVEtfRU5EX0JMT0NLJyAmJiBjaGVja190b2tlbi5vcGVuZWQgPT09IGN1cnJlbnRfdG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgob3B0LmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkpICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlICE9PSAnVEtfT1BFUkFUT1InICYmXG4gICAgICAgICAgICAgICAgKGVtcHR5X2Fub255bW91c19mdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBsYXN0X3R5cGUgPT09ICdUS19FUVVBTFMnIHx8XG4gICAgICAgICAgICAgICAgICAgIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaXNfc3BlY2lhbF93b3JkKGZsYWdzLmxhc3RfdGV4dCkgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnZWxzZScpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gY29sbGFwc2UgfHwgaW5saW5lX2ZyYW1lXG4gICAgICAgICAgICBpZiAoaXNfYXJyYXkocHJldmlvdXNfZmxhZ3MubW9kZSkgJiYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX0NPTU1BJykpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfQ09NTUEnIHx8IG9wdC5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfQ09NTUEnIHx8IChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9FWFBSJyAmJiBmbGFncy5pbmxpbmVfZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lIHx8IGZsYWdzLm11bHRpbGluZV9mcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSAhPT0gJ1RLX09QRVJBVE9SJyAmJiBsYXN0X3R5cGUgIT09ICdUS19TVEFSVF9FWFBSJykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSycgJiYgIWZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIGluZGVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9lbmRfYmxvY2soKSB7XG4gICAgICAgIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICAgICAgICBoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbXB0eV9icmFjZXMgPSBsYXN0X3R5cGUgPT09ICdUS19TVEFSVF9CTE9DSyc7XG5cbiAgICAgICAgaWYgKGZsYWdzLmlubGluZV9mcmFtZSAmJiAhZW1wdHlfYnJhY2VzKSB7IC8vIHRyeSBpbmxpbmVfZnJhbWUgKG9ubHkgc2V0IGlmIG9wdC5icmFjZXMtcHJlc2VydmUtaW5saW5lKSBmaXJzdFxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiKSB7XG4gICAgICAgICAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNraXAge31cbiAgICAgICAgICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2FycmF5KGZsYWdzLm1vZGUpICYmIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIFJFQUxMWSBuZWVkIGEgbmV3bGluZSBoZXJlLCBidXQgbmV3bGluZXIgd291bGQgc2tpcCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfd29yZCgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJykge1xuICAgICAgICAgICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pICYmIGZsYWdzLm1vZGUgIT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9ICdUS19XT1JEJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2FzJywgJ2Zyb20nXSkgJiYgIWZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9ICdUS19XT1JEJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBnZXRfdG9rZW4oMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9ICdUS19XT1JEJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfV09SRCcpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUgJiYgIWlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkgJiZcbiAgICAgICAgICAgIChsYXN0X3R5cGUgIT09ICdUS19PUEVSQVRPUicgfHwgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJy0tJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICcrKycpKSAmJlxuICAgICAgICAgICAgbGFzdF90eXBlICE9PSAnVEtfRVFVQUxTJyAmJlxuICAgICAgICAgICAgKG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCAhKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsndmFyJywgJ2xldCcsICdjb25zdCcsICdzZXQnLCAnZ2V0J10pKSkpIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5kb19ibG9jayAmJiAhZmxhZ3MuZG9fd2hpbGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgY3VycmVudF90b2tlbi50ZXh0ID09PSAnd2hpbGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8ge30gIyMgd2hpbGUgKClcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZsYWdzLmRvX3doaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvIHt9IHNob3VsZCBhbHdheXMgaGF2ZSB3aGlsZSBhcyB0aGUgbmV4dCB3b3JkLlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IHNlZSB0aGUgZXhwZWN0ZWQgd2hpbGUsIHJlY292ZXJcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG1heSBiZSBmb2xsb3dlZCBieSBlbHNlLCBvciBub3RcbiAgICAgICAgLy8gQmFyZS9pbmxpbmUgaWZzIGFyZSB0cmlja3lcbiAgICAgICAgLy8gTmVlZCB0byB1bndpbmQgdGhlIG1vZGVzIGNvcnJlY3RseTogaWYgKGEpIGlmIChiKSBjKCk7IGVsc2UgZCgpOyBlbHNlIGUoKTtcbiAgICAgICAgaWYgKGZsYWdzLmlmX2Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoIWZsYWdzLmVsc2VfYmxvY2sgJiYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdlbHNlJykpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5lbHNlX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbGFncy5pZl9ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZsYWdzLmVsc2VfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2Nhc2UnIHx8IChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdkZWZhdWx0JyAmJiBmbGFncy5pbl9jYXNlX3N0YXRlbWVudCkpKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBpZiAoZmxhZ3MuY2FzZV9ib2R5IHx8IG9wdC5qc2xpbnRfaGFwcHkpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggY2FzZXMgZm9sbG93aW5nIG9uZSBhbm90aGVyXG4gICAgICAgICAgICAgICAgZGVpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBmbGFncy5jYXNlX2JvZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICBmbGFncy5pbl9jYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19DT01NQScgfHwgbGFzdF90eXBlID09PSAnVEtfU1RBUlRfRVhQUicgfHwgbGFzdF90eXBlID09PSAnVEtfRVFVQUxTJyB8fCBsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWyd9JywgJzsnXSkgfHxcbiAgICAgICAgICAgICAgICAob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmICEoaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LCBbJygnLCAnWycsICd7JywgJzonLCAnPScsICcsJ10pIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX09QRVJBVE9SJykpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgbmljZSBjbGVhbiBzcGFjZSBvZiBhdCBsZWFzdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBhIG5ldyBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1dPUkQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnZ2V0JywgJ3NldCcsICduZXcnLCAnZXhwb3J0JywgJ2FzeW5jJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBmbGFncy5sYXN0X3RleHQgPT09ICdkZWZhdWx0JyAmJiBsYXN0X2xhc3RfdGV4dCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InIHx8IGZsYWdzLmxhc3RfdGV4dCA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9vID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiAoaXNfZXhwcmVzc2lvbihmbGFncy5tb2RlKSB8fCBpc19hcnJheShmbGFncy5tb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyAoZnVuY3Rpb25cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlZml4ID0gJ05PTkUnO1xuXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19FTkRfQkxPQ0snKSB7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c19mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5JywgJ2Zyb20nXSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdC5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9wdC5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19TRU1JQ09MT04nICYmIGZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGZvciBTVEFURU1FTlQgYXMgd2VsbD9cbiAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19TRU1JQ09MT04nICYmIGlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfU1RSSU5HJykge1xuICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyB8fCBsYXN0X3R5cGUgPT09ICdUS19XT1JEJyB8fFxuICAgICAgICAgICAgKGZsYWdzLmxhc3RfdGV4dCA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgKGluX2FycmF5KGxhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgIChmbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsIFsneycsICcsJ10pKSkpKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19FTkRfRVhQUicpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSAmJiBmbGFncy5sYXN0X3RleHQgIT09ICcpJykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLmlubGluZV9mcmFtZSB8fCBmbGFncy5sYXN0X3RleHQgPT09ICdlbHNlJyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydlbHNlJywgJ2NhdGNoJywgJ2ZpbmFsbHknXSkpIHtcbiAgICAgICAgICAgIGlmICgoIShsYXN0X3R5cGUgPT09ICdUS19FTkRfQkxPQ0snICYmIHByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdC5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBvcHQuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChvcHQuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpKSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC50cmltKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gb3V0cHV0LmN1cnJlbnRfbGluZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB0cmltbWVkIGFuZCB0aGVyZSdzIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgY2xvc2UgYmxvY2sgYmVmb3JlIHVzXG4gICAgICAgICAgICAgICAgLy8gcHV0IGEgbmV3bGluZSBiYWNrIGluLiAgSGFuZGxlcyAnfSAvLyBjb21tZW50JyBzY2VuYXJpby5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5sYXN0KCkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ05FV0xJTkUnKSB7XG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmV3bGluZSBiZXR3ZWVuICdyZXR1cm4gbm5uJ1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgIT09ICdUS19FTkRfRVhQUicpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxhc3RfdHlwZSAhPT0gJ1RLX1NUQVJUX0VYUFInIHx8ICEoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pKSkgJiYgZmxhZ3MubGFzdF90ZXh0ICE9PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBmb3JjZSBuZXdsaW5lIG9uICd2YXInOiBmb3IgKHZhciB4ID0gMC4uLilcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicgJiYgZmxhZ3MubGFzdF90ZXh0ID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ld2xpbmUgZm9yIH0gZWxzZSBpZiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgdG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpICYmIGZsYWdzLmxhc3RfdGV4dCAhPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiBpc19hcnJheShmbGFncy5tb2RlKSAmJiBmbGFncy5sYXN0X3RleHQgPT09ICcsJyAmJiBsYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7IC8vIH0sIGluIGxpc3RzIGdldCBhIG5ld2xpbmUgdHJlYXRtZW50XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAnU1BBQ0UnKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBmbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2RvJykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmRvX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaWYnKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuaWZfYmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuaW1wb3J0X2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MuaW1wb3J0X2Jsb2NrICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBjdXJyZW50X3Rva2VuLnRleHQgPT09ICdmcm9tJykge1xuICAgICAgICAgICAgICAgIGZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3NlbWljb2xvbigpIHtcbiAgICAgICAgaWYgKHN0YXJ0X29mX3N0YXRlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAvLyBTZW1pY29sb24gY2FuIGJlIHRoZSBzdGFydCAoYW5kIGVuZCkgb2YgYSBzdGF0ZW1lbnRcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICEoZmxhZ3MuaWZfYmxvY2sgJiYgbmV4dF90b2tlbiAmJiBuZXh0X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnZWxzZScpICYmXG4gICAgICAgICAgICAhZmxhZ3MuZG9fYmxvY2spIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFja3kgYnV0IGVmZmVjdGl2ZSBmb3IgdGhlIG1vbWVudFxuICAgICAgICBpZiAoZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgICAgICAgICBmbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcmludF90b2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zdHJpbmcoKSB7XG4gICAgICAgIGlmIChzdGFydF9vZl9zdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgLy8gT25lIGRpZmZlcmVuY2UgLSBzdHJpbmdzIHdhbnQgYXQgbGVhc3QgYSBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyB8fCBsYXN0X3R5cGUgPT09ICdUS19XT1JEJyB8fCBmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfQ09NTUEnIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInIHx8IGxhc3RfdHlwZSA9PT0gJ1RLX0VRVUFMUycgfHwgbGFzdF90eXBlID09PSAnVEtfT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZXF1YWxzKCkge1xuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgZ290IGFuICc9JyBpbiBhIHZhci1saW5lLCBkaWZmZXJlbnQgZm9ybWF0dGluZy9saW5lLWJyZWFraW5nLCBldGMgd2lsbCBub3cgYmUgZG9uZVxuICAgICAgICAgICAgZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9jb21tYSgpIHtcbiAgICAgICAgaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICBpZiAoZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNfZXhwcmVzc2lvbihmbGFncy5wYXJlbnQubW9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYnJlYWsgb24gY29tbWEsIGZvcih2YXIgYSA9IDEsIGIgPSAyKVxuICAgICAgICAgICAgICAgIGZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdC5jb21tYV9maXJzdCkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgICAgICAgICAgICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCB8fFxuICAgICAgICAgICAgKGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIGZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlX21vZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LmNvbW1hX2ZpcnN0KSB7XG4gICAgICAgICAgICAvLyBFWFBSIG9yIERPX0JMT0NLXG4gICAgICAgICAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgICAgICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfb3BlcmF0b3IoKSB7XG4gICAgICAgIHZhciBpc0dlbmVyYXRvckFzdGVyaXNrID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgICAgICAgICgobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSkgfHxcbiAgICAgICAgICAgICAgICAoaW5fYXJyYXkobGFzdF90eXBlLCBbJ1RLX1NUQVJUX0JMT0NLJywgJ1RLX0NPTU1BJywgJ1RLX0VORF9CTE9DSycsICdUS19TRU1JQ09MT04nXSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB2YXIgaXNVbmFyeSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctJywgJysnXSkgJiYgKFxuICAgICAgICAgICAgaW5fYXJyYXkobGFzdF90eXBlLCBbJ1RLX1NUQVJUX0JMT0NLJywgJ1RLX1NUQVJUX0VYUFInLCAnVEtfRVFVQUxTJywgJ1RLX09QRVJBVE9SJ10pIHx8XG4gICAgICAgICAgICBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIHRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSB8fFxuICAgICAgICAgICAgZmxhZ3MubGFzdF90ZXh0ID09PSAnLCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MgPSAhaXNHZW5lcmF0b3JBc3RlcmlzaztcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfdHlwZSA9PT0gJ1RLX1JFU0VSVkVEJyAmJiBpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSkge1xuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiBoYWQgYSBzcGVjaWFsIGhhbmRsaW5nIGluIFRLX1dPUkQuIE5vdyB3ZSBuZWVkIHRvIHJldHVybiB0aGUgZmF2b3JcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhY2sgZm9yIGFjdGlvbnNjcmlwdCdzIGltcG9ydCAuKjtcbiAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyonICYmIGxhc3RfdHlwZSA9PT0gJ1RLX0RPVCcpIHtcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOjonKSB7XG4gICAgICAgICAgICAvLyBubyBzcGFjZXMgYXJvdW5kIGV4b3RpYyBuYW1lc3BhY2luZyBzeW50YXggb3BlcmF0b3JcbiAgICAgICAgICAgIHByaW50X3Rva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBsaW5lIHdyYXBwaW5nIGJldHdlZW4gb3BlcmF0b3JzIHdoZW4gb3BlcmF0b3JfcG9zaXRpb24gaXNcbiAgICAgICAgLy8gICBzZXQgdG8gYmVmb3JlIG9yIHByZXNlcnZlXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicgJiYgaW5fYXJyYXkob3B0Lm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOicgJiYgZmxhZ3MuaW5fY2FzZSkge1xuICAgICAgICAgICAgZmxhZ3MuY2FzZV9ib2R5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoKTtcbiAgICAgICAgICAgIGZsYWdzLmluX2Nhc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICAgICAgICB2YXIgc3BhY2VfYWZ0ZXIgPSB0cnVlO1xuICAgICAgICB2YXIgaW5fdGVybmFyeSA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29sb24gaXMgaW52YWxpZCBqYXZhc2NyaXB0IG91dHNpZGUgb2YgdGVybmFyeSBhbmQgb2JqZWN0LCBidXQgZG8gb3VyIGJlc3QgdG8gZ3Vlc3Mgd2hhdCB3YXMgbWVhbnQuXG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsYWdzLnRlcm5hcnlfZGVwdGggLT0gMTtcbiAgICAgICAgICAgICAgICBpbl90ZXJuYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc/Jykge1xuICAgICAgICAgICAgZmxhZ3MudGVybmFyeV9kZXB0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0J3MgaGFuZGxlIHRoZSBvcGVyYXRvcl9wb3NpdGlvbiBvcHRpb24gcHJpb3IgdG8gYW55IGNvbmZsaWN0aW5nIGxvZ2ljXG4gICAgICAgIGlmICghaXNVbmFyeSAmJiAhaXNHZW5lcmF0b3JBc3RlcmlzayAmJiBvcHQucHJlc2VydmVfbmV3bGluZXMgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCB0b2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycykpIHtcbiAgICAgICAgICAgIHZhciBpc0NvbG9uID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnOic7XG4gICAgICAgICAgICB2YXIgaXNUZXJuYXJ5Q29sb24gPSAoaXNDb2xvbiAmJiBpbl90ZXJuYXJ5KTtcbiAgICAgICAgICAgIHZhciBpc090aGVyQ29sb24gPSAoaXNDb2xvbiAmJiAhaW5fdGVybmFyeSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAob3B0Lm9wZXJhdG9yX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgOiBhbmQgaXQncyBub3QgYSB0ZXJuYXJ5IHN0YXRlbWVudCB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9ICFpc090aGVyQ29sb247XG5cbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29sb24gfHwgaXNUZXJuYXJ5Q29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmFmdGVyX25ld2xpbmU6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIGFueXRoaW5nIGJ1dCBjb2xvbiwgb3IgKHZpYSBkZWR1Y3Rpb24pIGl0J3MgYSBjb2xvbiBhbmQgaW4gYSB0ZXJuYXJ5IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGVuIHByaW50IGEgbmV3bGluZS5cblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29sb24gfHwgaXNUZXJuYXJ5Q29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRfdG9rZW4oMSkud2FudGVkX25ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT3RoZXJDb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UganVzdCBhZGRlZCBhIG5ld2xpbmUsIG9yIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9ICEob3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpIHx8IGlzT3RoZXJDb2xvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2JlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0dlbmVyYXRvckFzdGVyaXNrKSB7XG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7XG4gICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gZ2V0X3Rva2VuKDEpO1xuICAgICAgICAgICAgc3BhY2VfYWZ0ZXIgPSBuZXh0X3Rva2VuICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgWydUS19XT1JEJywgJ1RLX1JFU0VSVkVEJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIGFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtcbiAgICAgICAgICAgIHNwYWNlX2JlZm9yZSA9IGxhc3RfdHlwZSA9PT0gJ1RLX1NUQVJUX0JMT0NLJztcbiAgICAgICAgICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJysrJywgJyEnLCAnfiddKSB8fCBpc1VuYXJ5KSB7XG4gICAgICAgICAgICAvLyB1bmFyeSBvcGVyYXRvcnMgKGFuZCBiaW5hcnkgKy8tIHByZXRlbmRpbmcgdG8gYmUgdW5hcnkpIHNwZWNpYWwgY2FzZXNcblxuICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgICAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtNy45LjFcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbmV3bGluZSBiZXR3ZWVuIC0tIG9yICsrIGFuZCBhbnl0aGluZyBlbHNlIHdlIHNob3VsZCBwcmVzZXJ2ZSBpdC5cbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSkge1xuICAgICAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhZ3MubGFzdF90ZXh0ID09PSAnOycgJiYgaXNfZXhwcmVzc2lvbihmbGFncy5tb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciAoOzsgKytpKVxuICAgICAgICAgICAgICAgIC8vICAgICAgICBeXl5cbiAgICAgICAgICAgICAgICBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdF90eXBlID09PSAnVEtfUkVTRVJWRUQnKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdF90eXBlID09PSAnVEtfRU5EX0VYUFInKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gIShmbGFncy5sYXN0X3RleHQgPT09ICddJyAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0X3R5cGUgPT09ICdUS19PUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICAvLyBhKysgKyArK2I7XG4gICAgICAgICAgICAgICAgLy8gYSAtIC1iXG4gICAgICAgICAgICAgICAgc3BhY2VfYmVmb3JlID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKSAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnLS0nLCAnLScsICcrKycsICcrJ10pO1xuICAgICAgICAgICAgICAgIC8vICsgYW5kIC0gYXJlIG5vdCB1bmFyeSB3aGVuIHByZWNlZWRlZCBieSAtLSBvciArKyBvcGVyYXRvclxuICAgICAgICAgICAgICAgIC8vIGEtLSArIGJcbiAgICAgICAgICAgICAgICAvLyBhICogK2JcbiAgICAgICAgICAgICAgICAvLyBhIC0gLWJcbiAgICAgICAgICAgICAgICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJysnLCAnLSddKSAmJiBpbl9hcnJheShmbGFncy5sYXN0X3RleHQsIFsnLS0nLCAnKysnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VfYWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoKChmbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmICFmbGFncy5pbmxpbmVfZnJhbWUpIHx8IGZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSAmJlxuICAgICAgICAgICAgICAgIChmbGFncy5sYXN0X3RleHQgPT09ICd7JyB8fCBmbGFncy5sYXN0X3RleHQgPT09ICc7JykpIHtcbiAgICAgICAgICAgICAgICAvLyB7IGZvbzsgLS1pIH1cbiAgICAgICAgICAgICAgICAvLyBmb28oKTsgLS1iYXI7XG4gICAgICAgICAgICAgICAgcHJpbnRfbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gfHwgc3BhY2VfYmVmb3JlO1xuICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gc3BhY2VfYWZ0ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2Jsb2NrX2NvbW1lbnQocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIGlmIChvdXRwdXQucmF3KSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMgJiYgY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRlc3RpbmcgdGhlIHJhdyBvdXRwdXQgYmVoYXZpb3IsIGRvIG5vdCBhbGxvdyBhIGRpcmVjdGl2ZSB0byB0dXJuIGl0IG9mZi5cbiAgICAgICAgICAgICAgICBvdXRwdXQucmF3ID0gb3B0LnRlc3Rfb3V0cHV0X3JhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5yYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmxpbmUgYmxvY2tcbiAgICAgICAgaWYgKCFhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF90b2tlbi50ZXh0KSAmJiAhY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICBwcmludF90b2tlbigpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZXMgPSBzcGxpdF9saW5lYnJlYWtzKGN1cnJlbnRfdG9rZW4udGV4dCk7XG4gICAgICAgIHZhciBqOyAvLyBpdGVyYXRvciBmb3IgdGhpcyBjYXNlXG4gICAgICAgIHZhciBqYXZhZG9jID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFybGVzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgbGFzdEluZGVudCA9IGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmU7XG4gICAgICAgIHZhciBsYXN0SW5kZW50TGVuZ3RoID0gbGFzdEluZGVudC5sZW5ndGg7XG5cbiAgICAgICAgLy8gYmxvY2sgY29tbWVudCBzdGFydHMgd2l0aCBhIG5ldyBsaW5lXG4gICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBqYXZhZG9jID0gYWxsX2xpbmVzX3N0YXJ0X3dpdGgobGluZXMuc2xpY2UoMSksICcqJyk7XG4gICAgICAgICAgICBzdGFybGVzcyA9IGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcy5zbGljZSgxKSwgbGFzdEluZGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBsaW5lIGFsd2F5cyBpbmRlbnRlZFxuICAgICAgICBwcmludF90b2tlbihsaW5lc1swXSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoamF2YWRvYykge1xuICAgICAgICAgICAgICAgIC8vIGphdmFkb2M6IHJlZm9ybWF0IGFuZCByZS1pbmRlbnRcbiAgICAgICAgICAgICAgICBwcmludF90b2tlbignICcgKyBsdHJpbShsaW5lc1tqXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFybGVzcyAmJiBsaW5lc1tqXS5sZW5ndGggPiBsYXN0SW5kZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gc3Rhcmxlc3M6IHJlLWluZGVudCBub24tZW1wdHkgY29udGVudCwgYXZvaWRpbmcgdHJpbVxuICAgICAgICAgICAgICAgIHByaW50X3Rva2VuKGxpbmVzW2pdLnN1YnN0cmluZyhsYXN0SW5kZW50TGVuZ3RoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBjb21tZW50cyBvdXRwdXQgcmF3XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZF90b2tlbihsaW5lc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgY29tbWVudHMgb2YgbW9yZSB0aGFuIG9uZSBsaW5lLCBtYWtlIHN1cmUgdGhlcmUncyBhIG5ldyBsaW5lIGFmdGVyXG4gICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2NvbW1lbnQocHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgICAgIGlmIChjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKSB7XG4gICAgICAgICAgICBwcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICAgICAgcHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICBpZiAoc3RhcnRfb2Zfc3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X3R5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaXNfc3BlY2lhbF93b3JkKGZsYWdzLmxhc3RfdGV4dCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYWxsb3cgcHJlc2VydmVkIG5ld2xpbmVzIGJlZm9yZSBkb3RzIGluIGdlbmVyYWxcbiAgICAgICAgICAgIC8vIGZvcmNlIG5ld2xpbmVzIG9uIGRvdHMgYWZ0ZXIgY2xvc2UgcGFyZW4gd2hlbiBicmVha19jaGFpbmVkIC0gZm9yIGJhcigpLmJheigpXG4gICAgICAgICAgICBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGZsYWdzLmxhc3RfdGV4dCA9PT0gJyknICYmIG9wdC5icmVha19jaGFpbmVkX21ldGhvZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfdW5rbm93bihwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICAgICAgcHJpbnRfdG9rZW4oKTtcblxuICAgICAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0W2N1cnJlbnRfdG9rZW4udGV4dC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZW9mKCkge1xuICAgICAgICAvLyBVbndpbmQgYW55IG9wZW4gc3RhdGVtZW50c1xuICAgICAgICB3aGlsZSAoZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3RvcmVfbW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTcgRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0KSB7XG4gICAgdmFyIF9pbnB1dCA9IGlucHV0O1xuICAgIHZhciBfaW5wdXRfbGVuZ3RoID0gX2lucHV0Lmxlbmd0aDtcbiAgICB2YXIgX3Bvc2l0aW9uID0gMDtcblxuICAgIHRoaXMuYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfcG9zaXRpb24gLT0gMTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb24gPCBfaW5wdXRfbGVuZ3RoO1xuICAgIH07XG5cbiAgICB0aGlzLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgICAgICAgICAgdmFsID0gX2lucHV0LmNoYXJBdChfcG9zaXRpb24pO1xuICAgICAgICAgICAgX3Bvc2l0aW9uICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbCA9IG51bGw7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgaW5kZXggKz0gX3Bvc2l0aW9uO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IF9pbnB1dF9sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbCA9IF9pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMucGVla0NoYXJDb2RlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbCA9IDA7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgaW5kZXggKz0gX3Bvc2l0aW9uO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IF9pbnB1dF9sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbCA9IF9pbnB1dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLnRlc3QgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gX3Bvc2l0aW9uICsgaW5kZXg7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoX2lucHV0KTtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXN0Q2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICAgICAgICByZXR1cm4gdmFsICE9PSBudWxsICYmIHBhdHRlcm4udGVzdCh2YWwpO1xuICAgIH07XG5cbiAgICB0aGlzLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IF9wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoX2lucHV0KTtcbiAgICAgICAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgcGF0dGVybl9tYXRjaC5pbmRleCA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBfcG9zaXRpb24gKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbiAgICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBtZXJnZU9wdHMoYWxsT3B0aW9ucywgdGFyZ2V0VHlwZSkge1xuICAgIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSB0YXJnZXRUeXBlXG4gICAgaWYgKHRhcmdldFR5cGUgaW4gYWxsT3B0aW9ucykge1xuICAgICAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXSkge1xuICAgICAgICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1t0YXJnZXRUeXBlXVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBtZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gICAgdmFyIF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAgIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIGxpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgICB2YXIgX2luZGVudF9jb3VudCA9IC0xO1xuXG4gICAgdmFyIF9pdGVtcyA9IFtdO1xuICAgIHZhciBfZW1wdHkgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCA9IHBhcmVudC5iYXNlSW5kZW50TGVuZ3RoICsgbGV2ZWwgKiBwYXJlbnQuaW5kZW50X2xlbmd0aDtcbiAgICAgICAgX2luZGVudF9jb3VudCA9IGxldmVsO1xuICAgIH07XG5cbiAgICB0aGlzLmdldF9jaGFyYWN0ZXJfY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgfTtcblxuICAgIHRoaXMuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9O1xuXG4gICAgdGhpcy5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaXRlbXNbX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgX2l0ZW1zLnB1c2goaW5wdXQpO1xuICAgICAgICBfY2hhcmFjdGVyX2NvdW50ICs9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgX2VtcHR5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gbnVsbDtcbiAgICAgICAgaWYgKCFfZW1wdHkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBfaXRlbXMucG9wKCk7XG4gICAgICAgICAgICBfY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgX2VtcHR5ID0gX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfaW5kZW50X2NvdW50ID4gMCkge1xuICAgICAgICAgICAgX2luZGVudF9jb3VudCAtPSAxO1xuICAgICAgICAgICAgX2NoYXJhY3Rlcl9jb3VudCAtPSBwYXJlbnQuaW5kZW50X2xlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICAgICAgICAgIF9pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBfZW1wdHkgPSBfaXRlbXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eSkge1xuICAgICAgICAgICAgaWYgKF9pbmRlbnRfY291bnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudC5pbmRlbnRfY2FjaGVbX2luZGVudF9jb3VudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gX2l0ZW1zLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gT3V0cHV0KGluZGVudF9zdHJpbmcsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgICB0aGlzLmluZGVudF9jYWNoZSA9IFtiYXNlSW5kZW50U3RyaW5nXTtcbiAgICB0aGlzLmJhc2VJbmRlbnRMZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbiAgICB0aGlzLmluZGVudF9sZW5ndGggPSBpbmRlbnRfc3RyaW5nLmxlbmd0aDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuXG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdGhpcy5iYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgICB0aGlzLmluZGVudF9zdHJpbmcgPSBpbmRlbnRfc3RyaW5nO1xuICAgIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG5cbiAgICB0aGlzLmFkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbiAgICB9O1xuXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcblxuXG4gICAgdGhpcy5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLy8gVXNpbmcgb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nIHRvIGFsbG93IGZvciBsYXRlciBleHBhbnNpb24gb2YgaW5mbyBhYm91dCBlYWNoIGxpbmVcbiAgICB0aGlzLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0X2xpbmVfbnVtYmVyKCkgPT09IDEgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBubyBuZXdsaW5lIG9uIHN0YXJ0IG9mIGZpbGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZV9uZXdsaW5lIHx8ICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmF3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRfb3V0cHV0bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0X2NvZGUgPSBmdW5jdGlvbihlbmRfd2l0aF9uZXdsaW5lLCBlb2wpIHtcbiAgICAgICAgdmFyIHN3ZWV0X2NvZGUgPSBsaW5lcy5qb2luKCdcXG4nKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRfY29kZSArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB3aGlsZSAobGV2ZWwgPj0gdGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY2FjaGUucHVzaCh0aGlzLmluZGVudF9jYWNoZVt0aGlzLmluZGVudF9jYWNoZS5sZW5ndGggLSAxXSArIHRoaXMuaW5kZW50X3N0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQobGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX291dHB1dGxpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgICAgICAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgICAgICAgdGhpcy5hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBvdXRwdXRfbGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lc1tpbmRleF0ucmVtb3ZlX2luZGVudCgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgICAgICAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gICAgICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oaW5kZW50X3N0cmluZywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgICAgICAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiBsaW5lcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9saW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSBsaW5lcy5sZW5ndGggPiAxID8gbGluZXNbbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzdGFydCBvZiB0aGUgZmlsZSBhbmQgbmV3bGluZSA9IGJsYW5rXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gbGluZS5pc19lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSwgcGFyZW50KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgLy8gY29tbWVudHNfYmVmb3JlIGFyZVxuICAgIC8vIGNvbW1lbnRzIHRoYXQgaGF2ZSBhIG5ldyBsaW5lIGJlZm9yZSB0aGVtXG4gICAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gICAgLy8gdGhpcyBpcyBhIHNldCBvZiBjb21tZW50cyBiZWZvcmVcbiAgICB0aGlzLmNvbW1lbnRzX2JlZm9yZSA9IC8qIGlubGluZSBjb21tZW50Ki8gW107XG5cblxuICAgIHRoaXMuY29tbWVudHNfYWZ0ZXIgPSBbXTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gICAgdGhpcy5uZXdsaW5lcyA9IG5ld2xpbmVzIHx8IDA7XG4gICAgdGhpcy53YW50ZWRfbmV3bGluZSA9IG5ld2xpbmVzID4gMDtcbiAgICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICB0aGlzLm9wZW5lZCA9IG51bGw7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG52YXIgQmVhdXRpZmllciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQmVhdXRpZmllcjtcblxuZnVuY3Rpb24ganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzX2JlYXV0aWZ5O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE3IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgU09GVFdBUkUuXG4qL1xuXG52YXIgSW5wdXRTY2FubmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5JbnB1dFNjYW5uZXI7XG52YXIgVG9rZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLlRva2VuO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJyW2ldID09PSB3aGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFRva2VuaXplcihpbnB1dF9zdHJpbmcsIG9wdHMpIHtcblxuICAgIHZhciB3aGl0ZXNwYWNlID0gXCJcXG5cXHJcXHQgXCIuc3BsaXQoJycpO1xuICAgIHZhciBkaWdpdCA9IC9bMC05XS87XG4gICAgdmFyIGRpZ2l0X2JpbiA9IC9bMDFdLztcbiAgICB2YXIgZGlnaXRfb2N0ID0gL1swMTIzNDU2N10vO1xuICAgIHZhciBkaWdpdF9oZXggPSAvWzAxMjM0NTY3ODlhYmNkZWZBQkNERUZdLztcblxuICAgIHRoaXMucG9zaXRpb25hYmxlX29wZXJhdG9ycyA9ICchPSAhPT0gJSAmICYmICogKiogKyAtIC8gOiA8IDw8IDw9ID09ID09PSA+ID49ID4+ID4+PiA/IF4gfCB8fCcuc3BsaXQoJyAnKTtcbiAgICB2YXIgcHVuY3QgPSB0aGlzLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMuY29uY2F0KFxuICAgICAgICAvLyBub24tcG9zaXRpb25hYmxlIG9wZXJhdG9ycyAtIHRoZXNlIGRvIG5vdCBmb2xsb3cgb3BlcmF0b3IgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgICAgJyEgJT0gJj0gKj0gKio9ICsrICs9ICwgLS0gLT0gLz0gOjogPDw9ID0gPT4gPj49ID4+Pj0gXj0gfD0gfiAuLi4nLnNwbGl0KCcgJykpO1xuXG4gICAgLy8gd29yZHMgd2hpY2ggc2hvdWxkIGFsd2F5cyBzdGFydCBvbiBuZXcgbGluZS5cbiAgICB0aGlzLmxpbmVfc3RhcnRlcnMgPSAnY29udGludWUsdHJ5LHRocm93LHJldHVybix2YXIsbGV0LGNvbnN0LGlmLHN3aXRjaCxjYXNlLGRlZmF1bHQsZm9yLHdoaWxlLGJyZWFrLGZ1bmN0aW9uLGltcG9ydCxleHBvcnQnLnNwbGl0KCcsJyk7XG4gICAgdmFyIHJlc2VydmVkX3dvcmRzID0gdGhpcy5saW5lX3N0YXJ0ZXJzLmNvbmNhdChbJ2RvJywgJ2luJywgJ29mJywgJ2Vsc2UnLCAnZ2V0JywgJ3NldCcsICduZXcnLCAnY2F0Y2gnLCAnZmluYWxseScsICd0eXBlb2YnLCAneWllbGQnLCAnYXN5bmMnLCAnYXdhaXQnLCAnZnJvbScsICdhcyddKTtcblxuICAgIC8vICAvKiAuLi4gKi8gY29tbWVudCBlbmRzIHdpdGggbmVhcmVzdCAqLyBvciBlbmQgb2YgZmlsZVxuICAgIHZhciBibG9ja19jb21tZW50X3BhdHRlcm4gPSAvKFtcXHNcXFNdKj8pKCg/OlxcKlxcLyl8JCkvZztcblxuICAgIC8vIGNvbW1lbnQgZW5kcyBqdXN0IGJlZm9yZSBuZWFyZXN0IGxpbmVmZWVkIG9yIGVuZCBvZiBmaWxlXG4gICAgdmFyIGNvbW1lbnRfcGF0dGVybiA9IC8oW15cXG5cXHJcXHUyMDI4XFx1MjAyOV0qKS9nO1xuXG4gICAgdmFyIGRpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IC9cXC9cXCogYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgXFwqXFwvL2c7XG4gICAgdmFyIGRpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcbiAgICB2YXIgZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSAvKFtcXHNcXFNdKj8pKCg/OlxcL1xcKlxcc2JlYXV0aWZ5XFxzaWdub3JlOmVuZFxcc1xcKlxcLyl8JCkvZztcblxuICAgIHZhciB0ZW1wbGF0ZV9wYXR0ZXJuID0gLygoPFxcP3BocHw8XFw/PSlbXFxzXFxTXSo/XFw/Pil8KDwlW1xcc1xcU10qPyU+KS9nO1xuXG4gICAgdmFyIG5fbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuLCBpbl9odG1sX2NvbW1lbnQsIHRva2VucztcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICB0aGlzLnRva2VuaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpO1xuICAgICAgICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdG9rZW5zID0gW107XG5cbiAgICAgICAgdmFyIG5leHQsIGxhc3Q7XG4gICAgICAgIHZhciB0b2tlbl92YWx1ZXM7XG4gICAgICAgIHZhciBvcGVuID0gbnVsbDtcbiAgICAgICAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XG5cbiAgICAgICAgd2hpbGUgKCEobGFzdCAmJiBsYXN0LnR5cGUgPT09ICdUS19FT0YnKSkge1xuICAgICAgICAgICAgdG9rZW5fdmFsdWVzID0gdG9rZW5pemVfbmV4dCgpO1xuICAgICAgICAgICAgbmV4dCA9IG5ldyBUb2tlbih0b2tlbl92YWx1ZXNbMV0sIHRva2VuX3ZhbHVlc1swXSwgbl9uZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQudHlwZSA9PT0gJ1RLX0NPTU1FTlQnIHx8IG5leHQudHlwZSA9PT0gJ1RLX0JMT0NLX0NPTU1FTlQnIHx8IG5leHQudHlwZSA9PT0gJ1RLX1VOS05PV04nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudHlwZSA9PT0gJ1RLX0JMT0NLX0NPTU1FTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGlyZWN0aXZlcyA9IHRva2VuX3ZhbHVlc1syXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICB0b2tlbl92YWx1ZXMgPSB0b2tlbml6ZV9uZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5ldyBUb2tlbih0b2tlbl92YWx1ZXNbMV0sIHRva2VuX3ZhbHVlc1swXSwgbl9uZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5jb21tZW50c19iZWZvcmUgPSBjb21tZW50cztcbiAgICAgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dC50eXBlID09PSAnVEtfU1RBUlRfQkxPQ0snIHx8IG5leHQudHlwZSA9PT0gJ1RLX1NUQVJUX0VYUFInKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5wYXJlbnQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIG9wZW5fc3RhY2sucHVzaChvcGVuKTtcbiAgICAgICAgICAgICAgICBvcGVuID0gbmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKG5leHQudHlwZSA9PT0gJ1RLX0VORF9CTE9DSycgfHwgbmV4dC50eXBlID09PSAnVEtfRU5EX0VYUFInKSAmJlxuICAgICAgICAgICAgICAgIChvcGVuICYmIChcbiAgICAgICAgICAgICAgICAgICAgKG5leHQudGV4dCA9PT0gJ10nICYmIG9wZW4udGV4dCA9PT0gJ1snKSB8fFxuICAgICAgICAgICAgICAgICAgICAobmV4dC50ZXh0ID09PSAnKScgJiYgb3Blbi50ZXh0ID09PSAnKCcpIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXh0LnRleHQgPT09ICd9JyAmJiBvcGVuLnRleHQgPT09ICd7JykpKSkge1xuICAgICAgICAgICAgICAgIG5leHQucGFyZW50ID0gb3Blbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbmV4dC5vcGVuZWQgPSBvcGVuO1xuXG4gICAgICAgICAgICAgICAgb3BlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgbGFzdCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRfZGlyZWN0aXZlcyh0ZXh0KSB7XG4gICAgICAgIGlmICghdGV4dC5tYXRjaChkaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0ge307XG4gICAgICAgIGRpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSBkaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gICAgICAgIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNbZGlyZWN0aXZlX21hdGNoWzFdXSA9IGRpcmVjdGl2ZV9tYXRjaFsyXTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZV9tYXRjaCA9IGRpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbml6ZV9uZXh0KCkge1xuICAgICAgICB2YXIgcmVzdWx0aW5nX3N0cmluZztcbiAgICAgICAgdmFyIHdoaXRlc3BhY2Vfb25fdGhpc19saW5lID0gW107XG5cbiAgICAgICAgbl9uZXdsaW5lcyA9IDA7XG4gICAgICAgIHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyc7XG5cbiAgICAgICAgdmFyIGMgPSBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0X3Rva2VuO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdF90b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIHNha2Ugb2YgdG9rZW5pemluZyB3ZSBjYW4gcHJldGVuZCB0aGF0IHRoZXJlIHdhcyBvbiBvcGVuIGJyYWNlIHRvIHN0YXJ0XG4gICAgICAgICAgICBsYXN0X3Rva2VuID0gbmV3IFRva2VuKCdUS19TVEFSVF9CTE9DSycsICd7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5fYXJyYXkoYywgd2hpdGVzcGFjZSkpIHtcblxuICAgICAgICAgICAgaWYgKGFjb3JuLm5ld2xpbmUudGVzdChjKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGMgPT09ICdcXG4nICYmIGlucHV0LnBlZWsoLTIpID09PSAnXFxyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbl9uZXdsaW5lcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlX29uX3RoaXNfbGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZV9vbl90aGlzX2xpbmUucHVzaChjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYyA9IGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCAnVEtfRU9GJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2hpdGVzcGFjZV9vbl90aGlzX2xpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IHdoaXRlc3BhY2Vfb25fdGhpc19saW5lLmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpZ2l0LnRlc3QoYykgfHwgKGMgPT09ICcuJyAmJiBpbnB1dC50ZXN0Q2hhcihkaWdpdCkpKSB7XG4gICAgICAgICAgICB2YXIgYWxsb3dfZGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYWxsb3dfZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbG9jYWxfZGlnaXQgPSBkaWdpdDtcblxuICAgICAgICAgICAgaWYgKGMgPT09ICcwJyAmJiBpbnB1dC50ZXN0Q2hhcigvW1h4T29CYl0vKSkge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBoZXgvb2N0L2JpbiBudW1iZXIsIG5vIGRlY2ltYWwgb3IgZSwganVzdCBoZXgvb2N0L2JpbiBkaWdpdHNcbiAgICAgICAgICAgICAgICBhbGxvd19kZWNpbWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsb3dfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50ZXN0Q2hhcigvW0JiXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsX2RpZ2l0ID0gZGlnaXRfYmluO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudGVzdENoYXIoL1tPb10vKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbF9kaWdpdCA9IGRpZ2l0X29jdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbF9kaWdpdCA9IGRpZ2l0X2hleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhIGRlY2ltYWwgZm9yIHRoaXMgbGl0ZXJhbCwgZG9uJ3QgYWxsb3cgYW5vdGhlclxuICAgICAgICAgICAgICAgIGFsbG93X2RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGlzIGZpcnN0IGxvb3Agd2lsbCBydW4uICBJdCBrZWVwcyB0aGUgbG9naWMgc2ltcGxlci5cbiAgICAgICAgICAgICAgICBjID0gJyc7XG4gICAgICAgICAgICAgICAgaW5wdXQuYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGRpZ2l0c1xuICAgICAgICAgICAgd2hpbGUgKGlucHV0LnRlc3RDaGFyKGxvY2FsX2RpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbG93X2RlY2ltYWwgJiYgaW5wdXQucGVlaygpID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X2RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhID0gMS5lLTcgaXMgdmFsaWQsIHNvIHdlIHRlc3QgZm9yIC4gdGhlbiBlIGluIG9uZSBsb29wXG4gICAgICAgICAgICAgICAgaWYgKGFsbG93X2UgJiYgaW5wdXQudGVzdENoYXIoL1tFZV0vKSkge1xuICAgICAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQudGVzdENoYXIoL1srLV0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhbGxvd19lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X2RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1dPUkQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY29ybi5pc0lkZW50aWZpZXJTdGFydChpbnB1dC5wZWVrQ2hhckNvZGUoLTEpKSkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChhY29ybi5pc0lkZW50aWZpZXJDaGFyKGlucHV0LnBlZWtDaGFyQ29kZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShsYXN0X3Rva2VuLnR5cGUgPT09ICdUS19ET1QnIHx8XG4gICAgICAgICAgICAgICAgICAgIChsYXN0X3Rva2VuLnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkobGFzdF90b2tlbi50ZXh0LCBbJ3NldCcsICdnZXQnXSkpKSAmJlxuICAgICAgICAgICAgICAgIGluX2FycmF5KGMsIHJlc2VydmVkX3dvcmRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnaW4nIHx8IGMgPT09ICdvZicpIHsgLy8gaGFjayBmb3IgJ2luJyBhbmQgJ29mJyBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfT1BFUkFUT1InXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfUkVTRVJWRUQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfV09SRCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcoJyB8fCBjID09PSAnWycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX1NUQVJUX0VYUFInXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnKScgfHwgYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19FTkRfRVhQUiddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICd7Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfU1RBUlRfQkxPQ0snXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0VORF9CTE9DSyddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICc7Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfU0VNSUNPTE9OJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9ICcnO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRfbWF0Y2g7XG4gICAgICAgICAgICAvLyBwZWVrIGZvciBjb21tZW50IC8qIC4uLiAqL1xuICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRfbWF0Y2ggPSBpbnB1dC5tYXRjaChibG9ja19jb21tZW50X3BhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnLyonICsgY29tbWVudF9tYXRjaFswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGdldF9kaXJlY3RpdmVzKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRfbWF0Y2ggPSBpbnB1dC5tYXRjaChkaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY29tbWVudF9tYXRjaFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb21tZW50LCAnVEtfQkxPQ0tfQ09NTUVOVCcsIGRpcmVjdGl2ZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvLyAuLi5cbiAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb21tZW50X21hdGNoID0gaW5wdXQubWF0Y2goY29tbWVudF9wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gJy8vJyArIGNvbW1lbnRfbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb21tZW50LCAnVEtfQ09NTUVOVCddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRYbWxSZWdFeHAgPSAvPCgpKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi9nO1xuXG4gICAgICAgIGlmIChjID09PSAnYCcgfHwgYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJyB8fCAvLyBzdHJpbmdcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAoYyA9PT0gJy8nKSB8fCAvLyByZWdleHBcbiAgICAgICAgICAgICAgICAob3B0cy5lNHggJiYgYyA9PT0gXCI8XCIgJiYgaW5wdXQudGVzdChzdGFydFhtbFJlZ0V4cCwgLTEpKSAvLyB4bWxcbiAgICAgICAgICAgICkgJiYgKCAvLyByZWdleCBhbmQgeG1sIGNhbiBvbmx5IGFwcGVhciBpbiBzcGVjaWZpYyBsb2NhdGlvbnMgZHVyaW5nIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAobGFzdF90b2tlbi50eXBlID09PSAnVEtfUkVTRVJWRUQnICYmIGluX2FycmF5KGxhc3RfdG9rZW4udGV4dCwgWydyZXR1cm4nLCAnY2FzZScsICd0aHJvdycsICdlbHNlJywgJ2RvJywgJ3R5cGVvZicsICd5aWVsZCddKSkgfHxcbiAgICAgICAgICAgICAgICAobGFzdF90b2tlbi50eXBlID09PSAnVEtfRU5EX0VYUFInICYmIGxhc3RfdG9rZW4udGV4dCA9PT0gJyknICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfdG9rZW4ucGFyZW50ICYmIGxhc3RfdG9rZW4ucGFyZW50LnR5cGUgPT09ICdUS19SRVNFUlZFRCcgJiYgaW5fYXJyYXkobGFzdF90b2tlbi5wYXJlbnQudGV4dCwgWydpZicsICd3aGlsZScsICdmb3InXSkpIHx8XG4gICAgICAgICAgICAgICAgKGluX2FycmF5KGxhc3RfdG9rZW4udHlwZSwgWydUS19DT01NRU5UJywgJ1RLX1NUQVJUX0VYUFInLCAnVEtfU1RBUlRfQkxPQ0snLFxuICAgICAgICAgICAgICAgICAgICAnVEtfRU5EX0JMT0NLJywgJ1RLX09QRVJBVE9SJywgJ1RLX0VRVUFMUycsICdUS19FT0YnLCAnVEtfU0VNSUNPTE9OJywgJ1RLX0NPTU1BJ1xuICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgKSkge1xuXG4gICAgICAgICAgICB2YXIgc2VwID0gYyxcbiAgICAgICAgICAgICAgICBlc2MgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBoYXNfY2hhcl9lc2NhcGVzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSBjO1xuXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSByZWdleHBcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHZhciBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKGVzYyB8fCBpbl9jaGFyX2NsYXNzIHx8IGlucHV0LnBlZWsoKSAhPT0gc2VwKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGlucHV0LnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzYyA9IGlucHV0LnBlZWsoKSA9PT0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnBlZWsoKSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5lNHggJiYgc2VwID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBlNHggeG1sIGxpdGVyYWxzXG4gICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgIHZhciB4bWxSZWdFeHAgPSAvW1xcc1xcU10qPzwoXFwvPykoWy1hLXpBLVo6MC05Xy5dK3x7W1xcc1xcU10rP318IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXSkoXFxzK3tbXFxzXFxTXSs/fXxcXHMrWy1hLXpBLVo6MC05Xy5dK3xcXHMrWy1hLXpBLVo6MC05Xy5dK1xccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8e1tcXHNcXFNdKz99KSkqXFxzKihcXC8/KVxccyo+L2c7XG4gICAgICAgICAgICAgICAgaW5wdXQuYmFjaygpO1xuICAgICAgICAgICAgICAgIHZhciB4bWxTdHIgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChzdGFydFhtbFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gcm9vdCB0YWcgdG8gYXR0ZW1wdCB0b1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFRhZyA9IG1hdGNoWzJdLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ3VybHlSb290ID0gcm9vdFRhZy5pbmRleE9mKCd7JykgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRW5kVGFnID0gISFtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTaW5nbGV0b25UYWcgPSAoISFtYXRjaFttYXRjaC5sZW5ndGggLSAxXSkgfHwgKHRhZ05hbWUuc2xpY2UoMCwgOCkgPT09IFwiIVtDREFUQVtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2luZ2xldG9uVGFnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhZ05hbWUgPT09IHJvb3RUYWcgfHwgKGlzQ3VybHlSb290ICYmIHRhZ05hbWUucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbmRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbFN0ciArPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKHhtbFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGNsb3NlIGNvcnJlY3RseSwga2VlcCB1bmZvcm1hdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sU3RyICs9IGlucHV0Lm1hdGNoKC9bXFxzXFxTXSovZylbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeG1sU3RyID0geG1sU3RyLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3htbFN0ciwgXCJUS19TVFJJTkdcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZV9zdHJpbmcgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgc3RhcnRfc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlIHN0cmluZ3MgY2FuIHRyYXZlcnMgbGluZXMgd2l0aG91dCBlc2NhcGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc3RyaW5ncyBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jaGFyID0gaW5wdXQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXNjIHx8IChjdXJyZW50X2NoYXIgIT09IGRlbGltaXRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzIHx8ICFhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF9jaGFyKSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgXFxyXFxuIGxpbmVicmVha3MgYWZ0ZXIgZXNjYXBlcyBvciBpbiB0ZW1wbGF0ZSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVzYyB8fCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMpICYmIGFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X2NoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ1xccicgJiYgaW5wdXQucGVlaygxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NoYXIgPSBpbnB1dC5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gY3VycmVudF9jaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ3gnIHx8IGN1cnJlbnRfY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc19jaGFyX2VzY2FwZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gY3VycmVudF9jaGFyID09PSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0X3N1YiAmJiByZXN1bHRpbmdfc3RyaW5nLmluZGV4T2Yoc3RhcnRfc3ViLCByZXN1bHRpbmdfc3RyaW5nLmxlbmd0aCAtIHN0YXJ0X3N1Yi5sZW5ndGgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxpbWl0ZXIgPT09ICdgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9zdHJpbmcoJ30nLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsICdgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyaW5nKCdgJywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnJHsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyaW5nKCdgJywgdHJ1ZSwgJyR7Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyaW5nKHNlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzX2NoYXJfZXNjYXBlcyAmJiBvcHRzLnVuZXNjYXBlX3N0cmluZ3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gdW5lc2NhcGVfc3RyaW5nKHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5wdXQucGVlaygpID09PSBzZXApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHNlcDtcbiAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnZXhwcyBtYXkgaGF2ZSBtb2RpZmllcnMgL3JlZ2V4cC9NT0QgLCBzbyBmZXRjaCB0aG9zZSwgdG9vXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgW2dpbV0gYXJlIHZhbGlkLCBidXQgaWYgdGhlIHVzZXIgcHV0cyBpbiBnYXJiYWdlLCBkbyB3aGF0IHdlIGNhbiB0byB0YWtlIGl0LlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmIGFjb3JuLmlzSWRlbnRpZmllclN0YXJ0KGlucHV0LnBlZWtDaGFyQ29kZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdGluZ19zdHJpbmcsICdUS19TVFJJTkcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnIycpIHtcblxuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgJiYgaW5wdXQucGVlaygpID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAvLyBzaGViYW5nXG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IGM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiBjICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJpbShyZXN1bHRpbmdfc3RyaW5nKSArICdcXG4nLCAnVEtfVU5LTk9XTiddO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgLy8gU3BpZGVybW9ua2V5LXNwZWNpZmljIHNoYXJwIHZhcmlhYmxlcyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvRW4vU2hhcnBfdmFyaWFibGVzX2luX0phdmFTY3JpcHRcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9teHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9qcy9zcmMvanNzY2FuLmNwcCBhcm91bmQgbGluZSAxOTM1XG4gICAgICAgICAgICB2YXIgc2hhcnAgPSAnIyc7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGFzTmV4dCgpICYmIGlucHV0LnRlc3RDaGFyKGRpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcnAgKz0gYztcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpbnB1dC5oYXNOZXh0KCkgJiYgYyAhPT0gJyMnICYmIGMgIT09ICc9Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQucGVlaygpID09PSAnWycgJiYgaW5wdXQucGVlaygxKSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJwICs9ICdbXSc7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQucGVlaygpID09PSAneycgJiYgaW5wdXQucGVlaygxKSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJwICs9ICd7fSc7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3NoYXJwLCAnVEtfV09SRCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICc8JyAmJiAoaW5wdXQucGVlaygpID09PSAnPycgfHwgaW5wdXQucGVlaygpID09PSAnJScpKSB7XG4gICAgICAgICAgICBpbnB1dC5iYWNrKCk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVfbWF0Y2ggPSBpbnB1dC5tYXRjaCh0ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZV9tYXRjaCkge1xuICAgICAgICAgICAgICAgIGMgPSB0ZW1wbGF0ZV9tYXRjaFswXTtcbiAgICAgICAgICAgICAgICBjID0gYy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19TVFJJTkcnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnPCcgJiYgaW5wdXQubWF0Y2goL1xcIS0tL2cpKSB7XG4gICAgICAgICAgICBjID0gJzwhLS0nO1xuICAgICAgICAgICAgd2hpbGUgKGlucHV0Lmhhc05leHQoKSAmJiAhaW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluX2h0bWxfY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gW2MsICdUS19DT01NRU5UJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA9PT0gJy0nICYmIGluX2h0bWxfY29tbWVudCAmJiBpbnB1dC5tYXRjaCgvLT4vZykpIHtcbiAgICAgICAgICAgIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFsnLS0+JywgJ1RLX0NPTU1FTlQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5wZWVrKCkgPT09ICcuJyAmJiBpbnB1dC5wZWVrKDEpID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBjICs9IGlucHV0Lm5leHQoKSArIGlucHV0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19PUEVSQVRPUiddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtjLCAnVEtfRE9UJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5fYXJyYXkoYywgcHVuY3QpKSB7XG4gICAgICAgICAgICB3aGlsZSAoaW5wdXQuaGFzTmV4dCgpICYmIGluX2FycmF5KGMgKyBpbnB1dC5wZWVrKCksIHB1bmN0KSkge1xuICAgICAgICAgICAgICAgIGMgKz0gaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPT09ICcsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0NPTU1BJ107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgJ1RLX0VRVUFMUyddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsICdUS19PUEVSQVRPUiddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtjLCAnVEtfVU5LTk9XTiddO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVfc3RyaW5nKHMpIHtcbiAgICAgICAgLy8gWW91IHRoaW5rIHRoYXQgYSByZWdleCB3b3VsZCB3b3JrIGZvciB0aGlzXG4gICAgICAgIC8vIHJldHVybiBzLnJlcGxhY2UoL1xcXFx4KFswLTlhLWZdezJ9KS9naSwgZnVuY3Rpb24obWF0Y2gsIHZhbCkge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHZhbCwgMTYpKTtcbiAgICAgICAgLy8gICAgIH0pXG4gICAgICAgIC8vIEhvd2V2ZXIsIGRlYWxpbmcgd2l0aCAnXFx4ZmYnLCAnXFxcXHhmZicsICdcXFxcXFx4ZmYnIG1ha2VzIHRoaXMgbW9yZSBmdW4uXG4gICAgICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgICAgIGVzY2FwZWQgPSAwO1xuXG4gICAgICAgIHZhciBpbnB1dF9zY2FuID0gbmV3IElucHV0U2Nhbm5lcihzKTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgICAgICAgICAgLy8gS2VlcCBhbnkgd2hpdGVzcGFjZSwgbm9uLXNsYXNoIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIC8vIGFsc28ga2VlcCBzbGFzaCBwYWlycy5cbiAgICAgICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC8oW1xcc118W15cXFxcXXxcXFxcXFxcXCkrL2cpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIG91dCArPSBtYXRjaGVkWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC94KFswLTlBLUZhLWZdezJ9KS9nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3UoWzAtOUEtRmEtZl17NH0pL2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgc29tZSBlcnJvciBkZWNvZGluZywgcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHBhcnNlSW50KG1hdGNoZWRbMV0sIDE2KTtcblxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkID4gMHg3ZSAmJiBlc2NhcGVkIDw9IDB4ZmYgJiYgbWF0Y2hlZFswXS5pbmRleE9mKCd4JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYmFpbCBvdXQgb24gXFx4N2YuLlxceGZmLFxuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2aW5nIHdob2xlIHN0cmluZyBlc2NhcGVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHByb2JhYmx5IGNvbXBsZXRlbHkgYmluYXJ5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA+PSAweDAwICYmIGVzY2FwZWQgPCAweDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlYXZlIDB4MDAuLi4weDFmIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXFxcJyArIG1hdGNoZWRbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA9PT0gMHgyMiB8fCBlc2NhcGVkID09PSAweDI3IHx8IGVzY2FwZWQgPT09IDB4NWMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlLXF1b3RlLCBhcG9zdHJvcGhlLCBiYWNrc2xhc2ggLSBlc2NhcGUgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIGpzX2JlYXV0aWZ5ID0gbGVnYWN5X2JlYXV0aWZ5X2pzO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBqc19iZWF1dGlmeToganNfYmVhdXRpZnkgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5qc19iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn1cblxufSgpKTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xOS4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIG0uX3BmO1xufVxuXG52YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbn1cblxuZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGZuKTtcbn1cblxudmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgfVxufVxuXG5ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgIHZhciBwcm9wLCBpO1xuICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbn1cblxudmFyIGtleXM7XG5cbmlmIChPYmplY3Qua2V5cykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cztcbn0gZWxzZSB7XG4gICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgIHNhbWVFbHNlIDogJ0wnXG59O1xuXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG59XG5cbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbn1cblxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xufVxuXG52YXIgYWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xufVxuXG52YXIgcHJpb3JpdGllcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG59XG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxudmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbnZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxudmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbi8vIHRva2VuOiAgICAnTSdcbi8vIHBhZGRlZDogICBbJ01NJywgMl1cbi8vIG9yZGluYWw6ICAnTW8nXG4vLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbmZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICB9XG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5cbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgIHZhciBpID0gNTtcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICB9XG5cbiAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaSAtPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQ7XG59XG5cbnZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG52YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG52YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG52YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxudmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxudmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbnZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxudmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbnZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxudmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxudmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG52YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxudmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxudmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4vLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG52YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cblxudmFyIHJlZ2V4ZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG5cbnZhciB0b2tlbnMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgfVxuICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgfVxufVxuXG52YXIgWUVBUiA9IDA7XG52YXIgTU9OVEggPSAxO1xudmFyIERBVEUgPSAyO1xudmFyIEhPVVIgPSAzO1xudmFyIE1JTlVURSA9IDQ7XG52YXIgU0VDT05EID0gNTtcbnZhciBNSUxMSVNFQ09ORCA9IDY7XG52YXIgV0VFSyA9IDc7XG52YXIgV0VFS0RBWSA9IDg7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xufVxuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMRVNcblxudmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG52YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG59XG5cbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuLy8gbW9udGhzXG4vLyB3ZWVrXG4vLyB3ZWVrZGF5c1xuLy8gbWVyaWRpZW1cbnZhciBiYXNlQ29uZmlnID0ge1xuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbi8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4vLyBsb2NhbGUga2V5LlxuZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAvLyBNRVJHRVxuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbG9jYWxlO1xuXG4gICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgIH1cblxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBjb25maWcuX2QuZ2V0RGF5KCkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICB3ID0gY29uZmlnLl93O1xuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgZG93ID0gMTtcbiAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG59XG5cbi8vIGlzbyA4NjAxIHJlZ2V4XG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xudmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxudmFyIGlzb0RhdGVzID0gW1xuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXG5dO1xuXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG52YXIgaXNvVGltZXMgPSBbXG4gICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgWydISCcsIC9cXGRcXGQvXVxuXTtcblxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbnZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgXTtcblxuICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgfVxuICAgIHJldHVybiB5ZWFyO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xuICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBvYnNPZmZzZXRzID0ge1xuICAgIFVUOiAwLFxuICAgIEdNVDogMCxcbiAgICBFRFQ6IC00ICogNjAsXG4gICAgRVNUOiAtNSAqIDYwLFxuICAgIENEVDogLTUgKiA2MCxcbiAgICBDU1Q6IC02ICogNjAsXG4gICAgTURUOiAtNiAqIDYwLFxuICAgIE1TVDogLTcgKiA2MCxcbiAgICBQRFQ6IC03ICogNjAsXG4gICAgUFNUOiAtOCAqIDYwXG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbn1cblxuaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICB9XG4pO1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgIHZhciBpc1BtO1xuXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgIHZhciBjID0ge307XG5cbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgYy5fbCA9IGxvY2FsZTtcbiAgICBjLl9pID0gaW5wdXQ7XG4gICAgYy5fZiA9IGZvcm1hdDtcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbn1cblxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4vLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4vL1xuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgIHZhciByZXMsIGk7XG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgfVxuICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgfVxuICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG5mdW5jdGlvbiBtaW4gKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbn07XG5cbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG5mdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbn1cblxuZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICB3ZWVrcyAqIDc7XG4gICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgIHllYXJzICogMTI7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgIHRoaXMuX2J1YmJsZSgpO1xufVxuXG5mdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgIH1cbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgIH0pO1xufVxuXG5vZmZzZXQoJ1onLCAnOicpO1xub2Zmc2V0KCdaWicsICcnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gdGltZXpvbmUgY2h1bmtlclxuLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4vLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbnZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgIDAgOlxuICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbn1cblxuLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbmZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICB2YXIgcmVzLCBkaWZmO1xuICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG59XG5cbi8vIEhPT0tTXG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbi8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbi8vIE1PTUVOVFNcblxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4vLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2Vcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG5mdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgIGlmIChjLl9hKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xufVxuXG4vLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbnZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4vLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxudmFyIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICBzaWduLFxuICAgICAgICByZXQsXG4gICAgICAgIGRpZmZSZXM7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogKG1hdGNoWzFdID09PSAnKycpID8gMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG5mdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgIH1cblxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbmZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG59XG5cbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgIHZhciB0aGF0LFxuICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICpcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICB9XG4gICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICB2YXIgem9uZSA9ICcnO1xuICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxudmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgIH1cblxuICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgIH1cblxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xufVxuXG5mdW5jdGlvbiB1bml4ICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgfTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbi8vIFBSSU9ST0lUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbmFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG52YXIgdG9rZW47XG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbn1cblxuZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xufVxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbn1cblxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxucHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG5wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xucHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xucHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbnByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xucHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xucHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xucHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbnByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG5wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbnByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xucHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xucHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbnByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xucHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG5wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG5wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xucHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG5wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG5wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbnByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbnByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xucHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG5wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbnByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xucHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xucHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbnByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbnByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG5wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbnByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG5wcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG5wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbnByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG5wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG5wcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG5wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuLy8gWWVhclxucHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuLy8gV2VlayBZZWFyXG5wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xucHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuLy8gUXVhcnRlclxucHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuLy8gTW9udGhcbnByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4vLyBXZWVrXG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuLy8gRGF5XG5wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbnByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xucHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbnByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG5wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4vLyBIb3VyXG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4vLyBNaW51dGVcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbi8vIFNlY29uZFxucHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuLy8gTWlsbGlzZWNvbmRcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbi8vIE9mZnNldFxucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG5wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbnByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4vLyBUaW1lem9uZVxucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbnByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG59XG5cbmZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG5wcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xucHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbnByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG5wcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG5wcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG5wcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG5wcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuLy8gTW9udGhcbnByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xucHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5wcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG5wcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuLy8gV2Vla1xucHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbnByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbnByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuLy8gRGF5IG9mIFdlZWtcbnByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG5wcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xucHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG5wcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuLy8gSG91cnNcbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG5wcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfVxufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbmhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbmhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gYWJzICgpIHtcbiAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbmZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG59XG5cbmZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgIGRheXMgPSAwO1xuICAgICAgICBtb250aHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG59XG5cbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG59XG5cbmZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXM7XG4gICAgdmFyIG1vbnRocztcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgfTtcbn1cblxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG52YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG52YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbmZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbn1cblxuZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xudmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbnZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG5mdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxufTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbmZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICBhWzRdID0gbG9jYWxlO1xuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICB9XG4gICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG52YXIgYWJzJDEgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBzZWNvbmRzICU9IDYwO1xuICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICB2YXIgWSA9IHllYXJzO1xuICAgIHZhciBNID0gbW9udGhzO1xuICAgIHZhciBEID0gZGF5cztcbiAgICB2YXIgaCA9IGhvdXJzO1xuICAgIHZhciBtID0gbWludXRlcztcbiAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xufVxuXG52YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxucHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbnByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG5wcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG5wcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbnByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbnByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbnByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG5wcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xucHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG5wcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xucHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG5wcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG5wcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbnByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG5wcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xucHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG5wcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG5wcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xucHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG5wcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbnByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbnByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xucHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xucHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbnByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbnByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbnByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG5wcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xucHJvdG8kMi5sYW5nID0gbGFuZztcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbmFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbmFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbn0pO1xuYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbmhvb2tzLnZlcnNpb24gPSAnMi4xOS4xJztcblxuc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG5ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbmhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbmhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG5ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxucmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBib3VuZGFyeV90b19kb3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJ11bJykuam9pbignLicpLnNwbGl0KCdbJykuam9pbignLicpO1xufVxuZnVuY3Rpb24gc3RyaXBfYnJhY2VzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCdbJykuam9pbignLicpLnNwbGl0KCddJykuam9pbignJyk7XG59XG5mdW5jdGlvbiBlc2NhcGVfZG90cyh2YWx1ZSkge1xuICAgIHZhciB2YWwgPSB2YWx1ZS5zcGxpdCgnXFwnJyk7XG4gICAgcmV0dXJuICh2YWwubGVuZ3RoIDwgMykgPyB2YWwuam9pbignXFwnJykgOiB2YWwubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgaWYgKHNlZy5sZW5ndGggPCAzKVxuICAgICAgICAgICAgcmV0dXJuIHNlZztcbiAgICAgICAgaWYgKChzZWdbMF0gPT09ICcuJykgfHwgKHNlZ1tzZWcubGVuZ3RoIC0gMV0gPT09ICcuJykpXG4gICAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICByZXR1cm4gc2VnLnNwbGl0KCcuJykuam9pbignJiYnKTtcbiAgICB9KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHVuZXNjYXBlX2RvdHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJyYmJykuam9pbignLicpO1xufVxuZnVuY3Rpb24gcGFydGlmeSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gZXNjYXBlX2RvdHMoc3RyaXBfYnJhY2VzKGJvdW5kYXJ5X3RvX2RvdCgnJyArIHZhbHVlKSkpLnNwbGl0KCcuJyk7XG59XG5mdW5jdGlvbiBjYW5DbG9uZShvKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygby5fX0NMT05FX18gPT09ICdmdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gY2xvbmUobykge1xuICAgIGlmICgodHlwZW9mIG8gIT09ICdvYmplY3QnKSB8fCAobyA9PT0gbnVsbCkpXG4gICAgICAgIHJldHVybiBvO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKVxuICAgICAgICByZXR1cm4gby5tYXAoY2xvbmUpO1xuICAgIHJldHVybiAoY2FuQ2xvbmUobykpID9cbiAgICAgICAgby5fX0NMT05FX18oY2xvbmUpIDogKG8uY29uc3RydWN0b3IgIT09IE9iamVjdCkgPyBvIDpcbiAgICAgICAgT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uIChwcmUsIGspIHtcbiAgICAgICAgICAgIHByZVtrXSA9ICh0eXBlb2Ygb1trXSA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgICAgICBjbG9uZShvW2tdKSA6IG9ba107XG4gICAgICAgICAgICByZXR1cm4gcHJlO1xuICAgICAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXQocGF0aCwgbykge1xuICAgIHZhciBwYXJ0cyA9IHBhcnRpZnkocGF0aCk7XG4gICAgdmFyIGZpcnN0O1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBvW3VuZXNjYXBlX2RvdHMocGFydHNbMF0pXTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZmlyc3QgPSBvW3BhcnRzLnNoaWZ0KCldO1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgbyA9PT0gJ29iamVjdCcpICYmIChvICE9PSBudWxsKSkgP1xuICAgICAgICAgICAgcGFydHMucmVkdWNlKGZ1bmN0aW9uICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFt1bmVzY2FwZV9kb3RzKHByb3ApXTtcbiAgICAgICAgICAgIH0sIGZpcnN0KSA6IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXQoKTogZXhwZWN0cyBhbiBvYmplY3QgZ290ICcgKyB0eXBlb2Ygbyk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXQgPSBnZXQ7XG47XG5mdW5jdGlvbiBzZXQocGF0aCwgdmFsdWUsIG9iaikge1xuICAgIHZhciBwYXJ0cyA9IHBhcnRpZnkocGF0aCk7XG4gICAgaWYgKCh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgfHwgKG9iaiA9PSBudWxsKSkge1xuICAgICAgICByZXR1cm4gY2xvbmUob2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfc2V0KG9iaiwgdmFsdWUsIHBhcnRzKTtcbiAgICB9XG59XG5leHBvcnRzLnNldCA9IHNldDtcbjtcbmZ1bmN0aW9uIF9zZXQob2JqLCB2YWx1ZSwgcGFydHMpIHtcbiAgICB2YXIgbztcbiAgICB2YXIgaztcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgbyA9ICgodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHx8IChvYmogPT09IG51bGwpKSA/IHt9IDogY2xvbmUob2JqKTtcbiAgICBrID0gdW5lc2NhcGVfZG90cyhwYXJ0c1swXSk7XG4gICAgb1trXSA9IF9zZXQob1trXSwgdmFsdWUsIHBhcnRzLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRfMShrLCB2LCBvKSB7XG4gICAgaWYgKG8gPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGdldChrLCB2KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBzZXQoaywgdiwgbyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXX0=
